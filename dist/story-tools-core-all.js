angular.module("storytools.core.templates", []).run(["$templateCache", function($templateCache) {$templateCache.put("error-dialog.html","<div><div class=modal-header><h3 class=modal-title>{{title}}</h3></div><div class=modal-body><span ng-bind-html=msg></span></div><div class=modal-footer><button class=\"btn btn-primary\" ng-click=$close()>OK</button></div></div>");
$templateCache.put("legend/legend.html","<div><div id=legend-btn-border class=map-btn-border tooltip-placement=top tooltip-append-to-body=true tooltip=\"Toggle Legend\"><div id=legend-btn ng-click=toggleLegend()><i class=\"glyphicon glyphicon-list-alt\"></i></div></div><div id=legend-container class=panel><div id=legend-panel class=\"panel collapse legend-panel-body\"><div id=legend-title-heading class=panel-heading><div class=\"legend-panel-title pull-left\" id=legend-title-text translate=legend_title>Legend</div><i class=\"glyphicon glyphicon-remove legend-panel-title pull-right\" ng-click=toggleLegend()></i></div><div class=\"panel in legend-panel-body\" ng-repeat=\"layer in mapManager.storyMap.getStoryLayers().getArray();\"><div class=\"panel-heading legend-item-header\" data-toggle=collapse data-target=\"{{\'#\' + layer.get(\'name\') + \'legend\'}}\">{{layer.get(\'title\')}}</div><div class=\"panel-collapse legend-item in legend-panel-body\" id=\"{{layer.get(\'name\') + \'legend\'}}\"><img ng-src={{getLegendUrl(layer)}}></div></div></div></div></div>");
$templateCache.put("loading/loading.html","<div class=loading-container ng-class=\"{\'hidden\':spinnerHidden}\"><div class=loading><div class=spinner><div class=mask><div class=loading-spinner></div></div></div></div></div>");
$templateCache.put("ogc/featureinfobox.tpl.html","<div><div class=\"info-box-title-row row\"><div class=info-box-back><i ng-if=\"featureInfoService.getPreviousState() != \'\'\" class=\"glyphicon glyphicon-chevron-left\" ng-click=featureInfoService.showPreviousState()></i></div><div ng-if=\"featureInfoService.getState() == \'layers\'\" class=\"info-box-title ellipsis\"></div><div ng-if=\"featureInfoService.getState() == \'layer\'\" class=\"info-box-title ellipsis\">{{featureInfoService.getSelectedItem().layer.get(\'metadata\').title}}</div><div ng-if=\"featureInfoService.getState() == \'feature\'\" class=\"info-box-title ellipsis\">{{featureInfoService.getSelectedItemLayer().layer.get(\'metadata\').title}}<br>{{featureInfoService.getSelectedItem().id}}</div><div class=info-box-close><i class=\"glyphicon glyphicon-remove\" ng-click=featureInfoService.hide()></i></div></div><div class=animate-switch-container><div ng-if=\"featureInfoService.getState() == \'layers\'\"><ul class=\"list-group list-group-info-box\"><li ng-repeat=\"layerInfo in featureInfoService.getSelectedItem()\" class=list-group-item-info-box ng-click=featureInfoService.show(layerInfo)><div>{{layerInfo.layer.get(\'title\')}}</div></li></ul></div><div ng-if=\"featureInfoService.getState() == \'layer\'\"><ul class=\"list-group list-group-info-box\"><li ng-repeat=\"feature in featureInfoService.getSelectedItem().features\" class=list-group-item-info-box ng-click=featureInfoService.show(feature)><div>{{feature.id}}</div></li></ul></div></div><div ng-if=\"featureInfoService.getState() == \'feature\'\"><div id=pic-carousel-container ng-if=featureInfoService.getSelectedItemMedia()><carousel id=feature-info-box-carousel interval=2000><slide ng-repeat=\"mediaItem in featureInfoService.getSelectedItemMedia() track by $index\"><img ng-src={{featureInfoService.getMediaUrlThumbnail(mediaItem)}} onerror=\"this.src=\'/static/maploom/assets/media-error.png\'\" style=\"margin: auto\" ng-click=\"featureInfoService.showMedia(null, $index)\"></slide></carousel></div><div class=feature-info-box><span class=info-box-attribute ng-show=!isShowingAttributes()></span> <span ng-repeat=\"prop in featureInfoService.getSelectedItemProperties()\"><div ng-if=!featureInfoService.isMediaPropertyName(prop[0]) ng-show=isAttributeVisible(prop[0])><span class=info-box-attribute>{{prop[0]}}</span> <span ng-switch on=isUrl(prop[1])><a ng-switch-when=true class=info-box-attribute-value target=_blank href={{prop[1]}}>{{prop[1]}}</a> <span ng-switch-default class=info-box-attribute-value>{{prop[1]}}</span></span></div></span></div><div id=feature-info-box-bottom></div></div></div>");
$templateCache.put("measure/measurepanel.tpl.html","<div class=\"panel-heading measure-content\"><label>Measure Tools</label><br><div class=\"measure-controls text-center\"><div class=btn-group><button class=\"btn btn-default\" tooltip=Line ng-class=\"{\'btn-primary\' : (measureType == \'line\')}\" ng-click=\"startMeasuring(\'line\')\"><i class=material-icons aria-hidden=true>mode_edit</i></button> <button class=\"btn btn-default\" tooltip=Area ng-class=\"{\'btn-primary\' : (measureType == \'area\')}\" ng-click=\"startMeasuring(\'area\')\"><i class=material-icons aria-hidden=true>picture_in_picture</i></button> <button class=\"btn btn-default\" ng-class=\"{\'disabled\': !isMeasuring}\" tooltip=Stop ng-click=stopMeasuring()><i class=material-icons aria-hidden=true>not_interested</i></button></div></div><label>Units</label><br><div class=\"measure-report text-center\"><div class=btn-group><button class=\"btn btn-default\" ng-repeat=\"unit in unitTypes\" ng-click=changeUnits(unit.type) ng-class=\"{\'btn-primary\' : (unit.type == units)}\">{{ unit.label }}</button></div></div><div ng-show=\"measureLabel > 0\"><label>{{ measureType }}</label><div class=measure-read-out>{{ measureLabel | number }} <em>{{ unitsLabel }}</em></div></div></div>");
$templateCache.put("time/playback-controls.html","<button class=\"btn btn-xs btn-inverse\" ng-click=play() tooltip-placement=top tooltip-append-to-body=true tooltip=\"{{ playbackState }}\"><i class=\"glyphicon glyphicon-{{ playbackState | lowercase }}\"></i></button><div id=slider tooltip-placement=top tooltip-append-to-body=true tooltip=\"{{ currentRange.start|date:\'medium\' }}\"></div><button class=\"btn btn-xs btn-inverse\" ng-click=prev() tooltip-placement=top tooltip-append-to-body=true tooltip=Previous><i class=\"glyphicon glyphicon-fast-backward\"></i></button> <span class=small style=\"color: white;\" ng-hide=\"playbackOptions.mode == \'cumulative\'\">{{ currentRange.start|date:\'medium\' }}</span> <span class=small style=\"color: white;\" ng-show=\"playbackOptions.mode == \'cumulative\'\">{{ currentRange.end|date:\'medium\' }}</span> <button class=\"btn btn-xs btn-inverse\" ng-click=next() tooltip-placement=top tooltip-append-to-body=true tooltip=Next><i class=\"glyphicon glyphicon-fast-forward\"></i></button> <button class=\"btn btn-xs btn-inverse\" ng-click=toggleLoop() tooltip-placement=top tooltip-append-to-body=true tooltip={{loopText}} ng-class=\"{ \'btn-warning\' : loopChapterEnabled, \'btn-success\' : loopStoryEnabled }\"><i ng-class=getLoopButtonGlyph()></i></button> <button class=\"btn btn-xs btn-inverse no-border\" ng-click=toggleTimeLine() tooltip-placement=top tooltip-append-to-body=true tooltip=\"Toggle Timeline\"><i class=\"glyphicon glyphicon-time\"></i></button> <button class=\"btn no-border\" data-toggle=collapse data-target=#playback-settings tooltip-placement=top tooltip-append-to-body=true tooltip=\"Playback Settings\"><i class=\"glyphicon glyphicon-cog\"></i></button> <button class=\"btn btn-xs btn-inverse no-border\" ng-click=toggleFullScreen() tooltip-placement=top tooltip-append-to-body=true tooltip=\"Toggle Fullscreen\"><i class=\"glyphicon glyphicon-fullscreen\"></i></button>");
$templateCache.put("time/playback-settings.html","<div style=padding:10px;><div class=radio-inline><label><input type=radio ng-model=playbackOptions.mode ng-change=optionsChanged() value=instant> Instant</label></div><div class=radio-inline><label><input type=radio ng-model=playbackOptions.mode ng-change=optionsChanged() value=range> Range</label></div><div class=radio-inline><label><input type=radio ng-model=playbackOptions.mode ng-change=optionsChanged() value=cumulative> Cumulative</label></div><div class=checkbox-inline><label><input type=checkbox ng-model=playbackOptions.fixed ng-change=optionsChanged()> Fixed Range</label></div></div><div style=padding:10px;><div class=radio-inline><label><input type=radio ng-model=playbackOptions.speed ng-change=optionsChanged() value=1500> 0.5x</label></div><div class=radio-inline><label><input type=radio ng-model=playbackOptions.speed ng-change=optionsChanged() value=1000> normal</label></div><div class=radio-inline><label><input type=radio ng-model=playbackOptions.speed ng-change=optionsChanged() value=500> 2x</label></div><div class=radio-inline><label><input type=radio ng-model=playbackOptions.speed ng-change=optionsChanged() value=300> 4x</label></div><div class=radio-inline><label><input type=radio ng-model=playbackOptions.speed ng-change=optionsChanged() value=125> 8x</label></div></div>");}]);
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var o;"undefined"!=typeof window?o=window:"undefined"!=typeof global?o=global:"undefined"!=typeof self&&(o=self),(o.storytools||(o.storytools={})).core=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
exports.time = require('./time/controls');
exports.maps = require('./time/maps');
exports.maps.pins = require('./time/pins');
exports.maps.boxes = require('./time/boxes');
exports.utils = require('./time/utils');

},{"./time/boxes":2,"./time/controls":3,"./time/maps":5,"./time/pins":7,"./time/utils":9}],2:[function(require,module,exports){
var utils = require('./utils');

function Box(options) {
    this.range = options.range || null;
    this.data = options.data || null;
    this.layerIds = options.layerIds || null;
    this.center = options.center || null; // ol.Coordinate
    this.resolution = options.resolution || null;
    this.allowPan = options.allowPan;
    this.allowZoom = options.allowZoom;
    this.speed = options.speed;  // interval, seconds
    this.title = options.title || '';
    this.id = options.id || new Date().getUTCMilliseconds();
    this.zoom = options.zoom || null;
    this._offset = 0;
    if (this.range === null) {
        if(this.data) {
            this.range = utils.createRange(this.data[0], this.data[this.data.length - 1]);
        }else{
            this.range = utils.createRange(options.start_time, options.end_time);
        }
    }
    // @todo possible divide by zero if speed.interval not set!
    this._steps = this.data === null ? Math.floor(this.range.width() / this.speed.interval) + 1: this.data.length;
}
Box.prototype.getSteps = function() {
    return this._steps;
};
Box.prototype.getRange = function() {
    return this.range;
};
Box.prototype.getIndex = function(instant) {
    return this.data ? utils.find(this.data, instant) :
        Math.floor(Math.min(this.range.width(), Math.max(0, instant - this.range.start)) / this.speed.interval);
};
Box.prototype.getDate = function(idx) {
    idx = idx - this._offset;
    return this.data ? this.data[idx] : this.range.start + (idx * this.speed.interval);
};


function getTime(props, prop) {
    var val = props[prop];
    if (typeof val != 'undefined') {
        return val *= 1000;
    }
    return null;
}

/**
 * Load Box from geojson, reprojecting from 4326 to the provided
 * projection.
 * @param {Object} geojson
 * @param {String} projection
 * @returns array of Box features
 */
exports.loadFromGeoJSON = function(geojson, projection) {
    if (projection) {
        projection = ol.proj.get(projection);
    }
    return geojson.features.map(function(f) {
        var props = f.properties;
        //props.the_geom = f.geometry;
        props.id = f.id;
        props.start_time = getTime(props, 'start_time');
        props.end_time = getTime(props, 'end_time');
        return new Box(props, projection);
    });
};

function findBox(boxes, idx) {
    var i, ii;
    var box;
    for (i = 0, ii = boxes.length; i < ii; i++) {
        box = boxes[i];
        if (idx >= box._offset) {
            if (i + 1 < ii) {
                if (idx < boxes[i + 1]._offset) {
                    break;
                }
            } else {
                break;
            }
        }
    }
    return box;
}

exports.BoxModel = function(boxArray) {
    var boxes,
        range,
        steps;
    function updateBoxes(neu) {
        var offset = 0;
        boxes = neu.map(function(b) {
            var box = new Box(b);
            box._offset = offset;
            offset += box.getSteps();
            return box;
        });
        range = utils.computeRange(boxes, 'range');
        steps = offset;
    }
    updateBoxes(boxArray);
    this.getRange = function() {
        return range;
    };
    this.getSteps = function() {
        return steps;
    };
    this.getRangeAt = function(s, e) {
        var start = findBox(boxes, s);
        var end = findBox(boxes, e);
        return utils.createRange(start.getDate(s), end.getDate(e));
    };
    this.getIndex = function(instant) {
        var idx = 0, i;
        if (instant < boxes[0].getRange().start) {
            return 0;
        }
        for (i = 0; i < boxes.length; i++) {
            var box = boxes[i];
            var range = box.getRange();
            if (instant >= range.start && instant <= range.end) {
                idx += box.getIndex(instant);
                break;
            } else {
                idx += box.getSteps();
            }
        }
        return idx;
    };
    this.setRange = function(newRange) {
        if (boxes.length == 1) {
            // @todo support for range
            if (utils.isRangeLike(newRange)) {
                throw new Error('not supported yet');
            }
            boxes[0].data = newRange;
            // @todo must set here or constructor is dumb and doesn't recompute
            boxes[0].range = utils.computeRange(newRange);
        } else {
            // @todo finish
            console.log('more than one story box to update range with!');
        }
        updateBoxes(boxes);
    };
    this.update = function(options) {

    };
};

exports.findBox = findBox;
exports.Box = Box;

},{"./utils":9}],3:[function(require,module,exports){
var utils = require('./utils');
var models = require('./models');
var timeslider = require('./slider');
var line = require('./line');
var maps = require('./maps');

/**
 * Facade object and guts of slider/timeline/playback logic.
 *
 * Since playback is driven by a timeout, all other potential events
 * are fired in an async manner to ensure a uniform API.
 */
function TimeController(model, slider, timeline, controls) {
    this.model = model;
    this.slider = slider;
    this.timeline = timeline;
    this.loop = 'none';

    var self = this,
        currentTimelineWindow = getTimelineWindow(),
        isAdjusting = false,
        started = false,
        timeout = null,
        events = new utils.Events(),
        deferred = [];

    function getTimelineWindow() {
        return utils.createRange(timeline.getWindow());
    }

    function adjust(fun, a, b) {
        if (isAdjusting) {
            return;
        }
        isAdjusting = true;
        try {
            fun(a, b);
        } finally {
            isAdjusting = false;
        }
    }

    function centerTimeline(range) {
        var c = model.mode === 'cumulative' ? range.end : range.center();
        timeline.moveTo(c);
        publishRangeChange(range);
    }

    function adjustSlider(range) {
        if (timeline.isWindowMax()) {
            return;
        }

        var center = range.center();
        var idx = model.getIndex(center);
        if (model.mode === 'cumulative') {
            slider.growTo(idx);
        } else {
            slider.center(idx);
        }
        timeline.setTime(center);
        publishRangeChange(slider.getRange());
    }

    function updateSlider(range) {
        if (utils.rangesEqual(range, currentTimelineWindow)) {
            return;
        }
        range = utils.createRange(range);
        // zoom or scroll event?
        if (range.width() !== currentTimelineWindow.width()) {
            timeline.moveToCurrentTime();
        } else {
            adjustSlider(range);
        }
        currentTimelineWindow = range;
    }

    slider.on('rangeChanged', function(range) {
        clearTimeout();
        adjust(centerTimeline, range);
        schedule();
    });
    timeline.on('rangechanged', function(range) {
        adjust(updateSlider, range);
    });
    timeline.on('select', function(properties) {
        console.log("Selected items: ", properties.items);
    });
    function clearTimeout() {
        if (timeout !== null) {
            window.clearTimeout(timeout);
        }
        timeout = null;
    }

    function move(amt) {
        timeout = null;
        var atEnd;
        if (model.mode === 'cumulative') {
            atEnd = slider.grow(amt);
        } else {
            atEnd = slider.move(amt);
        }
        if (atEnd) {
            if (self.loop === 'chapter') {
                slider.jump(0);
            } else if (self.loop === 'story') {
              var currentChapter = window.location.hash.split("/")[2];
              var nextChapter = currentChapter === undefined || currentChapter === null ? 2 : parseInt(currentChapter) + 1;
              if(nextChapter <= controls.chapterCount) {
                  console.log("Going to Chapter ", nextChapter);
                  window.location.href = '#/chapter/' + nextChapter;
                  slider.jump(0);
              } else {
                console.log("Going to Chapter 1");
                window.location.href = '#/chapter/1';
                slider.jump(0);
              }
            } else {
              self.stop();
            }
        }
        centerTimeline(slider.getRange());
        if (started) {
            schedule();
        }
    }

    function schedule() {
        if (started) {
            // @todo respect playback interval options...
            var wait = model.interval;
            $.when.apply($, deferred).then(function() {
                if (started) {
                    timeout = window.setTimeout(move, wait, 1);
                }
            }, function() {
                // the deferred was rejected, if arguments provided, this
                // represents an error state so don't continue playing
                if (arguments.length === 0 && started && timeout === null) {
                    timeout = window.setTimeout(move, wait, 1);
                } else {
                    self.stop();
                }
            });
            deferred = [];
        }
    }

    function run() {
        publishStateChange("running");
        move(1);
    }

    function publishRangeChange(data) {
        if (typeof data === 'undefined') {
            data = slider.getRange();
        }
        publish("rangeChange", data);
    }

    function publishStateChange(state) {
        publish("stateChange", state);
    }

    function publish(event, data) {
        events.event(event).publish(data);
    }

    this.defer = function(defer) {
        deferred.push(defer);
    };
    this.getCurrentRange = function() {
        return slider.getRange();
    };
    this.update = function(options) {
        model.update(options);
        slider.update(model);
        timeline.update(model);
        window.setTimeout(publishRangeChange, 0);
    };
    this.start = function() {
        if (started) {
            return;
        }
        deferred = [];
        started = true;
        window.setTimeout(run, 0);
    };
    this.stop = function() {
        deferred = [];
        started = false;
        clearTimeout();
        window.setTimeout(publishStateChange, 0, 'stopped');
    };
    this.next = function() {
        clearTimeout();
        window.setTimeout(move, 0, 1);
    };
    this.prev = function() {
        clearTimeout();
        window.setTimeout(move, 0, -1);
    };
    this.isStarted = function() {
        return started;
    };
    this.isReady = function() {
        var r = model.getRange();
        return r.start !== null && r.end !== null;
    };
    this.on = function(event, f) {
        events.event(event).subscribe(f);
    };
}

/**
 * annotation model:
 * title
 * content
 * the_geom
 * start_time
 * end_time
 * in_timeline
 * in_map
 * appearance
 */
function Annotations(annotations) {
    var ann = annotations || [];
    function inTimeline() {
        return ann.filter(function(a) {
            return a.in_timeline;
        });
    }
    this.getTimeLineAnnotatons = function() {
        return inTimeline(true);
    };
    this.update = function(annotations) {
        this.ann = annotations;
    };
}

/**
 * box model:
 * title
 * content
 * the_geom
 * start_time
 * end_time
 * in_timeline
 * in_map
 * appearance
 */
function Boxes(boxes) {
    var box = boxes || [];
    function inTimeline() {
        return box.filter(function(b) {
            return true;//b.in_timeline;
        });
    }
    this.getTimeLineBoxes = function() {
        return inTimeline(true);
    };
    this.update = function(boxes) {
        this.box = boxes;
    };
}


/**
 * common lingo:
 * instant: a single point in time
 * extent, range: has property start and end
 * start, end: long values representing UTC (internal) but generally,
 *             a date
 * interval: multipier * precision
 * precision: tick, second, minute, hour, day, week, month, year
 *            note: tick implies a multipier of 1
 * speed: object with property seconds (framerate) and optional interval
 *
 * options = {
 *   annotations: [ {
 *      title,
 *      content,
 *      the_geom,
 *      start_time,
 *      end_time,
 *      in_timeline,
 *      in_map,
 *      appearance
 *      } ... ],
 *   map: ol.Map,
 *   boxes : [ {
 *      range : {
 *          start, end
 *      },
 *      center: ol.Coordinate,
 *      resolution: float,
 *      static: boolean,
 *      speed: { interval, seconds }
 *      } ... ],
 *   data : [ date ...] | rangeWithInterval,
 *   playback : {
 *      mode: instant | range | cumulative,
 *      fixed: boolean
 *   },
 *   timeLineId : element id,
 *   timeSliderId : element id,
 *   controlsId: element id
 *
 * }
 */
function create(options) {
    // @todo for layers, annotations won't exist and, intially, we won't
    //       have playback settings for layers...
    var model,
        annotations = new Annotations(options.annotations),
        boxes = options.boxes,
        controls = {'chapterCount': options.chapterCount},
        totalRange,
        slider,
        timeline,
        mapController;
    options.boxy = new Boxes(options.boxes);
    // make a default box if none provided
    if (typeof boxes == 'undefined' || boxes.length === 0) {
        var interval = 0, data = null;
        if (Array.isArray(options.data)) {
            data = options.data;
            totalRange = utils.computeRange(options.data);
        } else {
            interval = options.data.interval || utils.pickInterval(options.data);
            totalRange = options.data;
        }
        boxes = [{
                data: data,
                range: totalRange,
                speed: {
                    interval: interval,
                    seconds: 3
                }
            }];
    }

    model = new models.TimeModel(options, boxes, annotations);
    slider = new timeslider.TimeSlider(options.timeSliderId || 'slider', model);
    timeline = new line.TimeLine(options.timeLineId || 'timeline', model);

    var timeControls = new TimeController(model, slider, timeline, controls);
    mapController = new maps.MapController(options, timeControls);
    return timeControls;
}

exports.create = create;
exports.maps = maps;
exports.utils = utils;

},{"./line":4,"./maps":5,"./models":6,"./slider":8,"./utils":9}],4:[function(require,module,exports){
var Timeline = require('vis/lib/timeline/Timeline');
var utils = require('./utils');

/**
 * Display annotations or other temporal instant/extent. Allow adjusting
 * time (either instant or extent) by dragging.
 * @param {type} id
 * @param {type} model
 * @returns {_L1.TimeLine}
 */
exports.TimeLine = function(id, model) {
    var dom = $("#" + id);
    var timeline = null;
    // @revisit - internally the timeline seems to apply the offset when
    //            creating a tool tip, does this cause problems elsewhere?
    var offset = new Date().getTimezoneOffset() * 60 * 1000;

    function init(model) {
        var elements = [], layer_groups = [], groups = [], options;
        var story_pin_label = 'Annotation';
        var range = model.getRange();
        if (range.isEmpty()) {
            range = utils.createRange(Date.now());
        }
        elements = model.annotations.getTimeLineAnnotatons().map(function(ann, i) {
            /*jshint eqnull:true */
            var start = ann.start_time != null ? ann.start_time : range.start;
            var end = ann.end_time != null ? ann.end_time : range.end;
            var type = start === end ? 'box' : 'range';
            return {
                id: utils.sha1('annotation' + ann.id + i),
                start: start,
                end: end,
                content: ann.content || ann.title,
                title: ann.title,
                type: type,
                group: story_pin_label
            };
        });

        // Add the Group we there are elements.
        if(elements.length > 0){
            groups.push({id: story_pin_label, title: story_pin_label, time: []});
        }

        if (model.boxy.box) {
            var box_elements = model.boxy.box.map(function(box, i) {
                /*jshint eqnull:true */
                var start = box.range != null ? box.range.start : range.start;
                var end = box.range != null ? box.range.end : range.end;
                var type = 'background';
                return {
                    id: utils.sha1('box' + box.id),
                    start: start,
                    end: end,
                    content: box.content || box.title,
                    type: type
                };
            });
            elements = elements.concat(box_elements);
        }


        layer_groups = $.map(model.storyLayers, function(lyr, i) {
            var id = lyr.get('id');
            var title = lyr.get('title');
            var times = lyr.get('times') || [];
            var group = null;

            if (times.length > 0) {
                if (times.length > 1500) {
                    elements.push({
                        id: utils.sha1(id),
                        group: id,
                        content: "",
                        start: times[0],
                        end: times[times.length - 1],
                        type: 'range'
                    });
                } else {
                    for (var j = 0; j < times.length; j++) {
                        var time = times[j];
                        elements.push({
                            id: utils.sha1(id + time + Date()),
                            group: id,
                            content: "",
                            start: time,
                            type: 'box'
                        });
                    }
                }
                group = {
                id: id,
                content: title
            };

            }
            return group;
        });

        groups = groups.concat(layer_groups);

        if(elements.length > 5000){
            console.debug("%s elements is too large for the timeline to render performant, no worries we will take care of it.", elements.length);
            elements = [];

        }

        console.debug("Building the timeline from %s to %s with %s elements and %s groups.",
              new Date(range.start).toISOString(),
              new Date(range.end).toISOString(),
              elements.length,
              groups.length);

        var height = $( document ).height() * 0.35;

        options = {
            min: range.start,
            max: range.end,
            start: range.start,
            end: range.end,
            height: (height < 300)? 138: height,
            maxHeight: 400,
            showCurrentTime: false
        };
        if (timeline === null) {
            timeline = new Timeline(dom.get(0), elements, options);
            timeline.setGroups(groups);
            timeline.setCurrentTime(range.start);
            timeline.addCustomTime();
        } else {
            timeline.setOptions(options);
            timeline.setItems(elements);
            timeline.setGroups(groups);
        }
    }
    init(model);

    // updates from user dragging customtime bar
    // @todo will not update slider currently at min timeline zoom as it
    // is difficult to determine whether an event is from zooming or dragging
    // need to wrap event handling to better differentiate
    timeline.on('timechanged', function() {
        timeline.moveTo(timeline.getCustomTime(), {animate: false});
    });

    this.moveTo = function(time) {
        timeline.moveTo(time, {animate: false});
        this.setTime(time);
    };
    this.setTime = function(time) {
        timeline.setCustomTime(time + offset);
    };
    this.isWindowMax = function() {
        return utils.rangesEqual(timeline.getWindow(), model.getRange());
    };
    this.moveToCurrentTime = function() {
        var current = timeline.getCustomTime().getTime();
        var width = utils.createRange(timeline.getWindow()).width();
        var range = model.getRange();
        if (current === range.start) {
            timeline.setWindow(range.start, range.start + width, {animate: false});
        } else if (current === range.end) {
            timeline.setWindow(range.end - width, range.end, {animate: false});
        } else {
            timeline.moveTo(current, {animate: false});
        }
    };
    this.getWindow = function() {
        return timeline.getWindow();
    };
    this.on = function(ev, cb) {
        timeline.on(ev, cb);
    };
    this.update = init;
    // @todo detect click or dblclick event and position based on % of total width
};

},{"./utils":9,"vis/lib/timeline/Timeline":31}],5:[function(require,module,exports){
/*jshint loopfunc: true */
var utils = require('./utils');
var moment = require('moment');

/**
 * Read the provide ol3 WMS capabilities document
 * @param {type} caps
 * @returns an object of name->[date|interval]|interval-range mappings
 */
exports.readCapabilitiesTimeDimensions = function(caps, openlayers2) {
    var dimensions = {};
    function readRange(subparts) {
        if (subparts.length < 2) {
            throw new Error('expected 2 parts for range : ' + subparts);
        }
        var range = utils.createRange(subparts[0], subparts[1]);
        if (subparts.length == 3) {
            range.duration = subparts[2];
            range = new utils.Interval(range);
        }
        return range;
    }
    function readPart(part) {
        var subparts = part.split('/');
        if (subparts.length == 1) {
            return utils.getTime(subparts[0]);
        } else {
            return readRange(subparts);
        }
    }
    function parse(dimension) {
        var dims = openlayers2 ? dimension : dimension.split(',');
        if (dims.length == 1) {
            var read = readPart(dims[0]);
            return typeof read === 'number' ? [read] : read;
        }
        return dims.map(readPart);
    }
    if (openlayers2 === true) {
        if (caps.dimensions && caps.dimensions.time) {
            dimensions = parse(caps.dimensions.time.values);
        } else {
            dimensions = undefined;
        }
    } else {
        // @todo need to make layer scanning recursive?
        caps.value.capability.layer.layer.forEach(function(lyr) {
          for (var i = 0; i < lyr.dimension.length; i ++) {
            if (lyr.dimension[i] && lyr.dimension[i].name && lyr.dimension[i].name === 'time') {
              dimensions[lyr.name] = parse(lyr.dimension[i].value);
            }
          }
        });
    }
    return dimensions;
};

function TileLoadListener(tileStatusCallback) {
    var tilesLoading = {};
    var deferred = $.Deferred(),
          cancelled = false;
    function remainingTiles() {
        var t = 0;
        for (var i in tilesLoading) {
            t += tilesLoading[i];
        }
        return t;
    }
    var listener = {
        deferred: deferred,
        cancel: function() {
            cancelled = true;
            for (var s in tilesLoading) {
                tilesLoading[s] = 0;
            }
            if (deferred) {
                deferred.reject(); // notify we've aborted but w/out error
            }
            if (tileStatusCallback) {
                tileStatusCallback(0);
            }
        },
        tileQueued: function(source) {
            if (cancelled) {
                return;
            }
            var key;
            if (source instanceof ol.source.TileWMS) {
                key = source.getUrls()[0];
            } else if (source instanceof ol.source.ImageWMS) {
                key = source.getUrl();
            }
            tilesLoading[key] = (tilesLoading[key] || 0) + 1;
            if (tileStatusCallback) {
                tileStatusCallback(remainingTiles());
            }
        },
        tileLoaded: function(event, source) {
            if (cancelled) {
                return;
            }
            var key;
            if (source instanceof ol.source.TileWMS) {
                key = source.getUrls()[0];
            } else if (source instanceof ol.source.ImageWMS) {
                key = source.getUrl();
            }
            tilesLoading[key] -= 1;
            var remaining = remainingTiles();
            if (tileStatusCallback) {
                tileStatusCallback(remaining);
            }
            if (remaining === 0 && deferred) {
                deferred.resolve();
            }
        }
    };
    // workaround for when the tiles are cached and no events are triggered
    // this adds a constant (small) additional delay to the current play rate
    // under optimal (cached) conditions
    // @todo can this safely be shortened?
    window.setTimeout(function() {
        if (Object.keys(tilesLoading).length === 0) {
            listener.cancel();
        }
    },100);
    return listener;
}

function filterVectorLayer(storyLayer, range) {
    var timeAttr = storyLayer.get('timeAttribute'), l_features = storyLayer.get('features') || storyLayer.getLayer().get('features');
    if (timeAttr === undefined || l_features === undefined) {
        return;
    }
    range = utils.createRange(range);
    // loop over all original features and filter them
    var features = [];
    var layer = storyLayer.getLayer();
    visitAllLayerFeatureTimes(storyLayer, function(f,r) {
        if (range.intersects(r)) {
            features.push(f);
        }
    }, l_features);
    layer.getSource().clear(true);
    layer.getSource().addFeatures(features);
    return features;
}


function filterVectorBoxLayer(storyLayer, range) {
    var timeAttr = storyLayer.get('timeAttribute'), l_features = storyLayer.get('features');
    if (timeAttr === undefined || l_features === undefined) {
        return;
    }
    range = utils.createRange(range);
    // loop over all original features and filter them
    var features = [];
    visitAllLayerFeatureTimes(storyLayer, function(f,r) {
        if (range.intersects(r)) {
            features.push(f);
        }
    });

    return features;
}
/**
 * Call the provided visitor function on the specified features using the
 * configuration provided in the layer. The visitor function will be called
 * with the feature, and start and end time, if any. The features visited will
 * be, in order of priority: the provided (optional) features argument, the
 * layer property 'features', the layer's source features.
 * @param {StoryLayer} story layer
 * @param {function} visitor function(feature, start, end)
 * @param {array} features (opitonal)
 */
function visitAllLayerFeatureTimes(storyLayer, visitor, features) {
    var startAtt = storyLayer.get('timeAttribute');
    var endAtt = storyLayer.get('endTimeAttribute');
    var rangeGetter;
    var layer = storyLayer.getLayer();
    features = features || storyLayer.get('features') || layer.getSource().getFeatures();
    if (endAtt) {
        rangeGetter = function(f) {
            if(f.range){
                return f.range;
            }else {
                var start = f.get(startAtt);
                var end = f.get(endAtt);
                return utils.createRange(start, end);
            }
        };
    } else {
        rangeGetter = function(f) {
            if(f.range){
                return f.range;
            }else {
                var start = f.get(startAtt);
                return utils.createRange(start, start);
            }
        };
    }
    utils.visitRanges(features, rangeGetter, visitor);
}

/**
 * Compute the range of the provided features using the layer's configured
 * timeattributes. If the optional features array is omitted, the features
 * will come from the layer.
 * @param {StoryLayer} storyLayer
 * @param {array} features (optional)
 * @returns {storytools.core.time.Range} range of features
 */
exports.computeVectorRange = function(storyLayer, features) {
    var startAtt = storyLayer.get('timeAttribute');
    var endAtt = storyLayer.get('endTimeAttribute');
    var layer = storyLayer.getLayer();
    features = features || storyLayer.get('features') || layer.getSource().getFeatures();
    return utils.computeRange(features, function(f) {
        return utils.createRange(f.get(startAtt), f.get(endAtt));
    });
};

exports.filterVectorLayer = filterVectorLayer;
exports.filterVectorBoxLayer = filterVectorBoxLayer;

exports.MapController = function(options, timeControls) {
    var loadListener = null,
          tileStatusCallback = options.tileStatusCallback,
          storyMap = options.storyMap;
    function layerAdded(layer) {
        var source, image;
        var loaded = function(event) {
            // grab the active loadListener to avoid phantom onloads
            // when listener is cancelled
            var currentListener = loadListener;
            if (currentListener) {
                currentListener.tileLoaded(event, source);
            }
        };
        var loadstart = function() {
            // grab the active loadListener to avoid phantom onloads
            // when listener is cancelled
            var currentListener = loadListener;
            if (currentListener) {
                currentListener.tileQueued(source);
            }
        };
        if (layer instanceof ol.layer.Tile && layer.getSource() instanceof ol.source.TileWMS) {
            source = layer.getSource();
            source.on('tileloadstart', loadstart);
            source.on('tileloadend', loaded);
            // @todo handle onerror and cancel deferred with an example
            // to stop automatic playback
            source.on('tileloaderror', loaded);
        } else if (layer instanceof ol.layer.Image && layer.getSource() instanceof ol.source.ImageWMS) {
            source = layer.getSource();
            source.on('imageloadstart', loadstart);
            source.on('imageloadend', loaded);
            source.on('imageloaderror', loaded);
        }
    }
    function createLoadListener() {
        if (loadListener !== null) {
            loadListener.cancel();
        }
        loadListener = new TileLoadListener(tileStatusCallback);
        return loadListener;
    }

    function updateCenterAndZoom(range){
        var currentBoxes = filterVectorBoxLayer(storyMap.storyBoxesLayer, range);
        var currentPinFeatures = filterVectorLayer(storyMap.storyPinsLayer, range);

        if (currentPinFeatures && currentPinFeatures.length > 0) {
          return;
        } else if (currentBoxes && currentBoxes.length > 0) {
            var currentBox = currentBoxes[0];

            if (currentBox.center) {
                storyMap.animateCenterAndZoom(currentBox.center, currentBox.zoom);
            }
        } else {
            if (storyMap.returnToExtent) {
               storyMap.animateCenterAndZoom(storyMap.getCenter(), storyMap.getZoom());
            }
        }
    }

    function updateLayers(range) {
        var storyLayers = storyMap.getStoryLayers();
        var time = new Date(range.start).toISOString();
        if (range.start != range.end) {
            time += "/" + new Date(range.end).toISOString();
        }
        for (var i = 0; i < storyLayers.getLength(); i++) {
            var storyLayer = storyLayers.item(i), layer = storyLayer.getLayer();
            if ((layer instanceof ol.layer.Tile && layer.getSource() instanceof ol.source.TileWMS) ||
                  (layer instanceof ol.layer.Image && layer.getSource() instanceof ol.source.ImageWMS)) {
                if (storyLayer.get('times')) {
                    layer.getSource().updateParams({TIME: time});
                }
            } else if (layer instanceof ol.layer.Vector) {
                filterVectorLayer(storyLayer, range);
            }
        }
        // this is a non-story layer - not part of the main collection
        filterVectorLayer(storyMap.storyPinsLayer, range);
        if (storyLayers.getLength() >= 1) {
            timeControls.defer(createLoadListener().deferred);
        }
    }
    var me = this;
    me.layers = {};
    storyMap.getStoryLayers().on('add', function(ev) {
        var lyr = ev.element, id = lyr.get('id');
        if (me.layers[id] !== true) {
            layerAdded(lyr.getLayer());
            me.layers[id] = true;
        }
    });
    storyMap.getStoryLayers().forEach(function(lyr) {
        var id = lyr.get('id');
        if (id !== undefined && me.layers[id] !== true) {
            layerAdded(lyr.getLayer());
            me.layers[id] = true;
        }
    });
    timeControls.on('rangeChange', updateCenterAndZoom);
    timeControls.on('rangeChange', updateLayers);
};

},{"./utils":9,"moment":13}],6:[function(require,module,exports){
var utils = require('./utils');
var BoxModel = require('./boxes').BoxModel;

/**
 * @todo document me
 */
exports.TimeModel = function(options, boxes, annotations) {
    
    var events = new utils.Events(),
        boxModel = new BoxModel(boxes);

    this.annotations = annotations;
    this.boxes = boxes;
    this.boxy = options.boxy;
    this.storyLayers = [];
    this.fixed = false;
    this.mode = 'instant';
    this.interval = 1000;

    function init(opts) {
        if (opts.hasOwnProperty('fixed')) {
            this.fixed = opts.fixed;
        }

        if (opts.hasOwnProperty('speed') && opts.speed !== undefined) {
            this.interval = opts.speed;
        }

        if (opts.hasOwnProperty('mode') && opts.mode !== undefined) {
            this.mode = opts.mode;
        }
        if (opts.hasOwnProperty('annotations')) {
            this.annotations.update(opts.annotations);
        }
        if (opts.hasOwnProperty('boxes')) {
            this.boxy.update(opts.boxes);
        }

        if (opts.hasOwnProperty('storyLayers')) {
            this.storyLayers = opts.storyLayers;
        }

        // @todo is the best name for this
        if (opts.hasOwnProperty('data')) {
            boxModel.setRange(opts.data);
        }
    }

    init.call(this, options);
    this.getRange = function() {
        return boxModel.getRange();
    };
    this.getTotalRange = function() {
        // @todo need to access layers and cached dimension data
        //       and consider annotations?
        throw Error('not implemented');
    };
    this.update = init;
    this.getSteps = function() {
        return boxModel.getSteps();
    };
    this.getIndex = function(instant) {
        return boxModel.getIndex(instant);
    };
    this.getRangeAt = function(i, j) {
        return boxModel.getRangeAt(i, j);
    };
};

},{"./boxes":2,"./utils":9}],7:[function(require,module,exports){
var format = new ol.format.GeoJSON();


var StoryPin = function(data, projection) {
    ol.Feature.call(this, data);
    if (data) {
        if (data.the_geom) {
            var geom = data.the_geom;
            if (typeof geom === 'string' || 'type' in geom) {
                geom = format.readGeometry(geom, {
                    featureProjection: projection
                });
            }
            this.setGeometry(geom);
            delete data.the_geom;
        }
        this.setId(data.id);
    }
};
StoryPin.prototype = Object.create(ol.Feature.prototype);
StoryPin.prototype.constructor = StoryPin;
// expose these simply for the timeline - it doesn't know they're features
['id','start_time','end_time','content','title','in_timeline','in_map', 'auto_show', 'pause_playback'].forEach(function(prop) {
    Object.defineProperty(StoryPin.prototype, prop, {
        get: function() {
            var val = this.get(prop);
            return typeof val === 'undefined' ? null : val;
        },
        set: function(val) {
            this.set(prop, val);
        }
    });
});

/*
 var start = ann.start_time != null ? ann.start_time : range.start;
 var end = ann.end_time != null ? ann.end_time : range.end;
 var type = start === end ? 'box' : 'range';
 return {
 id: ann.id,
 start: start,
 end: end,
 content: ann.content || ann.title,
 title: ann.title,
 type: type
 };
 */

function getTime(props, prop) {
    var val = props[prop];
    if (typeof val != 'undefined') {
        return val *= 1000;
    }
    return null;
}

/**
 * Load StoryPins from geojson, reprojecting from 4326 to the provided
 * projection.
 * @param {Object} geojson
 * @param {String} projection
 * @returns array of StoryPin features
 */
exports.loadFromGeoJSON = function(geojson, projection) {
    if (projection) {
        projection = ol.proj.get(projection);
    }
    return geojson.features.map(function(f) {
        var props = f.properties;
        props.the_geom = f.geometry;
        props.id = f.id;
        props.start_time = getTime(props, 'start_time');
        props.end_time = getTime(props, 'end_time');
        return new StoryPin(props, projection);
    });
};

exports.StoryPin = StoryPin;

},{}],8:[function(require,module,exports){
var utils = require('./utils');
/**
 * Visual feedback of complete story line. Allow dragging of range, click
 * to position.
 *
 * Playback Modes
 * - fixed cumulative (min fixed at 0, max adjusts with tick)
 * - fixed range playback (range fixed, window adjusts with tick)
 * - fixed instant (like fixed range but range of 0)
 * - open range playback (fully adjustable min/max, window adjusts with tick)
 *
 * Internal model
 * - 0-N where N is either the number of instants or the total number of extents
 *
 * @param {type} id
 * @param {type} model
 * @returns {TimeSlider}
 */
exports.TimeSlider = function(id, model) {
    var slider = $("#" + id)[0];
    var events = new utils.Events();
    var initialized = false;
    var singleSlider;

    function init(model) {
        var options = {
            step: 1,
            start: [0, 0],
            animate: false,
            connect: true,
            range: {
                min: 0,
                max: model.getSteps() - 1
            },
            behaviour: 'drag-snap'
        };
        singleSlider = false;

        /*if (model.fixed) {
            // @todo need model interval
        }*/

        if (model.mode === 'cumulative') {
            singleSlider = true;
            options.connect = 'lower';
        } else if (model.mode === 'instant') {
            singleSlider = true;
            options.connect = false;
        } else if (model.mode === 'range') {
            if (model.fixed) {
                // ideally we'd support snap but it breaks fixed
                options.behaviour = 'drag-fixed';
            }
        } else {
            throw "invalid model mode : " + model.mode;
        }

        if (initialized) {
            // have to update values based on current state
            var range = getSliderRangeInternal();
            if (singleSlider) {
                options.start = range[0];
            } else {
                if (range[0] === range[1]) {
                    range[1] += 1;
                }
                options.start = range;
            }
        } else if (singleSlider) {
            options.start = 0;
        }

        if (!initialized) {
            if(slider)
            {
                noUiSlider.create(slider, options);
                slider.noUiSlider.on('slide', function (ev) {
                    var range = getRange();
                    events.event('rangeChanged').publish(range);
                });
                initialized = true;
            }
        } else {
          options.range = {
            min: 0,
            max: model.getSteps() - 1
          };
          slider.noUiSlider.updateOptions(options, true);
        }

    }

    init(model);

    function getSliderRangeInternal() {
        var range = slider.noUiSlider.get();
        if (! Array.isArray(range)) {
            range = parseInt(range, 10);
            range = [model.mode === 'cumulative' ? 0 : range, range];
        } else {
            range = range.map(function(i) { return parseInt(i, 10); });
        }
        return range;
    }

    function getRange() {
        var range = getSliderRangeInternal();
        return model.getRangeAt(range[0], range[1]);
    }

    function width() {
        var range = getSliderRangeInternal();
        return range[1] - range[0];
    }

    function isAtEnd(left) {
        var range = getSliderRangeInternal();
        if (left) {
            return range[0] === 0;
        }
        return range[1] === model.getSteps()-1;
    }

    function setValue(val) {
        // normalize nouislider.val to handle array
        if (singleSlider) {
            slider.noUiSlider.set(val[1]);
        } else {
            slider.noUiSlider.set(val);
        }
    }

    this.slider = slider;
    this.on = function(event, fn) {
        if(initialized) {
            events.event(event).subscribe(fn);
        }
    };
    this.getSliderRangeInternal = getSliderRangeInternal;
    this.center = function(index) {
        var half = Math.floor(width() / 2);
        setValue([index - half, index + half]);
    };
    this.move = function(amt) {
        var vals  = getSliderRangeInternal();
        vals[0] += amt;
        vals[1] += amt;
        setValue(vals);
        return isAtEnd(amt < 0);
    };
    this.grow = function(amt) {
        var vals = getSliderRangeInternal();
        vals[1] += amt;
        setValue(vals);
        return isAtEnd(false);
    };
    this.growTo = function(where) {
        var vals = getSliderRangeInternal();
        vals[1] = where;
        setValue(vals);
        return isAtEnd(false);
    };
    this.jump = function(to) {
        setValue([to, to + width()]);
    };
    this.getRange = getRange;
    this.update = init;
};

},{"./utils":9}],9:[function(require,module,exports){
var moment = require('moment');

/**
 * Get the number of milliseconds from the provided arg.
 * @param arg - either Date, range (returns start), string or number
 * @returns milliseconds or null if nothing provided
 */
var getTime = function(arg) {
    var type = typeof arg;
    if (type === 'number') {
        return arg;
    }
    if (arg instanceof Date) {
        return arg.getTime();
    }
    if (type === 'string') {
        return parseDate(arg).getTime();
    }
    /*jshint eqnull:true */
    if (arg == null) {
        return null;
    }
    if (isRangeLike(arg)) {
        /*jshint eqnull:true */
        return getTime(arg.start != null ? arg.start : arg.end);
    }
    throw new Error('cannot call getTime with ' + type + ", : " + arg);
};

var isRangeLike = function(object) {
    /*jshint eqnull:true */
    return object != null && (object.hasOwnProperty('start') || object.hasOwnProperty('end'));
};

exports.isRangeLike = isRangeLike;

exports.createRange = function(start, end) {
    if (arguments.length === 1) {
        var other = start;
        if (isRangeLike(other)) {
            start = other.start;
            end = other.end;
        } else {
            end = start;
        }
    }
    /*jshint eqnull:true */
    if (start != null && end != null && start > end) {
        throw new Error('start > end');
    }
    return new Range(getTime(start), getTime(end));
};

exports.rangesEqual = function(a, b) {
    return getTime(a.start) === getTime(b.start) &&
        getTime(a.end) === getTime(b.end);
};

function rangeContains(range, time) {
    /*jshint eqnull:true */
    if (time == null) {
        throw new Error('invalid time argument');
    }
    /*jshint eqnull:true */
    return ((range.start != null ? time >= range.start : true) &&
           (range.end != null ? time < range.end : true)) ||
           range.start === range.end && time === range.start;
}

exports.parseISODuration = function(duration) {
    var values = exports.isoDurationToMoment(duration);
    return moment.duration(values).asMilliseconds();
};

exports.Interval = function(start, end, duration) {
    if (typeof start === 'object') {
        var opts = start;
        start = opts.start;
        end = opts.end;
        duration = opts.duration;
    }
    if (start === end) {
        throw new Error('interval should have width');
    }
    Range.call(this, start, end);
    this.duration = duration;
    this.interval = exports.parseISODuration(this.duration);
    this.offset = exports.createOffsetter(this);
};

function Range(start, end) {
    if (isNaN(start) || isNaN(end)) {
        throw new Error('invalid start and/or end');
    }
    this.start = start;
    this.end = end;
}
/**
 * extend this Range by another. This algorithm will consider an open-ended
 * range to represent a minimum of start and maximum of end.
 * @param {type} other
 * @returns {undefined}
 */
Range.prototype.extend = function(other) {
    /*jshint eqnull:true */
    if (!isRangeLike(other)) {
        other = exports.createRange(other);
    }
    var start = getTime(other.start);
    var end = getTime(other.end);
    if (start == null) {
        start = end;
    }
    if (end == null) {
        end = start;
    }
    if (start != null) {
        if (this.start == null) {
            this.start = start;
        } else {
            this.start = Math.min(this.start, start);
        }
    }
    if (end != null) {
        if (this.end == null) {
            this.end = end;
        } else {
            this.end = Math.max(this.end, end);
        }
    }
};
Range.prototype.intersects = function(other) {
    if (isRangeLike(other)) {
        /*jshint eqnull:true */
        var es = other.start == null ? Number.MIN_VALUE : other.start;
        var ee = other.end == null ? Number.MAX_VALUE : other.end;
        // intersection if (any)
        // effective end in this range
        // effective start in this range
        // effective start before and effective end after
        return rangeContains(this, es) ||
            rangeContains(this, ee) ||
            es <= this.start && ee >= this.end;
    } else {
        return rangeContains(this, getTime(other));
    }
};
Range.prototype.toString = function() {
    return new Date(this.start).toUTCString() + " : " + new Date(this.end).toUTCString();
};
Range.prototype.center = function() {
    return Math.floor(this.start + (this.end - this.start) / 2);
};
Range.prototype.width = function() {
    return this.end - this.start;
};
Range.prototype.isEmpty = function() {
    /*jshint eqnull:true */
    return this.end == null && this.start == null;
};
exports.Range = Range;



/**
 * Compute the overall range of provided args. Args may be an array of:
 * date or long, range, object with property/function yielding range for the
 * object.
 * @param {type} args
 * @returns range will have start/end even if the same time.
 */
exports.computeRange = function(args, rangeGetter) {
    var range = new Range(null, null);
    exports.visitRanges(args, rangeGetter, function(arg, r) {
        range.extend(r);
    });
    /*jshint eqnull:true */
    if (range.start == null) {
        range.start = range.end;
    }
    if (range.end == null) {
        range.end = range.start;
    }
    return range;
};

exports.visitRanges = function(objects, rangeGetter, visitor) {
    var getRange;
    if (typeof rangeGetter == 'string') {
        getRange = function(object) {
            return object[rangeGetter];
        };
    } else if (typeof rangeGetter == 'function') {
        getRange = rangeGetter;
    } else {
        getRange = function(object) {
            return isRangeLike(object) ? object : exports.createRange(object);
        };
    }
    for (var i = 0, ii = objects.length; i < ii; i++) {
        var object = objects[i];
        visitor(object, getRange(object));
    }
};

/** for the given what, find the index in the items that what is closest
 * to. items must be sorted. The lowest closest value possible is returned.
 */
exports.binarySearch = function(items, what) {
    var start = 0;
    var stop = items.length - 1;
    var mid = stop + start / 2 | 0;
    var val;
    if (what < items[0]) {
        return 0;
    }
    if (what > items[stop]) {
        return items.length - 1;
    }
    while ((val = items[mid]) !== what && start < stop) {
        if (what > val) {
            if (what < items[mid + 1]) {
                return mid;
            }
        } else if (what < val) {
            if (what > items[mid - 1]) {
                return mid - 1;
            }
            stop = mid - 1;
        }
        mid = stop + start / 2 | 0;
    }
    return mid;
};

exports.find = function(items, what) {
    if (what < items[0]) {
        return 0;
    }
    for (var i = 0, ii = items.length - 1; i < ii; i++) {
        if (what >= items[i] && what < items[i + 1]) {
            return i;
        }
    }
    return items.length - 1;
};

exports.Events = function() {
    var topics = {};

    // @todo introduce setting topics with arguments and logging/exception
    // on un-fired event

    function event(id) {
        var callbacks, method,
                topic = id && topics[ id ];
        if (!topic) {
            callbacks = jQuery.Callbacks();
            topic = {
                publish: callbacks.fire,
                subscribe: callbacks.add,
                unsubscribe: callbacks.remove
            };
            if (id) {
                topics[ id ] = topic;
            }
        }
        return topic;
    }

    return {
        event: event
    };
};

exports.pickInterval = function(range) {
    var intervals = [
        moment.duration(1, 'seconds').asMilliseconds(),
        moment.duration(1, 'minutes').asMilliseconds(),
        moment.duration(1, 'hours').asMilliseconds(),
        moment.duration(1, 'days').asMilliseconds(),
        moment.duration(1, 'weeks').asMilliseconds(),
        moment.duration(1, 'months').asMilliseconds(),
        moment.duration(1, 'years').asMilliseconds()
    ];
    return intervals[Math.max(exports.find(intervals, range.width()) - 1, 0)];
};

exports.stringToMoment = function(date, format){
    return moment(date, format);
};

exports.getTime = getTime;

/**
 * Read an iso duration into a moment.js object.
 * @param {string} duration
 * @returns {object} with moment.js info
 */
exports.isoDurationToMoment = function(duration) {
    if (duration.charAt(0) != 'P') {
        throw new Error('expected P as starting duration : ' + duration);
    }
    var pattern = /(\d+)(\w)/g;
    var date = null, time = null, values = {};
    duration = duration.substring(1);
    if (duration.indexOf('T') >= 0) {
        var parts = duration.split('T');
        date = parts[0];
        time = parts[1];
    } else {
        date = duration;
    }
    var mapping = {
        'Y': 'years',
        'M': 'months',
        'W': 'weeks',
        'D': 'days',
        'H': 'hours',
        'm': 'minutes',
        'S': 'seconds'
    };
    function parse(chunk, time) {
        function read(amount, part) {
            if (time && part == 'M') {
                part = 'm';
            }
            var mappedTo = mapping[part];
            if (typeof mappedTo == 'undefined') {
                throw Error('unknown duration specifier : ' + part);
            }
            values[mappedTo] = parseFloat(amount);
        }
        var next;
        while ((next = pattern.exec(chunk)) !== null) {
            read(next[1], next[2]);
        }
    }
    if (date !== null) {
        parse(date, false);
    }
    if (time !== null) {
        parse(time, true);
    }
    return values;
};

/**
 * Get a function for the provided duration that computes a new timestamp based on a
 * provided date and optional multiplier (negative for reverse).
 * @param {string} iso duration
 * @returns {function} offsetter(timestamp, multiplier=1)
 */
exports.createOffsetter = function(intervalOrDuration) {
    var duration = typeof intervalOrDuration === 'string' ? intervalOrDuration: intervalOrDuration.duration;
    var values = exports.isoDurationToMoment(duration);
    // as of writing, moment assumes y=365d and m=30d resulting in slow
    // day of month shifts that break ticks from matching
    // so we take care of this using a more accurate approach
    // ** the current approach breaks down if the day of month is greater than
    // 28 and day of month will no longer be retained (will shift)
    if ('years' in values || 'months' in values) {
        var years = values.years;
        var months = values.months;
        values.years = 0;
        values.months = 0;
        var millis = moment.duration(values).asMilliseconds();
        return function(ts, mult) {
            mult = mult || 1;
            var d = new Date(ts);
            /*jshint eqnull:true */
            var y = d.getUTCFullYear();
            if (years != null) {
                y += mult * years;
            }
            var m = d.getUTCMonth();
            if (months != null) {
                m += mult * months;
            }
            d.setUTCFullYear(y, m);
            return d.getTime() + (mult * millis);
        };
    } else {
        var offset = moment.duration(values).asMilliseconds();
        return function(ts, mult) {
            mult = mult || 1;
            return ts + (mult * offset);
        };
    }
};


/**
 * Contains implementations of Date.parse and date.toISOString that match the
 *     ECMAScript 5 specification for parsing RFC 3339 dates.
 *     http://tools.ietf.org/html/rfc3339
 */


/**
 * The regex to be used for validating dates. You can provide your own
 * regex for instance for adding support for years before BC. Default
 * value is: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/
 */
var dateRegEx = /^(-?)(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/;


/**
 * Generate a date object from a string.  The format for the string follows
 *     the profile of ISO 8601 for date and time on the Internet (see
 *     http://tools.ietf.org/html/rfc3339).  We don't call the native
 *     Date.parse because of inconsistency between implmentations.  In
 *     Chrome, calling Date.parse with a string that doesn't contain any
 *     indication of the timezone (e.g. "2011"), the date is interpreted
 *     in local time.  On Firefox, the assumption is UTC.
 *
 * Parameters:
 * str - {String} A string representing the date (e.g.
 *     "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z",
 *     "2010-08-07T11:58:23.123-06", "-3000-08-07T16:58:23.123Z").
 *
 * Returns:
 * {Date} A date object.  If the string could not be parsed, an invalid
 *     date is returned (i.e. isNaN(date.getTime())).
 */
parseDate = function(str) {
  var date;
  var match = str.match(dateRegEx);
  if (match && (match[2] || match[8])) { // must have at least year or time
    var year = parseInt(match[2], 10) || 0;
    if (match[1]){
      year = year * -1;
    }
    var month = (parseInt(match[3], 10) - 1) || 0;
    var day = parseInt(match[4], 10) || 1;
    date = new Date(Date.UTC(year, month, day));
    // optional time
    var type = match[8];
    if (type) {
      var hours = parseInt(match[5], 10);
      var minutes = parseInt(match[6], 10);
      var secFrac = parseFloat(match[7]);
      var seconds = secFrac | 0;
      var milliseconds = Math.round(1000 * (secFrac - seconds));
      date.setUTCHours(hours, minutes, seconds, milliseconds);
      // check offset
      if (type !== "Z") {
        var hoursOffset = parseInt(type, 10);
        var minutesOffset = parseInt(match[9], 10) || 0;
        var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);
        date = new Date(date.getTime() + offset);
      }
    }
  } else {
    date = new Date("invalid");
  }
  return date;
};


//  Secure Hash Algorithm (SHA1)
//  http://www.webtoolkit.info/

exports.sha1 = function(msg) {

  var rotate_left = function(n, s) {
    return (n << s) | (n >>> (32 - s));
  };

  var cvt_hex = function(val) {
    var str = '';
    var i;
    var v;

    for (i = 7; i >= 0; i--) {
      v = (val >>> (i * 4)) & 0x0f;
      str += v.toString(16);
    }
    return str;
  };


  var utf8Encode = function(string) {
    string = string.replace(/\r\n/g, '\n');
    var utftext = '';

    for (var n = 0; n < string.length; n++) {

      var c = string.charCodeAt(n);

      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if ((c > 127) && (c < 2048)) {
        utftext += String.fromCharCode((c >> 6) | 192);
        utftext += String.fromCharCode((c & 63) | 128);
      } else {
        utftext += String.fromCharCode((c >> 12) | 224);
        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
        utftext += String.fromCharCode((c & 63) | 128);
      }

    }
    return utftext;
  };

  var blockstart;
  var i, j;
  var W = new Array(80);
  var H0 = 0x67452301;
  var H1 = 0xEFCDAB89;
  var H2 = 0x98BADCFE;
  var H3 = 0x10325476;
  var H4 = 0xC3D2E1F0;
  var A, B, C, D, E;
  var temp;

  msg = utf8Encode(msg);

  var msg_len = msg.length;

  var word_array = [];
  for (i = 0; i < msg_len - 3; i += 4) {
    j = msg.charCodeAt(i) << 24 | msg.charCodeAt(i + 1) << 16 |
        msg.charCodeAt(i + 2) << 8 | msg.charCodeAt(i + 3);
    word_array.push(j);
  }

  switch (msg_len % 4) {
    case 0:
      i = 0x080000000;
      break;
    case 1:
      i = msg.charCodeAt(msg_len - 1) << 24 | 0x0800000;
      break;

    case 2:
      i = msg.charCodeAt(msg_len - 2) << 24 | msg.charCodeAt(msg_len - 1) << 16 | 0x08000;
      break;

    case 3:
      i = msg.charCodeAt(msg_len - 3) << 24 | msg.charCodeAt(msg_len - 2) << 16 |
          msg.charCodeAt(msg_len - 1) << 8 | 0x80;
      break;
  }

  word_array.push(i);

  while ((word_array.length % 16) != 14) {
    word_array.push(0);
  }

  word_array.push(msg_len >>> 29);
  word_array.push((msg_len << 3) & 0x0ffffffff);


  for (blockstart = 0; blockstart < word_array.length; blockstart += 16) {

    for (i = 0; i < 16; i++) {
      W[i] = word_array[blockstart + i];
    }
    for (i = 16; i <= 79; i++) {
      W[i] = rotate_left(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    }

    A = H0;
    B = H1;
    C = H2;
    D = H3;
    E = H4;

    for (i = 0; i <= 19; i++) {
      temp = (rotate_left(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    for (i = 20; i <= 39; i++) {
      temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    for (i = 40; i <= 59; i++) {
      temp = (rotate_left(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    for (i = 60; i <= 79; i++) {
      temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    H0 = (H0 + A) & 0x0ffffffff;
    H1 = (H1 + B) & 0x0ffffffff;
    H2 = (H2 + C) & 0x0ffffffff;
    H3 = (H3 + D) & 0x0ffffffff;
    H4 = (H4 + E) & 0x0ffffffff;

  }

  var localtemp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);

  return localtemp.toLowerCase();

};

},{"moment":13}],10:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],11:[function(require,module,exports){
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof define === 'function' && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],12:[function(require,module,exports){
"use strict";
/**
 * Created by Alex on 11/6/2014.
 */

// https://github.com/umdjs/umd/blob/master/returnExports.js#L40-L60
// if the module has no dependencies, the above pattern can be simplified to
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.keycharm = factory();
  }
}(this, function () {

  function keycharm(options) {
    var preventDefault = options && options.preventDefault || false;

    var container = options && options.container || window;

    var _exportFunctions = {};
    var _bound = {keydown:{}, keyup:{}};
    var _keys = {};
    var i;

    // a - z
    for (i = 97; i <= 122; i++) {_keys[String.fromCharCode(i)] = {code:65 + (i - 97), shift: false};}
    // A - Z
    for (i = 65; i <= 90; i++) {_keys[String.fromCharCode(i)] = {code:i, shift: true};}
    // 0 - 9
    for (i = 0;  i <= 9;   i++) {_keys['' + i] = {code:48 + i, shift: false};}
    // F1 - F12
    for (i = 1;  i <= 12;   i++) {_keys['F' + i] = {code:111 + i, shift: false};}
    // num0 - num9
    for (i = 0;  i <= 9;   i++) {_keys['num' + i] = {code:96 + i, shift: false};}

    // numpad misc
    _keys['num*'] = {code:106, shift: false};
    _keys['num+'] = {code:107, shift: false};
    _keys['num-'] = {code:109, shift: false};
    _keys['num/'] = {code:111, shift: false};
    _keys['num.'] = {code:110, shift: false};
    // arrows
    _keys['left']  = {code:37, shift: false};
    _keys['up']    = {code:38, shift: false};
    _keys['right'] = {code:39, shift: false};
    _keys['down']  = {code:40, shift: false};
    // extra keys
    _keys['space'] = {code:32, shift: false};
    _keys['enter'] = {code:13, shift: false};
    _keys['shift'] = {code:16, shift: undefined};
    _keys['esc']   = {code:27, shift: false};
    _keys['backspace'] = {code:8, shift: false};
    _keys['tab']       = {code:9, shift: false};
    _keys['ctrl']      = {code:17, shift: false};
    _keys['alt']       = {code:18, shift: false};
    _keys['delete']    = {code:46, shift: false};
    _keys['pageup']    = {code:33, shift: false};
    _keys['pagedown']  = {code:34, shift: false};
    // symbols
    _keys['=']     = {code:187, shift: false};
    _keys['-']     = {code:189, shift: false};
    _keys[']']     = {code:221, shift: false};
    _keys['[']     = {code:219, shift: false};



    var down = function(event) {handleEvent(event,'keydown');};
    var up = function(event) {handleEvent(event,'keyup');};

    // handle the actualy bound key with the event
    var handleEvent = function(event,type) {
      if (_bound[type][event.keyCode] !== undefined) {
        var bound = _bound[type][event.keyCode];
        for (var i = 0; i < bound.length; i++) {
          if (bound[i].shift === undefined) {
            bound[i].fn(event);
          }
          else if (bound[i].shift == true && event.shiftKey == true) {
            bound[i].fn(event);
          }
          else if (bound[i].shift == false && event.shiftKey == false) {
            bound[i].fn(event);
          }
        }

        if (preventDefault == true) {
          event.preventDefault();
        }
      }
    };

    // bind a key to a callback
    _exportFunctions.bind = function(key, callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      if (_keys[key] === undefined) {
        throw new Error("unsupported key: " + key);
      }
      if (_bound[type][_keys[key].code] === undefined) {
        _bound[type][_keys[key].code] = [];
      }
      _bound[type][_keys[key].code].push({fn:callback, shift:_keys[key].shift});
    };


    // bind all keys to a call back (demo purposes)
    _exportFunctions.bindAll = function(callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      for (var key in _keys) {
        if (_keys.hasOwnProperty(key)) {
          _exportFunctions.bind(key,callback,type);
        }
      }
    };

    // get the key label from an event
    _exportFunctions.getKey = function(event) {
      for (var key in _keys) {
        if (_keys.hasOwnProperty(key)) {
          if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
            return key;
          }
          else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
            return key;
          }
          else if (event.keyCode == _keys[key].code && key == 'shift') {
            return key;
          }
        }
      }
      return "unknown key, currently not supported";
    };

    // unbind either a specific callback from a key or all of them (by leaving callback undefined)
    _exportFunctions.unbind = function(key, callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      if (_keys[key] === undefined) {
        throw new Error("unsupported key: " + key);
      }
      if (callback !== undefined) {
        var newBindings = [];
        var bound = _bound[type][_keys[key].code];
        if (bound !== undefined) {
          for (var i = 0; i < bound.length; i++) {
            if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
              newBindings.push(_bound[type][_keys[key].code][i]);
            }
          }
        }
        _bound[type][_keys[key].code] = newBindings;
      }
      else {
        _bound[type][_keys[key].code] = [];
      }
    };

    // reset all bound variables.
    _exportFunctions.reset = function() {
      _bound = {keydown:{}, keyup:{}};
    };

    // unbind all listeners and reset all variables.
    _exportFunctions.destroy = function() {
      _bound = {keydown:{}, keyup:{}};
      container.removeEventListener('keydown', down, true);
      container.removeEventListener('keyup', up, true);
    };

    // create listeners.
    container.addEventListener('keydown',down,true);
    container.addEventListener('keyup',up,true);

    // return the public functions.
    return _exportFunctions;
  }

  return keycharm;
}));



},{}],13:[function(require,module,exports){
//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var string, match, dayFormat,
        dateFormat, timeFormat, tzFormat;
    var timezones = {
        ' GMT': ' +0000',
        ' EDT': ' -0400',
        ' EST': ' -0500',
        ' CDT': ' -0500',
        ' CST': ' -0600',
        ' MDT': ' -0600',
        ' MST': ' -0700',
        ' PDT': ' -0700',
        ' PST': ' -0800'
    };
    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
    var timezone, timezoneIndex;

    string = config._i
        .replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
    match = basicRfcRegex.exec(string);

    if (match) {
        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        if (match[1]) { // day of week given
            var momentDate = new Date(match[2]);
            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];

            if (match[1].substr(0,3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
            }
        }

        switch (match[5].length) {
            case 2: // military
                if (timezoneIndex === 0) {
                    timezone = ' +0000';
                } else {
                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
                }
                break;
            case 4: // Zone
                timezone = timezones[match[5]];
                break;
            default: // UT or +/-9999
                timezone = timezones[' GMT'];
        }
        match[5] = timezone;
        config._i = match.splice(1).join('');
        tzFormat = ' ZZ';
        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
        configFromStringAndFormat(config);
        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],14:[function(require,module,exports){
'use strict';

(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    window.propagating = factory();
  }
}(function () {
  var _firstTarget = null; // singleton, will contain the target element where the touch event started

  /**
   * Extend an Hammer.js instance with event propagation.
   *
   * Features:
   * - Events emitted by hammer will propagate in order from child to parent
   *   elements.
   * - Events are extended with a function `event.stopPropagation()` to stop
   *   propagation to parent elements.
   * - An option `preventDefault` to stop all default browser behavior.
   *
   * Usage:
   *   var hammer = propagatingHammer(new Hammer(element));
   *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});
   *
   * @param {Hammer.Manager} hammer   An hammer instance.
   * @param {Object} [options]        Available options:
   *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.
   *                                    Enforce preventing the default browser behavior.
   *                                    Cannot be set to `false`.
   * @return {Hammer.Manager} Returns the same hammer instance with extended
   *                          functionality
   */
  return function propagating(hammer, options) {
    var _options = options || {
      preventDefault: false
    };

    if (hammer.Manager) {
      // This looks like the Hammer constructor.
      // Overload the constructors with our own.
      var Hammer = hammer;

      var PropagatingHammer = function(element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer(element, o), o);
      };
      Hammer.assign(PropagatingHammer, Hammer);

      PropagatingHammer.Manager = function (element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer.Manager(element, o), o);
      };

      return PropagatingHammer;
    }

    // create a wrapper object which will override the functions
    // `on`, `off`, `destroy`, and `emit` of the hammer instance
    var wrapper = Object.create(hammer);

    // attach to DOM element
    var element = hammer.element;

    if(!element.hammer) element.hammer = [];
    element.hammer.push(wrapper);

    // register an event to catch the start of a gesture and store the
    // target in a singleton
    hammer.on('hammer.input', function (event) {
      if (_options.preventDefault === true || (_options.preventDefault === event.pointerType)) {
        event.preventDefault();
      }
      if (event.isFirst) {
        _firstTarget = event.target;
      }
    });

    /** @type {Object.<String, Array.<function>>} */
    wrapper._handlers = {};

    /**
     * Register a handler for one or multiple events
     * @param {String} events    A space separated string with events
     * @param {function} handler A callback function, called as handler(event)
     * @returns {Hammer.Manager} Returns the hammer instance
     */
    wrapper.on = function (events, handler) {
      // register the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];
        if (!_handlers) {
          wrapper._handlers[event] = _handlers = [];

          // register the static, propagated handler
          hammer.on(event, propagatedHandler);
        }
        _handlers.push(handler);
      });

      return wrapper;
    };

    /**
     * Unregister a handler for one or multiple events
     * @param {String} events      A space separated string with events
     * @param {function} [handler] Optional. The registered handler. If not
     *                             provided, all handlers for given events
     *                             are removed.
     * @returns {Hammer.Manager}   Returns the hammer instance
     */
    wrapper.off = function (events, handler) {
      // unregister the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];
        if (_handlers) {
          _handlers = handler ? _handlers.filter(function (h) {
            return h !== handler;
          }) : [];

          if (_handlers.length > 0) {
            wrapper._handlers[event] = _handlers;
          }
          else {
            // remove static, propagated handler
            hammer.off(event, propagatedHandler);
            delete wrapper._handlers[event];
          }
        }
      });

      return wrapper;
    };

    /**
     * Emit to the event listeners
     * @param {string} eventType
     * @param {Event} event
     */
    wrapper.emit = function(eventType, event) {
      _firstTarget = event.target;
      hammer.emit(eventType, event);
    };

    wrapper.destroy = function () {
      // Detach from DOM element
      var hammers = hammer.element.hammer;
      var idx = hammers.indexOf(wrapper);
      if(idx !== -1) hammers.splice(idx,1);
      if(!hammers.length) delete hammer.element.hammer;

      // clear all handlers
      wrapper._handlers = {};

      // call original hammer destroy
      hammer.destroy();
    };

    // split a string with space separated words
    function split(events) {
      return events.match(/[^ ]+/g);
    }

    /**
     * A static event handler, applying event propagation.
     * @param {Object} event
     */
    function propagatedHandler(event) {
      // let only a single hammer instance handle this event
      if (event.type !== 'hammer.input') {
        // it is possible that the same srcEvent is used with multiple hammer events,
        // we keep track on which events are handled in an object _handled
        if (!event.srcEvent._handled) {
          event.srcEvent._handled = {};
        }

        if (event.srcEvent._handled[event.type]) {
          return;
        }
        else {
          event.srcEvent._handled[event.type] = true;
        }
      }

      // attach a stopPropagation function to the event
      var stopped = false;
      event.stopPropagation = function () {
        stopped = true;
      };

      //wrap the srcEvent's stopPropagation to also stop hammer propagation:
      var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);
      if(typeof srcStop == "function") {
        event.srcEvent.stopPropagation = function(){
          srcStop();
          event.stopPropagation();
        }
      }

      // attach firstTarget property to the event
      event.firstTarget = _firstTarget;

      // propagate over all elements (until stopped)
      var elem = _firstTarget;
      while (elem && !stopped) {
        var elemHammer = elem.hammer;
        if(elemHammer){
          var _handlers;
          for(var k = 0; k < elemHammer.length; k++){
            _handlers = elemHammer[k]._handlers[event.type];
            if(_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
              _handlers[i](event);
            }
          }
        }
        elem = elem.parentNode;
      }
    }

    return wrapper;
  };
}));

},{}],15:[function(require,module,exports){
'use strict';

var util = require('./util');
var Queue = require('./Queue');

/**
 * DataSet
 *
 * Usage:
 *     var dataSet = new DataSet({
 *         fieldId: '_id',
 *         type: {
 *             // ...
 *         }
 *     });
 *
 *     dataSet.add(item);
 *     dataSet.add(data);
 *     dataSet.update(item);
 *     dataSet.update(data);
 *     dataSet.remove(id);
 *     dataSet.remove(ids);
 *     var data = dataSet.get();
 *     var data = dataSet.get(id);
 *     var data = dataSet.get(ids);
 *     var data = dataSet.get(ids, options, data);
 *     dataSet.clear();
 *
 * A data set can:
 * - add/remove/update data
 * - gives triggers upon changes in the data
 * - can  import/export data in various data formats
 *
 * @param {Array} [data]    Optional array with initial data
 * @param {Object} [options]   Available options:
 *                             {String} fieldId Field name of the id in the
 *                                              items, 'id' by default.
 *                             {Object.<String, String} type
 *                                              A map with field names as key,
 *                                              and the field type as value.
 *                             {Object} queue   Queue changes to the DataSet,
 *                                              flush them all at once.
 *                                              Queue options:
 *                                              - {number} delay  Delay in ms, null by default
 *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
 * @constructor DataSet
 */
// TODO: add a DataSet constructor DataSet(data, options)
function DataSet(data, options) {
  // correctly read optional arguments
  if (data && !Array.isArray(data)) {
    options = data;
    data = null;
  }

  this._options = options || {};
  this._data = {}; // map with data indexed by id
  this.length = 0; // number of items in the DataSet
  this._fieldId = this._options.fieldId || 'id'; // name of the field containing id
  this._type = {}; // internal field types (NOTE: this can differ from this._options.type)

  // all variants of a Date are internally stored as Date, so we can convert
  // from everything to everything (also from ISODate to Number for example)
  if (this._options.type) {
    for (var field in this._options.type) {
      if (this._options.type.hasOwnProperty(field)) {
        var value = this._options.type[field];
        if (value == 'Date' || value == 'ISODate' || value == 'ASPDate') {
          this._type[field] = 'Date';
        } else {
          this._type[field] = value;
        }
      }
    }
  }

  // TODO: deprecated since version 1.1.1 (or 2.0.0?)
  if (this._options.convert) {
    throw new Error('Option "convert" is deprecated. Use "type" instead.');
  }

  this._subscribers = {}; // event subscribers

  // add initial data when provided
  if (data) {
    this.add(data);
  }

  this.setOptions(options);
}

/**
 * @param {Object} [options]   Available options:
 *                             {Object} queue   Queue changes to the DataSet,
 *                                              flush them all at once.
 *                                              Queue options:
 *                                              - {number} delay  Delay in ms, null by default
 *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
 * @param options
 */
DataSet.prototype.setOptions = function (options) {
  if (options && options.queue !== undefined) {
    if (options.queue === false) {
      // delete queue if loaded
      if (this._queue) {
        this._queue.destroy();
        delete this._queue;
      }
    } else {
      // create queue and update its options
      if (!this._queue) {
        this._queue = Queue.extend(this, {
          replace: ['add', 'update', 'remove']
        });
      }

      if (typeof options.queue === 'object') {
        this._queue.setOptions(options.queue);
      }
    }
  }
};

/**
 * Subscribe to an event, add an event listener
 * @param {String} event        Event name. Available events: 'put', 'update',
 *                              'remove'
 * @param {function} callback   Callback method. Called with three parameters:
 *                                  {String} event
 *                                  {Object | null} params
 *                                  {String | Number} senderId
 */
DataSet.prototype.on = function (event, callback) {
  var subscribers = this._subscribers[event];
  if (!subscribers) {
    subscribers = [];
    this._subscribers[event] = subscribers;
  }

  subscribers.push({
    callback: callback
  });
};

// TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
DataSet.prototype.subscribe = function () {
  throw new Error('DataSet.subscribe is deprecated. Use DataSet.on instead.');
};

/**
 * Unsubscribe from an event, remove an event listener
 * @param {String} event
 * @param {function} callback
 */
DataSet.prototype.off = function (event, callback) {
  var subscribers = this._subscribers[event];
  if (subscribers) {
    this._subscribers[event] = subscribers.filter(function (listener) {
      return listener.callback != callback;
    });
  }
};

// TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
DataSet.prototype.unsubscribe = function () {
  throw new Error('DataSet.unsubscribe is deprecated. Use DataSet.off instead.');
};

/**
 * Trigger an event
 * @param {String} event
 * @param {Object | null} params
 * @param {String} [senderId]       Optional id of the sender.
 * @private
 */
DataSet.prototype._trigger = function (event, params, senderId) {
  if (event == '*') {
    throw new Error('Cannot trigger event *');
  }

  var subscribers = [];
  if (event in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers[event]);
  }
  if ('*' in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers['*']);
  }

  for (var i = 0; i < subscribers.length; i++) {
    var subscriber = subscribers[i];
    if (subscriber.callback) {
      subscriber.callback(event, params, senderId || null);
    }
  }
};

/**
 * Add data.
 * Adding an item will fail when there already is an item with the same id.
 * @param {Object | Array} data
 * @param {String} [senderId] Optional sender id
 * @return {Array} addedIds      Array with the ids of the added items
 */
DataSet.prototype.add = function (data, senderId) {
  var addedIds = [],
      id,
      me = this;

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      id = me._addItem(data[i]);
      addedIds.push(id);
    }
  } else if (data instanceof Object) {
    // Single item
    id = me._addItem(data);
    addedIds.push(id);
  } else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', { items: addedIds }, senderId);
  }

  return addedIds;
};

/**
 * Update existing items. When an item does not exist, it will be created
 * @param {Object | Array} data
 * @param {String} [senderId] Optional sender id
 * @return {Array} updatedIds     The ids of the added or updated items
 */
DataSet.prototype.update = function (data, senderId) {
  var addedIds = [];
  var updatedIds = [];
  var updatedData = [];
  var me = this;
  var fieldId = me._fieldId;

  var addOrUpdate = function addOrUpdate(item) {
    var id = item[fieldId];
    if (me._data[id]) {
      // update item
      id = me._updateItem(item);
      updatedIds.push(id);
      updatedData.push(item);
    } else {
      // add new item
      id = me._addItem(item);
      addedIds.push(id);
    }
  };

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      addOrUpdate(data[i]);
    }
  } else if (data instanceof Object) {
    // Single item
    addOrUpdate(data);
  } else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', { items: addedIds }, senderId);
  }
  if (updatedIds.length) {
    this._trigger('update', { items: updatedIds, data: updatedData }, senderId);
  }

  return addedIds.concat(updatedIds);
};

/**
 * Get a data item or multiple items.
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *
 *     get(id: Number | String)
 *     get(id: Number | String, options: Object)
 *
 *     get(ids: Number[] | String[])
 *     get(ids: Number[] | String[], options: Object)
 *
 * Where:
 *
 * {Number | String} id         The id of an item
 * {Number[] | String{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 * {String} [returnType]        Type of data to be returned.
 *                              Can be 'Array' (default) or 'Object'.
 * {Object.<String, String>} [type]
 * {String[]} [fields]          field names to be returned
 * {function} [filter]          filter items
 * {String | function} [order]  Order the items by a field name or custom sort function.
 * @throws Error
 */
DataSet.prototype.get = function (args) {
  var me = this;

  // parse the arguments
  var id, ids, options;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number') {
    // get(id [, options])
    id = arguments[0];
    options = arguments[1];
  } else if (firstType == 'Array') {
    // get(ids [, options])
    ids = arguments[0];
    options = arguments[1];
  } else {
    // get([, options])
    options = arguments[0];
  }

  // determine the return type
  var returnType;
  if (options && options.returnType) {
    var allowedValues = ['Array', 'Object'];
    returnType = allowedValues.indexOf(options.returnType) == -1 ? 'Array' : options.returnType;
  } else {
    returnType = 'Array';
  }

  // build options
  var type = options && options.type || this._options.type;
  var filter = options && options.filter;
  var items = [],
      item,
      itemId,
      i,
      len;

  // convert items
  if (id != undefined) {
    // return a single item
    item = me._getItem(id, type);
    if (filter && !filter(item)) {
      item = null;
    }
  } else if (ids != undefined) {
    // return a subset of items
    for (i = 0, len = ids.length; i < len; i++) {
      item = me._getItem(ids[i], type);
      if (!filter || filter(item)) {
        items.push(item);
      }
    }
  } else {
    // return all items
    for (itemId in this._data) {
      if (this._data.hasOwnProperty(itemId)) {
        item = me._getItem(itemId, type);
        if (!filter || filter(item)) {
          items.push(item);
        }
      }
    }
  }

  // order the results
  if (options && options.order && id == undefined) {
    this._sort(items, options.order);
  }

  // filter fields of the items
  if (options && options.fields) {
    var fields = options.fields;
    if (id != undefined) {
      item = this._filterFields(item, fields);
    } else {
      for (i = 0, len = items.length; i < len; i++) {
        items[i] = this._filterFields(items[i], fields);
      }
    }
  }

  // return the results
  if (returnType == 'Object') {
    var result = {};
    for (i = 0; i < items.length; i++) {
      result[items[i].id] = items[i];
    }
    return result;
  } else {
    if (id != undefined) {
      // a single item
      return item;
    } else {
      // just return our array
      return items;
    }
  }
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array} ids
 */
DataSet.prototype.getIds = function (options) {
  var data = this._data,
      filter = options && options.filter,
      order = options && options.order,
      type = options && options.type || this._options.type,
      i,
      len,
      id,
      item,
      items,
      ids = [];

  if (filter) {
    // get filtered items
    if (order) {
      // create ordered list
      items = [];
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = this._getItem(id, type);
          if (filter(item)) {
            items.push(item);
          }
        }
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids[i] = items[i][this._fieldId];
      }
    } else {
      // create unordered list
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = this._getItem(id, type);
          if (filter(item)) {
            ids.push(item[this._fieldId]);
          }
        }
      }
    }
  } else {
    // get all items
    if (order) {
      // create an ordered list
      items = [];
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          items.push(data[id]);
        }
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids[i] = items[i][this._fieldId];
      }
    } else {
      // create unordered list
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = data[id];
          ids.push(item[this._fieldId]);
        }
      }
    }
  }

  return ids;
};

/**
 * Returns the DataSet itself. Is overwritten for example by the DataView,
 * which returns the DataSet it is connected to instead.
 */
DataSet.prototype.getDataSet = function () {
  return this;
};

/**
 * Execute a callback function for every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<String, String>} [type]
 *                              {String[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 */
DataSet.prototype.forEach = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      data = this._data,
      item,
      id;

  if (options && options.order) {
    // execute forEach on ordered list
    var items = this.get(options);

    for (var i = 0, len = items.length; i < len; i++) {
      item = items[i];
      id = item[this._fieldId];
      callback(item, id);
    }
  } else {
    // unordered
    for (id in data) {
      if (data.hasOwnProperty(id)) {
        item = this._getItem(id, type);
        if (!filter || filter(item)) {
          callback(item, id);
        }
      }
    }
  }
};

/**
 * Map every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<String, String>} [type]
 *                              {String[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Object[]} mappedItems
 */
DataSet.prototype.map = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      mappedItems = [],
      data = this._data,
      item;

  // convert and filter items
  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      item = this._getItem(id, type);
      if (!filter || filter(item)) {
        mappedItems.push(callback(item, id));
      }
    }
  }

  // order items
  if (options && options.order) {
    this._sort(mappedItems, options.order);
  }

  return mappedItems;
};

/**
 * Filter the fields of an item
 * @param {Object | null} item
 * @param {String[]} fields     Field names
 * @return {Object | null} filteredItem or null if no item is provided
 * @private
 */
DataSet.prototype._filterFields = function (item, fields) {
  if (!item) {
    // item is null
    return item;
  }

  var filteredItem = {};

  if (Array.isArray(fields)) {
    for (var field in item) {
      if (item.hasOwnProperty(field) && fields.indexOf(field) != -1) {
        filteredItem[field] = item[field];
      }
    }
  } else {
    for (var field in item) {
      if (item.hasOwnProperty(field) && fields.hasOwnProperty(field)) {
        filteredItem[fields[field]] = item[field];
      }
    }
  }

  return filteredItem;
};

/**
 * Sort the provided array with items
 * @param {Object[]} items
 * @param {String | function} order      A field name or custom sort function.
 * @private
 */
DataSet.prototype._sort = function (items, order) {
  if (util.isString(order)) {
    // order by provided field name
    var name = order; // field name
    items.sort(function (a, b) {
      var av = a[name];
      var bv = b[name];
      return av > bv ? 1 : av < bv ? -1 : 0;
    });
  } else if (typeof order === 'function') {
    // order by sort function
    items.sort(order);
  }
  // TODO: extend order by an Object {field:String, direction:String}
  //       where direction can be 'asc' or 'desc'
  else {
      throw new TypeError('Order must be a function or a string');
    }
};

/**
 * Remove an object by pointer or by id
 * @param {String | Number | Object | Array} id Object or id, or an array with
 *                                              objects or ids to be removed
 * @param {String} [senderId] Optional sender id
 * @return {Array} removedIds
 */
DataSet.prototype.remove = function (id, senderId) {
  var removedIds = [],
      i,
      len,
      removedId;

  if (Array.isArray(id)) {
    for (i = 0, len = id.length; i < len; i++) {
      removedId = this._remove(id[i]);
      if (removedId != null) {
        removedIds.push(removedId);
      }
    }
  } else {
    removedId = this._remove(id);
    if (removedId != null) {
      removedIds.push(removedId);
    }
  }

  if (removedIds.length) {
    this._trigger('remove', { items: removedIds }, senderId);
  }

  return removedIds;
};

/**
 * Remove an item by its id
 * @param {Number | String | Object} id   id or item
 * @returns {Number | String | null} id
 * @private
 */
DataSet.prototype._remove = function (id) {
  if (util.isNumber(id) || util.isString(id)) {
    if (this._data[id]) {
      delete this._data[id];
      this.length--;
      return id;
    }
  } else if (id instanceof Object) {
    var itemId = id[this._fieldId];
    if (itemId && this._data[itemId]) {
      delete this._data[itemId];
      this.length--;
      return itemId;
    }
  }
  return null;
};

/**
 * Clear the data
 * @param {String} [senderId] Optional sender id
 * @return {Array} removedIds    The ids of all removed items
 */
DataSet.prototype.clear = function (senderId) {
  var ids = Object.keys(this._data);

  this._data = {};
  this.length = 0;

  this._trigger('remove', { items: ids }, senderId);

  return ids;
};

/**
 * Find the item with maximum value of a specified field
 * @param {String} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.max = function (field) {
  var data = this._data,
      max = null,
      maxField = null;

  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!max || itemField > maxField)) {
        max = item;
        maxField = itemField;
      }
    }
  }

  return max;
};

/**
 * Find the item with minimum value of a specified field
 * @param {String} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.min = function (field) {
  var data = this._data,
      min = null,
      minField = null;

  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!min || itemField < minField)) {
        min = item;
        minField = itemField;
      }
    }
  }

  return min;
};

/**
 * Find all distinct values of a specified field
 * @param {String} field
 * @return {Array} values  Array containing all distinct values. If data items
 *                         do not contain the specified field are ignored.
 *                         The returned array is unordered.
 */
DataSet.prototype.distinct = function (field) {
  var data = this._data;
  var values = [];
  var fieldType = this._options.type && this._options.type[field] || null;
  var count = 0;
  var i;

  for (var prop in data) {
    if (data.hasOwnProperty(prop)) {
      var item = data[prop];
      var value = item[field];
      var exists = false;
      for (i = 0; i < count; i++) {
        if (values[i] == value) {
          exists = true;
          break;
        }
      }
      if (!exists && value !== undefined) {
        values[count] = value;
        count++;
      }
    }
  }

  if (fieldType) {
    for (i = 0; i < values.length; i++) {
      values[i] = util.convert(values[i], fieldType);
    }
  }

  return values;
};

/**
 * Add a single item. Will fail when an item with the same id already exists.
 * @param {Object} item
 * @return {String} id
 * @private
 */
DataSet.prototype._addItem = function (item) {
  var id = item[this._fieldId];

  if (id != undefined) {
    // check whether this id is already taken
    if (this._data[id]) {
      // item already exists
      throw new Error('Cannot add item: item with id ' + id + ' already exists');
    }
  } else {
    // generate an id
    id = util.randomUUID();
    item[this._fieldId] = id;
  }

  var d = {};
  for (var field in item) {
    if (item.hasOwnProperty(field)) {
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
  }
  this._data[id] = d;
  this.length++;

  return id;
};

/**
 * Get an item. Fields can be converted to a specific type
 * @param {String} id
 * @param {Object.<String, String>} [types]  field types to convert
 * @return {Object | null} item
 * @private
 */
DataSet.prototype._getItem = function (id, types) {
  var field, value;

  // get the item from the dataset
  var raw = this._data[id];
  if (!raw) {
    return null;
  }

  // convert the items field types
  var converted = {};
  if (types) {
    for (field in raw) {
      if (raw.hasOwnProperty(field)) {
        value = raw[field];
        converted[field] = util.convert(value, types[field]);
      }
    }
  } else {
    // no field types specified, no converting needed
    for (field in raw) {
      if (raw.hasOwnProperty(field)) {
        value = raw[field];
        converted[field] = value;
      }
    }
  }
  return converted;
};

/**
 * Update a single item: merge with existing item.
 * Will fail when the item has no id, or when there does not exist an item
 * with the same id.
 * @param {Object} item
 * @return {String} id
 * @private
 */
DataSet.prototype._updateItem = function (item) {
  var id = item[this._fieldId];
  if (id == undefined) {
    throw new Error('Cannot update item: item has no id (item: ' + JSON.stringify(item) + ')');
  }
  var d = this._data[id];
  if (!d) {
    // item doesn't exist
    throw new Error('Cannot update item: no item with id ' + id + ' found');
  }

  // merge with current item
  for (var field in item) {
    if (item.hasOwnProperty(field)) {
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
  }

  return id;
};

module.exports = DataSet;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL0RhdGFTZXQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDN0IsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2Qy9CLFNBQVMsT0FBTyxDQUFFLElBQUksRUFBRSxPQUFPLEVBQUU7O0FBRS9CLE1BQUksSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNoQyxXQUFPLEdBQUcsSUFBSSxDQUFDO0FBQ2YsUUFBSSxHQUFHLElBQUksQ0FBQztHQUNiOztBQUVELE1BQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxJQUFJLEVBQUUsQ0FBQztBQUM5QixNQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNoQixNQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUNoQixNQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQztBQUM5QyxNQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQzs7OztBQUloQixNQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFO0FBQ3RCLFNBQUssSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUU7QUFDcEMsVUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDNUMsWUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdEMsWUFBSSxLQUFLLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxTQUFTLElBQUksS0FBSyxJQUFJLFNBQVMsRUFBRTtBQUMvRCxjQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQztTQUM1QixNQUNJO0FBQ0gsY0FBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7U0FDM0I7T0FDRjtLQUNGO0dBQ0Y7OztBQUdELE1BQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUU7QUFDekIsVUFBTSxJQUFJLEtBQUssQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO0dBQ3hFOztBQUVELE1BQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDOzs7QUFHdkIsTUFBSSxJQUFJLEVBQUU7QUFDUixRQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQ2hCOztBQUVELE1BQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDMUI7Ozs7Ozs7Ozs7O0FBV0QsT0FBTyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsVUFBUyxPQUFPLEVBQUU7QUFDL0MsTUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7QUFDMUMsUUFBSSxPQUFPLENBQUMsS0FBSyxLQUFLLEtBQUssRUFBRTs7QUFFM0IsVUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ2YsWUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUN0QixlQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7T0FDcEI7S0FDRixNQUNJOztBQUVILFVBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ2hCLFlBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUU7QUFDL0IsaUJBQU8sRUFBRSxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDO1NBQ3JDLENBQUMsQ0FBQztPQUNKOztBQUVELFVBQUksT0FBTyxPQUFPLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRTtBQUNyQyxZQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7T0FDdkM7S0FDRjtHQUNGO0NBQ0YsQ0FBQzs7Ozs7Ozs7Ozs7QUFXRixPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUUsR0FBRyxVQUFTLEtBQUssRUFBRSxRQUFRLEVBQUU7QUFDL0MsTUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMzQyxNQUFJLENBQUMsV0FBVyxFQUFFO0FBQ2hCLGVBQVcsR0FBRyxFQUFFLENBQUM7QUFDakIsUUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxXQUFXLENBQUM7R0FDeEM7O0FBRUQsYUFBVyxDQUFDLElBQUksQ0FBQztBQUNmLFlBQVEsRUFBRSxRQUFRO0dBQ25CLENBQUMsQ0FBQztDQUNKLENBQUM7OztBQUdGLE9BQU8sQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFlBQVk7QUFDeEMsUUFBTSxJQUFJLEtBQUssQ0FBQywwREFBMEQsQ0FBQyxDQUFDO0NBQzdFLENBQUM7Ozs7Ozs7QUFPRixPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxVQUFTLEtBQUssRUFBRSxRQUFRLEVBQUU7QUFDaEQsTUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMzQyxNQUFJLFdBQVcsRUFBRTtBQUNmLFFBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxVQUFBLFFBQVE7YUFBSSxRQUFRLENBQUMsUUFBUSxJQUFJLFFBQVE7S0FBQSxDQUFDLENBQUM7R0FDMUY7Q0FDRixDQUFDOzs7QUFHRixPQUFPLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxZQUFZO0FBQzFDLFFBQU0sSUFBSSxLQUFLLENBQUMsNkRBQTZELENBQUMsQ0FBQztDQUNoRixDQUFDOzs7Ozs7Ozs7QUFTRixPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxVQUFVLEtBQUssRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO0FBQzlELE1BQUksS0FBSyxJQUFJLEdBQUcsRUFBRTtBQUNoQixVQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7R0FDM0M7O0FBRUQsTUFBSSxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3JCLE1BQUksS0FBSyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7QUFDOUIsZUFBVyxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0dBQzVEO0FBQ0QsTUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtBQUM1QixlQUFXLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7R0FDMUQ7O0FBRUQsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDM0MsUUFBSSxVQUFVLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hDLFFBQUksVUFBVSxDQUFDLFFBQVEsRUFBRTtBQUN2QixnQkFBVSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsSUFBSSxJQUFJLENBQUMsQ0FBQztLQUN0RDtHQUNGO0NBQ0YsQ0FBQzs7Ozs7Ozs7O0FBU0YsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsVUFBVSxJQUFJLEVBQUUsUUFBUSxFQUFFO0FBQ2hELE1BQUksUUFBUSxHQUFHLEVBQUU7TUFDYixFQUFFO01BQ0YsRUFBRSxHQUFHLElBQUksQ0FBQzs7QUFFZCxNQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7O0FBRXZCLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDL0MsUUFBRSxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUIsY0FBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUNuQjtHQUNGLE1BQ0ksSUFBSSxJQUFJLFlBQVksTUFBTSxFQUFFOztBQUUvQixNQUFFLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN2QixZQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0dBQ25CLE1BQ0k7QUFDSCxVQUFNLElBQUksS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7R0FDckM7O0FBRUQsTUFBSSxRQUFRLENBQUMsTUFBTSxFQUFFO0FBQ25CLFFBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUMsS0FBSyxFQUFFLFFBQVEsRUFBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0dBQ25EOztBQUVELFNBQU8sUUFBUSxDQUFDO0NBQ2pCLENBQUM7Ozs7Ozs7O0FBUUYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsVUFBVSxJQUFJLEVBQUUsUUFBUSxFQUFFO0FBQ25ELE1BQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztBQUNsQixNQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDcEIsTUFBSSxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3JCLE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQztBQUNkLE1BQUksT0FBTyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUM7O0FBRTFCLE1BQUksV0FBVyxHQUFHLFNBQWQsV0FBVyxDQUFhLElBQUksRUFBRTtBQUNoQyxRQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdkIsUUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFOztBQUVoQixRQUFFLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMxQixnQkFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNwQixpQkFBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN4QixNQUNJOztBQUVILFFBQUUsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3ZCLGNBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDbkI7R0FDRixDQUFDOztBQUVGLE1BQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTs7QUFFdkIsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMvQyxpQkFBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3RCO0dBQ0YsTUFDSSxJQUFJLElBQUksWUFBWSxNQUFNLEVBQUU7O0FBRS9CLGVBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUNuQixNQUNJO0FBQ0gsVUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0dBQ3JDOztBQUVELE1BQUksUUFBUSxDQUFDLE1BQU0sRUFBRTtBQUNuQixRQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFDLEtBQUssRUFBRSxRQUFRLEVBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztHQUNuRDtBQUNELE1BQUksVUFBVSxDQUFDLE1BQU0sRUFBRTtBQUNyQixRQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFDLEtBQUssRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0dBQzNFOztBQUVELFNBQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztDQUNwQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCRixPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxVQUFVLElBQUksRUFBRTtBQUN0QyxNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUM7OztBQUdkLE1BQUksRUFBRSxFQUFFLEdBQUcsRUFBRSxPQUFPLENBQUM7QUFDckIsTUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzQyxNQUFJLFNBQVMsSUFBSSxRQUFRLElBQUksU0FBUyxJQUFJLFFBQVEsRUFBRTs7QUFFbEQsTUFBRSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQixXQUFPLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ3hCLE1BQ0ksSUFBSSxTQUFTLElBQUksT0FBTyxFQUFFOztBQUU3QixPQUFHLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ25CLFdBQU8sR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDeEIsTUFDSTs7QUFFSCxXQUFPLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ3hCOzs7QUFHRCxNQUFJLFVBQVUsQ0FBQztBQUNmLE1BQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUU7QUFDakMsUUFBSSxhQUFhLEdBQUcsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDeEMsY0FBVSxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLE9BQU8sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO0dBQzdGLE1BQ0k7QUFDSCxjQUFVLEdBQUcsT0FBTyxDQUFDO0dBQ3RCOzs7QUFHRCxNQUFJLElBQUksR0FBRyxPQUFPLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztBQUN6RCxNQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUN2QyxNQUFJLEtBQUssR0FBRyxFQUFFO01BQUUsSUFBSTtNQUFFLE1BQU07TUFBRSxDQUFDO01BQUUsR0FBRyxDQUFDOzs7QUFHckMsTUFBSSxFQUFFLElBQUksU0FBUyxFQUFFOztBQUVuQixRQUFJLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDN0IsUUFBSSxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDM0IsVUFBSSxHQUFHLElBQUksQ0FBQztLQUNiO0dBQ0YsTUFDSSxJQUFJLEdBQUcsSUFBSSxTQUFTLEVBQUU7O0FBRXpCLFNBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzFDLFVBQUksR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNqQyxVQUFJLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUMzQixhQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO09BQ2xCO0tBQ0Y7R0FDRixNQUNJOztBQUVILFNBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7QUFDekIsVUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsRUFBRTtBQUNyQyxZQUFJLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDakMsWUFBSSxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDM0IsZUFBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNsQjtPQUNGO0tBQ0Y7R0FDRjs7O0FBR0QsTUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLEtBQUssSUFBSSxFQUFFLElBQUksU0FBUyxFQUFFO0FBQy9DLFFBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUNsQzs7O0FBR0QsTUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUM3QixRQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO0FBQzVCLFFBQUksRUFBRSxJQUFJLFNBQVMsRUFBRTtBQUNuQixVQUFJLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDekMsTUFDSTtBQUNILFdBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzVDLGFBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztPQUNqRDtLQUNGO0dBQ0Y7OztBQUdELE1BQUksVUFBVSxJQUFJLFFBQVEsRUFBRTtBQUMxQixRQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDaEIsU0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2pDLFlBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2hDO0FBQ0QsV0FBTyxNQUFNLENBQUM7R0FDZixNQUNJO0FBQ0gsUUFBSSxFQUFFLElBQUksU0FBUyxFQUFFOztBQUVuQixhQUFPLElBQUksQ0FBQztLQUNiLE1BQ0k7O0FBRUgsYUFBTyxLQUFLLENBQUM7S0FDZDtHQUNGO0NBQ0YsQ0FBQzs7Ozs7Ozs7OztBQVVGLE9BQU8sQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFVBQVUsT0FBTyxFQUFFO0FBQzVDLE1BQUksSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLO01BQ2pCLE1BQU0sR0FBRyxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU07TUFDbEMsS0FBSyxHQUFHLE9BQU8sSUFBSSxPQUFPLENBQUMsS0FBSztNQUNoQyxJQUFJLEdBQUcsT0FBTyxJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJO01BQ3BELENBQUM7TUFDRCxHQUFHO01BQ0gsRUFBRTtNQUNGLElBQUk7TUFDSixLQUFLO01BQ0wsR0FBRyxHQUFHLEVBQUUsQ0FBQzs7QUFFYixNQUFJLE1BQU0sRUFBRTs7QUFFVixRQUFJLEtBQUssRUFBRTs7QUFFVCxXQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ1gsV0FBSyxFQUFFLElBQUksSUFBSSxFQUFFO0FBQ2YsWUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQzNCLGNBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMvQixjQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNoQixpQkFBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztXQUNsQjtTQUNGO09BQ0Y7O0FBRUQsVUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7O0FBRXpCLFdBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzVDLFdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ2xDO0tBQ0YsTUFDSTs7QUFFSCxXQUFLLEVBQUUsSUFBSSxJQUFJLEVBQUU7QUFDZixZQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDM0IsY0FBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQy9CLGNBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2hCLGVBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1dBQy9CO1NBQ0Y7T0FDRjtLQUNGO0dBQ0YsTUFDSTs7QUFFSCxRQUFJLEtBQUssRUFBRTs7QUFFVCxXQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ1gsV0FBSyxFQUFFLElBQUksSUFBSSxFQUFFO0FBQ2YsWUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQzNCLGVBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDdEI7T0FDRjs7QUFFRCxVQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQzs7QUFFekIsV0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDNUMsV0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDbEM7S0FDRixNQUNJOztBQUVILFdBQUssRUFBRSxJQUFJLElBQUksRUFBRTtBQUNmLFlBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUMzQixjQUFJLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2hCLGFBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1NBQy9CO09BQ0Y7S0FDRjtHQUNGOztBQUVELFNBQU8sR0FBRyxDQUFDO0NBQ1osQ0FBQzs7Ozs7O0FBTUYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsWUFBWTtBQUN6QyxTQUFPLElBQUksQ0FBQztDQUNiLENBQUM7Ozs7Ozs7Ozs7OztBQVlGLE9BQU8sQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFVBQVUsUUFBUSxFQUFFLE9BQU8sRUFBRTtBQUN2RCxNQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU07TUFDbEMsSUFBSSxHQUFHLE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSTtNQUNwRCxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUs7TUFDakIsSUFBSTtNQUNKLEVBQUUsQ0FBQzs7QUFFUCxNQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFOztBQUU1QixRQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQUU5QixTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2hELFVBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEIsUUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDekIsY0FBUSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztLQUNwQjtHQUNGLE1BQ0k7O0FBRUgsU0FBSyxFQUFFLElBQUksSUFBSSxFQUFFO0FBQ2YsVUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQzNCLFlBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMvQixZQUFJLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUMzQixrQkFBUSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztTQUNwQjtPQUNGO0tBQ0Y7R0FDRjtDQUNGLENBQUM7Ozs7Ozs7Ozs7Ozs7QUFhRixPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxVQUFVLFFBQVEsRUFBRSxPQUFPLEVBQUU7QUFDbkQsTUFBSSxNQUFNLEdBQUcsT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNO01BQ2xDLElBQUksR0FBRyxPQUFPLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUk7TUFDcEQsV0FBVyxHQUFHLEVBQUU7TUFDaEIsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLO01BQ2pCLElBQUksQ0FBQzs7O0FBR1QsT0FBSyxJQUFJLEVBQUUsSUFBSSxJQUFJLEVBQUU7QUFDbkIsUUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQzNCLFVBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMvQixVQUFJLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUMzQixtQkFBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7T0FDdEM7S0FDRjtHQUNGOzs7QUFHRCxNQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO0FBQzVCLFFBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUN4Qzs7QUFFRCxTQUFPLFdBQVcsQ0FBQztDQUNwQixDQUFDOzs7Ozs7Ozs7QUFTRixPQUFPLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxVQUFVLElBQUksRUFBRSxNQUFNLEVBQUU7QUFDeEQsTUFBSSxDQUFDLElBQUksRUFBRTs7QUFDVCxXQUFPLElBQUksQ0FBQztHQUNiOztBQUVELE1BQUksWUFBWSxHQUFHLEVBQUUsQ0FBQzs7QUFFdEIsTUFBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFDO0FBQ3ZCLFNBQUssSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFO0FBQ3RCLFVBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsSUFBSyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxBQUFDLEVBQUU7QUFDL0Qsb0JBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7T0FDbkM7S0FDRjtHQUNGLE1BQUk7QUFDSCxTQUFLLElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtBQUN0QixVQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUM5RCxvQkFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztPQUMzQztLQUNGO0dBQ0Y7O0FBRUQsU0FBTyxZQUFZLENBQUM7Q0FDckIsQ0FBQzs7Ozs7Ozs7QUFRRixPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxVQUFVLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDaEQsTUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFOztBQUV4QixRQUFJLElBQUksR0FBRyxLQUFLLENBQUM7QUFDakIsU0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDekIsVUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pCLFVBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqQixhQUFPLEFBQUMsRUFBRSxHQUFHLEVBQUUsR0FBSSxDQUFDLEdBQUksQUFBQyxFQUFFLEdBQUcsRUFBRSxHQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFBQyxDQUFDO0tBQzdDLENBQUMsQ0FBQztHQUNKLE1BQ0ksSUFBSSxPQUFPLEtBQUssS0FBSyxVQUFVLEVBQUU7O0FBRXBDLFNBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7R0FDbkI7OztPQUdJO0FBQ0gsWUFBTSxJQUFJLFNBQVMsQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO0tBQzdEO0NBQ0YsQ0FBQzs7Ozs7Ozs7O0FBU0YsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsVUFBVSxFQUFFLEVBQUUsUUFBUSxFQUFFO0FBQ2pELE1BQUksVUFBVSxHQUFHLEVBQUU7TUFDZixDQUFDO01BQUUsR0FBRztNQUFFLFNBQVMsQ0FBQzs7QUFFdEIsTUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ3JCLFNBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3pDLGVBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hDLFVBQUksU0FBUyxJQUFJLElBQUksRUFBRTtBQUNyQixrQkFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztPQUM1QjtLQUNGO0dBQ0YsTUFDSTtBQUNILGFBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzdCLFFBQUksU0FBUyxJQUFJLElBQUksRUFBRTtBQUNyQixnQkFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUM1QjtHQUNGOztBQUVELE1BQUksVUFBVSxDQUFDLE1BQU0sRUFBRTtBQUNyQixRQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFDLEtBQUssRUFBRSxVQUFVLEVBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztHQUN4RDs7QUFFRCxTQUFPLFVBQVUsQ0FBQztDQUNuQixDQUFDOzs7Ozs7OztBQVFGLE9BQU8sQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFVBQVUsRUFBRSxFQUFFO0FBQ3hDLE1BQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQzFDLFFBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUNsQixhQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdEIsVUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ2QsYUFBTyxFQUFFLENBQUM7S0FDWDtHQUNGLE1BQ0ksSUFBSSxFQUFFLFlBQVksTUFBTSxFQUFFO0FBQzdCLFFBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDL0IsUUFBSSxNQUFNLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRTtBQUNoQyxhQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDMUIsVUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ2QsYUFBTyxNQUFNLENBQUM7S0FDZjtHQUNGO0FBQ0QsU0FBTyxJQUFJLENBQUM7Q0FDYixDQUFDOzs7Ozs7O0FBT0YsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsVUFBVSxRQUFRLEVBQUU7QUFDNUMsTUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRWxDLE1BQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2hCLE1BQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDOztBQUVoQixNQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQzs7QUFFaEQsU0FBTyxHQUFHLENBQUM7Q0FDWixDQUFDOzs7Ozs7O0FBT0YsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsVUFBVSxLQUFLLEVBQUU7QUFDdkMsTUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUs7TUFDakIsR0FBRyxHQUFHLElBQUk7TUFDVixRQUFRLEdBQUcsSUFBSSxDQUFDOztBQUVwQixPQUFLLElBQUksRUFBRSxJQUFJLElBQUksRUFBRTtBQUNuQixRQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDM0IsVUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3BCLFVBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM1QixVQUFJLFNBQVMsSUFBSSxJQUFJLEtBQUssQ0FBQyxHQUFHLElBQUksU0FBUyxHQUFHLFFBQVEsQ0FBQSxBQUFDLEVBQUU7QUFDdkQsV0FBRyxHQUFHLElBQUksQ0FBQztBQUNYLGdCQUFRLEdBQUcsU0FBUyxDQUFDO09BQ3RCO0tBQ0Y7R0FDRjs7QUFFRCxTQUFPLEdBQUcsQ0FBQztDQUNaLENBQUM7Ozs7Ozs7QUFPRixPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxVQUFVLEtBQUssRUFBRTtBQUN2QyxNQUFJLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSztNQUNqQixHQUFHLEdBQUcsSUFBSTtNQUNWLFFBQVEsR0FBRyxJQUFJLENBQUM7O0FBRXBCLE9BQUssSUFBSSxFQUFFLElBQUksSUFBSSxFQUFFO0FBQ25CLFFBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUMzQixVQUFJLElBQUksR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDcEIsVUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzVCLFVBQUksU0FBUyxJQUFJLElBQUksS0FBSyxDQUFDLEdBQUcsSUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFBLEFBQUMsRUFBRTtBQUN2RCxXQUFHLEdBQUcsSUFBSSxDQUFDO0FBQ1gsZ0JBQVEsR0FBRyxTQUFTLENBQUM7T0FDdEI7S0FDRjtHQUNGOztBQUVELFNBQU8sR0FBRyxDQUFDO0NBQ1osQ0FBQzs7Ozs7Ozs7O0FBU0YsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsVUFBVSxLQUFLLEVBQUU7QUFDNUMsTUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztBQUN0QixNQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDaEIsTUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDO0FBQ3hFLE1BQUksS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNkLE1BQUksQ0FBQyxDQUFDOztBQUVOLE9BQUssSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO0FBQ3JCLFFBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUM3QixVQUFJLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdEIsVUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3hCLFVBQUksTUFBTSxHQUFHLEtBQUssQ0FBQztBQUNuQixXQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMxQixZQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLEVBQUU7QUFDdEIsZ0JBQU0sR0FBRyxJQUFJLENBQUM7QUFDZCxnQkFBTTtTQUNQO09BQ0Y7QUFDRCxVQUFJLENBQUMsTUFBTSxJQUFLLEtBQUssS0FBSyxTQUFTLEFBQUMsRUFBRTtBQUNwQyxjQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDO0FBQ3RCLGFBQUssRUFBRSxDQUFDO09BQ1Q7S0FDRjtHQUNGOztBQUVELE1BQUksU0FBUyxFQUFFO0FBQ2IsU0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2xDLFlBQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztLQUNoRDtHQUNGOztBQUVELFNBQU8sTUFBTSxDQUFDO0NBQ2YsQ0FBQzs7Ozs7Ozs7QUFRRixPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxVQUFVLElBQUksRUFBRTtBQUMzQyxNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUU3QixNQUFJLEVBQUUsSUFBSSxTQUFTLEVBQUU7O0FBRW5CLFFBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRTs7QUFFbEIsWUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsR0FBRyxFQUFFLEdBQUcsaUJBQWlCLENBQUMsQ0FBQztLQUM1RTtHQUNGLE1BQ0k7O0FBRUgsTUFBRSxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztBQUN2QixRQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQztHQUMxQjs7QUFFRCxNQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDWCxPQUFLLElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtBQUN0QixRQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDOUIsVUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNsQyxPQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDakQ7R0FDRjtBQUNELE1BQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ25CLE1BQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQzs7QUFFZCxTQUFPLEVBQUUsQ0FBQztDQUNYLENBQUM7Ozs7Ozs7OztBQVNGLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLFVBQVUsRUFBRSxFQUFFLEtBQUssRUFBRTtBQUNoRCxNQUFJLEtBQUssRUFBRSxLQUFLLENBQUM7OztBQUdqQixNQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3pCLE1BQUksQ0FBQyxHQUFHLEVBQUU7QUFDUixXQUFPLElBQUksQ0FBQztHQUNiOzs7QUFHRCxNQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDbkIsTUFBSSxLQUFLLEVBQUU7QUFDVCxTQUFLLEtBQUssSUFBSSxHQUFHLEVBQUU7QUFDakIsVUFBSSxHQUFHLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzdCLGFBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbkIsaUJBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztPQUN0RDtLQUNGO0dBQ0YsTUFDSTs7QUFFSCxTQUFLLEtBQUssSUFBSSxHQUFHLEVBQUU7QUFDakIsVUFBSSxHQUFHLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzdCLGFBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbkIsaUJBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7T0FDMUI7S0FDRjtHQUNGO0FBQ0QsU0FBTyxTQUFTLENBQUM7Q0FDbEIsQ0FBQzs7Ozs7Ozs7OztBQVVGLE9BQU8sQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLFVBQVUsSUFBSSxFQUFFO0FBQzlDLE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDN0IsTUFBSSxFQUFFLElBQUksU0FBUyxFQUFFO0FBQ25CLFVBQU0sSUFBSSxLQUFLLENBQUMsNENBQTRDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztHQUM1RjtBQUNELE1BQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdkIsTUFBSSxDQUFDLENBQUMsRUFBRTs7QUFFTixVQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxHQUFHLEVBQUUsR0FBRyxRQUFRLENBQUMsQ0FBQztHQUN6RTs7O0FBR0QsT0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUU7QUFDdEIsUUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzlCLFVBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbEMsT0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0tBQ2pEO0dBQ0Y7O0FBRUQsU0FBTyxFQUFFLENBQUM7Q0FDWCxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL0RhdGFTZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIFF1ZXVlID0gcmVxdWlyZSgnLi9RdWV1ZScpO1xuXG4vKipcbiAqIERhdGFTZXRcbiAqXG4gKiBVc2FnZTpcbiAqICAgICB2YXIgZGF0YVNldCA9IG5ldyBEYXRhU2V0KHtcbiAqICAgICAgICAgZmllbGRJZDogJ19pZCcsXG4gKiAgICAgICAgIHR5cGU6IHtcbiAqICAgICAgICAgICAgIC8vIC4uLlxuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGRhdGFTZXQuYWRkKGl0ZW0pO1xuICogICAgIGRhdGFTZXQuYWRkKGRhdGEpO1xuICogICAgIGRhdGFTZXQudXBkYXRlKGl0ZW0pO1xuICogICAgIGRhdGFTZXQudXBkYXRlKGRhdGEpO1xuICogICAgIGRhdGFTZXQucmVtb3ZlKGlkKTtcbiAqICAgICBkYXRhU2V0LnJlbW92ZShpZHMpO1xuICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoKTtcbiAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkKTtcbiAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkcyk7XG4gKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldChpZHMsIG9wdGlvbnMsIGRhdGEpO1xuICogICAgIGRhdGFTZXQuY2xlYXIoKTtcbiAqXG4gKiBBIGRhdGEgc2V0IGNhbjpcbiAqIC0gYWRkL3JlbW92ZS91cGRhdGUgZGF0YVxuICogLSBnaXZlcyB0cmlnZ2VycyB1cG9uIGNoYW5nZXMgaW4gdGhlIGRhdGFcbiAqIC0gY2FuICBpbXBvcnQvZXhwb3J0IGRhdGEgaW4gdmFyaW91cyBkYXRhIGZvcm1hdHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBbZGF0YV0gICAgT3B0aW9uYWwgYXJyYXkgd2l0aCBpbml0aWFsIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBmaWVsZElkIEZpZWxkIG5hbWUgb2YgdGhlIGlkIGluIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMsICdpZCcgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZ30gdHlwZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBtYXAgd2l0aCBmaWVsZCBuYW1lcyBhcyBrZXksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIGZpZWxkIHR5cGUgYXMgdmFsdWUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdH0gcXVldWUgICBRdWV1ZSBjaGFuZ2VzIHRvIHRoZSBEYXRhU2V0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2ggdGhlbSBhbGwgYXQgb25jZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1ZXVlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtudW1iZXJ9IGRlbGF5ICBEZWxheSBpbiBtcywgbnVsbCBieSBkZWZhdWx0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHtudW1iZXJ9IG1heCAgICBNYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBxdWV1ZSwgSW5maW5pdHkgYnkgZGVmYXVsdFxuICogQGNvbnN0cnVjdG9yIERhdGFTZXRcbiAqL1xuLy8gVE9ETzogYWRkIGEgRGF0YVNldCBjb25zdHJ1Y3RvciBEYXRhU2V0KGRhdGEsIG9wdGlvbnMpXG5mdW5jdGlvbiBEYXRhU2V0IChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGNvcnJlY3RseSByZWFkIG9wdGlvbmFsIGFyZ3VtZW50c1xuICBpZiAoZGF0YSAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIG9wdGlvbnMgPSBkYXRhO1xuICAgIGRhdGEgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX2RhdGEgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXAgd2l0aCBkYXRhIGluZGV4ZWQgYnkgaWRcbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgRGF0YVNldFxuICB0aGlzLl9maWVsZElkID0gdGhpcy5fb3B0aW9ucy5maWVsZElkIHx8ICdpZCc7ICAgLy8gbmFtZSBvZiB0aGUgZmllbGQgY29udGFpbmluZyBpZFxuICB0aGlzLl90eXBlID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJuYWwgZmllbGQgdHlwZXMgKE5PVEU6IHRoaXMgY2FuIGRpZmZlciBmcm9tIHRoaXMuX29wdGlvbnMudHlwZSlcblxuICAvLyBhbGwgdmFyaWFudHMgb2YgYSBEYXRlIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCBhcyBEYXRlLCBzbyB3ZSBjYW4gY29udmVydFxuICAvLyBmcm9tIGV2ZXJ5dGhpbmcgdG8gZXZlcnl0aGluZyAoYWxzbyBmcm9tIElTT0RhdGUgdG8gTnVtYmVyIGZvciBleGFtcGxlKVxuICBpZiAodGhpcy5fb3B0aW9ucy50eXBlKSB7XG4gICAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5fb3B0aW9ucy50eXBlKSB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy50eXBlLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9vcHRpb25zLnR5cGVbZmllbGRdO1xuICAgICAgICBpZiAodmFsdWUgPT0gJ0RhdGUnIHx8IHZhbHVlID09ICdJU09EYXRlJyB8fCB2YWx1ZSA9PSAnQVNQRGF0ZScpIHtcbiAgICAgICAgICB0aGlzLl90eXBlW2ZpZWxkXSA9ICdEYXRlJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90eXBlW2ZpZWxkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMS4xIChvciAyLjAuMD8pXG4gIGlmICh0aGlzLl9vcHRpb25zLmNvbnZlcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBcImNvbnZlcnRcIiBpcyBkZXByZWNhdGVkLiBVc2UgXCJ0eXBlXCIgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIHRoaXMuX3N1YnNjcmliZXJzID0ge307ICAvLyBldmVudCBzdWJzY3JpYmVyc1xuXG4gIC8vIGFkZCBpbml0aWFsIGRhdGEgd2hlbiBwcm92aWRlZFxuICBpZiAoZGF0YSkge1xuICAgIHRoaXMuYWRkKGRhdGEpO1xuICB9XG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBxdWV1ZSAgIFF1ZXVlIGNoYW5nZXMgdG8gdGhlIERhdGFTZXQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHVzaCB0aGVtIGFsbCBhdCBvbmNlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUXVldWUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gZGVsYXkgIERlbGF5IGluIG1zLCBudWxsIGJ5IGRlZmF1bHRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gbWF4ICAgIE1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHF1ZXVlLCBJbmZpbml0eSBieSBkZWZhdWx0XG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnF1ZXVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5xdWV1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIGRlbGV0ZSBxdWV1ZSBpZiBsb2FkZWRcbiAgICAgIGlmICh0aGlzLl9xdWV1ZSkge1xuICAgICAgICB0aGlzLl9xdWV1ZS5kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9xdWV1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgcXVldWUgYW5kIHVwZGF0ZSBpdHMgb3B0aW9uc1xuICAgICAgaWYgKCF0aGlzLl9xdWV1ZSkge1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFF1ZXVlLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgcmVwbGFjZTogWydhZGQnLCAndXBkYXRlJywgJ3JlbW92ZSddXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucXVldWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnNldE9wdGlvbnMob3B0aW9ucy5xdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBhbiBldmVudCwgYWRkIGFuIGV2ZW50IGxpc3RlbmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgICAgICAgIEV2ZW50IG5hbWUuIEF2YWlsYWJsZSBldmVudHM6ICdwdXQnLCAndXBkYXRlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbW92ZSdcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2sgbWV0aG9kLiBDYWxsZWQgd2l0aCB0aHJlZSBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gZXZlbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QgfCBudWxsfSBwYXJhbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IHNlbmRlcklkXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XTtcbiAgaWYgKCFzdWJzY3JpYmVycykge1xuICAgIHN1YnNjcmliZXJzID0gW107XG4gICAgdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdID0gc3Vic2NyaWJlcnM7XG4gIH1cblxuICBzdWJzY3JpYmVycy5wdXNoKHtcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG4vLyBUT0RPOiByZW1vdmUgdGhpcyBkZXByZWNhdGVkIGZ1bmN0aW9uIHNvbWUgZGF5IChyZXBsYWNlZCB3aXRoIGBvbmAgc2luY2UgdmVyc2lvbiAwLjUsIGRlcHJlY2F0ZWQgc2luY2UgdjQuMClcbkRhdGFTZXQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdEYXRhU2V0LnN1YnNjcmliZSBpcyBkZXByZWNhdGVkLiBVc2UgRGF0YVNldC5vbiBpbnN0ZWFkLicpO1xufTtcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIGFuIGV2ZW50LCByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XTtcbiAgaWYgKHN1YnNjcmliZXJzKSB7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdID0gc3Vic2NyaWJlcnMuZmlsdGVyKGxpc3RlbmVyID0+IGxpc3RlbmVyLmNhbGxiYWNrICE9IGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLy8gVE9ETzogcmVtb3ZlIHRoaXMgZGVwcmVjYXRlZCBmdW5jdGlvbiBzb21lIGRheSAocmVwbGFjZWQgd2l0aCBgb25gIHNpbmNlIHZlcnNpb24gMC41LCBkZXByZWNhdGVkIHNpbmNlIHY0LjApXG5EYXRhU2V0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdEYXRhU2V0LnVuc3Vic2NyaWJlIGlzIGRlcHJlY2F0ZWQuIFVzZSBEYXRhU2V0Lm9mZiBpbnN0ZWFkLicpO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSAgICAgICBPcHRpb25hbCBpZCBvZiB0aGUgc2VuZGVyLlxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX3RyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgaWYgKGV2ZW50ID09ICcqJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHRyaWdnZXIgZXZlbnQgKicpO1xuICB9XG5cbiAgdmFyIHN1YnNjcmliZXJzID0gW107XG4gIGlmIChldmVudCBpbiB0aGlzLl9zdWJzY3JpYmVycykge1xuICAgIHN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuY29uY2F0KHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSk7XG4gIH1cbiAgaWYgKCcqJyBpbiB0aGlzLl9zdWJzY3JpYmVycykge1xuICAgIHN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuY29uY2F0KHRoaXMuX3N1YnNjcmliZXJzWycqJ10pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3Vic2NyaWJlcnNbaV07XG4gICAgaWYgKHN1YnNjcmliZXIuY2FsbGJhY2spIHtcbiAgICAgIHN1YnNjcmliZXIuY2FsbGJhY2soZXZlbnQsIHBhcmFtcywgc2VuZGVySWQgfHwgbnVsbCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFkZCBkYXRhLlxuICogQWRkaW5nIGFuIGl0ZW0gd2lsbCBmYWlsIHdoZW4gdGhlcmUgYWxyZWFkeSBpcyBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQuXG4gKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5fSBhZGRlZElkcyAgICAgIEFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGUgYWRkZWQgaXRlbXNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRhdGEsIHNlbmRlcklkKSB7XG4gIHZhciBhZGRlZElkcyA9IFtdLFxuICAgICAgaWQsXG4gICAgICBtZSA9IHRoaXM7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAvLyBBcnJheVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZCA9IG1lLl9hZGRJdGVtKGRhdGFbaV0pO1xuICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAvLyBTaW5nbGUgaXRlbVxuICAgIGlkID0gbWUuX2FkZEl0ZW0oZGF0YSk7XG4gICAgYWRkZWRJZHMucHVzaChpZCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdGFUeXBlJyk7XG4gIH1cblxuICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcignYWRkJywge2l0ZW1zOiBhZGRlZElkc30sIHNlbmRlcklkKTtcbiAgfVxuXG4gIHJldHVybiBhZGRlZElkcztcbn07XG5cbi8qKlxuICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZFxuICogQHBhcmFtIHtPYmplY3QgfCBBcnJheX0gZGF0YVxuICogQHBhcmFtIHtTdHJpbmd9IFtzZW5kZXJJZF0gT3B0aW9uYWwgc2VuZGVyIGlkXG4gKiBAcmV0dXJuIHtBcnJheX0gdXBkYXRlZElkcyAgICAgVGhlIGlkcyBvZiB0aGUgYWRkZWQgb3IgdXBkYXRlZCBpdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgc2VuZGVySWQpIHtcbiAgdmFyIGFkZGVkSWRzID0gW107XG4gIHZhciB1cGRhdGVkSWRzID0gW107XG4gIHZhciB1cGRhdGVkRGF0YSA9IFtdO1xuICB2YXIgbWUgPSB0aGlzO1xuICB2YXIgZmllbGRJZCA9IG1lLl9maWVsZElkO1xuXG4gIHZhciBhZGRPclVwZGF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGlkID0gaXRlbVtmaWVsZElkXTtcbiAgICBpZiAobWUuX2RhdGFbaWRdKSB7XG4gICAgICAvLyB1cGRhdGUgaXRlbVxuICAgICAgaWQgPSBtZS5fdXBkYXRlSXRlbShpdGVtKTtcbiAgICAgIHVwZGF0ZWRJZHMucHVzaChpZCk7XG4gICAgICB1cGRhdGVkRGF0YS5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGFkZCBuZXcgaXRlbVxuICAgICAgaWQgPSBtZS5fYWRkSXRlbShpdGVtKTtcbiAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgIH1cbiAgfTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIC8vIEFycmF5XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFkZE9yVXBkYXRlKGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgLy8gU2luZ2xlIGl0ZW1cbiAgICBhZGRPclVwZGF0ZShkYXRhKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGF0YVR5cGUnKTtcbiAgfVxuXG4gIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7aXRlbXM6IGFkZGVkSWRzfSwgc2VuZGVySWQpO1xuICB9XG4gIGlmICh1cGRhdGVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ3VwZGF0ZScsIHtpdGVtczogdXBkYXRlZElkcywgZGF0YTogdXBkYXRlZERhdGF9LCBzZW5kZXJJZCk7XG4gIH1cblxuICByZXR1cm4gYWRkZWRJZHMuY29uY2F0KHVwZGF0ZWRJZHMpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBkYXRhIGl0ZW0gb3IgbXVsdGlwbGUgaXRlbXMuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAgIGdldCgpXG4gKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdClcbiAqXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIgfCBTdHJpbmcpXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIgfCBTdHJpbmcsIG9wdGlvbnM6IE9iamVjdClcbiAqXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10gfCBTdHJpbmdbXSlcbiAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSB8IFN0cmluZ1tdLCBvcHRpb25zOiBPYmplY3QpXG4gKlxuICogV2hlcmU6XG4gKlxuICoge051bWJlciB8IFN0cmluZ30gaWQgICAgICAgICBUaGUgaWQgb2YgYW4gaXRlbVxuICoge051bWJlcltdIHwgU3RyaW5ne319IGlkcyAgICBBbiBhcnJheSB3aXRoIGlkcyBvZiBpdGVtc1xuICoge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAqIHtTdHJpbmd9IFtyZXR1cm5UeXBlXSAgICAgICAgVHlwZSBvZiBkYXRhIHRvIGJlIHJldHVybmVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgJ0FycmF5JyAoZGVmYXVsdCkgb3IgJ09iamVjdCcuXG4gKiB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFt0eXBlXVxuICoge1N0cmluZ1tdfSBbZmllbGRzXSAgICAgICAgICBmaWVsZCBuYW1lcyB0byBiZSByZXR1cm5lZFxuICoge2Z1bmN0aW9ufSBbZmlsdGVyXSAgICAgICAgICBmaWx0ZXIgaXRlbXNcbiAqIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSAgT3JkZXIgdGhlIGl0ZW1zIGJ5IGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEB0aHJvd3MgRXJyb3JcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG4gIHZhciBpZCwgaWRzLCBvcHRpb25zO1xuICB2YXIgZmlyc3RUeXBlID0gdXRpbC5nZXRUeXBlKGFyZ3VtZW50c1swXSk7XG4gIGlmIChmaXJzdFR5cGUgPT0gJ1N0cmluZycgfHwgZmlyc3RUeXBlID09ICdOdW1iZXInKSB7XG4gICAgLy8gZ2V0KGlkIFssIG9wdGlvbnNdKVxuICAgIGlkID0gYXJndW1lbnRzWzBdO1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgZWxzZSBpZiAoZmlyc3RUeXBlID09ICdBcnJheScpIHtcbiAgICAvLyBnZXQoaWRzIFssIG9wdGlvbnNdKVxuICAgIGlkcyA9IGFyZ3VtZW50c1swXTtcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGdldChbLCBvcHRpb25zXSlcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzBdO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHRoZSByZXR1cm4gdHlwZVxuICB2YXIgcmV0dXJuVHlwZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXR1cm5UeXBlKSB7XG4gICAgdmFyIGFsbG93ZWRWYWx1ZXMgPSBbJ0FycmF5JywgJ09iamVjdCddO1xuICAgIHJldHVyblR5cGUgPSBhbGxvd2VkVmFsdWVzLmluZGV4T2Yob3B0aW9ucy5yZXR1cm5UeXBlKSA9PSAtMSA/ICdBcnJheScgOiBvcHRpb25zLnJldHVyblR5cGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuVHlwZSA9ICdBcnJheSc7XG4gIH1cblxuICAvLyBidWlsZCBvcHRpb25zXG4gIHZhciB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlO1xuICB2YXIgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcjtcbiAgdmFyIGl0ZW1zID0gW10sIGl0ZW0sIGl0ZW1JZCwgaSwgbGVuO1xuXG4gIC8vIGNvbnZlcnQgaXRlbXNcbiAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgIC8vIHJldHVybiBhIHNpbmdsZSBpdGVtXG4gICAgaXRlbSA9IG1lLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIoaXRlbSkpIHtcbiAgICAgIGl0ZW0gPSBudWxsO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpZHMgIT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gcmV0dXJuIGEgc3Vic2V0IG9mIGl0ZW1zXG4gICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtID0gbWUuX2dldEl0ZW0oaWRzW2ldLCB0eXBlKTtcbiAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyByZXR1cm4gYWxsIGl0ZW1zXG4gICAgZm9yIChpdGVtSWQgaW4gdGhpcy5fZGF0YSkge1xuICAgICAgaWYgKHRoaXMuX2RhdGEuaGFzT3duUHJvcGVydHkoaXRlbUlkKSkge1xuICAgICAgICBpdGVtID0gbWUuX2dldEl0ZW0oaXRlbUlkLCB0eXBlKTtcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG9yZGVyIHRoZSByZXN1bHRzXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIgJiYgaWQgPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fc29ydChpdGVtcywgb3B0aW9ucy5vcmRlcik7XG4gIH1cblxuICAvLyBmaWx0ZXIgZmllbGRzIG9mIHRoZSBpdGVtc1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpZWxkcykge1xuICAgIHZhciBmaWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVtID0gdGhpcy5fZmlsdGVyRmllbGRzKGl0ZW0sIGZpZWxkcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaXRlbXNbaV0gPSB0aGlzLl9maWx0ZXJGaWVsZHMoaXRlbXNbaV0sIGZpZWxkcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmV0dXJuIHRoZSByZXN1bHRzXG4gIGlmIChyZXR1cm5UeXBlID09ICdPYmplY3QnKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W2l0ZW1zW2ldLmlkXSA9IGl0ZW1zW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGEgc2luZ2xlIGl0ZW1cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGp1c3QgcmV0dXJuIG91ciBhcnJheVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgaWRzIG9mIGFsbCBpdGVtcyBvciBmcm9tIGEgZmlsdGVyZWQgc2V0IG9mIGl0ZW1zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHJldHVybiB7QXJyYXl9IGlkc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5nZXRJZHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBmaWx0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgb3JkZXIgPSBvcHRpb25zICYmIG9wdGlvbnMub3JkZXIsXG4gICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgaSxcbiAgICAgIGxlbixcbiAgICAgIGlkLFxuICAgICAgaXRlbSxcbiAgICAgIGl0ZW1zLFxuICAgICAgaWRzID0gW107XG5cbiAgaWYgKGZpbHRlcikge1xuICAgIC8vIGdldCBmaWx0ZXJlZCBpdGVtc1xuICAgIGlmIChvcmRlcikge1xuICAgICAgLy8gY3JlYXRlIG9yZGVyZWQgbGlzdFxuICAgICAgaXRlbXMgPSBbXTtcbiAgICAgIGZvciAoaWQgaW4gZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBpdGVtID0gdGhpcy5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgICAgICAgaWYgKGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc29ydChpdGVtcywgb3JkZXIpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZHNbaV0gPSBpdGVtc1tpXVt0aGlzLl9maWVsZElkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgdW5vcmRlcmVkIGxpc3RcbiAgICAgIGZvciAoaWQgaW4gZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBpdGVtID0gdGhpcy5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgICAgICAgaWYgKGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgICAgaWRzLnB1c2goaXRlbVt0aGlzLl9maWVsZElkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGdldCBhbGwgaXRlbXNcbiAgICBpZiAob3JkZXIpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbiBvcmRlcmVkIGxpc3RcbiAgICAgIGl0ZW1zID0gW107XG4gICAgICBmb3IgKGlkIGluIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChkYXRhW2lkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc29ydChpdGVtcywgb3JkZXIpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZHNbaV0gPSBpdGVtc1tpXVt0aGlzLl9maWVsZElkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgdW5vcmRlcmVkIGxpc3RcbiAgICAgIGZvciAoaWQgaW4gZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBpdGVtID0gZGF0YVtpZF07XG4gICAgICAgICAgaWRzLnB1c2goaXRlbVt0aGlzLl9maWVsZElkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWRzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBEYXRhU2V0IGl0c2VsZi4gSXMgb3ZlcndyaXR0ZW4gZm9yIGV4YW1wbGUgYnkgdGhlIERhdGFWaWV3LFxuICogd2hpY2ggcmV0dXJucyB0aGUgRGF0YVNldCBpdCBpcyBjb25uZWN0ZWQgdG8gaW5zdGVhZC5cbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuZ2V0RGF0YVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZXZlcnkgaXRlbSBpbiB0aGUgZGF0YXNldC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFt0eXBlXVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nW119IFtmaWVsZHNdIGZpbHRlciBmaWVsZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBmaWx0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IHRoaXMuX29wdGlvbnMudHlwZSxcbiAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgaXRlbSxcbiAgICAgIGlkO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICAvLyBleGVjdXRlIGZvckVhY2ggb24gb3JkZXJlZCBsaXN0XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5nZXQob3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcbiAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gdW5vcmRlcmVkXG4gICAgZm9yIChpZCBpbiBkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICBjYWxsYmFjayhpdGVtLCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIGV2ZXJ5IGl0ZW0gaW4gdGhlIGRhdGFzZXQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZV1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ1tdfSBbZmllbGRzXSBmaWx0ZXIgZmllbGRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09iamVjdFtdfSBtYXBwZWRJdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIsXG4gICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgbWFwcGVkSXRlbXMgPSBbXSxcbiAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgaXRlbTtcblxuICAvLyBjb252ZXJ0IGFuZCBmaWx0ZXIgaXRlbXNcbiAgZm9yICh2YXIgaWQgaW4gZGF0YSkge1xuICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgaXRlbSA9IHRoaXMuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIG1hcHBlZEl0ZW1zLnB1c2goY2FsbGJhY2soaXRlbSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBvcmRlciBpdGVtc1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgdGhpcy5fc29ydChtYXBwZWRJdGVtcywgb3B0aW9ucy5vcmRlcik7XG4gIH1cblxuICByZXR1cm4gbWFwcGVkSXRlbXM7XG59O1xuXG4vKipcbiAqIEZpbHRlciB0aGUgZmllbGRzIG9mIGFuIGl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gaXRlbVxuICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzICAgICBGaWVsZCBuYW1lc1xuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gZmlsdGVyZWRJdGVtIG9yIG51bGwgaWYgbm8gaXRlbSBpcyBwcm92aWRlZFxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX2ZpbHRlckZpZWxkcyA9IGZ1bmN0aW9uIChpdGVtLCBmaWVsZHMpIHtcbiAgaWYgKCFpdGVtKSB7IC8vIGl0ZW0gaXMgbnVsbFxuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgdmFyIGZpbHRlcmVkSXRlbSA9IHt9O1xuXG4gIGlmKEFycmF5LmlzQXJyYXkoZmllbGRzKSl7XG4gICAgZm9yICh2YXIgZmllbGQgaW4gaXRlbSkge1xuICAgICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkoZmllbGQpICYmIChmaWVsZHMuaW5kZXhPZihmaWVsZCkgIT0gLTEpKSB7XG4gICAgICAgIGZpbHRlcmVkSXRlbVtmaWVsZF0gPSBpdGVtW2ZpZWxkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1lbHNle1xuICAgIGZvciAodmFyIGZpZWxkIGluIGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KGZpZWxkKSAmJiBmaWVsZHMuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgIGZpbHRlcmVkSXRlbVtmaWVsZHNbZmllbGRdXSA9IGl0ZW1bZmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZEl0ZW07XG59O1xuXG4vKipcbiAqIFNvcnQgdGhlIHByb3ZpZGVkIGFycmF5IHdpdGggaXRlbXNcbiAqIEBwYXJhbSB7T2JqZWN0W119IGl0ZW1zXG4gKiBAcGFyYW0ge1N0cmluZyB8IGZ1bmN0aW9ufSBvcmRlciAgICAgIEEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9zb3J0ID0gZnVuY3Rpb24gKGl0ZW1zLCBvcmRlcikge1xuICBpZiAodXRpbC5pc1N0cmluZyhvcmRlcikpIHtcbiAgICAvLyBvcmRlciBieSBwcm92aWRlZCBmaWVsZCBuYW1lXG4gICAgdmFyIG5hbWUgPSBvcmRlcjsgLy8gZmllbGQgbmFtZVxuICAgIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBhdiA9IGFbbmFtZV07XG4gICAgICB2YXIgYnYgPSBiW25hbWVdO1xuICAgICAgcmV0dXJuIChhdiA+IGJ2KSA/IDEgOiAoKGF2IDwgYnYpID8gLTEgOiAwKTtcbiAgICB9KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBvcmRlciBieSBzb3J0IGZ1bmN0aW9uXG4gICAgaXRlbXMuc29ydChvcmRlcik7XG4gIH1cbiAgLy8gVE9ETzogZXh0ZW5kIG9yZGVyIGJ5IGFuIE9iamVjdCB7ZmllbGQ6U3RyaW5nLCBkaXJlY3Rpb246U3RyaW5nfVxuICAvLyAgICAgICB3aGVyZSBkaXJlY3Rpb24gY2FuIGJlICdhc2MnIG9yICdkZXNjJ1xuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPcmRlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gb2JqZWN0IGJ5IHBvaW50ZXIgb3IgYnkgaWRcbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyIHwgT2JqZWN0IHwgQXJyYXl9IGlkIE9iamVjdCBvciBpZCwgb3IgYW4gYXJyYXkgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0cyBvciBpZHMgdG8gYmUgcmVtb3ZlZFxuICogQHBhcmFtIHtTdHJpbmd9IFtzZW5kZXJJZF0gT3B0aW9uYWwgc2VuZGVyIGlkXG4gKiBAcmV0dXJuIHtBcnJheX0gcmVtb3ZlZElkc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaWQsIHNlbmRlcklkKSB7XG4gIHZhciByZW1vdmVkSWRzID0gW10sXG4gICAgICBpLCBsZW4sIHJlbW92ZWRJZDtcblxuICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVtb3ZlZElkID0gdGhpcy5fcmVtb3ZlKGlkW2ldKTtcbiAgICAgIGlmIChyZW1vdmVkSWQgIT0gbnVsbCkge1xuICAgICAgICByZW1vdmVkSWRzLnB1c2gocmVtb3ZlZElkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmVtb3ZlZElkID0gdGhpcy5fcmVtb3ZlKGlkKTtcbiAgICBpZiAocmVtb3ZlZElkICE9IG51bGwpIHtcbiAgICAgIHJlbW92ZWRJZHMucHVzaChyZW1vdmVkSWQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHtpdGVtczogcmVtb3ZlZElkc30sIHNlbmRlcklkKTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVkSWRzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBieSBpdHMgaWRcbiAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nIHwgT2JqZWN0fSBpZCAgIGlkIG9yIGl0ZW1cbiAqIEByZXR1cm5zIHtOdW1iZXIgfCBTdHJpbmcgfCBudWxsfSBpZFxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAodXRpbC5pc051bWJlcihpZCkgfHwgdXRpbC5pc1N0cmluZyhpZCkpIHtcbiAgICBpZiAodGhpcy5fZGF0YVtpZF0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9kYXRhW2lkXTtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGlkIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgdmFyIGl0ZW1JZCA9IGlkW3RoaXMuX2ZpZWxkSWRdO1xuICAgIGlmIChpdGVtSWQgJiYgdGhpcy5fZGF0YVtpdGVtSWRdKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZGF0YVtpdGVtSWRdO1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgIHJldHVybiBpdGVtSWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgZGF0YVxuICogQHBhcmFtIHtTdHJpbmd9IFtzZW5kZXJJZF0gT3B0aW9uYWwgc2VuZGVyIGlkXG4gKiBAcmV0dXJuIHtBcnJheX0gcmVtb3ZlZElkcyAgICBUaGUgaWRzIG9mIGFsbCByZW1vdmVkIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKHNlbmRlcklkKSB7XG4gIHZhciBpZHMgPSBPYmplY3Qua2V5cyh0aGlzLl9kYXRhKTtcblxuICB0aGlzLl9kYXRhID0ge307XG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7aXRlbXM6IGlkc30sIHNlbmRlcklkKTtcblxuICByZXR1cm4gaWRzO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBpdGVtIHdpdGggbWF4aW11bSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtICBJdGVtIGNvbnRhaW5pbmcgbWF4IHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBtYXggPSBudWxsLFxuICAgICAgbWF4RmllbGQgPSBudWxsO1xuXG4gIGZvciAodmFyIGlkIGluIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YVtpZF07XG4gICAgICB2YXIgaXRlbUZpZWxkID0gaXRlbVtmaWVsZF07XG4gICAgICBpZiAoaXRlbUZpZWxkICE9IG51bGwgJiYgKCFtYXggfHwgaXRlbUZpZWxkID4gbWF4RmllbGQpKSB7XG4gICAgICAgIG1heCA9IGl0ZW07XG4gICAgICAgIG1heEZpZWxkID0gaXRlbUZpZWxkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXg7XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIGl0ZW0gd2l0aCBtaW5pbXVtIHZhbHVlIG9mIGEgc3BlY2lmaWVkIGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGl0ZW0gIEl0ZW0gY29udGFpbmluZyBtYXggdmFsdWUsIG9yIG51bGwgaWYgbm8gaXRlbXNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgIG1pbiA9IG51bGwsXG4gICAgICBtaW5GaWVsZCA9IG51bGw7XG5cbiAgZm9yICh2YXIgaWQgaW4gZGF0YSkge1xuICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICAgIHZhciBpdGVtRmllbGQgPSBpdGVtW2ZpZWxkXTtcbiAgICAgIGlmIChpdGVtRmllbGQgIT0gbnVsbCAmJiAoIW1pbiB8fCBpdGVtRmllbGQgPCBtaW5GaWVsZCkpIHtcbiAgICAgICAgbWluID0gaXRlbTtcbiAgICAgICAgbWluRmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbjtcbn07XG5cbi8qKlxuICogRmluZCBhbGwgZGlzdGluY3QgdmFsdWVzIG9mIGEgc3BlY2lmaWVkIGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge0FycmF5fSB2YWx1ZXMgIEFycmF5IGNvbnRhaW5pbmcgYWxsIGRpc3RpbmN0IHZhbHVlcy4gSWYgZGF0YSBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgZG8gbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCBmaWVsZCBhcmUgaWdub3JlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSByZXR1cm5lZCBhcnJheSBpcyB1bm9yZGVyZWQuXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmRpc3RpbmN0ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgZmllbGRUeXBlID0gdGhpcy5fb3B0aW9ucy50eXBlICYmIHRoaXMuX29wdGlvbnMudHlwZVtmaWVsZF0gfHwgbnVsbDtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGk7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YVtwcm9wXTtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW1bZmllbGRdO1xuICAgICAgdmFyIGV4aXN0cyA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgaWYgKHZhbHVlc1tpXSA9PSB2YWx1ZSkge1xuICAgICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZXhpc3RzICYmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB2YWx1ZXNbY291bnRdID0gdmFsdWU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpZWxkVHlwZSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IHV0aWwuY29udmVydCh2YWx1ZXNbaV0sIGZpZWxkVHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIGl0ZW0uIFdpbGwgZmFpbCB3aGVuIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZCBhbHJlYWR5IGV4aXN0cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fYWRkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBpZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG5cbiAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhpcyBpZCBpcyBhbHJlYWR5IHRha2VuXG4gICAgaWYgKHRoaXMuX2RhdGFbaWRdKSB7XG4gICAgICAvLyBpdGVtIGFscmVhZHkgZXhpc3RzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgaXRlbTogaXRlbSB3aXRoIGlkICcgKyBpZCArICcgYWxyZWFkeSBleGlzdHMnKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2VuZXJhdGUgYW4gaWRcbiAgICBpZCA9IHV0aWwucmFuZG9tVVVJRCgpO1xuICAgIGl0ZW1bdGhpcy5fZmllbGRJZF0gPSBpZDtcbiAgfVxuXG4gIHZhciBkID0ge307XG4gIGZvciAodmFyIGZpZWxkIGluIGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgIHZhciBmaWVsZFR5cGUgPSB0aGlzLl90eXBlW2ZpZWxkXTsgIC8vIHR5cGUgbWF5IGJlIHVuZGVmaW5lZFxuICAgICAgZFtmaWVsZF0gPSB1dGlsLmNvbnZlcnQoaXRlbVtmaWVsZF0sIGZpZWxkVHlwZSk7XG4gICAgfVxuICB9XG4gIHRoaXMuX2RhdGFbaWRdID0gZDtcbiAgdGhpcy5sZW5ndGgrKztcblxuICByZXR1cm4gaWQ7XG59O1xuXG4vKipcbiAqIEdldCBhbiBpdGVtLiBGaWVsZHMgY2FuIGJlIGNvbnZlcnRlZCB0byBhIHNwZWNpZmljIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVzXSAgZmllbGQgdHlwZXMgdG8gY29udmVydFxuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gaXRlbVxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX2dldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIHR5cGVzKSB7XG4gIHZhciBmaWVsZCwgdmFsdWU7XG5cbiAgLy8gZ2V0IHRoZSBpdGVtIGZyb20gdGhlIGRhdGFzZXRcbiAgdmFyIHJhdyA9IHRoaXMuX2RhdGFbaWRdO1xuICBpZiAoIXJhdykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gY29udmVydCB0aGUgaXRlbXMgZmllbGQgdHlwZXNcbiAgdmFyIGNvbnZlcnRlZCA9IHt9O1xuICBpZiAodHlwZXMpIHtcbiAgICBmb3IgKGZpZWxkIGluIHJhdykge1xuICAgICAgaWYgKHJhdy5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgdmFsdWUgPSByYXdbZmllbGRdO1xuICAgICAgICBjb252ZXJ0ZWRbZmllbGRdID0gdXRpbC5jb252ZXJ0KHZhbHVlLCB0eXBlc1tmaWVsZF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBubyBmaWVsZCB0eXBlcyBzcGVjaWZpZWQsIG5vIGNvbnZlcnRpbmcgbmVlZGVkXG4gICAgZm9yIChmaWVsZCBpbiByYXcpIHtcbiAgICAgIGlmIChyYXcuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgIHZhbHVlID0gcmF3W2ZpZWxkXTtcbiAgICAgICAgY29udmVydGVkW2ZpZWxkXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29udmVydGVkO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYSBzaW5nbGUgaXRlbTogbWVyZ2Ugd2l0aCBleGlzdGluZyBpdGVtLlxuICogV2lsbCBmYWlsIHdoZW4gdGhlIGl0ZW0gaGFzIG5vIGlkLCBvciB3aGVuIHRoZXJlIGRvZXMgbm90IGV4aXN0IGFuIGl0ZW1cbiAqIHdpdGggdGhlIHNhbWUgaWQuXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICogQHJldHVybiB7U3RyaW5nfSBpZFxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX3VwZGF0ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgaWQgPSBpdGVtW3RoaXMuX2ZpZWxkSWRdO1xuICBpZiAoaWQgPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIGl0ZW06IGl0ZW0gaGFzIG5vIGlkIChpdGVtOiAnICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkgKyAnKScpO1xuICB9XG4gIHZhciBkID0gdGhpcy5fZGF0YVtpZF07XG4gIGlmICghZCkge1xuICAgIC8vIGl0ZW0gZG9lc24ndCBleGlzdFxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBpdGVtOiBubyBpdGVtIHdpdGggaWQgJyArIGlkICsgJyBmb3VuZCcpO1xuICB9XG5cbiAgLy8gbWVyZ2Ugd2l0aCBjdXJyZW50IGl0ZW1cbiAgZm9yICh2YXIgZmllbGQgaW4gaXRlbSkge1xuICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX3R5cGVbZmllbGRdOyAgLy8gdHlwZSBtYXkgYmUgdW5kZWZpbmVkXG4gICAgICBkW2ZpZWxkXSA9IHV0aWwuY29udmVydChpdGVtW2ZpZWxkXSwgZmllbGRUeXBlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTZXQ7XG4iXX0=
},{"./Queue":17,"./util":46}],16:[function(require,module,exports){
'use strict';

var util = require('./util');
var DataSet = require('./DataSet');

/**
 * DataView
 *
 * a dataview offers a filtered view on a dataset or an other dataview.
 *
 * @param {DataSet | DataView} data
 * @param {Object} [options]   Available options: see method get
 *
 * @constructor DataView
 */
function DataView(data, options) {
  this._data = null;
  this._ids = {}; // ids of the items currently in memory (just contains a boolean true)
  this.length = 0; // number of items in the DataView
  this._options = options || {};
  this._fieldId = 'id'; // name of the field containing id
  this._subscribers = {}; // event subscribers

  var me = this;
  this.listener = function () {
    me._onEvent.apply(me, arguments);
  };

  this.setData(data);
}

// TODO: implement a function .config() to dynamically update things like configured filter
// and trigger changes accordingly

/**
 * Set a data source for the view
 * @param {DataSet | DataView} data
 */
DataView.prototype.setData = function (data) {
  var ids, i, len;

  if (this._data) {
    // unsubscribe from current dataset
    if (this._data.off) {
      this._data.off('*', this.listener);
    }

    // trigger a remove of all items in memory
    ids = [];
    for (var id in this._ids) {
      if (this._ids.hasOwnProperty(id)) {
        ids.push(id);
      }
    }
    this._ids = {};
    this.length = 0;
    this._trigger('remove', { items: ids });
  }

  this._data = data;

  if (this._data) {
    // update fieldId
    this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || 'id';

    // trigger an add of all added items
    ids = this._data.getIds({ filter: this._options && this._options.filter });
    for (i = 0, len = ids.length; i < len; i++) {
      id = ids[i];
      this._ids[id] = true;
    }
    this.length = ids.length;
    this._trigger('add', { items: ids });

    // subscribe to new dataset
    if (this._data.on) {
      this._data.on('*', this.listener);
    }
  }
};

/**
 * Refresh the DataView. Useful when the DataView has a filter function
 * containing a variable parameter.
 */
DataView.prototype.refresh = function () {
  var id;
  var ids = this._data.getIds({ filter: this._options && this._options.filter });
  var newIds = {};
  var added = [];
  var removed = [];

  // check for additions
  for (var i = 0; i < ids.length; i++) {
    id = ids[i];
    newIds[id] = true;
    if (!this._ids[id]) {
      added.push(id);
      this._ids[id] = true;
      this.length++;
    }
  }

  // check for removals
  for (id in this._ids) {
    if (this._ids.hasOwnProperty(id)) {
      if (!newIds[id]) {
        removed.push(id);
        delete this._ids[id];
        this.length--;
      }
    }
  }

  // trigger events
  if (added.length) {
    this._trigger('add', { items: added });
  }
  if (removed.length) {
    this._trigger('remove', { items: removed });
  }
};

/**
 * Get data from the data view
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *     get(options: Object, data: Array | DataTable)
 *
 *     get(id: Number)
 *     get(id: Number, options: Object)
 *     get(id: Number, options: Object, data: Array | DataTable)
 *
 *     get(ids: Number[])
 *     get(ids: Number[], options: Object)
 *     get(ids: Number[], options: Object, data: Array | DataTable)
 *
 * Where:
 *
 * {Number | String} id         The id of an item
 * {Number[] | String{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 *                              {String} [type] Type of data to be returned. Can
 *                                              be 'DataTable' or 'Array' (default)
 *                              {Object.<String, String>} [convert]
 *                              {String[]} [fields] field names to be returned
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * {Array | DataTable} [data]   If provided, items will be appended to this
 *                              array or table. Required in case of Google
 *                              DataTable.
 * @param args
 */
DataView.prototype.get = function (args) {
  var me = this;

  // parse the arguments
  var ids, options, data;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number' || firstType == 'Array') {
    // get(id(s) [, options] [, data])
    ids = arguments[0]; // can be a single id or an array with ids
    options = arguments[1];
    data = arguments[2];
  } else {
    // get([, options] [, data])
    options = arguments[0];
    data = arguments[1];
  }

  // extend the options with the default options and provided options
  var viewOptions = util.extend({}, this._options, options);

  // create a combined filter method when needed
  if (this._options.filter && options && options.filter) {
    viewOptions.filter = function (item) {
      return me._options.filter(item) && options.filter(item);
    };
  }

  // build up the call to the linked data set
  var getArguments = [];
  if (ids != undefined) {
    getArguments.push(ids);
  }
  getArguments.push(viewOptions);
  getArguments.push(data);

  return this._data && this._data.get.apply(this._data, getArguments);
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array} ids
 */
DataView.prototype.getIds = function (options) {
  var ids;

  if (this._data) {
    var defaultFilter = this._options.filter;
    var filter;

    if (options && options.filter) {
      if (defaultFilter) {
        filter = function (item) {
          return defaultFilter(item) && options.filter(item);
        };
      } else {
        filter = options.filter;
      }
    } else {
      filter = defaultFilter;
    }

    ids = this._data.getIds({
      filter: filter,
      order: options && options.order
    });
  } else {
    ids = [];
  }

  return ids;
};

/**
 * Get the DataSet to which this DataView is connected. In case there is a chain
 * of multiple DataViews, the root DataSet of this chain is returned.
 * @return {DataSet} dataSet
 */
DataView.prototype.getDataSet = function () {
  var dataSet = this;
  while (dataSet instanceof DataView) {
    dataSet = dataSet._data;
  }
  return dataSet || null;
};

/**
 * Event listener. Will propagate all events from the connected data set to
 * the subscribers of the DataView, but will filter the items and only trigger
 * when there are changes in the filtered data set.
 * @param {String} event
 * @param {Object | null} params
 * @param {String} senderId
 * @private
 */
DataView.prototype._onEvent = function (event, params, senderId) {
  var i, len, id, item;
  var ids = params && params.items;
  var data = this._data;
  var updatedData = [];
  var added = [];
  var updated = [];
  var removed = [];

  if (ids && data) {
    switch (event) {
      case 'add':
        // filter the ids of the added items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);
          if (item) {
            this._ids[id] = true;
            added.push(id);
          }
        }

        break;

      case 'update':
        // determine the event from the views viewpoint: an updated
        // item can be added, updated, or removed from this view.
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);

          if (item) {
            if (this._ids[id]) {
              updated.push(id);
              updatedData.push(params.data[i]);
            } else {
              this._ids[id] = true;
              added.push(id);
            }
          } else {
            if (this._ids[id]) {
              delete this._ids[id];
              removed.push(id);
            } else {
              // nothing interesting for me :-(
            }
          }
        }

        break;

      case 'remove':
        // filter the ids of the removed items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          if (this._ids[id]) {
            delete this._ids[id];
            removed.push(id);
          }
        }

        break;
    }

    this.length += added.length - removed.length;

    if (added.length) {
      this._trigger('add', { items: added }, senderId);
    }
    if (updated.length) {
      this._trigger('update', { items: updated, data: updatedData }, senderId);
    }
    if (removed.length) {
      this._trigger('remove', { items: removed }, senderId);
    }
  }
};

// copy subscription functionality from DataSet
DataView.prototype.on = DataSet.prototype.on;
DataView.prototype.off = DataSet.prototype.off;
DataView.prototype._trigger = DataSet.prototype._trigger;

// TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)
DataView.prototype.subscribe = DataView.prototype.on;
DataView.prototype.unsubscribe = DataView.prototype.off;

module.exports = DataView;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL0RhdGFWaWV3LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzdCLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7O0FBWW5DLFNBQVMsUUFBUSxDQUFFLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDaEMsTUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7QUFDbEIsTUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7QUFDZixNQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUNoQixNQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7QUFDOUIsTUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7QUFDckIsTUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7O0FBRXZCLE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQztBQUNkLE1BQUksQ0FBQyxRQUFRLEdBQUcsWUFBWTtBQUMxQixNQUFFLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDbEMsQ0FBQzs7QUFFRixNQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3BCOzs7Ozs7Ozs7QUFTRCxRQUFRLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxVQUFVLElBQUksRUFBRTtBQUMzQyxNQUFJLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDOztBQUVoQixNQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7O0FBRWQsUUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRTtBQUNsQixVQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxD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QztLQUN4RTtBQUNELFFBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUNsQixVQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFDLEtBQUssRUFBRSxPQUFPLEVBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztLQUNyRDtHQUNGO0NBQ0YsQ0FBQzs7O0FBR0YsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUM7QUFDN0MsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7QUFDL0MsUUFBUSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUM7OztBQUd6RCxRQUFRLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztBQUNyRCxRQUFRLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQzs7QUFFeEQsTUFBTSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMiLCJmaWxlIjoiL1VzZXJzL2VtaWx5YXNobGV5L1NUT1JZVE9PTFMvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvRGF0YVZpZXcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIERhdGFTZXQgPSByZXF1aXJlKCcuL0RhdGFTZXQnKTtcblxuLyoqXG4gKiBEYXRhVmlld1xuICpcbiAqIGEgZGF0YXZpZXcgb2ZmZXJzIGEgZmlsdGVyZWQgdmlldyBvbiBhIGRhdGFzZXQgb3IgYW4gb3RoZXIgZGF0YXZpZXcuXG4gKlxuICogQHBhcmFtIHtEYXRhU2V0IHwgRGF0YVZpZXd9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICBBdmFpbGFibGUgb3B0aW9uczogc2VlIG1ldGhvZCBnZXRcbiAqXG4gKiBAY29uc3RydWN0b3IgRGF0YVZpZXdcbiAqL1xuZnVuY3Rpb24gRGF0YVZpZXcgKGRhdGEsIG9wdGlvbnMpIHtcbiAgdGhpcy5fZGF0YSA9IG51bGw7XG4gIHRoaXMuX2lkcyA9IHt9OyAvLyBpZHMgb2YgdGhlIGl0ZW1zIGN1cnJlbnRseSBpbiBtZW1vcnkgKGp1c3QgY29udGFpbnMgYSBib29sZWFuIHRydWUpXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBEYXRhVmlld1xuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fZmllbGRJZCA9ICdpZCc7IC8vIG5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgaWRcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTsgLy8gZXZlbnQgc3Vic2NyaWJlcnNcblxuICB2YXIgbWUgPSB0aGlzO1xuICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgIG1lLl9vbkV2ZW50LmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHRoaXMuc2V0RGF0YShkYXRhKTtcbn1cblxuLy8gVE9ETzogaW1wbGVtZW50IGEgZnVuY3Rpb24gLmNvbmZpZygpIHRvIGR5bmFtaWNhbGx5IHVwZGF0ZSB0aGluZ3MgbGlrZSBjb25maWd1cmVkIGZpbHRlclxuLy8gYW5kIHRyaWdnZXIgY2hhbmdlcyBhY2NvcmRpbmdseVxuXG4vKipcbiAqIFNldCBhIGRhdGEgc291cmNlIGZvciB0aGUgdmlld1xuICogQHBhcmFtIHtEYXRhU2V0IHwgRGF0YVZpZXd9IGRhdGFcbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgaWRzLCBpLCBsZW47XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICAgIGlmICh0aGlzLl9kYXRhLm9mZikge1xuICAgICAgdGhpcy5fZGF0YS5vZmYoJyonLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGEgcmVtb3ZlIG9mIGFsbCBpdGVtcyBpbiBtZW1vcnlcbiAgICBpZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9pZHMpIHtcbiAgICAgIGlmICh0aGlzLl9pZHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIGlkcy5wdXNoKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faWRzID0ge307XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHtpdGVtczogaWRzfSk7XG4gIH1cblxuICB0aGlzLl9kYXRhID0gZGF0YTtcblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIC8vIHVwZGF0ZSBmaWVsZElkXG4gICAgdGhpcy5fZmllbGRJZCA9IHRoaXMuX29wdGlvbnMuZmllbGRJZCB8fFxuICAgICAgICAodGhpcy5fZGF0YSAmJiB0aGlzLl9kYXRhLm9wdGlvbnMgJiYgdGhpcy5fZGF0YS5vcHRpb25zLmZpZWxkSWQpIHx8XG4gICAgICAgICdpZCc7XG5cbiAgICAvLyB0cmlnZ2VyIGFuIGFkZCBvZiBhbGwgYWRkZWQgaXRlbXNcbiAgICBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7ZmlsdGVyOiB0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMuZmlsdGVyfSk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZCA9IGlkc1tpXTtcbiAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IGlkcy5sZW5ndGg7XG4gICAgdGhpcy5fdHJpZ2dlcignYWRkJywge2l0ZW1zOiBpZHN9KTtcblxuICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgIGlmICh0aGlzLl9kYXRhLm9uKSB7XG4gICAgICB0aGlzLl9kYXRhLm9uKCcqJywgdGhpcy5saXN0ZW5lcik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJlZnJlc2ggdGhlIERhdGFWaWV3LiBVc2VmdWwgd2hlbiB0aGUgRGF0YVZpZXcgaGFzIGEgZmlsdGVyIGZ1bmN0aW9uXG4gKiBjb250YWluaW5nIGEgdmFyaWFibGUgcGFyYW1ldGVyLlxuICovXG5EYXRhVmlldy5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkO1xuICB2YXIgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe2ZpbHRlcjogdGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmZpbHRlcn0pO1xuICB2YXIgbmV3SWRzID0ge307XG4gIHZhciBhZGRlZCA9IFtdO1xuICB2YXIgcmVtb3ZlZCA9IFtdO1xuXG4gIC8vIGNoZWNrIGZvciBhZGRpdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZCA9IGlkc1tpXTtcbiAgICBuZXdJZHNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuX2lkc1tpZF0pIHtcbiAgICAgIGFkZGVkLnB1c2goaWQpO1xuICAgICAgdGhpcy5faWRzW2lkXSA9IHRydWU7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGZvciByZW1vdmFsc1xuICBmb3IgKGlkIGluIHRoaXMuX2lkcykge1xuICAgIGlmICh0aGlzLl9pZHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBpZiAoIW5ld0lkc1tpZF0pIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKGlkKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2lkc1tpZF07XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gdHJpZ2dlciBldmVudHNcbiAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHtpdGVtczogYWRkZWR9KTtcbiAgfVxuICBpZiAocmVtb3ZlZC5sZW5ndGgpIHtcbiAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7aXRlbXM6IHJlbW92ZWR9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgZGF0YSBmcm9tIHRoZSBkYXRhIHZpZXdcbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAgZ2V0KClcbiAqICAgICBnZXQob3B0aW9uczogT2JqZWN0KVxuICogICAgIGdldChvcHRpb25zOiBPYmplY3QsIGRhdGE6IEFycmF5IHwgRGF0YVRhYmxlKVxuICpcbiAqICAgICBnZXQoaWQ6IE51bWJlcilcbiAqICAgICBnZXQoaWQ6IE51bWJlciwgb3B0aW9uczogT2JqZWN0KVxuICogICAgIGdldChpZDogTnVtYmVyLCBvcHRpb25zOiBPYmplY3QsIGRhdGE6IEFycmF5IHwgRGF0YVRhYmxlKVxuICpcbiAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSlcbiAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSwgb3B0aW9uczogT2JqZWN0KVxuICogICAgIGdldChpZHM6IE51bWJlcltdLCBvcHRpb25zOiBPYmplY3QsIGRhdGE6IEFycmF5IHwgRGF0YVRhYmxlKVxuICpcbiAqIFdoZXJlOlxuICpcbiAqIHtOdW1iZXIgfCBTdHJpbmd9IGlkICAgICAgICAgVGhlIGlkIG9mIGFuIGl0ZW1cbiAqIHtOdW1iZXJbXSB8IFN0cmluZ3t9fSBpZHMgICAgQW4gYXJyYXkgd2l0aCBpZHMgb2YgaXRlbXNcbiAqIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgQW4gT2JqZWN0IHdpdGggb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IFt0eXBlXSBUeXBlIG9mIGRhdGEgdG8gYmUgcmV0dXJuZWQuIENhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgJ0RhdGFUYWJsZScgb3IgJ0FycmF5JyAoZGVmYXVsdClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbY29udmVydF1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ1tdfSBbZmllbGRzXSBmaWVsZCBuYW1lcyB0byBiZSByZXR1cm5lZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiB7QXJyYXkgfCBEYXRhVGFibGV9IFtkYXRhXSAgIElmIHByb3ZpZGVkLCBpdGVtcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkgb3IgdGFibGUuIFJlcXVpcmVkIGluIGNhc2Ugb2YgR29vZ2xlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERhdGFUYWJsZS5cbiAqIEBwYXJhbSBhcmdzXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXJncykge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIHBhcnNlIHRoZSBhcmd1bWVudHNcbiAgdmFyIGlkcywgb3B0aW9ucywgZGF0YTtcbiAgdmFyIGZpcnN0VHlwZSA9IHV0aWwuZ2V0VHlwZShhcmd1bWVudHNbMF0pO1xuICBpZiAoZmlyc3RUeXBlID09ICdTdHJpbmcnIHx8IGZpcnN0VHlwZSA9PSAnTnVtYmVyJyB8fCBmaXJzdFR5cGUgPT0gJ0FycmF5Jykge1xuICAgIC8vIGdldChpZChzKSBbLCBvcHRpb25zXSBbLCBkYXRhXSlcbiAgICBpZHMgPSBhcmd1bWVudHNbMF07ICAvLyBjYW4gYmUgYSBzaW5nbGUgaWQgb3IgYW4gYXJyYXkgd2l0aCBpZHNcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICAgIGRhdGEgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2V0KFssIG9wdGlvbnNdIFssIGRhdGFdKVxuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgfVxuXG4gIC8vIGV4dGVuZCB0aGUgb3B0aW9ucyB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMgYW5kIHByb3ZpZGVkIG9wdGlvbnNcbiAgdmFyIHZpZXdPcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8vIGNyZWF0ZSBhIGNvbWJpbmVkIGZpbHRlciBtZXRob2Qgd2hlbiBuZWVkZWRcbiAgaWYgKHRoaXMuX29wdGlvbnMuZmlsdGVyICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICB2aWV3T3B0aW9ucy5maWx0ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIG1lLl9vcHRpb25zLmZpbHRlcihpdGVtKSAmJiBvcHRpb25zLmZpbHRlcihpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvLyBidWlsZCB1cCB0aGUgY2FsbCB0byB0aGUgbGlua2VkIGRhdGEgc2V0XG4gIHZhciBnZXRBcmd1bWVudHMgPSBbXTtcbiAgaWYgKGlkcyAhPSB1bmRlZmluZWQpIHtcbiAgICBnZXRBcmd1bWVudHMucHVzaChpZHMpO1xuICB9XG4gIGdldEFyZ3VtZW50cy5wdXNoKHZpZXdPcHRpb25zKTtcbiAgZ2V0QXJndW1lbnRzLnB1c2goZGF0YSk7XG5cbiAgcmV0dXJuIHRoaXMuX2RhdGEgJiYgdGhpcy5fZGF0YS5nZXQuYXBwbHkodGhpcy5fZGF0YSwgZ2V0QXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogR2V0IGlkcyBvZiBhbGwgaXRlbXMgb3IgZnJvbSBhIGZpbHRlcmVkIHNldCBvZiBpdGVtcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgQW4gT2JqZWN0IHdpdGggb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5fSBpZHNcbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLmdldElkcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBpZHM7XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICB2YXIgZGVmYXVsdEZpbHRlciA9IHRoaXMuX29wdGlvbnMuZmlsdGVyO1xuICAgIHZhciBmaWx0ZXI7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikge1xuICAgICAgaWYgKGRlZmF1bHRGaWx0ZXIpIHtcbiAgICAgICAgZmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdEZpbHRlcihpdGVtKSAmJiBvcHRpb25zLmZpbHRlcihpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgfVxuXG4gICAgaWRzID0gdGhpcy5fZGF0YS5nZXRJZHMoe1xuICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyXG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWRzID0gW107XG4gIH1cblxuICByZXR1cm4gaWRzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIERhdGFTZXQgdG8gd2hpY2ggdGhpcyBEYXRhVmlldyBpcyBjb25uZWN0ZWQuIEluIGNhc2UgdGhlcmUgaXMgYSBjaGFpblxuICogb2YgbXVsdGlwbGUgRGF0YVZpZXdzLCB0aGUgcm9vdCBEYXRhU2V0IG9mIHRoaXMgY2hhaW4gaXMgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHtEYXRhU2V0fSBkYXRhU2V0XG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5nZXREYXRhU2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YVNldCA9IHRoaXM7XG4gIHdoaWxlIChkYXRhU2V0IGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICBkYXRhU2V0ID0gZGF0YVNldC5fZGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YVNldCB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBFdmVudCBsaXN0ZW5lci4gV2lsbCBwcm9wYWdhdGUgYWxsIGV2ZW50cyBmcm9tIHRoZSBjb25uZWN0ZWQgZGF0YSBzZXQgdG9cbiAqIHRoZSBzdWJzY3JpYmVycyBvZiB0aGUgRGF0YVZpZXcsIGJ1dCB3aWxsIGZpbHRlciB0aGUgaXRlbXMgYW5kIG9ubHkgdHJpZ2dlclxuICogd2hlbiB0aGVyZSBhcmUgY2hhbmdlcyBpbiB0aGUgZmlsdGVyZWQgZGF0YSBzZXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VuZGVySWRcbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5fb25FdmVudCA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICB2YXIgaSwgbGVuLCBpZCwgaXRlbTtcbiAgdmFyIGlkcyA9IHBhcmFtcyAmJiBwYXJhbXMuaXRlbXM7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgdmFyIHVwZGF0ZWREYXRhID0gW107XG4gIHZhciBhZGRlZCA9IFtdO1xuICB2YXIgdXBkYXRlZCA9IFtdO1xuICB2YXIgcmVtb3ZlZCA9IFtdO1xuXG4gIGlmIChpZHMgJiYgZGF0YSkge1xuICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgIC8vIGZpbHRlciB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtc1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgICBpdGVtID0gdGhpcy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGFkZGVkLnB1c2goaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGV2ZW50IGZyb20gdGhlIHZpZXdzIHZpZXdwb2ludDogYW4gdXBkYXRlZFxuICAgICAgICAvLyBpdGVtIGNhbiBiZSBhZGRlZCwgdXBkYXRlZCwgb3IgcmVtb3ZlZCBmcm9tIHRoaXMgdmlldy5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgaXRlbSA9IHRoaXMuZ2V0KGlkKTtcblxuICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faWRzW2lkXSkge1xuICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goaWQpO1xuICAgICAgICAgICAgICB1cGRhdGVkRGF0YS5wdXNoKHBhcmFtcy5kYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYWRkZWQucHVzaChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2lkc1tpZF07XG4gICAgICAgICAgICAgIHJlbW92ZWQucHVzaChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gbm90aGluZyBpbnRlcmVzdGluZyBmb3IgbWUgOi0oXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgIC8vIGZpbHRlciB0aGUgaWRzIG9mIHRoZSByZW1vdmVkIGl0ZW1zXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgIGlmICh0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faWRzW2lkXTtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggKz0gYWRkZWQubGVuZ3RoIC0gcmVtb3ZlZC5sZW5ndGg7XG5cbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7aXRlbXM6IGFkZGVkfSwgc2VuZGVySWQpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ3VwZGF0ZScsIHtpdGVtczogdXBkYXRlZCwgZGF0YTogdXBkYXRlZERhdGF9LCBzZW5kZXJJZCk7XG4gICAgfVxuICAgIGlmIChyZW1vdmVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpZ2dlcigncmVtb3ZlJywge2l0ZW1zOiByZW1vdmVkfSwgc2VuZGVySWQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gY29weSBzdWJzY3JpcHRpb24gZnVuY3Rpb25hbGl0eSBmcm9tIERhdGFTZXRcbkRhdGFWaWV3LnByb3RvdHlwZS5vbiA9IERhdGFTZXQucHJvdG90eXBlLm9uO1xuRGF0YVZpZXcucHJvdG90eXBlLm9mZiA9IERhdGFTZXQucHJvdG90eXBlLm9mZjtcbkRhdGFWaWV3LnByb3RvdHlwZS5fdHJpZ2dlciA9IERhdGFTZXQucHJvdG90eXBlLl90cmlnZ2VyO1xuXG4vLyBUT0RPOiBtYWtlIHRoZXNlIGZ1bmN0aW9ucyBkZXByZWNhdGVkIChyZXBsYWNlZCB3aXRoIGBvbmAgYW5kIGBvZmZgIHNpbmNlIHZlcnNpb24gMC41KVxuRGF0YVZpZXcucHJvdG90eXBlLnN1YnNjcmliZSA9IERhdGFWaWV3LnByb3RvdHlwZS5vbjtcbkRhdGFWaWV3LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IERhdGFWaWV3LnByb3RvdHlwZS5vZmY7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7Il19
},{"./DataSet":15,"./util":46}],17:[function(require,module,exports){
/**
 * A queue
 * @param {Object} options
 *            Available options:
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @constructor
 */
'use strict';

function Queue(options) {
  // options
  this.delay = null;
  this.max = Infinity;

  // properties
  this._queue = [];
  this._timeout = null;
  this._extended = null;

  this.setOptions(options);
}

/**
 * Update the configuration of the queue
 * @param {Object} options
 *            Available options:
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @param options
 */
Queue.prototype.setOptions = function (options) {
  if (options && typeof options.delay !== 'undefined') {
    this.delay = options.delay;
  }
  if (options && typeof options.max !== 'undefined') {
    this.max = options.max;
  }

  this._flushIfNeeded();
};

/**
 * Extend an object with queuing functionality.
 * The object will be extended with a function flush, and the methods provided
 * in options.replace will be replaced with queued ones.
 * @param {Object} object
 * @param {Object} options
 *            Available options:
 *            - replace: Array.<string>
 *                               A list with method names of the methods
 *                               on the object to be replaced with queued ones.
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @return {Queue} Returns the created queue
 */
Queue.extend = function (object, options) {
  var queue = new Queue(options);

  if (object.flush !== undefined) {
    throw new Error('Target object already has a property flush');
  }
  object.flush = function () {
    queue.flush();
  };

  var methods = [{
    name: 'flush',
    original: undefined
  }];

  if (options && options.replace) {
    for (var i = 0; i < options.replace.length; i++) {
      var name = options.replace[i];
      methods.push({
        name: name,
        original: object[name]
      });
      queue.replace(object, name);
    }
  }

  queue._extended = {
    object: object,
    methods: methods
  };

  return queue;
};

/**
 * Destroy the queue. The queue will first flush all queued actions, and in
 * case it has extended an object, will restore the original object.
 */
Queue.prototype.destroy = function () {
  this.flush();

  if (this._extended) {
    var object = this._extended.object;
    var methods = this._extended.methods;
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      if (method.original) {
        object[method.name] = method.original;
      } else {
        delete object[method.name];
      }
    }
    this._extended = null;
  }
};

/**
 * Replace a method on an object with a queued version
 * @param {Object} object   Object having the method
 * @param {string} method   The method name
 */
Queue.prototype.replace = function (object, method) {
  var me = this;
  var original = object[method];
  if (!original) {
    throw new Error('Method ' + method + ' undefined');
  }

  object[method] = function () {
    // create an Array with the arguments
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    // add this call to the queue
    me.queue({
      args: args,
      fn: original,
      context: this
    });
  };
};

/**
 * Queue a call
 * @param {function | {fn: function, args: Array} | {fn: function, args: Array, context: Object}} entry
 */
Queue.prototype.queue = function (entry) {
  if (typeof entry === 'function') {
    this._queue.push({ fn: entry });
  } else {
    this._queue.push(entry);
  }

  this._flushIfNeeded();
};

/**
 * Check whether the queue needs to be flushed
 * @private
 */
Queue.prototype._flushIfNeeded = function () {
  // flush when the maximum is exceeded.
  if (this._queue.length > this.max) {
    this.flush();
  }

  // flush after a period of inactivity when a delay is configured
  clearTimeout(this._timeout);
  if (this.queue.length > 0 && typeof this.delay === 'number') {
    var me = this;
    this._timeout = setTimeout(function () {
      me.flush();
    }, this.delay);
  }
};

/**
 * Flush all queued calls
 */
Queue.prototype.flush = function () {
  while (this._queue.length > 0) {
    var entry = this._queue.shift();
    entry.fn.apply(entry.context || entry.fn, entry.args || []);
  }
};

module.exports = Queue;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL1F1ZXVlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQWFBLFNBQVMsS0FBSyxDQUFDLE9BQU8sRUFBRTs7QUFFdEIsTUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7QUFDbEIsTUFBSSxDQUFDLEdBQUcsR0FBRyxRQUFRLENBQUM7OztBQUdwQixNQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNqQixNQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztBQUNyQixNQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQzs7QUFFdEIsTUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUMxQjs7Ozs7Ozs7Ozs7Ozs7O0FBZUQsS0FBSyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsVUFBVSxPQUFPLEVBQUU7QUFDOUMsTUFBSSxPQUFPLElBQUksT0FBTyxPQUFPLENBQUMsS0FBSyxLQUFLLFdBQVcsRUFBRTtBQUNuRCxRQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7R0FDNUI7QUFDRCxNQUFJLE9BQU8sSUFBSSxPQUFPLE9BQU8sQ0FBQyxHQUFHLEtBQUssV0FBVyxFQUFFO0FBQ2pELFFBQUksQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQztHQUN4Qjs7QUFFRCxNQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7Q0FDdkIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJGLEtBQUssQ0FBQyxNQUFNLEdBQUcsVUFBVSxNQUFNLEVBQUUsT0FBTyxFQUFFO0FBQ3hDLE1BQUksS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQUUvQixNQUFJLE1BQU0sQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFO0FBQzlCLFVBQU0sSUFBSSxL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Q0FBQyxDQUFDO0dBQzdEO0NBQ0YsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi9RdWV1ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBxdWV1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgIC0gZGVsYXk6IG51bWJlciAgICBXaGVuIHByb3ZpZGVkLCB0aGUgcXVldWUgd2lsbCBiZSBmbHVzaGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBpcyBudWxsLlxuICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGVudHJpZXMsIHRoZSBxdWV1ZSBpcyBmbHVzaGVkIGF1dG9tYXRpY2FsbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIG9mIG1heCBpcyBJbmZpbml0eS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBRdWV1ZShvcHRpb25zKSB7XG4gIC8vIG9wdGlvbnNcbiAgdGhpcy5kZWxheSA9IG51bGw7XG4gIHRoaXMubWF4ID0gSW5maW5pdHk7XG5cbiAgLy8gcHJvcGVydGllc1xuICB0aGlzLl9xdWV1ZSA9IFtdO1xuICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgdGhpcy5fZXh0ZW5kZWQgPSBudWxsO1xuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHF1ZXVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgLSBkZWxheTogbnVtYmVyICAgIFdoZW4gcHJvdmlkZWQsIHRoZSBxdWV1ZSB3aWxsIGJlIGZsdXNoZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgYW4gaW5hY3Rpdml0eSBvZiB0aGlzIGRlbGF5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBtaWxsaXNlY29uZHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzIG51bGwuXG4gKiAgICAgICAgICAgIC0gbWF4OiBudW1iZXIgICAgICBXaGVuIHRoZSBxdWV1ZSBleGNlZWRzIHRoZSBnaXZlbiBtYXhpbXVtIG51bWJlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZW50cmllcywgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgYXV0b21hdGljYWxseS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgb2YgbWF4IGlzIEluZmluaXR5LlxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuUXVldWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5kZWxheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgfVxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5tYXggPSBvcHRpb25zLm1heDtcbiAgfVxuXG4gIHRoaXMuX2ZsdXNoSWZOZWVkZWQoKTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHF1ZXVpbmcgZnVuY3Rpb25hbGl0eS5cbiAqIFRoZSBvYmplY3Qgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGEgZnVuY3Rpb24gZmx1c2gsIGFuZCB0aGUgbWV0aG9kcyBwcm92aWRlZFxuICogaW4gb3B0aW9ucy5yZXBsYWNlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBxdWV1ZWQgb25lcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAtIHJlcGxhY2U6IEFycmF5LjxzdHJpbmc+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIGxpc3Qgd2l0aCBtZXRob2QgbmFtZXMgb2YgdGhlIG1ldGhvZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRoZSBvYmplY3QgdG8gYmUgcmVwbGFjZWQgd2l0aCBxdWV1ZWQgb25lcy5cbiAqICAgICAgICAgICAgLSBkZWxheTogbnVtYmVyICAgIFdoZW4gcHJvdmlkZWQsIHRoZSBxdWV1ZSB3aWxsIGJlIGZsdXNoZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgYW4gaW5hY3Rpdml0eSBvZiB0aGlzIGRlbGF5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBtaWxsaXNlY29uZHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzIG51bGwuXG4gKiAgICAgICAgICAgIC0gbWF4OiBudW1iZXIgICAgICBXaGVuIHRoZSBxdWV1ZSBleGNlZWRzIHRoZSBnaXZlbiBtYXhpbXVtIG51bWJlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZW50cmllcywgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgYXV0b21hdGljYWxseS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgb2YgbWF4IGlzIEluZmluaXR5LlxuICogQHJldHVybiB7UXVldWV9IFJldHVybnMgdGhlIGNyZWF0ZWQgcXVldWVcbiAqL1xuUXVldWUuZXh0ZW5kID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0aW9ucykge1xuICB2YXIgcXVldWUgPSBuZXcgUXVldWUob3B0aW9ucyk7XG5cbiAgaWYgKG9iamVjdC5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgb2JqZWN0IGFscmVhZHkgaGFzIGEgcHJvcGVydHkgZmx1c2gnKTtcbiAgfVxuICBvYmplY3QuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcXVldWUuZmx1c2goKTtcbiAgfTtcblxuICB2YXIgbWV0aG9kcyA9IFt7XG4gICAgbmFtZTogJ2ZsdXNoJyxcbiAgICBvcmlnaW5hbDogdW5kZWZpbmVkXG4gIH1dO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5yZXBsYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IG9wdGlvbnMucmVwbGFjZVtpXTtcbiAgICAgIG1ldGhvZHMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG9yaWdpbmFsOiBvYmplY3RbbmFtZV1cbiAgICAgIH0pO1xuICAgICAgcXVldWUucmVwbGFjZShvYmplY3QsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHF1ZXVlLl9leHRlbmRlZCA9IHtcbiAgICBvYmplY3Q6IG9iamVjdCxcbiAgICBtZXRob2RzOiBtZXRob2RzXG4gIH07XG5cbiAgcmV0dXJuIHF1ZXVlO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBxdWV1ZS4gVGhlIHF1ZXVlIHdpbGwgZmlyc3QgZmx1c2ggYWxsIHF1ZXVlZCBhY3Rpb25zLCBhbmQgaW5cbiAqIGNhc2UgaXQgaGFzIGV4dGVuZGVkIGFuIG9iamVjdCwgd2lsbCByZXN0b3JlIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgaWYgKHRoaXMuX2V4dGVuZGVkKSB7XG4gICAgdmFyIG9iamVjdCA9IHRoaXMuX2V4dGVuZGVkLm9iamVjdDtcbiAgICB2YXIgbWV0aG9kcyA9IHRoaXMuX2V4dGVuZGVkLm1ldGhvZHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgICAgIGlmIChtZXRob2Qub3JpZ2luYWwpIHtcbiAgICAgICAgb2JqZWN0W21ldGhvZC5uYW1lXSA9IG1ldGhvZC5vcmlnaW5hbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZWxldGUgb2JqZWN0W21ldGhvZC5uYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZXh0ZW5kZWQgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYSBtZXRob2Qgb24gYW4gb2JqZWN0IHdpdGggYSBxdWV1ZWQgdmVyc2lvblxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAgIE9iamVjdCBoYXZpbmcgdGhlIG1ldGhvZFxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCAgIFRoZSBtZXRob2QgbmFtZVxuICovXG5RdWV1ZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kKSB7XG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBvcmlnaW5hbCA9IG9iamVjdFttZXRob2RdO1xuICBpZiAoIW9yaWdpbmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgJyArIG1ldGhvZCArICcgdW5kZWZpbmVkJyk7XG4gIH1cblxuICBvYmplY3RbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjcmVhdGUgYW4gQXJyYXkgd2l0aCB0aGUgYXJndW1lbnRzXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdGhpcyBjYWxsIHRvIHRoZSBxdWV1ZVxuICAgIG1lLnF1ZXVlKHtcbiAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICBmbjogb3JpZ2luYWwsXG4gICAgICBjb250ZXh0OiB0aGlzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFF1ZXVlIGEgY2FsbFxuICogQHBhcmFtIHtmdW5jdGlvbiB8IHtmbjogZnVuY3Rpb24sIGFyZ3M6IEFycmF5fSB8IHtmbjogZnVuY3Rpb24sIGFyZ3M6IEFycmF5LCBjb250ZXh0OiBPYmplY3R9fSBlbnRyeVxuICovXG5RdWV1ZS5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbihlbnRyeSkge1xuICBpZiAodHlwZW9mIGVudHJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fcXVldWUucHVzaCh7Zm46IGVudHJ5fSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5fcXVldWUucHVzaChlbnRyeSk7XG4gIH1cblxuICB0aGlzLl9mbHVzaElmTmVlZGVkKCk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHF1ZXVlIG5lZWRzIHRvIGJlIGZsdXNoZWRcbiAqIEBwcml2YXRlXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5fZmx1c2hJZk5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZmx1c2ggd2hlbiB0aGUgbWF4aW11bSBpcyBleGNlZWRlZC5cbiAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG5cbiAgLy8gZmx1c2ggYWZ0ZXIgYSBwZXJpb2Qgb2YgaW5hY3Rpdml0eSB3aGVuIGEgZGVsYXkgaXMgY29uZmlndXJlZFxuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHRoaXMuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5mbHVzaCgpO1xuICAgIH0sIHRoaXMuZGVsYXkpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIGFsbCBxdWV1ZWQgY2FsbHNcbiAqL1xuUXVldWUucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICB3aGlsZSAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgZW50cnkuZm4uYXBwbHkoZW50cnkuY29udGV4dCB8fCBlbnRyeS5mbiwgZW50cnkuYXJncyB8fCBbXSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG4iXX0=
},{}],18:[function(require,module,exports){
'use strict';

var Hammer = require('./module/hammer');

/**
 * Register a touch event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.onTouch = function (hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFirst && !isTouching) {
      callback(event);

      isTouching = true;
      setTimeout(function () {
        isTouching = false;
      }, 0);
    }
  };

  hammer.on('hammer.input', callback.inputHandler);
};

// isTouching is true while a touch action is being emitted
// this is a hack to prevent `touch` from being fired twice
var isTouching = false;

/**
 * Register a release event, taking place after a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.onRelease = function (hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFinal && !isReleasing) {
      callback(event);

      isReleasing = true;
      setTimeout(function () {
        isReleasing = false;
      }, 0);
    }
  };

  return hammer.on('hammer.input', callback.inputHandler);
};

// isReleasing is true while a release action is being emitted
// this is a hack to prevent `release` from being fired twice
var isReleasing = false;

/**
 * Unregister a touch event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.offTouch = function (hammer, callback) {
  hammer.off('hammer.input', callback.inputHandler);
};

/**
 * Unregister a release event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.offRelease = exports.offTouch;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL2hhbW1lclV0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQzs7Ozs7OztBQU94QyxPQUFPLENBQUMsT0FBTyxHQUFHLFVBQVUsTUFBTSxFQUFFLFFBQVEsRUFBRTtBQUM1QyxVQUFRLENBQUMsWUFBWSxHQUFHLFVBQVUsS0FBSyxFQUFFO0FBQ3ZDLFFBQUksS0FBSyxDQUFDLE9BQU8sSUFBSSxDQUFDLFVBQVUsRUFBRTtBQUNoQyxjQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRWhCLGdCQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ2xCLGdCQUFVLENBQUMsWUFBWTtBQUNyQixrQkFBVSxHQUFHLEtBQUssQ0FBQztPQUNwQixFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ1A7R0FDRixDQUFDOztBQUVGLFFBQU0sQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQztDQUNsRCxDQUFDOzs7O0FBSUYsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDOzs7Ozs7O0FBT3ZCLE9BQU8sQ0FBQyxTQUFTLEdBQUcsVUFBVSxNQUFNLEVBQUUsUUFBUSxFQUFFO0FBQzlDLFVBQVEsQ0FBQyxZQUFZLEdBQUcsVUFBVSxLQUFLLEVBQUU7QUFDdkMsUUFBSSxLQUFLLENBQUMsT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFO0FBQ2pDLGNBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFaEIsaUJBQVcsR0FBRyxJQUFJLENBQUM7QUFDbkIsZ0JBQVUsQ0FBQyxZQUFZO0FBQ3JCLG1CQUFXLEdBQUcsS0FBSyxDQUFDO09BQ3JCLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDUDtHQUNGLENBQUM7O0FBRUYsU0FBTyxNQUFNLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRSxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUM7Q0FDekQsQ0FBQzs7OztBQUtGLElBQUksV0FBVyxHQUFHLEtBQUssQ0FBQzs7Ozs7OztBQVF4QixPQUFPLENBQUMsUUFBUSxHQUFHLFVBQVUsTUFBTSxFQUFFLFFBQVEsRUFBRTtBQUM3QyxRQUFNLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUM7Q0FDbkQsQ0FBQzs7Ozs7OztBQU9GLE9BQU8sQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi9oYW1tZXJVdGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4vbW9kdWxlL2hhbW1lcicpO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgdG91Y2ggZXZlbnQsIHRha2luZyBwbGFjZSBiZWZvcmUgYSBnZXN0dXJlXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKi9cbmV4cG9ydHMub25Ub3VjaCA9IGZ1bmN0aW9uIChoYW1tZXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrLmlucHV0SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5pc0ZpcnN0ICYmICFpc1RvdWNoaW5nKSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG5cbiAgICAgIGlzVG91Y2hpbmcgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzVG91Y2hpbmcgPSBmYWxzZTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfTtcblxuICBoYW1tZXIub24oJ2hhbW1lci5pbnB1dCcsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59O1xuXG4vLyBpc1RvdWNoaW5nIGlzIHRydWUgd2hpbGUgYSB0b3VjaCBhY3Rpb24gaXMgYmVpbmcgZW1pdHRlZFxuLy8gdGhpcyBpcyBhIGhhY2sgdG8gcHJldmVudCBgdG91Y2hgIGZyb20gYmVpbmcgZmlyZWQgdHdpY2VcbnZhciBpc1RvdWNoaW5nID0gZmFsc2U7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSByZWxlYXNlIGV2ZW50LCB0YWtpbmcgcGxhY2UgYWZ0ZXIgYSBnZXN0dXJlXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKi9cbmV4cG9ydHMub25SZWxlYXNlID0gZnVuY3Rpb24gKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2suaW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlzRmluYWwgJiYgIWlzUmVsZWFzaW5nKSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG5cbiAgICAgIGlzUmVsZWFzaW5nID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpc1JlbGVhc2luZyA9IGZhbHNlO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBoYW1tZXIub24oJ2hhbW1lci5pbnB1dCcsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59O1xuXG5cbi8vIGlzUmVsZWFzaW5nIGlzIHRydWUgd2hpbGUgYSByZWxlYXNlIGFjdGlvbiBpcyBiZWluZyBlbWl0dGVkXG4vLyB0aGlzIGlzIGEgaGFjayB0byBwcmV2ZW50IGByZWxlYXNlYCBmcm9tIGJlaW5nIGZpcmVkIHR3aWNlXG52YXIgaXNSZWxlYXNpbmcgPSBmYWxzZTtcblxuXG4vKipcbiAqIFVucmVnaXN0ZXIgYSB0b3VjaCBldmVudCwgdGFraW5nIHBsYWNlIGJlZm9yZSBhIGdlc3R1cmVcbiAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAqL1xuZXhwb3J0cy5vZmZUb3VjaCA9IGZ1bmN0aW9uIChoYW1tZXIsIGNhbGxiYWNrKSB7XG4gIGhhbW1lci5vZmYoJ2hhbW1lci5pbnB1dCcsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59O1xuXG4vKipcbiAqIFVucmVnaXN0ZXIgYSByZWxlYXNlIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICovXG5leHBvcnRzLm9mZlJlbGVhc2UgPSBleHBvcnRzLm9mZlRvdWNoO1xuIl19
},{"./module/hammer":19}],19:[function(require,module,exports){
// Only load hammer.js when in a browser environment
// (loading hammer.js in a node.js environment gives errors)
'use strict';

if (typeof window !== 'undefined') {
  var propagating = require('propagating-hammerjs');
  var Hammer = window['Hammer'] || require('hammerjs');
  module.exports = propagating(Hammer, {
    preventDefault: 'mouse'
  });
} else {
  module.exports = function () {
    throw Error('hammer.js is only available in a browser, not in node.js.');
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL21vZHVsZS9oYW1tZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUVBLElBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxFQUFFO0FBQ2pDLE1BQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQ2xELE1BQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDckQsUUFBTSxDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUMsTUFBTSxFQUFFO0FBQ25DLGtCQUFjLEVBQUUsT0FBTztHQUN4QixDQUFDLENBQUM7Q0FDSixNQUNJO0FBQ0gsUUFBTSxDQUFDLE9BQU8sR0FBRyxZQUFZO0FBQzNCLFVBQU0sS0FBSyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7R0FDMUUsQ0FBQTtDQUNGIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL21vZHVsZS9oYW1tZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPbmx5IGxvYWQgaGFtbWVyLmpzIHdoZW4gaW4gYSBicm93c2VyIGVudmlyb25tZW50XG4vLyAobG9hZGluZyBoYW1tZXIuanMgaW4gYSBub2RlLmpzIGVudmlyb25tZW50IGdpdmVzIGVycm9ycylcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgcHJvcGFnYXRpbmcgPSByZXF1aXJlKCdwcm9wYWdhdGluZy1oYW1tZXJqcycpO1xuICB2YXIgSGFtbWVyID0gd2luZG93WydIYW1tZXInXSB8fCByZXF1aXJlKCdoYW1tZXJqcycpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb3BhZ2F0aW5nKEhhbW1lciwge1xuICAgIHByZXZlbnREZWZhdWx0OiAnbW91c2UnXG4gIH0pO1xufVxuZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IEVycm9yKCdoYW1tZXIuanMgaXMgb25seSBhdmFpbGFibGUgaW4gYSBicm93c2VyLCBub3QgaW4gbm9kZS5qcy4nKTtcbiAgfVxufVxuIl19
},{"hammerjs":11,"propagating-hammerjs":14}],20:[function(require,module,exports){
// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.
'use strict';

module.exports = typeof window !== 'undefined' && window['moment'] || require('moment');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL21vZHVsZS9tb21lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUVBLE1BQU0sQ0FBQyxPQUFPLEdBQUcsQUFBQyxPQUFPLE1BQU0sS0FBSyxXQUFXLElBQUssTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi9tb2R1bGUvbW9tZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZmlyc3QgY2hlY2sgaWYgbW9tZW50LmpzIGlzIGFscmVhZHkgbG9hZGVkIGluIHRoZSBicm93c2VyIHdpbmRvdywgaWYgc28sXG4vLyB1c2UgdGhpcyBpbnN0YW5jZS4gRWxzZSwgbG9hZCB2aWEgY29tbW9uanMuXG5tb2R1bGUuZXhwb3J0cyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgJiYgd2luZG93Wydtb21lbnQnXSB8fCByZXF1aXJlKCdtb21lbnQnKTtcbiJdfQ==
},{"moment":13}],21:[function(require,module,exports){
(function (global){
'use strict';

var _rng;

var globalVar = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

if (globalVar && globalVar.crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  _rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!_rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var _rnds = new Array(16);
  _rng = function () {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required

//var _rng = require('./rng');

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = buf && offset || 0,
      ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {
    if (ii < 16) {
      // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0,
      bth = _byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0,
    _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL21vZHVsZS91dWlkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxJQUFJLENBQUM7O0FBRVQsSUFBSSxTQUFTLEdBQUcsT0FBTyxNQUFNLEtBQUssV0FBVyxHQUN2QyxNQUFNLEdBQ04sT0FBTyxNQUFNLEtBQUssV0FBVyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUM7O0FBRXBELElBQUksU0FBUyxJQUFJLFNBQVMsQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRTs7O0FBRzNELE1BQUksTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2hDLE1BQUksR0FBRyxTQUFTLFNBQVMsR0FBRztBQUMxQixVQUFNLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQy9CLFdBQU8sTUFBTSxDQUFDO0dBQ2YsQ0FBQztDQUNIOztBQUVELElBQUksQ0FBQyxJQUFJLEVBQUU7Ozs7O0FBS1QsTUFBSSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDMUIsTUFBSSxHQUFHLFlBQVk7QUFDakIsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDOUIsVUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUEsS0FBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxXQUFXLENBQUM7QUFDdEQsV0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUEsSUFBSyxDQUFDLENBQUEsQUFBQyxHQUFHLElBQUksQ0FBQztLQUMzQzs7QUFFRCxXQUFPLEtBQUssQ0FBQztHQUNkLENBQUM7Q0FDSDs7Ozs7Ozs7Ozs7Ozs7QUFjRCxJQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDcEIsSUFBSSxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDNUIsWUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQSxDQUFFLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkQsWUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUMvQjs7O0FBR0QsU0FBUyxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUU7QUFDN0IsTUFBSSxDQUFDLEdBQUcsQUFBQyxHQUFHLElBQUksTUFBTSxJQUFLLENBQUM7TUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDOztBQUVyQyxLQUFHLEdBQUcsR0FBRyxJQUFJLEVBQUUsQ0FBQztBQUNoQixHQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxVQUFVLEdBQUcsRUFBRTtBQUNyRCxRQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUU7O0FBQ1gsU0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNqQztHQUNGLENBQUMsQ0FBQzs7O0FBR0gsU0FBTyxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ2QsT0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztHQUNuQjs7QUFFRCxTQUFPLEdBQUcsQ0FBQztDQUNaOzs7QUFHRCxTQUFTLE9BQU8sQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFO0FBQzVCLE1BQUksQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDO01BQUUsR0FBRyxHQUFHLFVBQVUsQ0FBQztBQUN0QyxTQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUNoQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQ25DLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FDbkMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUNuQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQ25DLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUM3QixHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FDN0IsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Q0FDbkM7Ozs7Ozs7O0FBUUQsSUFBSSxVQUFVLEdBQUcsSUFBSSxFQUFFLENBQUM7OztBQUd4QixJQUFJLE9BQU8sR0FBRyxDQUNaLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQ3BCLFVBQVUsQ0FBQyxDQUFDLENBQUMs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TUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEFBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBSSxJQUFJLENBQUM7QUFDbEMsTUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEFBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBSSxJQUFJLENBQUM7OztBQUdsQyxNQUFJLEdBQUcsRUFBRTtBQUNQLFNBQUssSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDOUIsU0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDeEI7R0FDRjs7QUFFRCxTQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDN0I7OztBQUdELElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNkLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO0FBQ2IsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDYixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNuQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQzs7QUFFdkIsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMiLCJmaWxlIjoiL1VzZXJzL2VtaWx5YXNobGV5L1NUT1JZVE9PTFMvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvbW9kdWxlL3V1aWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3JuZztcblxudmFyIGdsb2JhbFZhciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgPyB3aW5kb3dcbiAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogbnVsbDtcblxuaWYgKGdsb2JhbFZhciAmJiBnbG9iYWxWYXIuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gIHZhciBfcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG4gIF9ybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kczgpO1xuICAgIHJldHVybiBfcm5kczg7XG4gIH07XG59XG5cbmlmICghX3JuZykge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gIF9ybmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIF9ybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBfcm5kcztcbiAgfTtcbn1cblxuLy8gICAgIHV1aWQuanNcbi8vXG4vLyAgICAgQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgUm9iZXJ0IEtpZWZmZXJcbi8vICAgICBNSVQgTGljZW5zZSAtIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblxuLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIFdlIGZlYXR1cmVcbi8vIGRldGVjdCB0byBkZXRlcm1pbmUgdGhlIGJlc3QgUk5HIHNvdXJjZSwgbm9ybWFsaXppbmcgdG8gYSBmdW5jdGlvbiB0aGF0XG4vLyByZXR1cm5zIDEyOC1iaXRzIG9mIHJhbmRvbW5lc3MsIHNpbmNlIHRoYXQncyB3aGF0J3MgdXN1YWxseSByZXF1aXJlZFxuXG4vL3ZhciBfcm5nID0gcmVxdWlyZSgnLi9ybmcnKTtcblxuLy8gTWFwcyBmb3IgbnVtYmVyIDwtPiBoZXggc3RyaW5nIGNvbnZlcnNpb25cbnZhciBfYnl0ZVRvSGV4ID0gW107XG52YXIgX2hleFRvQnl0ZSA9IHt9O1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBfYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbiAgX2hleFRvQnl0ZVtfYnl0ZVRvSGV4W2ldXSA9IGk7XG59XG5cbi8vICoqYHBhcnNlKClgIC0gUGFyc2UgYSBVVUlEIGludG8gaXQncyBjb21wb25lbnQgYnl0ZXMqKlxuZnVuY3Rpb24gcGFyc2UocywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSAoYnVmICYmIG9mZnNldCkgfHwgMCwgaWkgPSAwO1xuXG4gIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1swLTlhLWZdezJ9L2csIGZ1bmN0aW9uIChvY3QpIHtcbiAgICBpZiAoaWkgPCAxNikgeyAvLyBEb24ndCBvdmVyZmxvdyFcbiAgICAgIGJ1ZltpICsgaWkrK10gPSBfaGV4VG9CeXRlW29jdF07XG4gICAgfVxuICB9KTtcblxuICAvLyBaZXJvIG91dCByZW1haW5pbmcgYnl0ZXMgaWYgc3RyaW5nIHdhcyBzaG9ydFxuICB3aGlsZSAoaWkgPCAxNikge1xuICAgIGJ1ZltpICsgaWkrK10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuLy8gKipgdW5wYXJzZSgpYCAtIENvbnZlcnQgVVVJRCBieXRlIGFycmF5IChhbGEgcGFyc2UoKSkgaW50byBhIHN0cmluZyoqXG5mdW5jdGlvbiB1bnBhcnNlKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDAsIGJ0aCA9IF9ieXRlVG9IZXg7XG4gIHJldHVybiBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXTtcbn1cblxuLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG4vLyByYW5kb20gIydzIHdlIG5lZWQgdG8gaW5pdCBub2RlIGFuZCBjbG9ja3NlcVxudmFyIF9zZWVkQnl0ZXMgPSBfcm5nKCk7XG5cbi8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxudmFyIF9ub2RlSWQgPSBbXG4gIF9zZWVkQnl0ZXNbMF0gfCAweDAxLFxuICBfc2VlZEJ5dGVzWzFdLCBfc2VlZEJ5dGVzWzJdLCBfc2VlZEJ5dGVzWzNdLCBfc2VlZEJ5dGVzWzRdLCBfc2VlZEJ5dGVzWzVdXG5dO1xuXG4vLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxudmFyIF9jbG9ja3NlcSA9IChfc2VlZEJ5dGVzWzZdIDw8IDggfCBfc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcblxuLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG52YXIgX2xhc3RNU2VjcyA9IDAsIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgdmFyIGR0ID0gKG1zZWNzIC0gX2xhc3RNU2VjcykgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAvLyBgdGltZV9sb3dgXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgbisrKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IHVucGFyc2UoYik7XG59XG5cbi8vICoqYHY0KClgIC0gR2VuZXJhdGUgcmFuZG9tIFVVSUQqKlxuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAvLyBEZXByZWNhdGVkIC0gJ2Zvcm1hdCcgYXJndW1lbnQsIGFzIHN1cHBvcnRlZCBpbiB2MS4yXG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyBpaSsrKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbn1cblxuLy8gRXhwb3J0IHB1YmxpYyBBUElcbnZhciB1dWlkID0gdjQ7XG51dWlkLnYxID0gdjE7XG51dWlkLnY0ID0gdjQ7XG51dWlkLnBhcnNlID0gcGFyc2U7XG51dWlkLnVucGFyc2UgPSB1bnBhcnNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG4iXX0=
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],22:[function(require,module,exports){
'use strict';

var keycharm = require('keycharm');
var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var util = require('../util');

/**
 * Turn an element into an clickToUse element.
 * When not active, the element has a transparent overlay. When the overlay is
 * clicked, the mode is changed to active.
 * When active, the element is displayed with a blue border around it, and
 * the interactive contents of the element can be used. When clicked outside
 * the element, the elements mode is changed to inactive.
 * @param {Element} container
 * @constructor
 */
function Activator(container) {
  this.active = false;

  this.dom = {
    container: container
  };

  this.dom.overlay = document.createElement('div');
  this.dom.overlay.className = 'vis-overlay';

  this.dom.container.appendChild(this.dom.overlay);

  this.hammer = Hammer(this.dom.overlay);
  this.hammer.on('tap', this._onTapOverlay.bind(this));

  // block all touch events (except tap)
  var me = this;
  var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'];
  events.forEach(function (event) {
    me.hammer.on(event, function (event) {
      event.stopPropagation();
    });
  });

  // attach a click event to the window, in order to deactivate when clicking outside the timeline
  if (document && document.body) {
    this.onClick = function (event) {
      if (!_hasParent(event.target, container)) {
        me.deactivate();
      }
    };
    document.body.addEventListener('click', this.onClick);
  }

  if (this.keycharm !== undefined) {
    this.keycharm.destroy();
  }
  this.keycharm = keycharm();

  // keycharm listener only bounded when active)
  this.escListener = this.deactivate.bind(this);
}

// turn into an event emitter
Emitter(Activator.prototype);

// The currently active activator
Activator.current = null;

/**
 * Destroy the activator. Cleans up all created DOM and event listeners
 */
Activator.prototype.destroy = function () {
  this.deactivate();

  // remove dom
  this.dom.overlay.parentNode.removeChild(this.dom.overlay);

  // remove global event listener
  if (this.onClick) {
    document.body.removeEventListener('click', this.onClick);
  }

  // cleanup hammer instances
  this.hammer.destroy();
  this.hammer = null;
  // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)
};

/**
 * Activate the element
 * Overlay is hidden, element is decorated with a blue shadow border
 */
Activator.prototype.activate = function () {
  // we allow only one active activator at a time
  if (Activator.current) {
    Activator.current.deactivate();
  }
  Activator.current = this;

  this.active = true;
  this.dom.overlay.style.display = 'none';
  util.addClassName(this.dom.container, 'vis-active');

  this.emit('change');
  this.emit('activate');

  // ugly hack: bind ESC after emitting the events, as the Network rebinds all
  // keyboard events on a 'change' event
  this.keycharm.bind('esc', this.escListener);
};

/**
 * Deactivate the element
 * Overlay is displayed on top of the element
 */
Activator.prototype.deactivate = function () {
  this.active = false;
  this.dom.overlay.style.display = '';
  util.removeClassName(this.dom.container, 'vis-active');
  this.keycharm.unbind('esc', this.escListener);

  this.emit('change');
  this.emit('deactivate');
};

/**
 * Handle a tap event: activate the container
 * @param event
 * @private
 */
Activator.prototype._onTapOverlay = function (event) {
  // activate the container
  this.activate();
  event.stopPropagation();
};

/**
 * Test whether the element has the requested parent element somewhere in
 * its chain of parent nodes.
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @returns {boolean} Returns true when the parent is found somewhere in the
 *                    chain of parent nodes.
 * @private
 */
function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }
    element = element.parentNode;
  }
  return false;
}

module.exports = Activator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3NoYXJlZC9BY3RpdmF0b3IuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDbkMsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDM0MsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDekMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7QUFZOUIsU0FBUyxTQUFTLENBQUMsU0FBUyxFQUFFO0FBQzVCLE1BQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDOztBQUVwQixNQUFJLENBQUMsR0FBRyxHQUFHO0FBQ1QsYUFBUyxFQUFFLFNBQVM7R0FDckIsQ0FBQzs7QUFFRixNQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2pELE1BQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxhQUFhLENBQUM7O0FBRTNDLE1BQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQUVqRCxNQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3ZDLE1BQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOzs7QUFHckQsTUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDO0FBQ2QsTUFBSSxNQUFNLEdBQUcsQ0FDWCxLQUFLLEVB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QU8sR0FBRyxFQUFFLENBQUM7QUFDcEMsTUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsQ0FBQztBQUN2RCxNQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDOztBQUU5QyxNQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3BCLE1BQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7Q0FDekIsQ0FBQzs7Ozs7OztBQU9GLFNBQVMsQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFVBQVUsS0FBSyxFQUFFOztBQUVuRCxNQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDaEIsT0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO0NBQ3pCLENBQUM7Ozs7Ozs7Ozs7O0FBV0YsU0FBUyxVQUFVLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRTtBQUNuQyxTQUFPLE9BQU8sRUFBRTtBQUNkLFFBQUksT0FBTyxLQUFLLE1BQU0sRUFBRTtBQUN0QixhQUFPLElBQUksQ0FBQTtLQUNaO0FBQ0QsV0FBTyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7R0FDOUI7QUFDRCxTQUFPLEtBQUssQ0FBQztDQUNkOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3NoYXJlZC9BY3RpdmF0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIga2V5Y2hhcm0gPSByZXF1aXJlKCdrZXljaGFybScpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdlbWl0dGVyLWNvbXBvbmVudCcpO1xudmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vKipcbiAqIFR1cm4gYW4gZWxlbWVudCBpbnRvIGFuIGNsaWNrVG9Vc2UgZWxlbWVudC5cbiAqIFdoZW4gbm90IGFjdGl2ZSwgdGhlIGVsZW1lbnQgaGFzIGEgdHJhbnNwYXJlbnQgb3ZlcmxheS4gV2hlbiB0aGUgb3ZlcmxheSBpc1xuICogY2xpY2tlZCwgdGhlIG1vZGUgaXMgY2hhbmdlZCB0byBhY3RpdmUuXG4gKiBXaGVuIGFjdGl2ZSwgdGhlIGVsZW1lbnQgaXMgZGlzcGxheWVkIHdpdGggYSBibHVlIGJvcmRlciBhcm91bmQgaXQsIGFuZFxuICogdGhlIGludGVyYWN0aXZlIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50IGNhbiBiZSB1c2VkLiBXaGVuIGNsaWNrZWQgb3V0c2lkZVxuICogdGhlIGVsZW1lbnQsIHRoZSBlbGVtZW50cyBtb2RlIGlzIGNoYW5nZWQgdG8gaW5hY3RpdmUuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFjdGl2YXRvcihjb250YWluZXIpIHtcbiAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcblxuICB0aGlzLmRvbSA9IHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICB9O1xuXG4gIHRoaXMuZG9tLm92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20ub3ZlcmxheS5jbGFzc05hbWUgPSAndmlzLW92ZXJsYXknO1xuXG4gIHRoaXMuZG9tLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5vdmVybGF5KTtcblxuICB0aGlzLmhhbW1lciA9IEhhbW1lcih0aGlzLmRvbS5vdmVybGF5KTtcbiAgdGhpcy5oYW1tZXIub24oJ3RhcCcsIHRoaXMuX29uVGFwT3ZlcmxheS5iaW5kKHRoaXMpKTtcblxuICAvLyBibG9jayBhbGwgdG91Y2ggZXZlbnRzIChleGNlcHQgdGFwKVxuICB2YXIgbWUgPSB0aGlzO1xuICB2YXIgZXZlbnRzID0gW1xuICAgICd0YXAnLCAnZG91YmxldGFwJywgJ3ByZXNzJyxcbiAgICAncGluY2gnLFxuICAgICdwYW4nLCAncGFuc3RhcnQnLCAncGFubW92ZScsICdwYW5lbmQnXG4gIF07XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIG1lLmhhbW1lci5vbihldmVudCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gYXR0YWNoIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHdpbmRvdywgaW4gb3JkZXIgdG8gZGVhY3RpdmF0ZSB3aGVuIGNsaWNraW5nIG91dHNpZGUgdGhlIHRpbWVsaW5lXG4gIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgdGhpcy5vbkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIV9oYXNQYXJlbnQoZXZlbnQudGFyZ2V0LCBjb250YWluZXIpKSB7XG4gICAgICAgIG1lLmRlYWN0aXZhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICB9XG5cbiAgaWYgKHRoaXMua2V5Y2hhcm0gIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICB9XG4gIHRoaXMua2V5Y2hhcm0gPSBrZXljaGFybSgpO1xuXG4gIC8vIGtleWNoYXJtIGxpc3RlbmVyIG9ubHkgYm91bmRlZCB3aGVuIGFjdGl2ZSlcbiAgdGhpcy5lc2NMaXN0ZW5lciA9IHRoaXMuZGVhY3RpdmF0ZS5iaW5kKHRoaXMpO1xufVxuXG4vLyB0dXJuIGludG8gYW4gZXZlbnQgZW1pdHRlclxuRW1pdHRlcihBY3RpdmF0b3IucHJvdG90eXBlKTtcblxuLy8gVGhlIGN1cnJlbnRseSBhY3RpdmUgYWN0aXZhdG9yXG5BY3RpdmF0b3IuY3VycmVudCA9IG51bGw7XG5cbi8qKlxuICogRGVzdHJveSB0aGUgYWN0aXZhdG9yLiBDbGVhbnMgdXAgYWxsIGNyZWF0ZWQgRE9NIGFuZCBldmVudCBsaXN0ZW5lcnNcbiAqL1xuQWN0aXZhdG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRlYWN0aXZhdGUoKTtcblxuICAvLyByZW1vdmUgZG9tXG4gIHRoaXMuZG9tLm92ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5vdmVybGF5KTtcblxuICAvLyByZW1vdmUgZ2xvYmFsIGV2ZW50IGxpc3RlbmVyXG4gIGlmICh0aGlzLm9uQ2xpY2spIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgfVxuXG4gIC8vIGNsZWFudXAgaGFtbWVyIGluc3RhbmNlc1xuICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcbiAgLy8gRklYTUU6IGNsZWFuaW5nIHVwIGhhbW1lciBpbnN0YW5jZXMgZG9lc24ndCB3b3JrIChUaW1lbGluZSBub3QgcmVtb3ZlZCBmcm9tIG1lbW9yeSlcbn07XG5cbi8qKlxuICogQWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAqIE92ZXJsYXkgaXMgaGlkZGVuLCBlbGVtZW50IGlzIGRlY29yYXRlZCB3aXRoIGEgYmx1ZSBzaGFkb3cgYm9yZGVyXG4gKi9cbkFjdGl2YXRvci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHdlIGFsbG93IG9ubHkgb25lIGFjdGl2ZSBhY3RpdmF0b3IgYXQgYSB0aW1lXG4gIGlmIChBY3RpdmF0b3IuY3VycmVudCkge1xuICAgIEFjdGl2YXRvci5jdXJyZW50LmRlYWN0aXZhdGUoKTtcbiAgfVxuICBBY3RpdmF0b3IuY3VycmVudCA9IHRoaXM7XG5cbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmNvbnRhaW5lciwgJ3Zpcy1hY3RpdmUnKTtcblxuICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICB0aGlzLmVtaXQoJ2FjdGl2YXRlJyk7XG5cbiAgLy8gdWdseSBoYWNrOiBiaW5kIEVTQyBhZnRlciBlbWl0dGluZyB0aGUgZXZlbnRzLCBhcyB0aGUgTmV0d29yayByZWJpbmRzIGFsbFxuICAvLyBrZXlib2FyZCBldmVudHMgb24gYSAnY2hhbmdlJyBldmVudFxuICB0aGlzLmtleWNoYXJtLmJpbmQoJ2VzYycsIHRoaXMuZXNjTGlzdGVuZXIpO1xufTtcblxuLyoqXG4gKiBEZWFjdGl2YXRlIHRoZSBlbGVtZW50XG4gKiBPdmVybGF5IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgdGhlIGVsZW1lbnRcbiAqL1xuQWN0aXZhdG9yLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLmRvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uY29udGFpbmVyLCAndmlzLWFjdGl2ZScpO1xuICB0aGlzLmtleWNoYXJtLnVuYmluZCgnZXNjJywgdGhpcy5lc2NMaXN0ZW5lcik7XG5cbiAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbiAgdGhpcy5lbWl0KCdkZWFjdGl2YXRlJyk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBhIHRhcCBldmVudDogYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICogQHBhcmFtIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLl9vblRhcE92ZXJsYXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICB0aGlzLmFjdGl2YXRlKCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHRoZSByZXF1ZXN0ZWQgcGFyZW50IGVsZW1lbnQgc29tZXdoZXJlIGluXG4gKiBpdHMgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHBhcmVudCBpcyBmb3VuZCBzb21ld2hlcmUgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2hhc1BhcmVudChlbGVtZW50LCBwYXJlbnQpIHtcbiAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBY3RpdmF0b3I7XG4iXX0=
},{"../module/hammer":19,"../util":46,"emitter-component":10,"keycharm":12}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Hammer = require('../module/hammer');
var hammerUtil = require('../hammerUtil');
var util = require('../util');

var ColorPicker = (function () {
  function ColorPicker() {
    var pixelRatio = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

    _classCallCheck(this, ColorPicker);

    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = { x: 289 / 2, y: 289 / 2 };
    this.r = 289 * 0.49;
    this.color = { r: 255, g: 255, b: 255, a: 1.0 };
    this.hueCircle = undefined;
    this.initialColor = { r: 255, g: 255, b: 255, a: 1.0 };
    this.previousColor = undefined;
    this.applied = false;

    // bound by
    this.updateCallback = function () {};

    // create all DOM elements
    this._create();
  }

  /**
   * this inserts the colorPicker into a div from the DOM
   * @param container
   */

  _createClass(ColorPicker, [{
    key: 'insertTo',
    value: function insertTo(container) {
      if (this.hammer !== undefined) {
        this.hammer.destroy();
        this.hammer = undefined;
      }
      this.container = container;
      this.container.appendChild(this.frame);
      this._bindHammer();

      this._setSize();
    }

    /**
     * the callback is executed on apply and save. Bind it to the application
     * @param callback
     */
  }, {
    key: 'setCallback',
    value: function setCallback(callback) {
      if (typeof callback === 'function') {
        this.updateCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker callback is not a function.");
      }
    }
  }, {
    key: '_isColorString',
    value: function _isColorString(color) {
      var htmlColors = { black: '#000000', navy: '#000080', darkblue: '#00008B', mediumblue: '#0000CD', blue: '#0000FF', darkgreen: '#006400', green: '#008000', teal: '#008080', darkcyan: '#008B8B', deepskyblue: '#00BFFF', darkturquoise: '#00CED1', mediumspringgreen: '#00FA9A', lime: '#00FF00', springgreen: '#00FF7F', aqua: '#00FFFF', cyan: '#00FFFF', midnightblue: '#191970', dodgerblue: '#1E90FF', lightseagreen: '#20B2AA', forestgreen: '#228B22', seagreen: '#2E8B57', darkslategray: '#2F4F4F', limegreen: '#32CD32', mediumseagreen: '#3CB371', turquoise: '#40E0D0', royalblue: '#4169E1', steelblue: '#4682B4', darkslateblue: '#483D8B', mediumturquoise: '#48D1CC', indigo: '#4B0082', darkolivegreen: '#556B2F', cadetblue: '#5F9EA0', cornflowerblue: '#6495ED', mediumaquamarine: '#66CDAA', dimgray: '#696969', slateblue: '#6A5ACD', olivedrab: '#6B8E23', slategray: '#708090', lightslategray: '#778899', mediumslateblue: '#7B68EE', lawngreen: '#7CFC00', chartreuse: '#7FFF00', aquamarine: '#7FFFD4', maroon: '#800000', purple: '#800080', olive: '#808000', gray: '#808080', skyblue: '#87CEEB', lightskyblue: '#87CEFA', blueviolet: '#8A2BE2', darkred: '#8B0000', darkmagenta: '#8B008B', saddlebrown: '#8B4513', darkseagreen: '#8FBC8F', lightgreen: '#90EE90', mediumpurple: '#9370D8', darkviolet: '#9400D3', palegreen: '#98FB98', darkorchid: '#9932CC', yellowgreen: '#9ACD32', sienna: '#A0522D', brown: '#A52A2A', darkgray: '#A9A9A9', lightblue: '#ADD8E6', greenyellow: '#ADFF2F', paleturquoise: '#AFEEEE', lightsteelblue: '#B0C4DE', powderblue: '#B0E0E6', firebrick: '#B22222', darkgoldenrod: '#B8860B', mediumorchid: '#BA55D3', rosybrown: '#BC8F8F', darkkhaki: '#BDB76B', silver: '#C0C0C0', mediumvioletred: '#C71585', indianred: '#CD5C5C', peru: '#CD853F', chocolate: '#D2691E', tan: '#D2B48C', lightgrey: '#D3D3D3', palevioletred: '#D87093', thistle: '#D8BFD8', orchid: '#DA70D6', goldenrod: '#DAA520', crimson: '#DC143C', gainsboro: '#DCDCDC', plum: '#DDA0DD', burlywood: '#DEB887', lightcyan: '#E0FFFF', lavender: '#E6E6FA', darksalmon: '#E9967A', violet: '#EE82EE', palegoldenrod: '#EEE8AA', lightcoral: '#F08080', khaki: '#F0E68C', aliceblue: '#F0F8FF', honeydew: '#F0FFF0', azure: '#F0FFFF', sandybrown: '#F4A460', wheat: '#F5DEB3', beige: '#F5F5DC', whitesmoke: '#F5F5F5', mintcream: '#F5FFFA', ghostwhite: '#F8F8FF', salmon: '#FA8072', antiquewhite: '#FAEBD7', linen: '#FAF0E6', lightgoldenrodyellow: '#FAFAD2', oldlace: '#FDF5E6', red: '#FF0000', fuchsia: '#FF00FF', magenta: '#FF00FF', deeppink: '#FF1493', orangered: '#FF4500', tomato: '#FF6347', hotpink: '#FF69B4', coral: '#FF7F50', darkorange: '#FF8C00', lightsalmon: '#FFA07A', orange: '#FFA500', lightpink: '#FFB6C1', pink: '#FFC0CB', gold: '#FFD700', peachpuff: '#FFDAB9', navajowhite: '#FFDEAD', moccasin: '#FFE4B5', bisque: '#FFE4C4', mistyrose: '#FFE4E1', blanchedalmond: '#FFEBCD', papayawhip: '#FFEFD5', lavenderblush: '#FFF0F5', seashell: '#FFF5EE', cornsilk: '#FFF8DC', lemonchiffon: '#FFFACD', floralwhite: '#FFFAF0', snow: '#FFFAFA', yellow: '#FFFF00', lightyellow: '#FFFFE0', ivory: '#FFFFF0', white: '#FFFFFF' };
      if (typeof color === 'string') {
        return htmlColors[color];
      }
    }

    /**
     * Set the color of the colorPicker
     * Supported formats:
     * 'red'                   --> HTML color string
     * '#ffffff'               --> hex string
     * 'rbg(255,255,255)'      --> rgb string
     * 'rgba(255,255,255,1.0)' --> rgba string
     * {r:255,g:255,b:255}     --> rgb object
     * {r:255,g:255,b:255,a:1.0} --> rgba object
     * @param color
     * @param setInitial
     */
  }, {
    key: 'setColor',
    value: function setColor(color) {
      var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      if (color === 'none') {
        return;
      }

      var rgba = undefined;

      // if a html color shorthand is used, convert to hex
      var htmlColor = this._isColorString(color);
      if (htmlColor !== undefined) {
        color = htmlColor;
      }

      // check format
      if (util.isString(color) === true) {
        if (util.isValidRGB(color) === true) {
          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(',');
          rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: 1.0 };
        } else if (util.isValidRGBA(color) === true) {
          var rgbaArray = color.substr(5).substr(0, color.length - 6).split(',');
          rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: rgbaArray[3] };
        } else if (util.isValidHex(color) === true) {
          var rgbObj = util.hexToRGB(color);
          rgba = { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1.0 };
        }
      } else {
        if (color instanceof Object) {
          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
            var alpha = color.a !== undefined ? color.a : '1.0';
            rgba = { r: color.r, g: color.g, b: color.b, a: alpha };
          }
        }
      }

      // set color
      if (rgba === undefined) {
        throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + JSON.stringify(color));
      } else {
        this._setColor(rgba, setInitial);
      }
    }

    /**
     * this shows the color picker at a location. The hue circle is constructed once and stored.
     * @param x
     * @param y
     */
  }, {
    key: 'show',
    value: function show(x, y) {
      this.applied = false;
      this.frame.style.display = 'block';
      this.frame.style.top = y + 'px';
      this.frame.style.left = x + 'px';
      this._generateHueCircle();
    }

    // ------------------------------------------ PRIVATE ----------------------------- //

    /**
     * Hide the picker. Is called by the cancel button.
     * Optional boolean to store the previous color for easy access later on.
     * @param storePrevious
     * @private
     */
  }, {
    key: '_hide',
    value: function _hide() {
      var storePrevious = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      // store the previous color for next time;
      if (storePrevious === true) {
        this.previousColor = util.extend({}, this.color);
      }

      if (this.applied === true) {
        this.updateCallback(this.initialColor);
      }

      this.frame.style.display = 'none';
    }

    /**
     * bound to the save button. Saves and hides.
     * @private
     */
  }, {
    key: '_save',
    value: function _save() {
      this.updateCallback(this.color);
      this.applied = false;
      this._hide();
    }

    /**
     * Bound to apply button. Saves but does not close. Is undone by the cancel button.
     * @private
     */
  }, {
    key: '_apply',
    value: function _apply() {
      this.applied = true;
      this.updateCallback(this.color);
      this._updatePicker(this.color);
    }

    /**
     * load the color from the previous session.
     * @private
     */
  }, {
    key: '_loadLast',
    value: function _loadLast() {
      if (this.previousColor !== undefined) {
        this.setColor(this.previousColor, false);
      } else {
        alert("There is no last color to load...");
      }
    }

    /**
     * set the color, place the picker
     * @param rgba
     * @param setInitial
     * @private
     */
  }, {
    key: '_setColor',
    value: function _setColor(rgba) {
      var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      // store the initial color
      if (setInitial === true) {
        this.initialColor = util.extend({}, rgba);
      }

      this.color = rgba;
      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);

      var angleConvert = 2 * Math.PI;
      var radius = this.r * hsv.s;
      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);

      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + 'px';
      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + 'px';

      this._updatePicker(rgba);
    }

    /**
     * bound to opacity control
     * @param value
     * @private
     */
  }, {
    key: '_setOpacity',
    value: function _setOpacity(value) {
      this.color.a = value / 100;
      this._updatePicker(this.color);
    }

    /**
     * bound to brightness control
     * @param value
     * @private
     */
  }, {
    key: '_setBrightness',
    value: function _setBrightness(value) {
      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.v = value / 100;
      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba;
      this._updatePicker();
    }

    /**
     * update the colorpicker. A black circle overlays the hue circle to mimic the brightness decreasing.
     * @param rgba
     * @private
     */
  }, {
    key: '_updatePicker',
    value: function _updatePicker() {
      var rgba = arguments.length <= 0 || arguments[0] === undefined ? this.color : arguments[0];

      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
      var ctx = this.colorPickerCanvas.getContext('2d');
      if (this.pixelRation === undefined) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }
      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

      // clear the canvas
      var w = this.colorPickerCanvas.clientWidth;
      var h = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h);

      ctx.putImageData(this.hueCircle, 0, 0);
      ctx.fillStyle = 'rgba(0,0,0,' + (1 - hsv.v) + ')';
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
      ctx.fill();

      this.brightnessRange.value = 100 * hsv.v;
      this.opacityRange.value = 100 * rgba.a;

      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }

    /**
     * used by create to set the size of the canvas.
     * @private
     */
  }, {
    key: '_setSize',
    value: function _setSize() {
      this.colorPickerCanvas.style.width = '100%';
      this.colorPickerCanvas.style.height = '100%';

      this.colorPickerCanvas.width = 289 * this.pixelRatio;
      this.colorPickerCanvas.height = 289 * this.pixelRatio;
    }

    /**
     * create all dom elements
     * TODO: cleanup, lots of similar dom elements
     * @private
     */
  }, {
    key: '_create',
    value: function _create() {
      this.frame = document.createElement('div');
      this.frame.className = 'vis-color-picker';

      this.colorPickerDiv = document.createElement('div');
      this.colorPickerSelector = document.createElement('div');
      this.colorPickerSelector.className = 'vis-selector';
      this.colorPickerDiv.appendChild(this.colorPickerSelector);

      this.colorPickerCanvas = document.createElement('canvas');
      this.colorPickerDiv.appendChild(this.colorPickerCanvas);

      if (!this.colorPickerCanvas.getContext) {
        var noCanvas = document.createElement('DIV');
        noCanvas.style.color = 'red';
        noCanvas.style.fontWeight = 'bold';
        noCanvas.style.padding = '10px';
        noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
        this.colorPickerCanvas.appendChild(noCanvas);
      } else {
        var ctx = this.colorPickerCanvas.getContext("2d");
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

        this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      }

      this.colorPickerDiv.className = 'vis-color';

      this.opacityDiv = document.createElement('div');
      this.opacityDiv.className = 'vis-opacity';

      this.brightnessDiv = document.createElement('div');
      this.brightnessDiv.className = 'vis-brightness';

      this.arrowDiv = document.createElement('div');
      this.arrowDiv.className = 'vis-arrow';

      this.opacityRange = document.createElement('input');
      try {
        this.opacityRange.type = 'range'; // Not supported on IE9
        this.opacityRange.min = '0';
        this.opacityRange.max = '100';
      } catch (err) {}
      this.opacityRange.value = '100';
      this.opacityRange.className = 'vis-range';

      this.brightnessRange = document.createElement('input');
      try {
        this.brightnessRange.type = 'range'; // Not supported on IE9
        this.brightnessRange.min = '0';
        this.brightnessRange.max = '100';
      } catch (err) {}
      this.brightnessRange.value = '100';
      this.brightnessRange.className = 'vis-range';

      this.opacityDiv.appendChild(this.opacityRange);
      this.brightnessDiv.appendChild(this.brightnessRange);

      var me = this;
      this.opacityRange.onchange = function () {
        me._setOpacity(this.value);
      };
      this.opacityRange.oninput = function () {
        me._setOpacity(this.value);
      };
      this.brightnessRange.onchange = function () {
        me._setBrightness(this.value);
      };
      this.brightnessRange.oninput = function () {
        me._setBrightness(this.value);
      };

      this.brightnessLabel = document.createElement("div");
      this.brightnessLabel.className = "vis-label vis-brightness";
      this.brightnessLabel.innerHTML = 'brightness:';

      this.opacityLabel = document.createElement("div");
      this.opacityLabel.className = "vis-label vis-opacity";
      this.opacityLabel.innerHTML = 'opacity:';

      this.newColorDiv = document.createElement("div");
      this.newColorDiv.className = "vis-new-color";
      this.newColorDiv.innerHTML = 'new';

      this.initialColorDiv = document.createElement("div");
      this.initialColorDiv.className = "vis-initial-color";
      this.initialColorDiv.innerHTML = 'initial';

      this.cancelButton = document.createElement("div");
      this.cancelButton.className = "vis-button vis-cancel";
      this.cancelButton.innerHTML = 'cancel';
      this.cancelButton.onclick = this._hide.bind(this, false);

      this.applyButton = document.createElement("div");
      this.applyButton.className = "vis-button vis-apply";
      this.applyButton.innerHTML = 'apply';
      this.applyButton.onclick = this._apply.bind(this);

      this.saveButton = document.createElement("div");
      this.saveButton.className = "vis-button vis-save";
      this.saveButton.innerHTML = 'save';
      this.saveButton.onclick = this._save.bind(this);

      this.loadButton = document.createElement("div");
      this.loadButton.className = "vis-button vis-load";
      this.loadButton.innerHTML = 'load last';
      this.loadButton.onclick = this._loadLast.bind(this);

      this.frame.appendChild(this.colorPickerDiv);
      this.frame.appendChild(this.arrowDiv);
      this.frame.appendChild(this.brightnessLabel);
      this.frame.appendChild(this.brightnessDiv);
      this.frame.appendChild(this.opacityLabel);
      this.frame.appendChild(this.opacityDiv);
      this.frame.appendChild(this.newColorDiv);
      this.frame.appendChild(this.initialColorDiv);

      this.frame.appendChild(this.cancelButton);
      this.frame.appendChild(this.applyButton);
      this.frame.appendChild(this.saveButton);
      this.frame.appendChild(this.loadButton);
    }

    /**
     * bind hammer to the color picker
     * @private
     */
  }, {
    key: '_bindHammer',
    value: function _bindHammer() {
      var _this = this;

      this.drag = {};
      this.pinch = {};
      this.hammer = new Hammer(this.colorPickerCanvas);
      this.hammer.get('pinch').set({ enable: true });

      hammerUtil.onTouch(this.hammer, function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('tap', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panstart', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panmove', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panend', function (event) {
        _this._moveSelector(event);
      });
    }

    /**
     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
     * @private
     */
  }, {
    key: '_generateHueCircle',
    value: function _generateHueCircle() {
      if (this.generated === false) {
        var ctx = this.colorPickerCanvas.getContext('2d');
        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

        // clear the canvas
        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h);

        // draw hue circle
        var x = undefined,
            y = undefined,
            hue = undefined,
            sat = undefined;
        this.centerCoordinates = { x: w * 0.5, y: h * 0.5 };
        this.r = 0.49 * w;
        var angleConvert = 2 * Math.PI / 360;
        var hfac = 1 / 360;
        var sfac = 1 / this.r;
        var rgb = undefined;
        for (hue = 0; hue < 360; hue++) {
          for (sat = 0; sat < this.r; sat++) {
            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
            rgb = util.HSVToRGB(hue * hfac, sat * sfac, 1);
            ctx.fillStyle = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
          }
        }
        ctx.strokeStyle = 'rgba(0,0,0,1)';
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.stroke();

        this.hueCircle = ctx.getImageData(0, 0, w, h);
      }
      this.generated = true;
    }

    /**
     * move the selector. This is called by hammer functions.
     *
     * @param event
     * @private
     */
  }, {
    key: '_moveSelector',
    value: function _moveSelector(event) {
      var rect = this.colorPickerDiv.getBoundingClientRect();
      var left = event.center.x - rect.left;
      var top = event.center.y - rect.top;

      var centerY = 0.5 * this.colorPickerDiv.clientHeight;
      var centerX = 0.5 * this.colorPickerDiv.clientWidth;

      var x = left - centerX;
      var y = top - centerY;

      var angle = Math.atan2(x, y);
      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);

      var newTop = Math.cos(angle) * radius + centerY;
      var newLeft = Math.sin(angle) * radius + centerX;

      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + 'px';
      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + 'px';

      // set color
      var h = angle / (2 * Math.PI);
      h = h < 0 ? h + 1 : h;
      var s = radius / this.r;
      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.h = h;
      hsv.s = s;
      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba;

      // update previews
      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }
  }]);

  return ColorPicker;
})();

exports['default'] = ColorPicker;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3NoYXJlZC9Db2xvclBpY2tlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDekMsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzFDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzs7SUFFeEIsV0FBVztBQUNKLFdBRFAsV0FBVyxHQUNhO1FBQWhCLFVBQVUseURBQUcsQ0FBQzs7MEJBRHRCLFdBQVc7O0FBRWIsUUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7QUFDN0IsUUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFDdkIsUUFBSSxDQUFDLGlCQUFpQixHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsR0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFDLEdBQUcsR0FBQyxDQUFDLEVBQUMsQ0FBQztBQUM1QyxRQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7QUFDcEIsUUFBSSxDQUFDLEtBQUssR0FBRyxFQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQztBQUN2QyxRQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztBQUMzQixRQUFJLENBQUMsWUFBWSxHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDO0FBQzlDLFFBQUksQ0FBQyxhQUFhLEdBQUUsU0FBUyxDQUFDO0FBQzlCLFFBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDOzs7QUFHckIsUUFBSSxDQUFDLGNBQWMsR0FBRyxZQUFNLEVBQUUsQ0FBQzs7O0FBRy9CLFFBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztHQUNoQjs7Ozs7OztlQWpCRyxXQUFXOztXQXdCUCxrQkFBQyxTQUFTLEVBQUU7QUFDbEIsVUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRTtBQUM3QixZQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ3RCLFlBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDO09BQ3pCO0FBQ0QsVUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7QUFDM0IsVUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3ZDLFVBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQzs7QUFFbkIsVUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0tBQ2pCOzs7Ozs7OztXQU1VLHFCQUFDLFFBQVEsRUFBRTtBQUNwQixVQUFJLE9BQU8sUUFBUSxLQUFLLFVBQVUsRUFBRTtBQUNsQyxZQUFJLENBQUMsY0FBYyxHQUFHLFFBQVEsQ0FBQztPQUNoQyxNQUNJO0FBQ0gsY0FBTSxJQUFJLEtBQUssQ0FBQyxzRUFBc0UsQ0FBQyxDQUFDO09BQ3pGO0tBQ0Y7OztXQUVhLHdCQUFDLEtBQUssRUFBRTtBQUNwQixVQUFJLFVBQVUsR0FBRyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxRQUFRLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxRQUFRLEVBQUUsU0FBUyxFQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUMsYUFBYSxFQUFFLFNBQVMsRUFBQyxpQkFBaUIsRUFBRSxTQUFTLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxXQUFXLEVBQUUsU0FBUyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxZQUFZLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsYUFBYSxFQUFFLFNBQVMsRUFBQyxXQUFXLEVBQUUsU0FBUyxFQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUMsYUFBYSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsYUFBYSxFQUFFLFNBQVMsRUFBQyxlQUFlLEVBQUUsU0FBUyxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUMsY0FBYyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUMsZ0JBQWdCLEVBQUUsU0FBUyxFQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsY0FBYyxFQUFFLFNBQVMsRUFBQyxlQUFlLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUMsT0FBTyxFQUFFLFNBQVMsRUFBQyxZQUFZLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsT0FBTyxFQUFFLFNBQVMsRUFBQyxXQUFXLEVBQUUsU0FBUyxFQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUMsWUFBWSxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLFlBQVksRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsV0FBVyxFQUFFLFNBQVMsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUMsUUFBUSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUMsYUFBYSxFQUFFLFNBQVMsRUFBQyxjQUFjLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLFlBQVksRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUMsZUFBZSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxHQUFHLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsYUFBYSxFQUFFLFNBQVMsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsUUFBUSxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUMsYUFBYSxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxRQUFRLEVBQUUsU0FBUyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFVBQVUs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ZSxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7S0FDdEk7OztTQTVnQkcsV0FBVzs7O3FCQStnQkYsV0FBVyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi9zaGFyZWQvQ29sb3JQaWNrZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgSGFtbWVyID0gcmVxdWlyZSgnLi4vbW9kdWxlL2hhbW1lcicpO1xubGV0IGhhbW1lclV0aWwgPSByZXF1aXJlKCcuLi9oYW1tZXJVdGlsJyk7XG5sZXQgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuY2xhc3MgQ29sb3JQaWNrZXIge1xuICBjb25zdHJ1Y3RvcihwaXhlbFJhdGlvID0gMSkge1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgdGhpcy5nZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNlbnRlckNvb3JkaW5hdGVzID0ge3g6Mjg5LzIsIHk6Mjg5LzJ9O1xuICAgIHRoaXMuciA9IDI4OSAqIDAuNDk7XG4gICAgdGhpcy5jb2xvciA9IHtyOjI1NSxnOjI1NSxiOjI1NSxhOjEuMH07XG4gICAgdGhpcy5odWVDaXJjbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbml0aWFsQ29sb3IgPSB7cjoyNTUsZzoyNTUsYjoyNTUsYToxLjB9O1xuICAgIHRoaXMucHJldmlvdXNDb2xvcj0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuXG4gICAgLy8gYm91bmQgYnlcbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gKCkgPT4ge307XG5cbiAgICAvLyBjcmVhdGUgYWxsIERPTSBlbGVtZW50c1xuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cblxuICAvKipcbiAgICogdGhpcyBpbnNlcnRzIHRoZSBjb2xvclBpY2tlciBpbnRvIGEgZGl2IGZyb20gdGhlIERPTVxuICAgKiBAcGFyYW0gY29udGFpbmVyXG4gICAqL1xuICBpbnNlcnRUbyhjb250YWluZXIpIHtcbiAgICBpZiAodGhpcy5oYW1tZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5oYW1tZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuICAgIHRoaXMuX2JpbmRIYW1tZXIoKTtcblxuICAgIHRoaXMuX3NldFNpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgb24gYXBwbHkgYW5kIHNhdmUuIEJpbmQgaXQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgc2V0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gYXR0ZW1wdGVkIHRvIHNldCBhcyBjb2xvclBpY2tlciBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuICB9XG5cbiAgX2lzQ29sb3JTdHJpbmcoY29sb3IpIHtcbiAgICB2YXIgaHRtbENvbG9ycyA9IHtibGFjazogJyMwMDAwMDAnLG5hdnk6ICcjMDAwMDgwJyxkYXJrYmx1ZTogJyMwMDAwOEInLG1lZGl1bWJsdWU6ICcjMDAwMENEJyxibHVlOiAnIzAwMDBGRicsZGFya2dyZWVuOiAnIzAwNjQwMCcsZ3JlZW46ICcjMDA4MDAwJyx0ZWFsOiAnIzAwODA4MCcsZGFya2N5YW46ICcjMDA4QjhCJyxkZWVwc2t5Ymx1ZTogJyMwMEJGRkYnLGRhcmt0dXJxdW9pc2U6ICcjMDBDRUQxJyxtZWRpdW1zcHJpbmdncmVlbjogJyMwMEZBOUEnLGxpbWU6ICcjMDBGRjAwJyxzcHJpbmdncmVlbjogJyMwMEZGN0YnLGFxdWE6ICcjMDBGRkZGJyxjeWFuOiAnIzAwRkZGRicsbWlkbmlnaHRibHVlOiAnIzE5MTk3MCcsZG9kZ2VyYmx1ZTogJyMxRTkwRkYnLGxpZ2h0c2VhZ3JlZW46ICcjMjBCMkFBJyxmb3Jlc3RncmVlbjogJyMyMjhCMjInLHNlYWdyZWVuOiAnIzJFOEI1NycsZGFya3NsYXRlZ3JheTogJyMyRjRGNEYnLGxpbWVncmVlbjogJyMzMkNEMzInLG1lZGl1bXNlYWdyZWVuOiAnIzNDQjM3MScsdHVycXVvaXNlOiAnIzQwRTBEMCcscm95YWxibHVlOiAnIzQxNjlFMScsc3RlZWxibHVlOiAnIzQ2ODJCNCcsZGFya3NsYXRlYmx1ZTogJyM0ODNEOEInLG1lZGl1bXR1cnF1b2lzZTogJyM0OEQxQ0MnLGluZGlnbzogJyM0QjAwODInLGRhcmtvbGl2ZWdyZWVuOiAnIzU1NkIyRicsY2FkZXRibHVlOiAnIzVGOUVBMCcsY29ybmZsb3dlcmJsdWU6ICcjNjQ5NUVEJyxtZWRpdW1hcXVhbWFyaW5lOiAnIzY2Q0RBQScsZGltZ3JheTogJyM2OTY5NjknLHNsYXRlYmx1ZTogJyM2QTVBQ0QnLG9saXZlZHJhYjogJyM2QjhFMjMnLHNsYXRlZ3JheTogJyM3MDgwOTAnLGxpZ2h0c2xhdGVncmF5OiAnIzc3ODg5OScsbWVkaXVtc2xhdGVibHVlOiAnIzdCNjhFRScsbGF3bmdyZWVuOiAnIzdDRkMwMCcsY2hhcnRyZXVzZTogJyM3RkZGMDAnLGFxdWFtYXJpbmU6ICcjN0ZGRkQ0JyxtYXJvb246ICcjODAwMDAwJyxwdXJwbGU6ICcjODAwMDgwJyxvbGl2ZTogJyM4MDgwMDAnLGdyYXk6ICcjODA4MDgwJyxza3libHVlOiAnIzg3Q0VFQicsbGlnaHRza3libHVlOiAnIzg3Q0VGQScsYmx1ZXZpb2xldDogJyM4QTJCRTInLGRhcmtyZWQ6ICcjOEIwMDAwJyxkYXJrbWFnZW50YTogJyM4QjAwOEInLHNhZGRsZWJyb3duOiAnIzhCNDUxMycsZGFya3NlYWdyZWVuOiAnIzhGQkM4RicsbGlnaHRncmVlbjogJyM5MEVFOTAnLG1lZGl1bXB1cnBsZTogJyM5MzcwRDgnLGRhcmt2aW9sZXQ6ICcjOTQwMEQzJyxwYWxlZ3JlZW46ICcjOThGQjk4JyxkYXJrb3JjaGlkOiAnIzk5MzJDQycseWVsbG93Z3JlZW46ICcjOUFDRDMyJyxzaWVubmE6ICcjQTA1MjJEJyxicm93bjogJyNBNTJBMkEnLGRhcmtncmF5OiAnI0E5QTlBOScsbGlnaHRibHVlOiAnI0FERDhFNicsZ3JlZW55ZWxsb3c6ICcjQURGRjJGJyxwYWxldHVycXVvaXNlOiAnI0FGRUVFRScsbGlnaHRzdGVlbGJsdWU6ICcjQjBDNERFJyxwb3dkZXJibHVlOiAnI0IwRTBFNicsZmlyZWJyaWNrOiAnI0IyMjIyMicsZGFya2dvbGRlbnJvZDogJyNCODg2MEInLG1lZGl1bW9yY2hpZDogJyNCQTU1RDMnLHJvc3licm93bjogJyNCQzhGOEYnLGRhcmtraGFraTogJyNCREI3NkInLHNpbHZlcjogJyNDMEMwQzAnLG1lZGl1bXZpb2xldHJlZDogJyNDNzE1ODUnLGluZGlhbnJlZDogJyNDRDVDNUMnLHBlcnU6ICcjQ0Q4NTNGJyxjaG9jb2xhdGU6ICcjRDI2OTFFJyx0YW46ICcjRDJCNDhDJyxsaWdodGdyZXk6ICcjRDNEM0QzJyxwYWxldmlvbGV0cmVkOiAnI0Q4NzA5MycsdGhpc3RsZTogJyNEOEJGRDgnLG9yY2hpZDogJyNEQTcwRDYnLGdvbGRlbnJvZDogJyNEQUE1MjAnLGNyaW1zb246ICcjREMxNDNDJyxnYWluc2Jvcm86ICcjRENEQ0RDJyxwbHVtOiAnI0REQTBERCcsYnVybHl3b29kOiAnI0RFQjg4NycsbGlnaHRjeWFuOiAnI0UwRkZGRicsbGF2ZW5kZXI6ICcjRTZFNkZBJyxkYXJrc2FsbW9uOiAnI0U5OTY3QScsdmlvbGV0OiAnI0VFODJFRScscGFsZWdvbGRlbnJvZDogJyNFRUU4QUEnLGxpZ2h0Y29yYWw6ICcjRjA4MDgwJyxraGFraTogJyNGMEU2OEMnLGFsaWNlYmx1ZTogJyNGMEY4RkYnLGhvbmV5ZGV3OiAnI0YwRkZGMCcsYXp1cmU6ICcjRjBGRkZGJyxzYW5keWJyb3duOiAnI0Y0QTQ2MCcsd2hlYXQ6ICcjRjVERUIzJyxiZWlnZTogJyNGNUY1REMnLHdoaXRlc21va2U6ICcjRjVGNUY1JyxtaW50Y3JlYW06ICcjRjVGRkZBJyxnaG9zdHdoaXRlOiAnI0Y4RjhGRicsc2FsbW9uOiAnI0ZBODA3MicsYW50aXF1ZXdoaXRlOiAnI0ZBRUJENycsbGluZW46ICcjRkFGMEU2JyxsaWdodGdvbGRlbnJvZHllbGxvdzogJyNGQUZBRDInLG9sZGxhY2U6ICcjRkRGNUU2JyxyZWQ6ICcjRkYwMDAwJyxmdWNoc2lhOiAnI0ZGMDBGRicsbWFnZW50YTogJyNGRjAwRkYnLGRlZXBwaW5rOiAnI0ZGMTQ5Mycsb3JhbmdlcmVkOiAnI0ZGNDUwMCcsdG9tYXRvOiAnI0ZGNjM0NycsaG90cGluazogJyNGRjY5QjQnLGNvcmFsOiAnI0ZGN0Y1MCcsZGFya29yYW5nZTogJyNGRjhDMDAnLGxpZ2h0c2FsbW9uOiAnI0ZGQTA3QScsb3JhbmdlOiAnI0ZGQTUwMCcsbGlnaHRwaW5rOiAnI0ZGQjZDMScscGluazogJyNGRkMwQ0InLGdvbGQ6ICcjRkZENzAwJyxwZWFjaHB1ZmY6ICcjRkZEQUI5JyxuYXZham93aGl0ZTogJyNGRkRFQUQnLG1vY2Nhc2luOiAnI0ZGRTRCNScsYmlzcXVlOiAnI0ZGRTRDNCcsbWlzdHlyb3NlOiAnI0ZGRTRFMScsYmxhbmNoZWRhbG1vbmQ6ICcjRkZFQkNEJyxwYXBheWF3aGlwOiAnI0ZGRUZENScsbGF2ZW5kZXJibHVzaDogJyNGRkYwRjUnLHNlYXNoZWxsOiAnI0ZGRjVFRScsY29ybnNpbGs6ICcjRkZGOERDJyxsZW1vbmNoaWZmb246ICcjRkZGQUNEJyxmbG9yYWx3aGl0ZTogJyNGRkZBRjAnLHNub3c6ICcjRkZGQUZBJyx5ZWxsb3c6ICcjRkZGRjAwJyxsaWdodHllbGxvdzogJyNGRkZGRTAnLGl2b3J5OiAnI0ZGRkZGMCcsd2hpdGU6ICcjRkZGRkZGJ307XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBodG1sQ29sb3JzW2NvbG9yXTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbG9yIG9mIHRoZSBjb2xvclBpY2tlclxuICAgKiBTdXBwb3J0ZWQgZm9ybWF0czpcbiAgICogJ3JlZCcgICAgICAgICAgICAgICAgICAgLS0+IEhUTUwgY29sb3Igc3RyaW5nXG4gICAqICcjZmZmZmZmJyAgICAgICAgICAgICAgIC0tPiBoZXggc3RyaW5nXG4gICAqICdyYmcoMjU1LDI1NSwyNTUpJyAgICAgIC0tPiByZ2Igc3RyaW5nXG4gICAqICdyZ2JhKDI1NSwyNTUsMjU1LDEuMCknIC0tPiByZ2JhIHN0cmluZ1xuICAgKiB7cjoyNTUsZzoyNTUsYjoyNTV9ICAgICAtLT4gcmdiIG9iamVjdFxuICAgKiB7cjoyNTUsZzoyNTUsYjoyNTUsYToxLjB9IC0tPiByZ2JhIG9iamVjdFxuICAgKiBAcGFyYW0gY29sb3JcbiAgICogQHBhcmFtIHNldEluaXRpYWxcbiAgICovXG4gIHNldENvbG9yKGNvbG9yLCBzZXRJbml0aWFsID0gdHJ1ZSkge1xuICAgIGlmIChjb2xvciA9PT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHJnYmE7XG5cbiAgICAvLyBpZiBhIGh0bWwgY29sb3Igc2hvcnRoYW5kIGlzIHVzZWQsIGNvbnZlcnQgdG8gaGV4XG4gICAgdmFyIGh0bWxDb2xvciA9IHRoaXMuX2lzQ29sb3JTdHJpbmcoY29sb3IpO1xuICAgIGlmIChodG1sQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29sb3IgPSBodG1sQ29sb3I7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9ybWF0XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICBpZiAodXRpbC5pc1ZhbGlkUkdCKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICBsZXQgcmdiYUFycmF5ID0gY29sb3Iuc3Vic3RyKDQpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA1KS5zcGxpdCgnLCcpO1xuICAgICAgICByZ2JhID0ge3I6cmdiYUFycmF5WzBdLCBnOnJnYmFBcnJheVsxXSwgYjpyZ2JhQXJyYXlbMl0sIGE6MS4wfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHV0aWwuaXNWYWxpZFJHQkEoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgIGxldCByZ2JhQXJyYXkgPSBjb2xvci5zdWJzdHIoNSkuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDYpLnNwbGl0KCcsJyk7XG4gICAgICAgIHJnYmEgPSB7cjpyZ2JhQXJyYXlbMF0sIGc6cmdiYUFycmF5WzFdLCBiOnJnYmFBcnJheVsyXSwgYTpyZ2JhQXJyYXlbM119O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodXRpbC5pc1ZhbGlkSGV4KGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICBsZXQgcmdiT2JqID0gdXRpbC5oZXhUb1JHQihjb2xvcik7XG4gICAgICAgIHJnYmEgPSB7cjpyZ2JPYmouciwgZzpyZ2JPYmouZywgYjpyZ2JPYmouYiwgYToxLjB9O1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBpZiAoY29sb3IuciAhPT0gdW5kZWZpbmVkICYmIGNvbG9yLmcgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5iICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsZXQgYWxwaGEgPSBjb2xvci5hICE9PSB1bmRlZmluZWQgPyBjb2xvci5hIDogJzEuMCc7XG4gICAgICAgICAgcmdiYSA9IHtyOmNvbG9yLnIsIGc6Y29sb3IuZywgYjpjb2xvci5iLCBhOmFscGhhfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCBjb2xvclxuICAgIGlmIChyZ2JhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29sb3IgcGFzc2VkIHRvIHRoZSBjb2xvclBpY2tlci4gU3VwcG9ydGVkIGFyZSBzdHJpbmdzOiByZ2IsIGhleCwgcmdiYS4gT2JqZWN0OiByZ2IgKHtyOnIsZzpnLGI6YixbYTphXX0pLiBTdXBwbGllZDogXCIgKyBKU09OLnN0cmluZ2lmeShjb2xvcikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3NldENvbG9yKHJnYmEsIHNldEluaXRpYWwpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIHRoaXMgc2hvd3MgdGhlIGNvbG9yIHBpY2tlciBhdCBhIGxvY2F0aW9uLiBUaGUgaHVlIGNpcmNsZSBpcyBjb25zdHJ1Y3RlZCBvbmNlIGFuZCBzdG9yZWQuXG4gICAqIEBwYXJhbSB4XG4gICAqIEBwYXJhbSB5XG4gICAqL1xuICBzaG93KHgseSkge1xuICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuICAgIHRoaXMuZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgdGhpcy5mcmFtZS5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICB0aGlzLl9nZW5lcmF0ZUh1ZUNpcmNsZSgpO1xuICB9XG5cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFJJVkFURSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBwaWNrZXIuIElzIGNhbGxlZCBieSB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICogT3B0aW9uYWwgYm9vbGVhbiB0byBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIGVhc3kgYWNjZXNzIGxhdGVyIG9uLlxuICAgKiBAcGFyYW0gc3RvcmVQcmV2aW91c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hpZGUoc3RvcmVQcmV2aW91cyA9IHRydWUpIHtcbiAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIG5leHQgdGltZTtcbiAgICBpZiAoc3RvcmVQcmV2aW91cyA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5wcmV2aW91c0NvbG9yID0gdXRpbC5leHRlbmQoe30sIHRoaXMuY29sb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFwcGxpZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5pbml0aWFsQ29sb3IpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGJvdW5kIHRvIHRoZSBzYXZlIGJ1dHRvbi4gU2F2ZXMgYW5kIGhpZGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NhdmUoKSB7XG4gICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmNvbG9yKTtcbiAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9oaWRlKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBCb3VuZCB0byBhcHBseSBidXR0b24uIFNhdmVzIGJ1dCBkb2VzIG5vdCBjbG9zZS4gSXMgdW5kb25lIGJ5IHRoZSBjYW5jZWwgYnV0dG9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5KCkge1xuICAgIHRoaXMuYXBwbGllZCA9IHRydWU7XG4gICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmNvbG9yKTtcbiAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBsb2FkIHRoZSBjb2xvciBmcm9tIHRoZSBwcmV2aW91cyBzZXNzaW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2xvYWRMYXN0KCkge1xuICAgIGlmICh0aGlzLnByZXZpb3VzQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRDb2xvcih0aGlzLnByZXZpb3VzQ29sb3IsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhbGVydChcIlRoZXJlIGlzIG5vIGxhc3QgY29sb3IgdG8gbG9hZC4uLlwiKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBzZXQgdGhlIGNvbG9yLCBwbGFjZSB0aGUgcGlja2VyXG4gICAqIEBwYXJhbSByZ2JhXG4gICAqIEBwYXJhbSBzZXRJbml0aWFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0Q29sb3IocmdiYSwgc2V0SW5pdGlhbCA9IHRydWUpIHtcbiAgICAvLyBzdG9yZSB0aGUgaW5pdGlhbCBjb2xvclxuICAgIGlmIChzZXRJbml0aWFsID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmluaXRpYWxDb2xvciA9IHV0aWwuZXh0ZW5kKHt9LCByZ2JhKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbG9yID0gcmdiYTtcbiAgICBsZXQgaHN2ID0gdXRpbC5SR0JUb0hTVihyZ2JhLnIsIHJnYmEuZywgcmdiYS5iKTtcblxuICAgIGxldCBhbmdsZUNvbnZlcnQgPSAyICogTWF0aC5QSTtcbiAgICBsZXQgcmFkaXVzID0gdGhpcy5yICogaHN2LnM7XG4gICAgbGV0IHggPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnggKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZUNvbnZlcnQgKiBoc3YuaCk7XG4gICAgbGV0IHkgPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkgKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUNvbnZlcnQgKiBoc3YuaCk7XG5cbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IHggLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyAncHgnO1xuICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS50b3AgPSB5IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudEhlaWdodCArICdweCc7XG5cbiAgICB0aGlzLl91cGRhdGVQaWNrZXIocmdiYSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBib3VuZCB0byBvcGFjaXR5IGNvbnRyb2xcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0T3BhY2l0eSh2YWx1ZSkge1xuICAgIHRoaXMuY29sb3IuYSA9IHZhbHVlIC8gMTAwO1xuICAgIHRoaXMuX3VwZGF0ZVBpY2tlcih0aGlzLmNvbG9yKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGJvdW5kIHRvIGJyaWdodG5lc3MgY29udHJvbFxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRCcmlnaHRuZXNzKHZhbHVlKSB7XG4gICAgbGV0IGhzdiA9IHV0aWwuUkdCVG9IU1YodGhpcy5jb2xvci5yLCB0aGlzLmNvbG9yLmcsIHRoaXMuY29sb3IuYik7XG4gICAgaHN2LnYgPSB2YWx1ZSAvIDEwMDtcbiAgICBsZXQgcmdiYSA9IHV0aWwuSFNWVG9SR0IoaHN2LmgsIGhzdi5zLCBoc3Yudik7XG4gICAgcmdiYVsnYSddID0gdGhpcy5jb2xvci5hO1xuICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuICAgIHRoaXMuX3VwZGF0ZVBpY2tlcigpO1xuICB9XG5cblxuICAvKipcbiAgICogdXBkYXRlIHRoZSBjb2xvcnBpY2tlci4gQSBibGFjayBjaXJjbGUgb3ZlcmxheXMgdGhlIGh1ZSBjaXJjbGUgdG8gbWltaWMgdGhlIGJyaWdodG5lc3MgZGVjcmVhc2luZy5cbiAgICogQHBhcmFtIHJnYmFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVQaWNrZXIocmdiYSA9IHRoaXMuY29sb3IpIHtcbiAgICBsZXQgaHN2ID0gdXRpbC5SR0JUb0hTVihyZ2JhLnIsIHJnYmEuZywgcmdiYS5iKTtcbiAgICBsZXQgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgfVxuICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuXG4gICAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICAgIGxldCB3ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICBsZXQgaCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICBjdHgucHV0SW1hZ2VEYXRhKHRoaXMuaHVlQ2lyY2xlLCAwLDApO1xuICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwnICsgKDEtIGhzdi52KSArICcpJztcbiAgICBjdHguY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCwgdGhpcy5jZW50ZXJDb29yZGluYXRlcy55LCB0aGlzLnIpO1xuICAgIGN0eC5maWxsKCk7XG5cbiAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS52YWx1ZSA9IDEwMCAqIGhzdi52O1xuICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlICAgID0gMTAwICogcmdiYS5hO1xuXG4gICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuaW5pdGlhbENvbG9yLnIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5nICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuYiArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmEgKyAnKSc7XG4gICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5jb2xvci5yICsgJywnICsgdGhpcy5jb2xvci5nICsgJywnICsgdGhpcy5jb2xvci5iICsgJywnICsgdGhpcy5jb2xvci5hICsgJyknO1xuICB9XG5cblxuICAvKipcbiAgICogdXNlZCBieSBjcmVhdGUgdG8gc2V0IHRoZSBzaXplIG9mIHRoZSBjYW52YXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U2l6ZSgpIHtcbiAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy53aWR0aCA9IDI4OSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmhlaWdodCA9IDI4OSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhbGwgZG9tIGVsZW1lbnRzXG4gICAqIFRPRE86IGNsZWFudXAsIGxvdHMgb2Ygc2ltaWxhciBkb20gZWxlbWVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGUoKSB7XG4gICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1jb2xvci1waWNrZXInO1xuXG4gICAgdGhpcy5jb2xvclBpY2tlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGFzc05hbWUgPSAndmlzLXNlbGVjdG9yJztcbiAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvcik7XG5cbiAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5jb2xvclBpY2tlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyQ2FudmFzKTtcblxuICAgIGlmICghdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICBsZXQgbm9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnRElWJyApO1xuICAgICAgbm9DYW52YXMuc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgIG5vQ2FudmFzLnN0eWxlLmZvbnRXZWlnaHQgPSAgJ2JvbGQnIDtcbiAgICAgIG5vQ2FudmFzLnN0eWxlLnBhZGRpbmcgPSAgJzEwcHgnO1xuICAgICAgbm9DYW52YXMuaW5uZXJIVE1MID0gICdFcnJvcjogeW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgSFRNTCBjYW52YXMnO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5hcHBlbmRDaGlsZChub0NhbnZhcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbGV0IGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcblxuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmNsYXNzTmFtZSA9ICd2aXMtY29sb3InO1xuXG4gICAgdGhpcy5vcGFjaXR5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vcGFjaXR5RGl2LmNsYXNzTmFtZSA9ICd2aXMtb3BhY2l0eSc7XG5cbiAgICB0aGlzLmJyaWdodG5lc3NEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmJyaWdodG5lc3NEaXYuY2xhc3NOYW1lID0gJ3Zpcy1icmlnaHRuZXNzJztcblxuICAgIHRoaXMuYXJyb3dEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmFycm93RGl2LmNsYXNzTmFtZSA9ICd2aXMtYXJyb3cnO1xuXG4gICAgdGhpcy5vcGFjaXR5UmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm1pbiA9ICcwJztcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm1heCA9ICcxMDAnO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7fVxuICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlID0gJzEwMCc7XG4gICAgdGhpcy5vcGFjaXR5UmFuZ2UuY2xhc3NOYW1lID0gJ3Zpcy1yYW5nZSc7XG5cbiAgICB0aGlzLmJyaWdodG5lc3NSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnR5cGUgPSAncmFuZ2UnOyAvLyBOb3Qgc3VwcG9ydGVkIG9uIElFOVxuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UubWluID0gJzAnO1xuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UubWF4ID0gJzEwMCc7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHt9XG4gICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAnMTAwJztcbiAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5jbGFzc05hbWUgPSAndmlzLXJhbmdlJztcblxuICAgIHRoaXMub3BhY2l0eURpdi5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlSYW5nZSk7XG4gICAgdGhpcy5icmlnaHRuZXNzRGl2LmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc1JhbmdlKTtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7bWUuX3NldE9wYWNpdHkodGhpcy52YWx1ZSk7fTtcbiAgICB0aGlzLm9wYWNpdHlSYW5nZS5vbmlucHV0ICA9IGZ1bmN0aW9uICgpIHttZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTt9O1xuICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge21lLl9zZXRCcmlnaHRuZXNzKHRoaXMudmFsdWUpO307XG4gICAgdGhpcy5icmlnaHRuZXNzUmFuZ2Uub25pbnB1dCAgPSBmdW5jdGlvbiAoKSB7bWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7fTtcblxuICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5jbGFzc05hbWUgPSBcInZpcy1sYWJlbCB2aXMtYnJpZ2h0bmVzc1wiO1xuICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsLmlubmVySFRNTCA9ICdicmlnaHRuZXNzOic7XG5cbiAgICB0aGlzLm9wYWNpdHlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5vcGFjaXR5TGFiZWwuY2xhc3NOYW1lID0gXCJ2aXMtbGFiZWwgdmlzLW9wYWNpdHlcIjtcbiAgICB0aGlzLm9wYWNpdHlMYWJlbC5pbm5lckhUTUwgPSAnb3BhY2l0eTonO1xuXG4gICAgdGhpcy5uZXdDb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5uZXdDb2xvckRpdi5jbGFzc05hbWUgPSBcInZpcy1uZXctY29sb3JcIjtcbiAgICB0aGlzLm5ld0NvbG9yRGl2LmlubmVySFRNTCA9ICduZXcnO1xuXG4gICAgdGhpcy5pbml0aWFsQ29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LmNsYXNzTmFtZSA9IFwidmlzLWluaXRpYWwtY29sb3JcIjtcbiAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5pbm5lckhUTUwgPSAnaW5pdGlhbCc7XG5cbiAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1jYW5jZWxcIjtcbiAgICB0aGlzLmNhbmNlbEJ1dHRvbi5pbm5lckhUTUwgPSAnY2FuY2VsJztcbiAgICB0aGlzLmNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gdGhpcy5faGlkZS5iaW5kKHRoaXMsIGZhbHNlKTtcblxuICAgIHRoaXMuYXBwbHlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuYXBwbHlCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1hcHBseVwiO1xuICAgIHRoaXMuYXBwbHlCdXR0b24uaW5uZXJIVE1MID0gJ2FwcGx5JztcbiAgICB0aGlzLmFwcGx5QnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9hcHBseS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5zYXZlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLnNhdmVCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1zYXZlXCI7XG4gICAgdGhpcy5zYXZlQnV0dG9uLmlubmVySFRNTCA9ICdzYXZlJztcbiAgICB0aGlzLnNhdmVCdXR0b24ub25jbGljayA9IHRoaXMuX3NhdmUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMubG9hZEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5sb2FkQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtbG9hZFwiO1xuICAgIHRoaXMubG9hZEJ1dHRvbi5pbm5lckhUTUwgPSAnbG9hZCBsYXN0JztcbiAgICB0aGlzLmxvYWRCdXR0b24ub25jbGljayA9IHRoaXMuX2xvYWRMYXN0LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJEaXYpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd0Rpdik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NMYWJlbCk7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NEaXYpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5TGFiZWwpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5RGl2KTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubmV3Q29sb3JEaXYpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5pbml0aWFsQ29sb3JEaXYpO1xuXG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNhbmNlbEJ1dHRvbik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmFwcGx5QnV0dG9uKTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuc2F2ZUJ1dHRvbik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmxvYWRCdXR0b24pO1xuICB9XG5cblxuICAvKipcbiAgICogYmluZCBoYW1tZXIgdG8gdGhlIGNvbG9yIHBpY2tlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2JpbmRIYW1tZXIoKSB7XG4gICAgdGhpcy5kcmFnID0ge307XG4gICAgdGhpcy5waW5jaCA9IHt9O1xuICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmNvbG9yUGlja2VyQ2FudmFzKTtcbiAgICB0aGlzLmhhbW1lci5nZXQoJ3BpbmNoJykuc2V0KHtlbmFibGU6IHRydWV9KTtcblxuICAgIGhhbW1lclV0aWwub25Ub3VjaCh0aGlzLmhhbW1lciwgKGV2ZW50KSA9PiB7dGhpcy5fbW92ZVNlbGVjdG9yKGV2ZW50KX0pO1xuICAgIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCAgICAgICAoZXZlbnQpID0+IHt0aGlzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpfSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3BhbnN0YXJ0JywgIChldmVudCkgPT4ge3RoaXMuX21vdmVTZWxlY3RvcihldmVudCl9KTtcbiAgICB0aGlzLmhhbW1lci5vbigncGFubW92ZScsICAgKGV2ZW50KSA9PiB7dGhpcy5fbW92ZVNlbGVjdG9yKGV2ZW50KX0pO1xuICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCAgICAoZXZlbnQpID0+IHt0aGlzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBnZW5lcmF0ZSB0aGUgaHVlIGNpcmNsZS4gVGhpcyBpcyByZWxhdGl2ZWx5IGhlYXZ5ICgyMDBtcykgYW5kIGlzIGRvbmUgb25seSBvbmNlIG9uIHRoZSBmaXJzdCB0aW1lIGl0IGlzIHNob3duLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dlbmVyYXRlSHVlQ2lyY2xlKCkge1xuICAgIGlmICh0aGlzLmdlbmVyYXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGxldCBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAodGhpcy5waXhlbFJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICAgIH1cbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuXG4gICAgICAvLyBjbGVhciB0aGUgY2FudmFzXG4gICAgICBsZXQgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICBsZXQgaCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcblxuXG4gICAgICAvLyBkcmF3IGh1ZSBjaXJjbGVcbiAgICAgIGxldCB4LCB5LCBodWUsIHNhdDtcbiAgICAgIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMgPSB7eDogdyAqIDAuNSwgeTogaCAqIDAuNX07XG4gICAgICB0aGlzLnIgPSAwLjQ5ICogdztcbiAgICAgIGxldCBhbmdsZUNvbnZlcnQgPSAoMiAqIE1hdGguUEkpIC8gMzYwO1xuICAgICAgbGV0IGhmYWMgPSAxIC8gMzYwO1xuICAgICAgbGV0IHNmYWMgPSAxIC8gdGhpcy5yO1xuICAgICAgbGV0IHJnYjtcbiAgICAgIGZvciAoaHVlID0gMDsgaHVlIDwgMzYwOyBodWUrKykge1xuICAgICAgICBmb3IgKHNhdCA9IDA7IHNhdCA8IHRoaXMucjsgc2F0KyspIHtcbiAgICAgICAgICB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgc2F0ICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHVlKTtcbiAgICAgICAgICB5ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy55ICsgc2F0ICogTWF0aC5jb3MoYW5nbGVDb252ZXJ0ICogaHVlKTtcbiAgICAgICAgICByZ2IgPSB1dGlsLkhTVlRvUkdCKGh1ZSAqIGhmYWMsIHNhdCAqIHNmYWMsIDEpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKCcgKyByZ2IuciArICcsJyArIHJnYi5nICsgJywnICsgcmdiLmIgKyAnKSc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHggLSAwLjUsIHkgLSAwLjUsIDIsIDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwxKSc7XG4gICAgICBjdHguY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCwgdGhpcy5jZW50ZXJDb29yZGluYXRlcy55LCB0aGlzLnIpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICB0aGlzLmh1ZUNpcmNsZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwwLHcsaCk7XG4gICAgfVxuICAgIHRoaXMuZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIG1vdmUgdGhlIHNlbGVjdG9yLiBUaGlzIGlzIGNhbGxlZCBieSBoYW1tZXIgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb3ZlU2VsZWN0b3IoZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IHRoaXMuY29sb3JQaWNrZXJEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGxlZnQgPSBldmVudC5jZW50ZXIueCAtIHJlY3QubGVmdDtcbiAgICBsZXQgdG9wID0gZXZlbnQuY2VudGVyLnkgLSByZWN0LnRvcDtcblxuICAgIGxldCBjZW50ZXJZID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRIZWlnaHQ7XG4gICAgbGV0IGNlbnRlclggPSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyRGl2LmNsaWVudFdpZHRoO1xuXG4gICAgbGV0IHggPSBsZWZ0IC0gY2VudGVyWDtcbiAgICBsZXQgeSA9IHRvcCAtIGNlbnRlclk7XG5cbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHgseSk7XG4gICAgbGV0IHJhZGl1cyA9IDAuOTggKiBNYXRoLm1pbihNYXRoLnNxcnQoeCAqIHggKyB5ICogeSksIGNlbnRlclgpO1xuXG4gICAgbGV0IG5ld1RvcCA9IE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyArIGNlbnRlclk7XG4gICAgbGV0IG5ld0xlZnQgPSBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJYO1xuXG4gICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLnRvcCA9IG5ld1RvcCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyAncHgnO1xuICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS5sZWZ0ID0gbmV3TGVmdCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCArICdweCc7XG5cbiAgICAvLyBzZXQgY29sb3JcbiAgICBsZXQgaCA9IGFuZ2xlIC8gKDIgKiBNYXRoLlBJKTtcbiAgICBoID0gaCA8IDAgPyBoICsgMSA6IGg7XG4gICAgbGV0IHMgPSByYWRpdXMgLyB0aGlzLnI7XG4gICAgbGV0IGhzdiA9IHV0aWwuUkdCVG9IU1YodGhpcy5jb2xvci5yLCB0aGlzLmNvbG9yLmcsIHRoaXMuY29sb3IuYik7XG4gICAgaHN2LmggPSBoO1xuICAgIGhzdi5zID0gcztcbiAgICBsZXQgcmdiYSA9IHV0aWwuSFNWVG9SR0IoaHN2LmgsIGhzdi5zLCBoc3Yudik7XG4gICAgcmdiYVsnYSddID0gdGhpcy5jb2xvci5hO1xuICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuXG4gICAgLy8gdXBkYXRlIHByZXZpZXdzXG4gICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuaW5pdGlhbENvbG9yLnIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5nICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuYiArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmEgKyAnKSc7XG4gICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5jb2xvci5yICsgJywnICsgdGhpcy5jb2xvci5nICsgJywnICsgdGhpcy5jb2xvci5iICsgJywnICsgdGhpcy5jb2xvci5hICsgJyknO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbG9yUGlja2VyOyJdfQ==
},{"../hammerUtil":18,"../module/hammer":19,"../util":46}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _ColorPicker = require('./ColorPicker');

var _ColorPicker2 = _interopRequireDefault(_ColorPicker);

/**
 * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
 * Boolean options are recognised as Boolean
 * Number options should be written as array: [default value, min value, max value, stepsize]
 * Colors should be written as array: ['color', '#ffffff']
 * Strings with should be written as array: [option1, option2, option3, ..]
 *
 * The options are matched with their counterparts in each of the modules and the values used in the configuration are
 *
 * @param parentModule        | the location where parentModule.setOptions() can be called
 * @param defaultContainer    | the default container of the module
 * @param configureOptions    | the fully configured and predefined options set found in allOptions.js
 * @param pixelRatio          | canvas pixel ratio
 */
var util = require('../util');

var Configurator = (function () {
  function Configurator(parentModule, defaultContainer, configureOptions) {
    var pixelRatio = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];

    _classCallCheck(this, Configurator);

    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;

    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: undefined,
      showButton: true
    };
    util.extend(this.options, this.defaultOptions);

    this.configureOptions = configureOptions;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new _ColorPicker2['default'](pixelRatio);
    this.wrapper = undefined;
  }

  /**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   *
   * @param options
   */

  _createClass(Configurator, [{
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        // reset the popup history because the indices may have been changed.
        this.popupHistory = {};
        this._removePopup();

        var enabled = true;
        if (typeof options === 'string') {
          this.options.filter = options;
        } else if (options instanceof Array) {
          this.options.filter = options.join();
        } else if (typeof options === 'object') {
          if (options.container !== undefined) {
            this.options.container = options.container;
          }
          if (options.filter !== undefined) {
            this.options.filter = options.filter;
          }
          if (options.showButton !== undefined) {
            this.options.showButton = options.showButton;
          }
          if (options.enabled !== undefined) {
            enabled = options.enabled;
          }
        } else if (typeof options === 'boolean') {
          this.options.filter = true;
          enabled = options;
        } else if (typeof options === 'function') {
          this.options.filter = options;
          enabled = true;
        }
        if (this.options.filter === false) {
          enabled = false;
        }

        this.options.enabled = enabled;
      }
      this._clean();
    }
  }, {
    key: 'setModuleOptions',
    value: function setModuleOptions(moduleOptions) {
      this.moduleOptions = moduleOptions;
      if (this.options.enabled === true) {
        this._clean();
        if (this.options.container !== undefined) {
          this.container = this.options.container;
        }
        this._create();
      }
    }

    /**
     * Create all DOM elements
     * @private
     */
  }, {
    key: '_create',
    value: function _create() {
      var _this = this;

      this._clean();
      this.changedOptions = [];

      var filter = this.options.filter;
      var counter = 0;
      var show = false;
      for (var option in this.configureOptions) {
        if (this.configureOptions.hasOwnProperty(option)) {
          this.allowCreation = false;
          show = false;
          if (typeof filter === 'function') {
            show = filter(option, []);
            show = show || this._handleObject(this.configureOptions[option], [option], true);
          } else if (filter === true || filter.indexOf(option) !== -1) {
            show = true;
          }

          if (show !== false) {
            this.allowCreation = true;

            // linebreak between categories
            if (counter > 0) {
              this._makeItem([]);
            }
            // a header for the category
            this._makeHeader(option);

            // get the suboptions
            this._handleObject(this.configureOptions[option], [option]);
          }
          counter++;
        }
      }

      if (this.options.showButton === true) {
        (function () {
          var generateButton = document.createElement('div');
          generateButton.className = 'vis-configuration vis-config-button';
          generateButton.innerHTML = 'generate options';
          generateButton.onclick = function () {
            _this._printOptions();
          };
          generateButton.onmouseover = function () {
            generateButton.className = 'vis-configuration vis-config-button hover';
          };
          generateButton.onmouseout = function () {
            generateButton.className = 'vis-configuration vis-config-button';
          };

          _this.optionsContainer = document.createElement('div');
          _this.optionsContainer.className = 'vis-configuration vis-config-option-container';

          _this.domElements.push(_this.optionsContainer);
          _this.domElements.push(generateButton);
        })();
      }

      this._push();
      this.colorPicker.insertTo(this.container);
    }

    /**
     * draw all DOM elements on the screen
     * @private
     */
  }, {
    key: '_push',
    value: function _push() {
      this.wrapper = document.createElement('div');
      this.wrapper.className = 'vis-configuration-wrapper';
      this.container.appendChild(this.wrapper);
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.appendChild(this.domElements[i]);
      }

      this._showPopupIfNeeded();
    }

    /**
     * delete all DOM elements
     * @private
     */
  }, {
    key: '_clean',
    value: function _clean() {
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.removeChild(this.domElements[i]);
      }

      if (this.wrapper !== undefined) {
        this.container.removeChild(this.wrapper);
        this.wrapper = undefined;
      }
      this.domElements = [];

      this._removePopup();
    }

    /**
     * get the value from the actualOptions if it exists
     * @param {array} path    | where to look for the actual option
     * @returns {*}
     * @private
     */
  }, {
    key: '_getValue',
    value: function _getValue(path) {
      var base = this.moduleOptions;
      for (var i = 0; i < path.length; i++) {
        if (base[path[i]] !== undefined) {
          base = base[path[i]];
        } else {
          base = undefined;
          break;
        }
      }
      return base;
    }

    /**
     * all option elements are wrapped in an item
     * @param path
     * @param domElements
     * @private
     */
  }, {
    key: '_makeItem',
    value: function _makeItem(path) {
      var _arguments = arguments,
          _this2 = this;

      if (this.allowCreation === true) {
        var _len, domElements, _key;

        var _ret2 = (function () {
          var item = document.createElement('div');
          item.className = 'vis-configuration vis-config-item vis-config-s' + path.length;

          for (_len = _arguments.length, domElements = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            domElements[_key - 1] = _arguments[_key];
          }

          domElements.forEach(function (element) {
            item.appendChild(element);
          });
          _this2.domElements.push(item);
          return {
            v: _this2.domElements.length
          };
        })();

        if (typeof _ret2 === 'object') return _ret2.v;
      }
      return 0;
    }

    /**
     * header for major subjects
     * @param name
     * @private
     */
  }, {
    key: '_makeHeader',
    value: function _makeHeader(name) {
      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-header';
      div.innerHTML = name;
      this._makeItem([], div);
    }

    /**
     * make a label, if it is an object label, it gets different styling.
     * @param name
     * @param path
     * @param objectLabel
     * @returns {HTMLElement}
     * @private
     */
  }, {
    key: '_makeLabel',
    value: function _makeLabel(name, path) {
      var objectLabel = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-label vis-config-s' + path.length;
      if (objectLabel === true) {
        div.innerHTML = '<i><b>' + name + ':</b></i>';
      } else {
        div.innerHTML = name + ':';
      }
      return div;
    }

    /**
     * make a dropdown list for multiple possible string optoins
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeDropdown',
    value: function _makeDropdown(arr, value, path) {
      var select = document.createElement('select');
      select.className = 'vis-configuration vis-config-select';
      var selectedValue = 0;
      if (value !== undefined) {
        if (arr.indexOf(value) !== -1) {
          selectedValue = arr.indexOf(value);
        }
      }

      for (var i = 0; i < arr.length; i++) {
        var option = document.createElement('option');
        option.value = arr[i];
        if (i === selectedValue) {
          option.selected = 'selected';
        }
        option.innerHTML = arr[i];
        select.appendChild(option);
      }

      var me = this;
      select.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, select);
    }

    /**
     * make a range object for numeric options
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeRange',
    value: function _makeRange(arr, value, path) {
      var defaultValue = arr[0];
      var min = arr[1];
      var max = arr[2];
      var step = arr[3];
      var range = document.createElement('input');
      range.className = 'vis-configuration vis-config-range';
      try {
        range.type = 'range'; // not supported on IE9
        range.min = min;
        range.max = max;
      } catch (err) {}
      range.step = step;

      // set up the popup settings in case they are needed.
      var popupString = '';
      var popupValue = 0;

      if (value !== undefined) {
        var factor = 1.20;
        if (value < 0 && value * factor < min) {
          range.min = Math.ceil(value * factor);
          popupValue = range.min;
          popupString = 'range increased';
        } else if (value / factor < min) {
          range.min = Math.ceil(value / factor);
          popupValue = range.min;
          popupString = 'range increased';
        }
        if (value * factor > max && max !== 1) {
          range.max = Math.ceil(value * factor);
          popupValue = range.max;
          popupString = 'range increased';
        }
        range.value = value;
      } else {
        range.value = defaultValue;
      }

      var input = document.createElement('input');
      input.className = 'vis-configuration vis-config-rangeinput';
      input.value = range.value;

      var me = this;
      range.onchange = function () {
        input.value = this.value;me._update(Number(this.value), path);
      };
      range.oninput = function () {
        input.value = this.value;
      };

      var label = this._makeLabel(path[path.length - 1], path);
      var itemIndex = this._makeItem(path, label, range, input);

      // if a popup is needed AND it has not been shown for this value, show it.
      if (popupString !== '' && this.popupHistory[itemIndex] !== popupValue) {
        this.popupHistory[itemIndex] = popupValue;
        this._setupPopup(popupString, itemIndex);
      }
    }

    /**
     * prepare the popup
     * @param string
     * @param index
     * @private
     */
  }, {
    key: '_setupPopup',
    value: function _setupPopup(string, index) {
      var _this3 = this;

      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
        var div = document.createElement("div");
        div.id = "vis-configuration-popup";
        div.className = "vis-configuration-popup";
        div.innerHTML = string;
        div.onclick = function () {
          _this3._removePopup();
        };
        this.popupCounter += 1;
        this.popupDiv = { html: div, index: index };
      }
    }

    /**
     * remove the popup from the dom
     * @private
     */
  }, {
    key: '_removePopup',
    value: function _removePopup() {
      if (this.popupDiv.html !== undefined) {
        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
        clearTimeout(this.popupDiv.hideTimeout);
        clearTimeout(this.popupDiv.deleteTimeout);
        this.popupDiv = {};
      }
    }

    /**
     * Show the popup if it is needed.
     * @private
     */
  }, {
    key: '_showPopupIfNeeded',
    value: function _showPopupIfNeeded() {
      var _this4 = this;

      if (this.popupDiv.html !== undefined) {
        var correspondingElement = this.domElements[this.popupDiv.index];
        var rect = correspondingElement.getBoundingClientRect();
        this.popupDiv.html.style.left = rect.left + "px";
        this.popupDiv.html.style.top = rect.top - 30 + "px"; // 30 is the height;
        document.body.appendChild(this.popupDiv.html);
        this.popupDiv.hideTimeout = setTimeout(function () {
          _this4.popupDiv.html.style.opacity = 0;
        }, 1500);
        this.popupDiv.deleteTimeout = setTimeout(function () {
          _this4._removePopup();
        }, 1800);
      }
    }

    /**
     * make a checkbox for boolean options.
     * @param defaultValue
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeCheckbox',
    value: function _makeCheckbox(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'vis-configuration vis-config-checkbox';
      checkbox.checked = defaultValue;
      if (value !== undefined) {
        checkbox.checked = value;
        if (value !== defaultValue) {
          if (typeof defaultValue === 'object') {
            if (value !== defaultValue.enabled) {
              this.changedOptions.push({ path: path, value: value });
            }
          } else {
            this.changedOptions.push({ path: path, value: value });
          }
        }
      }

      var me = this;
      checkbox.onchange = function () {
        me._update(this.checked, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, checkbox);
    }

    /**
     * make a text input field for string options.
     * @param defaultValue
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeTextInput',
    value: function _makeTextInput(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'text';
      checkbox.className = 'vis-configuration vis-config-text';
      checkbox.value = value;
      if (value !== defaultValue) {
        this.changedOptions.push({ path: path, value: value });
      }

      var me = this;
      checkbox.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, checkbox);
    }

    /**
     * make a color field with a color picker for color fields
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeColorField',
    value: function _makeColorField(arr, value, path) {
      var _this5 = this;

      var defaultColor = arr[1];
      var div = document.createElement('div');
      value = value === undefined ? defaultColor : value;

      if (value !== 'none') {
        div.className = 'vis-configuration vis-config-colorBlock';
        div.style.backgroundColor = value;
      } else {
        div.className = 'vis-configuration vis-config-colorBlock none';
      }

      value = value === undefined ? defaultColor : value;
      div.onclick = function () {
        _this5._showColorPicker(value, div, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, div);
    }

    /**
     * used by the color buttons to call the color picker.
     * @param event
     * @param value
     * @param div
     * @param path
     * @private
     */
  }, {
    key: '_showColorPicker',
    value: function _showColorPicker(value, div, path) {
      var _this6 = this;

      var rect = div.getBoundingClientRect();
      var bodyRect = document.body.getBoundingClientRect();
      var pickerX = rect.left + rect.width + 5;
      var pickerY = rect.top - bodyRect.top + rect.height + 2;
      this.colorPicker.show(pickerX, pickerY);
      this.colorPicker.setColor(value);
      this.colorPicker.setCallback(function (color) {
        var colorString = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + color.a + ')';
        div.style.backgroundColor = colorString;
        _this6._update(colorString, path);
      });
    }

    /**
     * parse an object and draw the correct items
     * @param obj
     * @param path
     * @private
     */
  }, {
    key: '_handleObject',
    value: function _handleObject(obj) {
      var path = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
      var checkOnly = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var show = false;
      var filter = this.options.filter;
      var visibleInSet = false;
      for (var subObj in obj) {
        if (obj.hasOwnProperty(subObj)) {
          show = true;
          var item = obj[subObj];
          var newPath = util.copyAndExtendArray(path, subObj);
          if (typeof filter === 'function') {
            show = filter(subObj, path);

            // if needed we must go deeper into the object.
            if (show === false) {
              if (!(item instanceof Array) && typeof item !== 'string' && typeof item !== 'boolean' && item instanceof Object) {
                this.allowCreation = false;
                show = this._handleObject(item, newPath, true);
                this.allowCreation = checkOnly === false;
              }
            }
          }

          if (show !== false) {
            visibleInSet = true;
            var value = this._getValue(newPath);

            if (item instanceof Array) {
              this._handleArray(item, value, newPath);
            } else if (typeof item === 'string') {
              this._makeTextInput(item, value, newPath);
            } else if (typeof item === 'boolean') {
              this._makeCheckbox(item, value, newPath);
            } else if (item instanceof Object) {
              // collapse the physics options that are not enabled
              var draw = true;
              if (path.indexOf('physics') !== -1) {
                if (this.moduleOptions.physics.solver !== subObj) {
                  draw = false;
                }
              }

              if (draw === true) {
                // initially collapse options with an disabled enabled option.
                if (item.enabled !== undefined) {
                  var enabledPath = util.copyAndExtendArray(newPath, 'enabled');
                  var enabledValue = this._getValue(enabledPath);
                  if (enabledValue === true) {
                    var label = this._makeLabel(subObj, newPath, true);
                    this._makeItem(newPath, label);
                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  } else {
                    this._makeCheckbox(item, enabledValue, newPath);
                  }
                } else {
                  var label = this._makeLabel(subObj, newPath, true);
                  this._makeItem(newPath, label);
                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                }
              }
            } else {
              console.error('dont know how to handle', item, subObj, newPath);
            }
          }
        }
      }
      return visibleInSet;
    }

    /**
     * handle the array type of option
     * @param optionName
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_handleArray',
    value: function _handleArray(arr, value, path) {
      if (typeof arr[0] === 'string' && arr[0] === 'color') {
        this._makeColorField(arr, value, path);
        if (arr[1] !== value) {
          this.changedOptions.push({ path: path, value: value });
        }
      } else if (typeof arr[0] === 'string') {
        this._makeDropdown(arr, value, path);
        if (arr[0] !== value) {
          this.changedOptions.push({ path: path, value: value });
        }
      } else if (typeof arr[0] === 'number') {
        this._makeRange(arr, value, path);
        if (arr[0] !== value) {
          this.changedOptions.push({ path: path, value: Number(value) });
        }
      }
    }

    /**
     * called to update the network with the new settings.
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_update',
    value: function _update(value, path) {
      var options = this._constructOptions(value, path);

      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
        this.parent.body.emitter.emit("configChange", options);
      }
      this.initialized = true;
      this.parent.setOptions(options);
    }
  }, {
    key: '_constructOptions',
    value: function _constructOptions(value, path) {
      var optionsObj = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var pointer = optionsObj;

      // when dropdown boxes can be string or boolean, we typecast it into correct types
      value = value === 'true' ? true : value;
      value = value === 'false' ? false : value;

      for (var i = 0; i < path.length; i++) {
        if (path[i] !== 'global') {
          if (pointer[path[i]] === undefined) {
            pointer[path[i]] = {};
          }
          if (i !== path.length - 1) {
            pointer = pointer[path[i]];
          } else {
            pointer[path[i]] = value;
          }
        }
      }
      return optionsObj;
    }
  }, {
    key: '_printOptions',
    value: function _printOptions() {
      var options = this.getOptions();
      this.optionsContainer.innerHTML = '<pre>var options = ' + JSON.stringify(options, null, 2) + '</pre>';
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      var options = {};
      for (var i = 0; i < this.changedOptions.length; i++) {
        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
      }
      return options;
    }
  }]);

  return Configurator;
})();

exports['default'] = Configurator;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3NoYXJlZC9Db25maWd1cmF0b3IuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OzJCQUV3QixlQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFGdkMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDOztJQWtCeEIsWUFBWTtBQUNMLFdBRFAsWUFBWSxDQUNKLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBa0I7UUFBaEIsVUFBVSx5REFBRyxDQUFDOzswQkFEeEUsWUFBWTs7QUFFZCxRQUFJLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQztBQUMzQixRQUFJLENBQUMsY0FBYyxHQUFHLEVBQUUsQ0FBQztBQUN6QixRQUFJLENBQUMsU0FBUyxHQUFHLGdCQUFnQixDQUFDO0FBQ2xDLFFBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDOztBQUUzQixRQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztBQUNsQixRQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztBQUN6QixRQUFJLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQztBQUN0QixRQUFJLENBQUMsY0FBYyxHQUFHO0FBQ3BCLGFBQU8sRUFBRSxLQUFLO0FBQ2QsWUFBTSxFQUFFLElBQUk7QUFDWixlQUFTLEVBQUUsU0FBUztBQUNwQixnQkFBVSxFQUFFLElBQUk7S0FDakIsQ0FBQztBQUNGLFFBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7O0FBRS9DLFFBQUksQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUN6QyxRQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQztBQUN4QixRQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUN0QixRQUFJLENBQUMs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N3FCRyxZQUFZOzs7cUJBaXJCSCxZQUFZIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3NoYXJlZC9Db25maWd1cmF0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4vQ29sb3JQaWNrZXInXG5cbi8qKlxuICogVGhlIHdheSB0aGlzIHdvcmtzIGlzIGZvciBhbGwgcHJvcGVydGllcyBvZiB0aGlzLnBvc3NpYmxlIG9wdGlvbnMsIHlvdSBjYW4gc3VwcGx5IHRoZSBwcm9wZXJ0eSBuYW1lIGluIGFueSBmb3JtIHRvIGxpc3QgdGhlIG9wdGlvbnMuXG4gKiBCb29sZWFuIG9wdGlvbnMgYXJlIHJlY29nbmlzZWQgYXMgQm9vbGVhblxuICogTnVtYmVyIG9wdGlvbnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtkZWZhdWx0IHZhbHVlLCBtaW4gdmFsdWUsIG1heCB2YWx1ZSwgc3RlcHNpemVdXG4gKiBDb2xvcnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFsnY29sb3InLCAnI2ZmZmZmZiddXG4gKiBTdHJpbmdzIHdpdGggc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zLCAuLl1cbiAqXG4gKiBUaGUgb3B0aW9ucyBhcmUgbWF0Y2hlZCB3aXRoIHRoZWlyIGNvdW50ZXJwYXJ0cyBpbiBlYWNoIG9mIHRoZSBtb2R1bGVzIGFuZCB0aGUgdmFsdWVzIHVzZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24gYXJlXG4gKlxuICogQHBhcmFtIHBhcmVudE1vZHVsZSAgICAgICAgfCB0aGUgbG9jYXRpb24gd2hlcmUgcGFyZW50TW9kdWxlLnNldE9wdGlvbnMoKSBjYW4gYmUgY2FsbGVkXG4gKiBAcGFyYW0gZGVmYXVsdENvbnRhaW5lciAgICB8IHRoZSBkZWZhdWx0IGNvbnRhaW5lciBvZiB0aGUgbW9kdWxlXG4gKiBAcGFyYW0gY29uZmlndXJlT3B0aW9ucyAgICB8IHRoZSBmdWxseSBjb25maWd1cmVkIGFuZCBwcmVkZWZpbmVkIG9wdGlvbnMgc2V0IGZvdW5kIGluIGFsbE9wdGlvbnMuanNcbiAqIEBwYXJhbSBwaXhlbFJhdGlvICAgICAgICAgIHwgY2FudmFzIHBpeGVsIHJhdGlvXG4gKi9cbmNsYXNzIENvbmZpZ3VyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudE1vZHVsZSwgZGVmYXVsdENvbnRhaW5lciwgY29uZmlndXJlT3B0aW9ucywgcGl4ZWxSYXRpbyA9IDEpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudE1vZHVsZTtcbiAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG4gICAgdGhpcy5jb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyO1xuICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMucG9wdXBDb3VudGVyID0gMDtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBmaWx0ZXI6IHRydWUsXG4gICAgICBjb250YWluZXI6IHVuZGVmaW5lZCxcbiAgICAgIHNob3dCdXR0b246IHRydWVcbiAgICB9O1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZG9tRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgdGhpcy5wb3B1cExpbWl0ID0gNTtcbiAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgIHRoaXMuY29sb3JQaWNrZXIgPSBuZXcgQ29sb3JQaWNrZXIocGl4ZWxSYXRpbyk7XG4gICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICB9XG5cblxuICAvKipcbiAgICogcmVmcmVzaCBhbGwgb3B0aW9ucy5cbiAgICogQmVjYXVzZSBhbGwgbW9kdWxlcyBwYXJzZSB0aGVpciBvcHRpb25zIGJ5IHRoZW1zZWx2ZXMsIHdlIGp1c3QgdXNlIHRoZWlyIG9wdGlvbnMuIFdlIGNvcHkgdGhlbSBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmVzZXQgdGhlIHBvcHVwIGhpc3RvcnkgYmVjYXVzZSB0aGUgaW5kaWNlcyBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQuXG4gICAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcblxuICAgICAgbGV0IGVuYWJsZWQgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucy5qb2luKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0J1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNob3dCdXR0b24gPSBvcHRpb25zLnNob3dCdXR0b247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIHRoaXMuX2NsZWFuKCk7XG4gIH1cblxuXG4gIHNldE1vZHVsZU9wdGlvbnMobW9kdWxlT3B0aW9ucykge1xuICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IG1vZHVsZU9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgICB9XG4gICAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFsbCBET00gZWxlbWVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGUoKSB7XG4gICAgdGhpcy5fY2xlYW4oKTtcbiAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG5cbiAgICBsZXQgZmlsdGVyID0gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgbGV0IHNob3cgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBvcHRpb24gaW4gdGhpcy5jb25maWd1cmVPcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5jb25maWd1cmVPcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgICAgIHNob3cgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzaG93ID0gZmlsdGVyKG9wdGlvbixbXSk7XG4gICAgICAgICAgc2hvdyA9IHNob3cgfHwgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tvcHRpb25dLCBbb3B0aW9uXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsdGVyID09PSB0cnVlIHx8IGZpbHRlci5pbmRleE9mKG9wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgc2hvdyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSB0cnVlO1xuXG4gICAgICAgICAgLy8gbGluZWJyZWFrIGJldHdlZW4gY2F0ZWdvcmllc1xuICAgICAgICAgIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0oW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhIGhlYWRlciBmb3IgdGhlIGNhdGVnb3J5XG4gICAgICAgICAgdGhpcy5fbWFrZUhlYWRlcihvcHRpb24pO1xuXG4gICAgICAgICAgLy8gZ2V0IHRoZSBzdWJvcHRpb25zXG4gICAgICAgICAgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tvcHRpb25dLCBbb3B0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IGdlbmVyYXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24nO1xuICAgICAgZ2VuZXJhdGVCdXR0b24uaW5uZXJIVE1MID0gJ2dlbmVyYXRlIG9wdGlvbnMnO1xuICAgICAgZ2VuZXJhdGVCdXR0b24ub25jbGljayA9ICAgICAoKSA9PiB7dGhpcy5fcHJpbnRPcHRpb25zKCk7fTtcbiAgICAgIGdlbmVyYXRlQnV0dG9uLm9ubW91c2VvdmVyID0gKCkgPT4ge2dlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvbiBob3Zlcic7fTtcbiAgICAgIGdlbmVyYXRlQnV0dG9uLm9ubW91c2VvdXQgPSAgKCkgPT4ge2dlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvbic7fTtcblxuICAgICAgdGhpcy5vcHRpb25zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctb3B0aW9uLWNvbnRhaW5lcic7XG5cbiAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaCh0aGlzLm9wdGlvbnNDb250YWluZXIpO1xuICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKGdlbmVyYXRlQnV0dG9uKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wdXNoKCk7XG4gICAgdGhpcy5jb2xvclBpY2tlci5pbnNlcnRUbyh0aGlzLmNvbnRhaW5lcik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBkcmF3IGFsbCBET00gZWxlbWVudHMgb24gdGhlIHNjcmVlblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3B1c2goKSB7XG4gICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy53cmFwcGVyLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbi13cmFwcGVyJztcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3Nob3dQb3B1cElmTmVlZGVkKClcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGRlbGV0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xlYW4oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud3JhcHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmRvbUVsZW1lbnRzID0gW107XG5cbiAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuICB9XG5cblxuICAvKipcbiAgICogZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBhY3R1YWxPcHRpb25zIGlmIGl0IGV4aXN0c1xuICAgKiBAcGFyYW0ge2FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VmFsdWUocGF0aCkge1xuICAgIGxldCBiYXNlID0gdGhpcy5tb2R1bGVPcHRpb25zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGJhc2VbcGF0aFtpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiYXNlID0gYmFzZVtwYXRoW2ldXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBiYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBhbGwgb3B0aW9uIGVsZW1lbnRzIGFyZSB3cmFwcGVkIGluIGFuIGl0ZW1cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIGRvbUVsZW1lbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZUl0ZW0ocGF0aCwgLi4uZG9tRWxlbWVudHMpIHtcbiAgICBpZiAodGhpcy5hbGxvd0NyZWF0aW9uID09PSB0cnVlKSB7XG4gICAgICBsZXQgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaXRlbS5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1pdGVtIHZpcy1jb25maWctcycgKyBwYXRoLmxlbmd0aDtcbiAgICAgIGRvbUVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKGl0ZW0pO1xuICAgICAgcmV0dXJuIHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGhlYWRlciBmb3IgbWFqb3Igc3ViamVjdHNcbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlSGVhZGVyKG5hbWUpIHtcbiAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWhlYWRlcic7XG4gICAgZGl2LmlubmVySFRNTCA9IG5hbWU7XG4gICAgdGhpcy5fbWFrZUl0ZW0oW10sZGl2KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIG1ha2UgYSBsYWJlbCwgaWYgaXQgaXMgYW4gb2JqZWN0IGxhYmVsLCBpdCBnZXRzIGRpZmZlcmVudCBzdHlsaW5nLlxuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gb2JqZWN0TGFiZWxcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VMYWJlbChuYW1lLCBwYXRoLCBvYmplY3RMYWJlbCA9IGZhbHNlKSB7XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1sYWJlbCB2aXMtY29uZmlnLXMnICsgcGF0aC5sZW5ndGg7XG4gICAgaWYgKG9iamVjdExhYmVsID09PSB0cnVlKSB7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxpPjxiPicgKyBuYW1lICsgJzo8L2I+PC9pPic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZGl2LmlubmVySFRNTCA9IG5hbWUgKyAnOic7XG4gICAgfVxuICAgIHJldHVybiBkaXY7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBtYWtlIGEgZHJvcGRvd24gbGlzdCBmb3IgbXVsdGlwbGUgcG9zc2libGUgc3RyaW5nIG9wdG9pbnNcbiAgICogQHBhcmFtIGFyclxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgIGxldCBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICBzZWxlY3QuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctc2VsZWN0JztcbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZSA9IDA7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChhcnIuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgIHNlbGVjdGVkVmFsdWUgPSBhcnIuaW5kZXhPZih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgIG9wdGlvbi52YWx1ZSA9IGFycltpXTtcbiAgICAgIGlmIChpID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9ICdzZWxlY3RlZCc7XG4gICAgICB9XG4gICAgICBvcHRpb24uaW5uZXJIVE1MID0gYXJyW2ldO1xuICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgfVxuXG4gICAgbGV0IG1lID0gdGhpcztcbiAgICBzZWxlY3Qub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7bWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTt9O1xuXG4gICAgbGV0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGgtMV0sIHBhdGgpO1xuICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBzZWxlY3QpO1xuICB9XG5cblxuICAvKipcbiAgICogbWFrZSBhIHJhbmdlIG9iamVjdCBmb3IgbnVtZXJpYyBvcHRpb25zXG4gICAqIEBwYXJhbSBhcnJcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICBsZXQgZGVmYXVsdFZhbHVlID0gYXJyWzBdO1xuICAgIGxldCBtaW4gPSBhcnJbMV07XG4gICAgbGV0IG1heCA9IGFyclsyXTtcbiAgICBsZXQgc3RlcCA9IGFyclszXTtcbiAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHJhbmdlLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlJztcbiAgICB0cnkge1xuICAgICAgcmFuZ2UudHlwZSA9ICdyYW5nZSc7IC8vIG5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICByYW5nZS5taW4gPSBtaW47XG4gICAgICByYW5nZS5tYXggPSBtYXg7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHt9XG4gICAgcmFuZ2Uuc3RlcCA9IHN0ZXA7XG5cbiAgICAvLyBzZXQgdXAgdGhlIHBvcHVwIHNldHRpbmdzIGluIGNhc2UgdGhleSBhcmUgbmVlZGVkLlxuICAgIGxldCBwb3B1cFN0cmluZyA9ICcnO1xuICAgIGxldCBwb3B1cFZhbHVlID0gMDtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgZmFjdG9yID0gMS4yMDtcbiAgICAgIGlmICh2YWx1ZSA8IDAgJiYgdmFsdWUgKiBmYWN0b3IgPCBtaW4pIHtcbiAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1pbjtcbiAgICAgICAgcG9wdXBTdHJpbmcgPSAncmFuZ2UgaW5jcmVhc2VkJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlIC8gZmFjdG9yIDwgbWluKSB7XG4gICAgICAgIHJhbmdlLm1pbiA9IE1hdGguY2VpbCh2YWx1ZSAvIGZhY3Rvcik7XG4gICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5taW47XG4gICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgKiBmYWN0b3IgPiBtYXggJiYgbWF4ICE9PSAxKSB7XG4gICAgICAgIHJhbmdlLm1heCA9IE1hdGguY2VpbCh2YWx1ZSAqIGZhY3Rvcik7XG4gICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5tYXg7XG4gICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICB9XG4gICAgICByYW5nZS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJhbmdlLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGxldCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgaW5wdXQuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2VpbnB1dCc7XG4gICAgaW5wdXQudmFsdWUgPSByYW5nZS52YWx1ZTtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgcmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7aW5wdXQudmFsdWUgPSB0aGlzLnZhbHVlOyBtZS5fdXBkYXRlKE51bWJlcih0aGlzLnZhbHVlKSwgcGF0aCk7fTtcbiAgICByYW5nZS5vbmlucHV0ICA9IGZ1bmN0aW9uICgpIHtpbnB1dC52YWx1ZSA9IHRoaXMudmFsdWU7IH07XG5cbiAgICBsZXQgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aC0xXSwgcGF0aCk7XG4gICAgbGV0IGl0ZW1JbmRleCA9IHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCByYW5nZSwgaW5wdXQpO1xuXG4gICAgLy8gaWYgYSBwb3B1cCBpcyBuZWVkZWQgQU5EIGl0IGhhcyBub3QgYmVlbiBzaG93biBmb3IgdGhpcyB2YWx1ZSwgc2hvdyBpdC5cbiAgICBpZiAocG9wdXBTdHJpbmcgIT09ICcnICYmIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gIT09IHBvcHVwVmFsdWUpIHtcbiAgICAgIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gPSBwb3B1cFZhbHVlO1xuICAgICAgdGhpcy5fc2V0dXBQb3B1cChwb3B1cFN0cmluZywgaXRlbUluZGV4KTtcbiAgICB9XG5cbiAgfVxuXG5cbiAgLyoqXG4gICAqIHByZXBhcmUgdGhlIHBvcHVwXG4gICAqIEBwYXJhbSBzdHJpbmdcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBQb3B1cChzdHJpbmcsIGluZGV4KSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09IHRydWUgJiYgdGhpcy5hbGxvd0NyZWF0aW9uID09PSB0cnVlICYmIHRoaXMucG9wdXBDb3VudGVyIDwgdGhpcy5wb3B1cExpbWl0KSB7XG4gICAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5pZCA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uLXBvcHVwXCI7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gc3RyaW5nO1xuICAgICAgZGl2Lm9uY2xpY2sgPSAoKSA9PiB7dGhpcy5fcmVtb3ZlUG9wdXAoKX07XG4gICAgICB0aGlzLnBvcHVwQ291bnRlciArPSAxO1xuICAgICAgdGhpcy5wb3B1cERpdiA9IHtodG1sOmRpdiwgaW5kZXg6aW5kZXh9O1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIHJlbW92ZSB0aGUgcG9wdXAgZnJvbSB0aGUgZG9tXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVtb3ZlUG9wdXAoKSB7XG4gICAgaWYgKHRoaXMucG9wdXBEaXYuaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucG9wdXBEaXYuaGlkZVRpbWVvdXQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucG9wdXBEaXYuZGVsZXRlVGltZW91dCk7XG4gICAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogU2hvdyB0aGUgcG9wdXAgaWYgaXQgaXMgbmVlZGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Nob3dQb3B1cElmTmVlZGVkKCkge1xuICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGNvcnJlc3BvbmRpbmdFbGVtZW50ID0gdGhpcy5kb21FbGVtZW50c1t0aGlzLnBvcHVwRGl2LmluZGV4XTtcbiAgICAgIGxldCByZWN0ID0gY29ycmVzcG9uZGluZ0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUubGVmdCA9IHJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS50b3AgPSByZWN0LnRvcCAtIDMwICsgXCJweFwiOyAvLyAzMCBpcyB0aGUgaGVpZ2h0O1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpXG4gICAgICB0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIH0sMTUwMCk7XG4gICAgICB0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgIH0sMTgwMClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogbWFrZSBhIGNoZWNrYm94IGZvciBib29sZWFuIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWVcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZUNoZWNrYm94KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICB2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNoZWNrYm94JztcbiAgICBjaGVja2JveC5jaGVja2VkID0gZGVmYXVsdFZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZS5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6cGF0aCwgdmFsdWU6dmFsdWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOnBhdGgsIHZhbHVlOnZhbHVlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbWUgPSB0aGlzO1xuICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gZnVuY3Rpb24oKSB7bWUuX3VwZGF0ZSh0aGlzLmNoZWNrZWQsIHBhdGgpfTtcblxuICAgIGxldCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoKTtcbiAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgY2hlY2tib3gpO1xuICB9XG5cbiAgLyoqXG4gICAqIG1ha2UgYSB0ZXh0IGlucHV0IGZpZWxkIGZvciBzdHJpbmcgb3B0aW9ucy5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlVGV4dElucHV0KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICB2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGNoZWNrYm94LnR5cGUgPSAndGV4dCc7XG4gICAgY2hlY2tib3guY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctdGV4dCc7XG4gICAgY2hlY2tib3gudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOnBhdGgsIHZhbHVlOnZhbHVlfSk7XG4gICAgfVxuXG4gICAgbGV0IG1lID0gdGhpcztcbiAgICBjaGVja2JveC5vbmNoYW5nZSA9IGZ1bmN0aW9uKCkge21lLl91cGRhdGUodGhpcy52YWx1ZSwgcGF0aCl9O1xuXG4gICAgbGV0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGgtMV0sIHBhdGgpO1xuICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBjaGVja2JveCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBtYWtlIGEgY29sb3IgZmllbGQgd2l0aCBhIGNvbG9yIHBpY2tlciBmb3IgY29sb3IgZmllbGRzXG4gICAqIEBwYXJhbSBhcnJcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZUNvbG9yRmllbGQoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgIGxldCBkZWZhdWx0Q29sb3IgPSBhcnJbMV07XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICE9PSAnbm9uZScpIHtcbiAgICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jb2xvckJsb2NrJztcbiAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9jayBub25lJztcbiAgICB9XG5cbiAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29sb3IgOiB2YWx1ZTtcbiAgICBkaXYub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3Nob3dDb2xvclBpY2tlcih2YWx1ZSxkaXYscGF0aCk7XG4gICAgfTtcblxuICAgIGxldCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoKTtcbiAgICB0aGlzLl9tYWtlSXRlbShwYXRoLGxhYmVsLCBkaXYpO1xuICB9XG5cblxuICAvKipcbiAgICogdXNlZCBieSB0aGUgY29sb3IgYnV0dG9ucyB0byBjYWxsIHRoZSBjb2xvciBwaWNrZXIuXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIGRpdlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKSB7XG4gICAgbGV0IHJlY3QgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcGlja2VyWCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGggKyA1O1xuICAgIGxldCBwaWNrZXJZID0gcmVjdC50b3AgLSBib2R5UmVjdC50b3AgKyByZWN0LmhlaWdodCArMjtcbiAgICB0aGlzLmNvbG9yUGlja2VyLnNob3cocGlja2VyWCxwaWNrZXJZKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyLnNldENvbG9yKHZhbHVlKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyLnNldENhbGxiYWNrKChjb2xvcikgPT4ge1xuICAgICAgbGV0IGNvbG9yU3RyaW5nID0gJ3JnYmEoJyArIGNvbG9yLnIgKyAnLCcgKyBjb2xvci5nICsgJywnICsgY29sb3IuYiArICcsJyArIGNvbG9yLmEgKyAnKSc7XG4gICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JTdHJpbmc7XG4gICAgICB0aGlzLl91cGRhdGUoY29sb3JTdHJpbmcscGF0aCk7XG4gICAgfSlcbiAgfVxuXG5cbiAgLyoqXG4gICAqIHBhcnNlIGFuIG9iamVjdCBhbmQgZHJhdyB0aGUgY29ycmVjdCBpdGVtc1xuICAgKiBAcGFyYW0gb2JqXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlT2JqZWN0KG9iaiwgcGF0aCA9IFtdLCBjaGVja09ubHkgPSBmYWxzZSkge1xuICAgIGxldCBzaG93ID0gZmFsc2U7XG4gICAgbGV0IGZpbHRlciA9IHRoaXMub3B0aW9ucy5maWx0ZXI7XG4gICAgbGV0IHZpc2libGVJblNldCA9IGZhbHNlO1xuICAgIGZvciAobGV0IHN1Yk9iaiBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoc3ViT2JqKSkge1xuICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgbGV0IGl0ZW0gPSBvYmpbc3ViT2JqXTtcbiAgICAgICAgbGV0IG5ld1BhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBzdWJPYmopO1xuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHNob3cgPSBmaWx0ZXIoc3ViT2JqLHBhdGgpO1xuXG4gICAgICAgICAgLy8gaWYgbmVlZGVkIHdlIG11c3QgZ28gZGVlcGVyIGludG8gdGhlIG9iamVjdC5cbiAgICAgICAgICBpZiAoc2hvdyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkgJiYgdHlwZW9mIGl0ZW0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBpdGVtICE9PSAnYm9vbGVhbicgJiYgaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2hvdyA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gY2hlY2tPbmx5ID09PSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0cnVlO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuX2dldFZhbHVlKG5ld1BhdGgpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlQXJyYXkoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VUZXh0SW5wdXQoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWtlQ2hlY2tib3goaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBjb2xsYXBzZSB0aGUgcGh5c2ljcyBvcHRpb25zIHRoYXQgYXJlIG5vdCBlbmFibGVkXG4gICAgICAgICAgICBsZXQgZHJhdyA9IHRydWU7XG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCdwaHlzaWNzJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm1vZHVsZU9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgIT09IHN1Yk9iaikge1xuICAgICAgICAgICAgICAgIGRyYXcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvLyBpbml0aWFsbHkgY29sbGFwc2Ugb3B0aW9ucyB3aXRoIGFuIGRpc2FibGVkIGVuYWJsZWQgb3B0aW9uLlxuICAgICAgICAgICAgICBpZiAoaXRlbS5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5hYmxlZFBhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShuZXdQYXRoLCAnZW5hYmxlZCcpO1xuICAgICAgICAgICAgICAgIGxldCBlbmFibGVkVmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShlbmFibGVkUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWRWYWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCkgfHwgdmlzaWJsZUluU2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCBlbmFibGVkVmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwoc3ViT2JqLCBuZXdQYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2RvbnQga25vdyBob3cgdG8gaGFuZGxlJywgaXRlbSwgc3ViT2JqLCBuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZpc2libGVJblNldDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGhhbmRsZSB0aGUgYXJyYXkgdHlwZSBvZiBvcHRpb25cbiAgICogQHBhcmFtIG9wdGlvbk5hbWVcbiAgICogQHBhcmFtIGFyclxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVBcnJheShhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBhcnJbMF0gPT09ICdzdHJpbmcnICYmIGFyclswXSA9PT0gJ2NvbG9yJykge1xuICAgICAgdGhpcy5fbWFrZUNvbG9yRmllbGQoYXJyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICBpZiAoYXJyWzFdICE9PSB2YWx1ZSkge3RoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7cGF0aDpwYXRoLCB2YWx1ZTp2YWx1ZX0pO31cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGFyclswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX21ha2VEcm9wZG93bihhcnIsIHZhbHVlLCBwYXRoKTtcbiAgICAgIGlmIChhcnJbMF0gIT09IHZhbHVlKSB7dGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOnBhdGgsIHZhbHVlOnZhbHVlfSk7fVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5fbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHt0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6cGF0aCwgdmFsdWU6TnVtYmVyKHZhbHVlKX0pO31cbiAgICB9XG4gIH1cblxuXG5cbiAgLyoqXG4gICAqIGNhbGxlZCB0byB1cGRhdGUgdGhlIG5ldHdvcmsgd2l0aCB0aGUgbmV3IHNldHRpbmdzLlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGUodmFsdWUsIHBhdGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModmFsdWUscGF0aCk7XG5cbiAgICBpZiAodGhpcy5wYXJlbnQuYm9keSAmJiB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIgJiYgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQpIHtcbiAgICAgIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlci5lbWl0KFwiY29uZmlnQ2hhbmdlXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmVudC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgsIG9wdGlvbnNPYmogPSB7fSkge1xuICAgIGxldCBwb2ludGVyID0gb3B0aW9uc09iajtcblxuICAgIC8vIHdoZW4gZHJvcGRvd24gYm94ZXMgY2FuIGJlIHN0cmluZyBvciBib29sZWFuLCB3ZSB0eXBlY2FzdCBpdCBpbnRvIGNvcnJlY3QgdHlwZXNcbiAgICB2YWx1ZSA9IHZhbHVlID09PSAndHJ1ZScgID8gdHJ1ZSAgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gIT09ICdnbG9iYWwnKSB7XG4gICAgICAgIGlmIChwb2ludGVyW3BhdGhbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgIT09IHBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyW3BhdGhbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHBvaW50ZXJbcGF0aFtpXV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uc09iajtcblxuICB9XG5cbiAgX3ByaW50T3B0aW9ucygpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHByZT52YXIgb3B0aW9ucyA9ICcgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zLCBudWxsLCAyKSArICc8L3ByZT4nO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGFuZ2VkT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY29uc3RydWN0T3B0aW9ucyh0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnZhbHVlLCB0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnBhdGgsIG9wdGlvbnMpXG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlndXJhdG9yOyJdfQ==
},{"../util":46,"./ColorPicker":23}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var util = require('../util');

var errorFound = false;
var allOptions = undefined;
var printStyle = 'background: #FFeeee; color: #dd0000';
/**
 *  Used to validate options.
 */

var Validator = (function () {
  function Validator() {
    _classCallCheck(this, Validator);
  }

  /**
   * Main function to be called
   * @param options
   * @param subObject
   * @returns {boolean}
   */

  _createClass(Validator, null, [{
    key: 'validate',
    value: function validate(options, referenceOptions, subObject) {
      errorFound = false;
      allOptions = referenceOptions;
      var usedOptions = referenceOptions;
      if (subObject !== undefined) {
        usedOptions = referenceOptions[subObject];
      }
      Validator.parse(options, usedOptions, []);
      return errorFound;
    }

    /**
     * Will traverse an object recursively and check every value
     * @param options
     * @param referenceOptions
     * @param path
     */
  }, {
    key: 'parse',
    value: function parse(options, referenceOptions, path) {
      for (var option in options) {
        if (options.hasOwnProperty(option)) {
          Validator.check(option, options, referenceOptions, path);
        }
      }
    }

    /**
     * Check every value. If the value is an object, call the parse function on that object.
     * @param option
     * @param options
     * @param referenceOptions
     * @param path
     */
  }, {
    key: 'check',
    value: function check(option, options, referenceOptions, path) {
      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
        Validator.getSuggestion(option, referenceOptions, path);
      } else if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
        if (Validator.getType(options[option]) === 'object' && referenceOptions['__any__'].__type__ !== undefined) {
          // if the any subgroup is not a predefined object int he configurator we do not look deeper into the object.
          Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'].__type__, path);
        } else {
          Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'], path);
        }
      } else {
        // Since all options in the reference are objects, we can check whether they are supposed to be object to look for the __type__ field.
        if (referenceOptions[option].__type__ !== undefined) {
          // if this should be an object, we check if the correct type has been supplied to account for shorthand options.
          Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option].__type__, path);
        } else {
          Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option], path);
        }
      }
    }

    /**
     *
     * @param {String}  option     | the option property
     * @param {Object}  options    | The supplied options object
     * @param {Object}  referenceOptions    | The reference options containing all options and their allowed formats
     * @param {String}  referenceOption     | Usually this is the same as option, except when handling an __any__ tag.
     * @param {String}  refOptionType       | This is the type object from the reference options
     * @param {Array}   path      | where in the object is the option
     */
  }, {
    key: 'checkFields',
    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
      var optionType = Validator.getType(options[option]);
      var refOptionType = refOptionObj[optionType];
      if (refOptionType !== undefined) {
        // if the type is correct, we check if it is supposed to be one of a few select values
        if (Validator.getType(refOptionType) === 'array') {
          if (refOptionType.indexOf(options[option]) === -1) {
            console.log('%cInvalid option detected in "' + option + '".' + ' Allowed values are:' + Validator.print(refOptionType) + ' not "' + options[option] + '". ' + Validator.printLocation(path, option), printStyle);
            errorFound = true;
          } else if (optionType === 'object' && referenceOption !== "__any__") {
            path = util.copyAndExtendArray(path, option);
            Validator.parse(options[option], referenceOptions[referenceOption], path);
          }
        } else if (optionType === 'object' && referenceOption !== "__any__") {
          path = util.copyAndExtendArray(path, option);
          Validator.parse(options[option], referenceOptions[referenceOption], path);
        }
      } else if (refOptionObj['any'] === undefined) {
        // type of the field is incorrect and the field cannot be any
        console.log('%cInvalid type received for "' + option + '". Expected: ' + Validator.print(Object.keys(refOptionObj)) + '. Received [' + optionType + '] "' + options[option] + '"' + Validator.printLocation(path, option), printStyle);
        errorFound = true;
      }
    }
  }, {
    key: 'getType',
    value: function getType(object) {
      var type = typeof object;

      if (type === 'object') {
        if (object === null) {
          return 'null';
        }
        if (object instanceof Boolean) {
          return 'boolean';
        }
        if (object instanceof Number) {
          return 'number';
        }
        if (object instanceof String) {
          return 'string';
        }
        if (Array.isArray(object)) {
          return 'array';
        }
        if (object instanceof Date) {
          return 'date';
        }
        if (object.nodeType !== undefined) {
          return 'dom';
        }
        if (object._isAMomentObject === true) {
          return 'moment';
        }
        return 'object';
      } else if (type === 'number') {
        return 'number';
      } else if (type === 'boolean') {
        return 'boolean';
      } else if (type === 'string') {
        return 'string';
      } else if (type === undefined) {
        return 'undefined';
      }
      return type;
    }
  }, {
    key: 'getSuggestion',
    value: function getSuggestion(option, options, path) {
      var localSearch = Validator.findInOptions(option, options, path, false);
      var globalSearch = Validator.findInOptions(option, allOptions, [], true);

      var localSearchThreshold = 8;
      var globalSearchThreshold = 4;

      if (localSearch.indexMatch !== undefined) {
        console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n', printStyle);
      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
        console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was misplaced? Matching option found at: ' + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, ''), printStyle);
      } else if (localSearch.distance <= localSearchThreshold) {
        console.log('%cUnknown option detected: "' + option + '". Did you mean "' + localSearch.closestMatch + '"?' + Validator.printLocation(localSearch.path, option), printStyle);
      } else {
        console.log('%cUnknown option detected: "' + option + '". Did you mean one of these: ' + Validator.print(Object.keys(options)) + Validator.printLocation(path, option), printStyle);
      }

      errorFound = true;
    }

    /**
     * traverse the options in search for a match.
     * @param option
     * @param options
     * @param path
     * @param recursive
     * @returns {{closestMatch: string, path: Array, distance: number}}
     */
  }, {
    key: 'findInOptions',
    value: function findInOptions(option, options, path) {
      var recursive = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

      var min = 1e9;
      var closestMatch = '';
      var closestMatchPath = [];
      var lowerCaseOption = option.toLowerCase();
      var indexMatch = undefined;
      for (var op in options) {
        var distance = undefined;
        if (options[op].__type__ !== undefined && recursive === true) {
          var result = Validator.findInOptions(option, options[op], util.copyAndExtendArray(path, op));
          if (min > result.distance) {
            closestMatch = result.closestMatch;
            closestMatchPath = result.path;
            min = result.distance;
            indexMatch = result.indexMatch;
          }
        } else {
          if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {
            indexMatch = op;
          }
          distance = Validator.levenshteinDistance(option, op);
          if (min > distance) {
            closestMatch = op;
            closestMatchPath = util.copyArray(path);
            min = distance;
          }
        }
      }
      return { closestMatch: closestMatch, path: closestMatchPath, distance: min, indexMatch: indexMatch };
    }
  }, {
    key: 'printLocation',
    value: function printLocation(path, option) {
      var prefix = arguments.length <= 2 || arguments[2] === undefined ? 'Problem value found at: \n' : arguments[2];

      var str = '\n\n' + prefix + 'options = {\n';
      for (var i = 0; i < path.length; i++) {
        for (var j = 0; j < i + 1; j++) {
          str += '  ';
        }
        str += path[i] + ': {\n';
      }
      for (var j = 0; j < path.length + 1; j++) {
        str += '  ';
      }
      str += option + '\n';
      for (var i = 0; i < path.length + 1; i++) {
        for (var j = 0; j < path.length - i; j++) {
          str += '  ';
        }
        str += '}\n';
      }
      return str + '\n\n';
    }
  }, {
    key: 'print',
    value: function print(options) {
      return JSON.stringify(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ', ');
    }

    // Compute the edit distance between the two given strings
    // http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
    /*
     Copyright (c) 2011 Andrei Mackenzie
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
  }, {
    key: 'levenshteinDistance',
    value: function levenshteinDistance(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;

      var matrix = [];

      // increment along the first column of each row
      var i;
      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }

      // increment each column in the first row
      var j;
      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }

      // Fill in the rest of the matrix
      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) == a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
            Math.min(matrix[i][j - 1] + 1, // insertion
            matrix[i - 1][j] + 1)); // deletion
          }
        }
      }

      return matrix[b.length][a.length];
    }
  }]);

  return Validator;
})();

exports['default'] = Validator;
exports.printStyle = printStyle;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3NoYXJlZC9WYWxpZGF0b3IuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzs7QUFFOUIsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDO0FBQ3ZCLElBQUksVUFBVSxZQUFBLENBQUM7QUFDZixJQUFJLFVBQVUsR0FBRyxxQ0FBcUMsQ0FBQzs7Ozs7SUFJakQsU0FBUztBQUNGLFdBRFAsU0FBUyxHQUNDOzBCQURWLFNBQVM7R0FFWjs7Ozs7Ozs7O2VBRkcsU0FBUzs7V0FVRSxrQkFBQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsU0FBUyxFQUFFO0FBQ3BELGdCQUFVLEdBQUcsS0FBSyxDQUFDO0FBQ25CLGdCQUFVLEdBQUcsZ0JBQWdCLENBQUM7QUFDOUIsVUFBSSxXQUFXLEdBQUcsZ0JBQWdCLENBQUM7QUFDbkMsVUFBSSxTQUFTLEtBQUssU0FBUyxFQUFFO0FBQzNCLG1CQUFXLEdBQUcsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7T0FDM0M7QUFDRCxlQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDMUMsYUFBTyxVQUFVLENBQUM7S0FDbkI7Ozs7Ozs7Ozs7V0FTVyxlQUFDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7QUFDNUMsV0FBSyxJQUFJLE1BQU0sSUFBSSxPQUFPLEVBQUU7QUFDMUIsWUFBSSxPQUFPLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0FBQ2xDLG1CQUFTLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDMUQ7T0FDRjtLQUNGOzs7Ozs7Ozs7OztXQVVXLGVBQUMsTUFBTSxFQUFF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TSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzlCLGNBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7QUFDdEMsa0JBQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztXQUNyQyxNQUFNO0FBQ0wsa0JBQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDOUMsZ0JBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzNCLGtCQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7V0FDNUI7U0FDRjtPQUNGOztBQUVELGFBQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDbkM7OztTQTdSRyxTQUFTOzs7cUJBbVNBLFNBQVM7UUFDaEIsVUFBVSxHQUFWLFVBQVUiLCJmaWxlIjoiL1VzZXJzL2VtaWx5YXNobGV5L1NUT1JZVE9PTFMvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvc2hhcmVkL1ZhbGlkYXRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5sZXQgZXJyb3JGb3VuZCA9IGZhbHNlO1xubGV0IGFsbE9wdGlvbnM7XG5sZXQgcHJpbnRTdHlsZSA9ICdiYWNrZ3JvdW5kOiAjRkZlZWVlOyBjb2xvcjogI2RkMDAwMCc7XG4vKipcbiAqICBVc2VkIHRvIHZhbGlkYXRlIG9wdGlvbnMuXG4gKi9cbmNsYXNzIFZhbGlkYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgLyoqXG4gICAqIE1haW4gZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSBzdWJPYmplY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGUob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgc3ViT2JqZWN0KSB7XG4gICAgZXJyb3JGb3VuZCA9IGZhbHNlO1xuICAgIGFsbE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zO1xuICAgIGxldCB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgaWYgKHN1Yk9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnNbc3ViT2JqZWN0XTtcbiAgICB9XG4gICAgVmFsaWRhdG9yLnBhcnNlKG9wdGlvbnMsIHVzZWRPcHRpb25zLCBbXSk7XG4gICAgcmV0dXJuIGVycm9yRm91bmQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaWxsIHRyYXZlcnNlIGFuIG9iamVjdCByZWN1cnNpdmVseSBhbmQgY2hlY2sgZXZlcnkgdmFsdWVcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIHJlZmVyZW5jZU9wdGlvbnNcbiAgICogQHBhcmFtIHBhdGhcbiAgICovXG4gIHN0YXRpYyBwYXJzZShvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKSB7XG4gICAgZm9yIChsZXQgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgVmFsaWRhdG9yLmNoZWNrKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQ2hlY2sgZXZlcnkgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGNhbGwgdGhlIHBhcnNlIGZ1bmN0aW9uIG9uIHRoYXQgb2JqZWN0LlxuICAgKiBAcGFyYW0gb3B0aW9uXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSByZWZlcmVuY2VPcHRpb25zXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqL1xuICBzdGF0aWMgY2hlY2sob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKSB7XG4gICAgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSA9PT0gdW5kZWZpbmVkICYmIHJlZmVyZW5jZU9wdGlvbnMuX19hbnlfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBWYWxpZGF0b3IuZ2V0U3VnZ2VzdGlvbihvcHRpb24sIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJiByZWZlcmVuY2VPcHRpb25zLl9fYW55X18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gX19hbnlfXyBpcyBhIHdpbGRjYXJkLiBBbnkgdmFsdWUgaXMgYWNjZXB0ZWQgYW5kIHdpbGwgYmUgZnVydGhlciBhbmFseXNlZCBieSByZWZlcmVuY2UuXG4gICAgICBpZiAoVmFsaWRhdG9yLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlT3B0aW9uc1snX19hbnlfXyddLl9fdHlwZV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGFueSBzdWJncm91cCBpcyBub3QgYSBwcmVkZWZpbmVkIG9iamVjdCBpbnQgaGUgY29uZmlndXJhdG9yIHdlIGRvIG5vdCBsb29rIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG4gICAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsICdfX2FueV9fJywgcmVmZXJlbmNlT3B0aW9uc1snX19hbnlfXyddLl9fdHlwZV9fLCBwYXRoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBWYWxpZGF0b3IuY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCAnX19hbnlfXycsIHJlZmVyZW5jZU9wdGlvbnNbJ19fYW55X18nXSwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gU2luY2UgYWxsIG9wdGlvbnMgaW4gdGhlIHJlZmVyZW5jZSBhcmUgb2JqZWN0cywgd2UgY2FuIGNoZWNrIHdoZXRoZXIgdGhleSBhcmUgc3VwcG9zZWQgdG8gYmUgb2JqZWN0IHRvIGxvb2sgZm9yIHRoZSBfX3R5cGVfXyBmaWVsZC5cbiAgICAgIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0uX190eXBlX18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBpZiB0aGlzIHNob3VsZCBiZSBhbiBvYmplY3QsIHdlIGNoZWNrIGlmIHRoZSBjb3JyZWN0IHR5cGUgaGFzIGJlZW4gc3VwcGxpZWQgdG8gYWNjb3VudCBmb3Igc2hvcnRoYW5kIG9wdGlvbnMuXG4gICAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dLl9fdHlwZV9fLCBwYXRoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBWYWxpZGF0b3IuY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBvcHRpb24sIHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgb3B0aW9uICAgICB8IHRoZSBvcHRpb24gcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9ICBvcHRpb25zICAgIHwgVGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgcmVmZXJlbmNlT3B0aW9ucyAgICB8IFRoZSByZWZlcmVuY2Ugb3B0aW9ucyBjb250YWluaW5nIGFsbCBvcHRpb25zIGFuZCB0aGVpciBhbGxvd2VkIGZvcm1hdHNcbiAgICogQHBhcmFtIHtTdHJpbmd9ICByZWZlcmVuY2VPcHRpb24gICAgIHwgVXN1YWxseSB0aGlzIGlzIHRoZSBzYW1lIGFzIG9wdGlvbiwgZXhjZXB0IHdoZW4gaGFuZGxpbmcgYW4gX19hbnlfXyB0YWcuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgcmVmT3B0aW9uVHlwZSAgICAgICB8IFRoaXMgaXMgdGhlIHR5cGUgb2JqZWN0IGZyb20gdGhlIHJlZmVyZW5jZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgcGF0aCAgICAgIHwgd2hlcmUgaW4gdGhlIG9iamVjdCBpcyB0aGUgb3B0aW9uXG4gICAqL1xuICBzdGF0aWMgY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCByZWZlcmVuY2VPcHRpb24sIHJlZk9wdGlvbk9iaiwgcGF0aCkge1xuICAgIGxldCBvcHRpb25UeXBlID0gVmFsaWRhdG9yLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKTtcbiAgICBsZXQgcmVmT3B0aW9uVHlwZSA9IHJlZk9wdGlvbk9ialtvcHRpb25UeXBlXTtcbiAgICBpZiAocmVmT3B0aW9uVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCB3ZSBjaGVjayBpZiBpdCBpcyBzdXBwb3NlZCB0byBiZSBvbmUgb2YgYSBmZXcgc2VsZWN0IHZhbHVlc1xuICAgICAgaWYgKFZhbGlkYXRvci5nZXRUeXBlKHJlZk9wdGlvblR5cGUpID09PSAnYXJyYXknKSB7XG4gICAgICAgIGlmIChyZWZPcHRpb25UeXBlLmluZGV4T2Yob3B0aW9uc1tvcHRpb25dKSA9PT0gLTEpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnJWNJbnZhbGlkIG9wdGlvbiBkZXRlY3RlZCBpbiBcIicgKyBvcHRpb24gKyAnXCIuJyArXG4gICAgICAgICAgICAnIEFsbG93ZWQgdmFsdWVzIGFyZTonICsgVmFsaWRhdG9yLnByaW50KHJlZk9wdGlvblR5cGUpICsgJyBub3QgXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiLiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9uVHlwZSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlT3B0aW9uICE9PSBcIl9fYW55X19cIikge1xuICAgICAgICAgIHBhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBvcHRpb24pO1xuICAgICAgICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zW29wdGlvbl0sIHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wdGlvblR5cGUgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZU9wdGlvbiAhPT0gXCJfX2FueV9fXCIpIHtcbiAgICAgICAgcGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zW29wdGlvbl0sIHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXSwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZk9wdGlvbk9ialsnYW55J10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdHlwZSBvZiB0aGUgZmllbGQgaXMgaW5jb3JyZWN0IGFuZCB0aGUgZmllbGQgY2Fubm90IGJlIGFueVxuICAgICAgY29uc29sZS5sb2coJyVjSW52YWxpZCB0eXBlIHJlY2VpdmVkIGZvciBcIicgKyBvcHRpb24gKyAnXCIuIEV4cGVjdGVkOiAnICsgVmFsaWRhdG9yLnByaW50KE9iamVjdC5rZXlzKHJlZk9wdGlvbk9iaikpICsgJy4gUmVjZWl2ZWQgWycgKyBvcHRpb25UeXBlICsgJ10gXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiksIHByaW50U3R5bGUpO1xuICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgfVxuICB9XG5cblxuICBzdGF0aWMgZ2V0VHlwZShvYmplY3QpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmplY3Q7XG5cbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICdkb20nO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5faXNBTW9tZW50T2JqZWN0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAnbW9tZW50JztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzdGF0aWMgZ2V0U3VnZ2VzdGlvbihvcHRpb24sIG9wdGlvbnMsIHBhdGgpIHtcbiAgICBsZXQgbG9jYWxTZWFyY2ggPSBWYWxpZGF0b3IuZmluZEluT3B0aW9ucyhvcHRpb24sb3B0aW9ucyxwYXRoLGZhbHNlKTtcbiAgICBsZXQgZ2xvYmFsU2VhcmNoID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLGFsbE9wdGlvbnMsW10sdHJ1ZSk7XG5cbiAgICBsZXQgbG9jYWxTZWFyY2hUaHJlc2hvbGQgPSA4O1xuICAgIGxldCBnbG9iYWxTZWFyY2hUaHJlc2hvbGQgPSA0O1xuXG4gICAgaWYgKGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5sb2coJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJyArIG9wdGlvbiArICdcIiBpbiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uLCcnKSArICdQZXJoYXBzIGl0IHdhcyBpbmNvbXBsZXRlPyBEaWQgeW91IG1lYW46IFwiJyArIGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggKyAnXCI/XFxuXFxuJywgcHJpbnRTdHlsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdsb2JhbFNlYXJjaC5kaXN0YW5jZSA8PSBnbG9iYWxTZWFyY2hUaHJlc2hvbGQgJiYgbG9jYWxTZWFyY2guZGlzdGFuY2UgPiBnbG9iYWxTZWFyY2guZGlzdGFuY2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIgaW4gJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwnJykgKyAnUGVyaGFwcyBpdCB3YXMgbWlzcGxhY2VkPyBNYXRjaGluZyBvcHRpb24gZm91bmQgYXQ6ICcgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihnbG9iYWxTZWFyY2gucGF0aCwgZ2xvYmFsU2VhcmNoLmNsb3Nlc3RNYXRjaCwnJyksIHByaW50U3R5bGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2NhbFNlYXJjaC5kaXN0YW5jZSA8PSBsb2NhbFNlYXJjaFRocmVzaG9sZCkge1xuICAgICAgY29uc29sZS5sb2coJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJyArIG9wdGlvbiArICdcIi4gRGlkIHlvdSBtZWFuIFwiJyArIGxvY2FsU2VhcmNoLmNsb3Nlc3RNYXRjaCArICdcIj8nICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJyArIG9wdGlvbiArICdcIi4gRGlkIHlvdSBtZWFuIG9uZSBvZiB0aGVzZTogJyArIFZhbGlkYXRvci5wcmludChPYmplY3Qua2V5cyhvcHRpb25zKSkgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pLCBwcmludFN0eWxlKTtcbiAgICB9XG5cbiAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0cmF2ZXJzZSB0aGUgb3B0aW9ucyBpbiBzZWFyY2ggZm9yIGEgbWF0Y2guXG4gICAqIEBwYXJhbSBvcHRpb25cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIHJlY3Vyc2l2ZVxuICAgKiBAcmV0dXJucyB7e2Nsb3Nlc3RNYXRjaDogc3RyaW5nLCBwYXRoOiBBcnJheSwgZGlzdGFuY2U6IG51bWJlcn19XG4gICAqL1xuICBzdGF0aWMgZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnMsIHBhdGgsIHJlY3Vyc2l2ZSA9IGZhbHNlKSB7XG4gICAgbGV0IG1pbiA9IDFlOTtcbiAgICBsZXQgY2xvc2VzdE1hdGNoID0gJyc7XG4gICAgbGV0IGNsb3Nlc3RNYXRjaFBhdGggPSBbXTtcbiAgICBsZXQgbG93ZXJDYXNlT3B0aW9uID0gb3B0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IGluZGV4TWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgb3AgaW4gb3B0aW9ucykge1xuICAgICAgbGV0IGRpc3RhbmNlO1xuICAgICAgaWYgKG9wdGlvbnNbb3BdLl9fdHlwZV9fICE9PSB1bmRlZmluZWQgJiYgcmVjdXJzaXZlID09PSB0cnVlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBWYWxpZGF0b3IuZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnNbb3BdLCB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShwYXRoLG9wKSk7XG4gICAgICAgIGlmIChtaW4gPiByZXN1bHQuZGlzdGFuY2UpIHtcbiAgICAgICAgICBjbG9zZXN0TWF0Y2ggPSByZXN1bHQuY2xvc2VzdE1hdGNoO1xuICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSByZXN1bHQucGF0aDtcbiAgICAgICAgICBtaW4gPSByZXN1bHQuZGlzdGFuY2U7XG4gICAgICAgICAgaW5kZXhNYXRjaCA9IHJlc3VsdC5pbmRleE1hdGNoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsb3dlckNhc2VPcHRpb24pICE9PSAtMSkge1xuICAgICAgICAgIGluZGV4TWF0Y2ggPSBvcDtcbiAgICAgICAgfVxuICAgICAgICBkaXN0YW5jZSA9IFZhbGlkYXRvci5sZXZlbnNodGVpbkRpc3RhbmNlKG9wdGlvbiwgb3ApO1xuICAgICAgICBpZiAobWluID4gZGlzdGFuY2UpIHtcbiAgICAgICAgICBjbG9zZXN0TWF0Y2ggPSBvcDtcbiAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gdXRpbC5jb3B5QXJyYXkocGF0aCk7XG4gICAgICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtjbG9zZXN0TWF0Y2g6Y2xvc2VzdE1hdGNoLCBwYXRoOmNsb3Nlc3RNYXRjaFBhdGgsIGRpc3RhbmNlOm1pbiwgaW5kZXhNYXRjaDogaW5kZXhNYXRjaH07XG4gIH1cblxuICBzdGF0aWMgcHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24sIHByZWZpeCA9ICdQcm9ibGVtIHZhbHVlIGZvdW5kIGF0OiBcXG4nKSB7XG4gICAgbGV0IHN0ciA9ICdcXG5cXG4nICsgcHJlZml4ICsgJ29wdGlvbnMgPSB7XFxuJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaSArIDE7IGorKykge1xuICAgICAgICBzdHIgKz0gJyAgJztcbiAgICAgIH1cbiAgICAgIHN0ciArPSBwYXRoW2ldICsgJzoge1xcbidcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXRoLmxlbmd0aCArIDE7IGorKykge1xuICAgICAgc3RyICs9ICcgICc7XG4gICAgfVxuICAgIHN0ciArPSBvcHRpb24gKyAnXFxuJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhdGgubGVuZ3RoIC0gaTsgaisrKSB7XG4gICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgfVxuICAgICAgc3RyICs9ICd9XFxuJ1xuICAgIH1cbiAgICByZXR1cm4gc3RyICsgJ1xcblxcbic7XG4gIH1cblxuICBzdGF0aWMgcHJpbnQob3B0aW9ucykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvcHRpb25zKS5yZXBsYWNlKC8oXFxcIil8KFxcWyl8KFxcXSl8KCxcIl9fdHlwZV9fXCIpL2csIFwiXCIpLnJlcGxhY2UoLyhcXCwpL2csICcsICcpXG4gIH1cblxuXG4gIC8vIENvbXB1dGUgdGhlIGVkaXQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3NcbiAgLy8gaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9BbGdvcml0aG1fSW1wbGVtZW50YXRpb24vU3RyaW5ncy9MZXZlbnNodGVpbl9kaXN0YW5jZSNKYXZhU2NyaXB0XG4gIC8qXG4gICBDb3B5cmlnaHQgKGMpIDIwMTEgQW5kcmVpIE1hY2tlbnppZVxuXG4gICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gICAqL1xuICBzdGF0aWMgbGV2ZW5zaHRlaW5EaXN0YW5jZShhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoID09PSAwKSByZXR1cm4gYi5sZW5ndGg7XG4gICAgaWYgKGIubGVuZ3RoID09PSAwKSByZXR1cm4gYS5sZW5ndGg7XG5cbiAgICB2YXIgbWF0cml4ID0gW107XG5cbiAgICAvLyBpbmNyZW1lbnQgYWxvbmcgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIHJvd1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgbWF0cml4W2ldID0gW2ldO1xuICAgIH1cblxuICAgIC8vIGluY3JlbWVudCBlYWNoIGNvbHVtbiBpbiB0aGUgZmlyc3Qgcm93XG4gICAgdmFyIGo7XG4gICAgZm9yIChqID0gMDsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICBtYXRyaXhbMF1bal0gPSBqO1xuICAgIH1cblxuICAgIC8vIEZpbGwgaW4gdGhlIHJlc3Qgb2YgdGhlIG1hdHJpeFxuICAgIGZvciAoaSA9IDE7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChiLmNoYXJBdChpIC0gMSkgPT0gYS5jaGFyQXQoaiAtIDEpKSB7XG4gICAgICAgICAgbWF0cml4W2ldW2pdID0gbWF0cml4W2kgLSAxXVtqIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4obWF0cml4W2kgLSAxXVtqIC0gMV0gKyAxLCAvLyBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgIE1hdGgubWluKG1hdHJpeFtpXVtqIC0gMV0gKyAxLCAvLyBpbnNlcnRpb25cbiAgICAgICAgICAgICAgbWF0cml4W2kgLSAxXVtqXSArIDEpKTsgLy8gZGVsZXRpb25cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRyaXhbYi5sZW5ndGhdW2EubGVuZ3RoXTtcbiAgfVxuXG47XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVmFsaWRhdG9yO1xuZXhwb3J0IHtwcmludFN0eWxlfSJdfQ==
},{"../util":46}],26:[function(require,module,exports){
'use strict';

var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var hammerUtil = require('../hammerUtil');
var util = require('../util');
var DataSet = require('../DataSet');
var DataView = require('../DataView');
var Range = require('./Range');
var ItemSet = require('./component/ItemSet');
var TimeAxis = require('./component/TimeAxis');
var Activator = require('../shared/Activator');
var DateUtil = require('./DateUtil');
var CustomTime = require('./component/CustomTime');

/**
 * Create a timeline visualization
 * @constructor
 */
function Core() {}

// turn Core into an event emitter
Emitter(Core.prototype);

/**
 * Create the main DOM for the Core: a root panel containing left, right,
 * top, bottom, content, and background panel.
 * @param {Element} container  The container element where the Core will
 *                             be attached.
 * @protected
 */
Core.prototype._create = function (container) {
  this.dom = {};

  this.dom.container = container;

  this.dom.root = document.createElement('div');
  this.dom.background = document.createElement('div');
  this.dom.backgroundVertical = document.createElement('div');
  this.dom.backgroundHorizontal = document.createElement('div');
  this.dom.centerContainer = document.createElement('div');
  this.dom.leftContainer = document.createElement('div');
  this.dom.rightContainer = document.createElement('div');
  this.dom.center = document.createElement('div');
  this.dom.left = document.createElement('div');
  this.dom.right = document.createElement('div');
  this.dom.top = document.createElement('div');
  this.dom.bottom = document.createElement('div');
  this.dom.shadowTop = document.createElement('div');
  this.dom.shadowBottom = document.createElement('div');
  this.dom.shadowTopLeft = document.createElement('div');
  this.dom.shadowBottomLeft = document.createElement('div');
  this.dom.shadowTopRight = document.createElement('div');
  this.dom.shadowBottomRight = document.createElement('div');

  this.dom.root.className = 'vis-timeline';
  this.dom.background.className = 'vis-panel vis-background';
  this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical';
  this.dom.backgroundHorizontal.className = 'vis-panel vis-background vis-horizontal';
  this.dom.centerContainer.className = 'vis-panel vis-center';
  this.dom.leftContainer.className = 'vis-panel vis-left';
  this.dom.rightContainer.className = 'vis-panel vis-right';
  this.dom.top.className = 'vis-panel vis-top';
  this.dom.bottom.className = 'vis-panel vis-bottom';
  this.dom.left.className = 'vis-content';
  this.dom.center.className = 'vis-content';
  this.dom.right.className = 'vis-content';
  this.dom.shadowTop.className = 'vis-shadow vis-top';
  this.dom.shadowBottom.className = 'vis-shadow vis-bottom';
  this.dom.shadowTopLeft.className = 'vis-shadow vis-top';
  this.dom.shadowBottomLeft.className = 'vis-shadow vis-bottom';
  this.dom.shadowTopRight.className = 'vis-shadow vis-top';
  this.dom.shadowBottomRight.className = 'vis-shadow vis-bottom';

  this.dom.root.appendChild(this.dom.background);
  this.dom.root.appendChild(this.dom.backgroundVertical);
  this.dom.root.appendChild(this.dom.backgroundHorizontal);
  this.dom.root.appendChild(this.dom.centerContainer);
  this.dom.root.appendChild(this.dom.leftContainer);
  this.dom.root.appendChild(this.dom.rightContainer);
  this.dom.root.appendChild(this.dom.top);
  this.dom.root.appendChild(this.dom.bottom);

  this.dom.centerContainer.appendChild(this.dom.center);
  this.dom.leftContainer.appendChild(this.dom.left);
  this.dom.rightContainer.appendChild(this.dom.right);

  this.dom.centerContainer.appendChild(this.dom.shadowTop);
  this.dom.centerContainer.appendChild(this.dom.shadowBottom);
  this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);
  this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);
  this.dom.rightContainer.appendChild(this.dom.shadowTopRight);
  this.dom.rightContainer.appendChild(this.dom.shadowBottomRight);

  this.on('rangechange', (function () {
    this._redraw(); // this allows overriding the _redraw method
  }).bind(this));
  this.on('touch', this._onTouch.bind(this));
  this.on('pan', this._onDrag.bind(this));

  var me = this;
  this.on('change', function (properties) {
    if (properties && properties.queue == true) {
      // redraw once on next tick
      if (!me._redrawTimer) {
        me._redrawTimer = setTimeout(function () {
          me._redrawTimer = null;
          me._redraw();
        }, 0);
      }
    } else {
      // redraw immediately
      me._redraw();
    }
  });

  // create event listeners for all interesting events, these events will be
  // emitted via emitter
  this.hammer = new Hammer(this.dom.root);
  this.hammer.get('pinch').set({ enable: true });
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.
  this.listeners = {};

  var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'
  // TODO: cleanup
  //'touch', 'pinch',
  //'tap', 'doubletap', 'hold',
  //'dragstart', 'drag', 'dragend',
  //'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
  ];
  events.forEach(function (type) {
    var listener = function listener(event) {
      if (me.isActive()) {
        me.emit(type, event);
      }
    };
    me.hammer.on(type, listener);
    me.listeners[type] = listener;
  });

  // emulate a touch event (emitted before the start of a pan, pinch, tap, or press)
  hammerUtil.onTouch(this.hammer, (function (event) {
    me.emit('touch', event);
  }).bind(this));

  // emulate a release event (emitted after a pan, pinch, tap, or press)
  hammerUtil.onRelease(this.hammer, (function (event) {
    me.emit('release', event);
  }).bind(this));

  function onMouseWheel(event) {
    if (me.isActive()) {
      me.emit('mousewheel', event);
    }
  }
  this.dom.root.addEventListener('mousewheel', onMouseWheel);
  this.dom.root.addEventListener('DOMMouseScroll', onMouseWheel);

  // size properties of each of the panels
  this.props = {
    root: {},
    background: {},
    centerContainer: {},
    leftContainer: {},
    rightContainer: {},
    center: {},
    left: {},
    right: {},
    top: {},
    bottom: {},
    border: {},
    scrollTop: 0,
    scrollTopMin: 0
  };

  this.customTimes = [];

  // store state information needed for touch events
  this.touch = {};

  this.redrawCount = 0;

  // attach the root panel to the provided container
  if (!container) throw new Error('No container provided');
  container.appendChild(this.dom.root);
};

/**
 * Set options. Options will be passed to all components loaded in the Timeline.
 * @param {Object} [options]
 *                           {String} orientation
 *                              Vertical orientation for the Timeline,
 *                              can be 'bottom' (default) or 'top'.
 *                           {String | Number} width
 *                              Width for the timeline, a number in pixels or
 *                              a css string like '1000px' or '75%'. '100%' by default.
 *                           {String | Number} height
 *                              Fixed height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'. If undefined,
 *                              The Timeline will automatically size such that
 *                              its contents fit.
 *                           {String | Number} minHeight
 *                              Minimum height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'.
 *                           {String | Number} maxHeight
 *                              Maximum height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'.
 *                           {Number | Date | String} start
 *                              Start date for the visible window
 *                           {Number | Date | String} end
 *                              End date for the visible window
 */
Core.prototype.setOptions = function (options) {
  if (options) {
    // copy the known options
    var fields = ['width', 'height', 'minHeight', 'maxHeight', 'autoResize', 'start', 'end', 'clickToUse', 'dataAttributes', 'hiddenDates', 'locale', 'locales', 'moment', 'throttleRedraw'];
    util.selectiveExtend(fields, this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation = {
          item: options.orientation,
          axis: options.orientation
        };
      } else if (typeof options.orientation === 'object') {
        if ('item' in options.orientation) {
          this.options.orientation.item = options.orientation.item;
        }
        if ('axis' in options.orientation) {
          this.options.orientation.axis = options.orientation.axis;
        }
      }
    }

    if (this.options.orientation.axis === 'both') {
      if (!this.timeAxis2) {
        var timeAxis2 = this.timeAxis2 = new TimeAxis(this.body);
        timeAxis2.setOptions = function (options) {
          var _options = options ? util.extend({}, options) : {};
          _options.orientation = 'top'; // override the orientation option, always top
          TimeAxis.prototype.setOptions.call(timeAxis2, _options);
        };
        this.components.push(timeAxis2);
      }
    } else {
      if (this.timeAxis2) {
        var index = this.components.indexOf(this.timeAxis2);
        if (index !== -1) {
          this.components.splice(index, 1);
        }
        this.timeAxis2.destroy();
        this.timeAxis2 = null;
      }
    }

    // if the graph2d's drawPoints is a function delegate the callback to the onRender property
    if (typeof options.drawPoints == 'function') {
      options.drawPoints = {
        onRender: options.drawPoints
      };
    }

    if ('hiddenDates' in this.options) {
      DateUtil.convertHiddenOptions(this.options.moment, this.body, this.options.hiddenDates);
    }

    if ('clickToUse' in options) {
      if (options.clickToUse) {
        if (!this.activator) {
          this.activator = new Activator(this.dom.root);
        }
      } else {
        if (this.activator) {
          this.activator.destroy();
          delete this.activator;
        }
      }
    }

    if ('showCustomTime' in options) {
      throw new Error('Option `showCustomTime` is deprecated. Create a custom time bar via timeline.addCustomTime(time [, id])');
    }

    // enable/disable autoResize
    this._initAutoResize();
  }

  // propagate options to all components
  this.components.forEach(function (component) {
    return component.setOptions(options);
  });

  // enable/disable configure
  if ('configure' in options) {
    if (!this.configurator) {
      this.configurator = this._createConfigurator();
    }

    this.configurator.setOptions(options.configure);

    // collect the settings of all components, and pass them to the configuration system
    var appliedOptions = util.deepExtend({}, this.options);
    this.components.forEach(function (component) {
      util.deepExtend(appliedOptions, component.options);
    });
    this.configurator.setModuleOptions({ global: appliedOptions });
  }

  // override redraw with a throttled version
  if (!this._origRedraw) {
    this._origRedraw = this._redraw.bind(this);
  }
  this._redraw = util.throttle(this._origRedraw, this.options.throttleRedraw);

  // redraw everything
  this._redraw();
};

/**
 * Returns true when the Timeline is active.
 * @returns {boolean}
 */
Core.prototype.isActive = function () {
  return !this.activator || this.activator.active;
};

/**
 * Destroy the Core, clean up all DOM elements and event listeners.
 */
Core.prototype.destroy = function () {
  // unbind datasets
  this.setItems(null);
  this.setGroups(null);

  // remove all event listeners
  this.off();

  // stop checking for changed size
  this._stopAutoResize();

  // remove from DOM
  if (this.dom.root.parentNode) {
    this.dom.root.parentNode.removeChild(this.dom.root);
  }
  this.dom = null;

  // remove Activator
  if (this.activator) {
    this.activator.destroy();
    delete this.activator;
  }

  // cleanup hammer touch events
  for (var event in this.listeners) {
    if (this.listeners.hasOwnProperty(event)) {
      delete this.listeners[event];
    }
  }
  this.listeners = null;
  this.hammer = null;

  // give all components the opportunity to cleanup
  this.components.forEach(function (component) {
    return component.destroy();
  });

  this.body = null;
};

/**
 * Set a custom time bar
 * @param {Date} time
 * @param {number} [id=undefined] Optional id of the custom time bar to be adjusted.
 */
Core.prototype.setCustomTime = function (time, id) {
  var customTimes = this.customTimes.filter(function (component) {
    return id === component.options.id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }

  if (customTimes.length > 0) {
    customTimes[0].setCustomTime(time);
  }
};

/**
 * Retrieve the current custom time.
 * @param {number} [id=undefined]    Id of the custom time bar.
 * @return {Date | undefined} customTime
 */
Core.prototype.getCustomTime = function (id) {
  var customTimes = this.customTimes.filter(function (component) {
    return component.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }
  return customTimes[0].getCustomTime();
};

/**
 * Set a custom title for the custom time bar.
 * @param {String} [title] Custom title
 * @param {number} [id=undefined]    Id of the custom time bar.
 */
Core.prototype.setCustomTimeTitle = function (title, id) {
  var customTimes = this.customTimes.filter(function (component) {
    return component.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }
  if (customTimes.length > 0) {
    return customTimes[0].setCustomTitle(title);
  }
};

/**
 * Retrieve meta information from an event.
 * Should be overridden by classes extending Core
 * @param {Event} event
 * @return {Object} An object with related information.
 */
Core.prototype.getEventProperties = function (event) {
  return { event: event };
};

/**
 * Add custom vertical bar
 * @param {Date | String | Number} [time]  A Date, unix timestamp, or
 *                                         ISO date string. Time point where
 *                                         the new bar should be placed.
 *                                         If not provided, `new Date()` will
 *                                         be used.
 * @param {Number | String} [id=undefined] Id of the new bar. Optional
 * @return {Number | String}               Returns the id of the new bar
 */
Core.prototype.addCustomTime = function (time, id) {
  var timestamp = time !== undefined ? util.convert(time, 'Date').valueOf() : new Date();

  var exists = this.customTimes.some(function (customTime) {
    return customTime.options.id === id;
  });
  if (exists) {
    throw new Error('A custom time with id ' + JSON.stringify(id) + ' already exists');
  }

  var customTime = new CustomTime(this.body, util.extend({}, this.options, {
    time: timestamp,
    id: id
  }));

  this.customTimes.push(customTime);
  this.components.push(customTime);
  this._redraw();

  return id;
};

/**
 * Remove previously added custom bar
 * @param {int} id ID of the custom bar to be removed
 * @return {boolean} True if the bar exists and is removed, false otherwise
 */
Core.prototype.removeCustomTime = function (id) {
  var customTimes = this.customTimes.filter(function (bar) {
    return bar.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }

  customTimes.forEach((function (customTime) {
    this.customTimes.splice(this.customTimes.indexOf(customTime), 1);
    this.components.splice(this.components.indexOf(customTime), 1);
    customTime.destroy();
  }).bind(this));
};

/**
 * Get the id's of the currently visible items.
 * @returns {Array} The ids of the visible items
 */
Core.prototype.getVisibleItems = function () {
  return this.itemSet && this.itemSet.getVisibleItems() || [];
};

/**
 * Set Core window such that it fits all items
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.fit = function (options) {
  var range = this.getDataRange();

  // skip range set if there is no min and max date
  if (range.min === null && range.max === null) {
    return;
  }

  // apply a margin of 1% left and right of the data
  var interval = range.max - range.min;
  var min = new Date(range.min.valueOf() - interval * 0.01);
  var max = new Date(range.max.valueOf() + interval * 0.01);

  var animation = options && options.animation !== undefined ? options.animation : true;
  this.range.setRange(min, max, animation);
};

/**
 * Calculate the data range of the items start and end dates
 * @returns {{min: Date | null, max: Date | null}}
 * @protected
 */
Core.prototype.getDataRange = function () {
  // must be implemented by Timeline and Graph2d
  throw new Error('Cannot invoke abstract method getDataRange');
};

/**
 * Set the visible window. Both parameters are optional, you can change only
 * start or only end. Syntax:
 *
 *     TimeLine.setWindow(start, end)
 *     TimeLine.setWindow(start, end, options)
 *     TimeLine.setWindow(range)
 *
 * Where start and end can be a Date, number, or string, and range is an
 * object with properties start and end.
 *
 * @param {Date | Number | String | Object} [start] Start date of visible window
 * @param {Date | Number | String} [end]            End date of visible window
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.setWindow = function (start, end, options) {
  var animation;
  if (arguments.length == 1) {
    var range = arguments[0];
    animation = range.animation !== undefined ? range.animation : true;
    this.range.setRange(range.start, range.end, animation);
  } else {
    animation = options && options.animation !== undefined ? options.animation : true;
    this.range.setRange(start, end, animation);
  }
};

/**
 * Move the window such that given time is centered on screen.
 * @param {Date | Number | String} time
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.moveTo = function (time, options) {
  var interval = this.range.end - this.range.start;
  var t = util.convert(time, 'Date').valueOf();

  var start = t - interval / 2;
  var end = t + interval / 2;
  var animation = options && options.animation !== undefined ? options.animation : true;

  this.range.setRange(start, end, animation);
};

/**
 * Get the visible window
 * @return {{start: Date, end: Date}}   Visible range
 */
Core.prototype.getWindow = function () {
  var range = this.range.getRange();
  return {
    start: new Date(range.start),
    end: new Date(range.end)
  };
};

/**
 * Force a redraw. Can be overridden by implementations of Core
 *
 * Note: this function will be overridden on construction with a trottled version
 */
Core.prototype.redraw = function () {
  this._redraw();
};

/**
 * Redraw for internal use. Redraws all components. See also the public
 * method redraw.
 * @protected
 */
Core.prototype._redraw = function () {
  var resized = false;
  var options = this.options;
  var props = this.props;
  var dom = this.dom;

  if (!dom) return; // when destroyed

  DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);

  // update class names
  if (options.orientation == 'top') {
    util.addClassName(dom.root, 'vis-top');
    util.removeClassName(dom.root, 'vis-bottom');
  } else {
    util.removeClassName(dom.root, 'vis-top');
    util.addClassName(dom.root, 'vis-bottom');
  }

  // update root width and height options
  dom.root.style.maxHeight = util.option.asSize(options.maxHeight, '');
  dom.root.style.minHeight = util.option.asSize(options.minHeight, '');
  dom.root.style.width = util.option.asSize(options.width, '');

  // calculate border widths
  props.border.left = (dom.centerContainer.offsetWidth - dom.centerContainer.clientWidth) / 2;
  props.border.right = props.border.left;
  props.border.top = (dom.centerContainer.offsetHeight - dom.centerContainer.clientHeight) / 2;
  props.border.bottom = props.border.top;
  var borderRootHeight = dom.root.offsetHeight - dom.root.clientHeight;
  var borderRootWidth = dom.root.offsetWidth - dom.root.clientWidth;

  // workaround for a bug in IE: the clientWidth of an element with
  // a height:0px and overflow:hidden is not calculated and always has value 0
  if (dom.centerContainer.clientHeight === 0) {
    props.border.left = props.border.top;
    props.border.right = props.border.left;
  }
  if (dom.root.clientHeight === 0) {
    borderRootWidth = borderRootHeight;
  }

  // calculate the heights. If any of the side panels is empty, we set the height to
  // minus the border width, such that the border will be invisible
  props.center.height = dom.center.offsetHeight;
  props.left.height = dom.left.offsetHeight;
  props.right.height = dom.right.offsetHeight;
  props.top.height = dom.top.clientHeight || -props.border.top;
  props.bottom.height = dom.bottom.clientHeight || -props.border.bottom;

  // TODO: compensate borders when any of the panels is empty.

  // apply auto height
  // TODO: only calculate autoHeight when needed (else we cause an extra reflow/repaint of the DOM)
  var contentHeight = Math.max(props.left.height, props.center.height, props.right.height);
  var autoHeight = props.top.height + contentHeight + props.bottom.height + borderRootHeight + props.border.top + props.border.bottom;
  dom.root.style.height = util.option.asSize(options.height, autoHeight + 'px');

  // calculate heights of the content panels
  props.root.height = dom.root.offsetHeight;
  props.background.height = props.root.height - borderRootHeight;
  var containerHeight = props.root.height - props.top.height - props.bottom.height - borderRootHeight;
  props.centerContainer.height = containerHeight;
  props.leftContainer.height = containerHeight;
  props.rightContainer.height = props.leftContainer.height;

  // calculate the widths of the panels
  props.root.width = dom.root.offsetWidth;
  props.background.width = props.root.width - borderRootWidth;
  props.left.width = dom.leftContainer.clientWidth || -props.border.left;
  props.leftContainer.width = props.left.width;
  props.right.width = dom.rightContainer.clientWidth || -props.border.right;
  props.rightContainer.width = props.right.width;
  var centerWidth = props.root.width - props.left.width - props.right.width - borderRootWidth;
  props.center.width = centerWidth;
  props.centerContainer.width = centerWidth;
  props.top.width = centerWidth;
  props.bottom.width = centerWidth;

  // resize the panels
  dom.background.style.height = props.background.height + 'px';
  dom.backgroundVertical.style.height = props.background.height + 'px';
  dom.backgroundHorizontal.style.height = props.centerContainer.height + 'px';
  dom.centerContainer.style.height = props.centerContainer.height + 'px';
  dom.leftContainer.style.height = props.leftContainer.height + 'px';
  dom.rightContainer.style.height = props.rightContainer.height + 'px';

  dom.background.style.width = props.background.width + 'px';
  dom.backgroundVertical.style.width = props.centerContainer.width + 'px';
  dom.backgroundHorizontal.style.width = props.background.width + 'px';
  dom.centerContainer.style.width = props.center.width + 'px';
  dom.top.style.width = props.top.width + 'px';
  dom.bottom.style.width = props.bottom.width + 'px';

  // reposition the panels
  dom.background.style.left = '0';
  dom.background.style.top = '0';
  dom.backgroundVertical.style.left = props.left.width + props.border.left + 'px';
  dom.backgroundVertical.style.top = '0';
  dom.backgroundHorizontal.style.left = '0';
  dom.backgroundHorizontal.style.top = props.top.height + 'px';
  dom.centerContainer.style.left = props.left.width + 'px';
  dom.centerContainer.style.top = props.top.height + 'px';
  dom.leftContainer.style.left = '0';
  dom.leftContainer.style.top = props.top.height + 'px';
  dom.rightContainer.style.left = props.left.width + props.center.width + 'px';
  dom.rightContainer.style.top = props.top.height + 'px';
  dom.top.style.left = props.left.width + 'px';
  dom.top.style.top = '0';
  dom.bottom.style.left = props.left.width + 'px';
  dom.bottom.style.top = props.top.height + props.centerContainer.height + 'px';

  // update the scrollTop, feasible range for the offset can be changed
  // when the height of the Core or of the contents of the center changed
  this._updateScrollTop();

  // reposition the scrollable contents
  var offset = this.props.scrollTop;
  if (options.orientation.item != 'top') {
    offset += Math.max(this.props.centerContainer.height - this.props.center.height - this.props.border.top - this.props.border.bottom, 0);
  }
  dom.center.style.left = '0';
  dom.center.style.top = offset + 'px';
  dom.left.style.left = '0';
  dom.left.style.top = offset + 'px';
  dom.right.style.left = '0';
  dom.right.style.top = offset + 'px';

  // show shadows when vertical scrolling is available
  var visibilityTop = this.props.scrollTop == 0 ? 'hidden' : '';
  var visibilityBottom = this.props.scrollTop == this.props.scrollTopMin ? 'hidden' : '';
  dom.shadowTop.style.visibility = visibilityTop;
  dom.shadowBottom.style.visibility = visibilityBottom;
  dom.shadowTopLeft.style.visibility = visibilityTop;
  dom.shadowBottomLeft.style.visibility = visibilityBottom;
  dom.shadowTopRight.style.visibility = visibilityTop;
  dom.shadowBottomRight.style.visibility = visibilityBottom;

  // redraw all components
  this.components.forEach(function (component) {
    resized = component.redraw() || resized;
  });
  if (resized) {
    // keep repainting until all sizes are settled
    var MAX_REDRAWS = 3; // maximum number of consecutive redraws
    if (this.redrawCount < MAX_REDRAWS) {
      this.redrawCount++;
      this._redraw();
    } else {
      console.log('WARNING: infinite loop in redraw?');
    }
    this.redrawCount = 0;
  }
};

// TODO: deprecated since version 1.1.0, remove some day
Core.prototype.repaint = function () {
  throw new Error('Function repaint is deprecated. Use redraw instead.');
};

/**
 * Set a current time. This can be used for example to ensure that a client's
 * time is synchronized with a shared server time.
 * Only applicable when option `showCurrentTime` is true.
 * @param {Date | String | Number} time     A Date, unix timestamp, or
 *                                          ISO date string.
 */
Core.prototype.setCurrentTime = function (time) {
  if (!this.currentTime) {
    throw new Error('Option showCurrentTime must be true');
  }

  this.currentTime.setCurrentTime(time);
};

/**
 * Get the current time.
 * Only applicable when option `showCurrentTime` is true.
 * @return {Date} Returns the current time.
 */
Core.prototype.getCurrentTime = function () {
  if (!this.currentTime) {
    throw new Error('Option showCurrentTime must be true');
  }

  return this.currentTime.getCurrentTime();
};

/**
 * Convert a position on screen (pixels) to a datetime
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toTime = function (x) {
  return DateUtil.toTime(this, x, this.props.center.width);
};

/**
 * Convert a position on the global screen (pixels) to a datetime
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toGlobalTime = function (x) {
  return DateUtil.toTime(this, x, this.props.root.width);
  //var conversion = this.range.conversion(this.props.root.width);
  //return new Date(x / conversion.scale + conversion.offset);
};

/**
 * Convert a datetime (Date object) into a position on the screen
 * @param {Date}   time A date
 * @return {int}   x    The position on the screen in pixels which corresponds
 *                      with the given date.
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toScreen = function (time) {
  return DateUtil.toScreen(this, time, this.props.center.width);
};

/**
 * Convert a datetime (Date object) into a position on the root
 * This is used to get the pixel density estimate for the screen, not the center panel
 * @param {Date}   time A date
 * @return {int}   x    The position on root in pixels which corresponds
 *                      with the given date.
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toGlobalScreen = function (time) {
  return DateUtil.toScreen(this, time, this.props.root.width);
  //var conversion = this.range.conversion(this.props.root.width);
  //return (time.valueOf() - conversion.offset) * conversion.scale;
};

/**
 * Initialize watching when option autoResize is true
 * @private
 */
Core.prototype._initAutoResize = function () {
  if (this.options.autoResize == true) {
    this._startAutoResize();
  } else {
    this._stopAutoResize();
  }
};

/**
 * Watch for changes in the size of the container. On resize, the Panel will
 * automatically redraw itself.
 * @private
 */
Core.prototype._startAutoResize = function () {
  var me = this;

  this._stopAutoResize();

  this._onResize = function () {
    if (me.options.autoResize != true) {
      // stop watching when the option autoResize is changed to false
      me._stopAutoResize();
      return;
    }

    if (me.dom.root) {
      // check whether the frame is resized
      // Note: we compare offsetWidth here, not clientWidth. For some reason,
      // IE does not restore the clientWidth from 0 to the actual width after
      // changing the timeline's container display style from none to visible
      if (me.dom.root.offsetWidth != me.props.lastWidth || me.dom.root.offsetHeight != me.props.lastHeight) {
        me.props.lastWidth = me.dom.root.offsetWidth;
        me.props.lastHeight = me.dom.root.offsetHeight;

        me.emit('change');
      }
    }
  };

  // add event listener to window resize
  util.addEventListener(window, 'resize', this._onResize);

  this.watchTimer = setInterval(this._onResize, 1000);
};

/**
 * Stop watching for a resize of the frame.
 * @private
 */
Core.prototype._stopAutoResize = function () {
  if (this.watchTimer) {
    clearInterval(this.watchTimer);
    this.watchTimer = undefined;
  }

  // remove event listener on window.resize
  if (this._onResize) {
    util.removeEventListener(window, 'resize', this._onResize);
    this._onResize = null;
  }
};

/**
 * Start moving the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onTouch = function (event) {
  this.touch.allowDragging = true;
  this.touch.initialScrollTop = this.props.scrollTop;
};

/**
 * Start moving the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onPinch = function (event) {
  this.touch.allowDragging = false;
};

/**
 * Move the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onDrag = function (event) {
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.touch.allowDragging) return;

  var delta = event.deltaY;

  var oldScrollTop = this._getScrollTop();
  var newScrollTop = this._setScrollTop(this.touch.initialScrollTop + delta);

  if (newScrollTop != oldScrollTop) {
    this._redraw(); // TODO: this causes two redraws when dragging, the other is triggered by rangechange already
    this.emit("verticalDrag");
  }
};

/**
 * Apply a scrollTop
 * @param {Number} scrollTop
 * @returns {Number} scrollTop  Returns the applied scrollTop
 * @private
 */
Core.prototype._setScrollTop = function (scrollTop) {
  this.props.scrollTop = scrollTop;
  this._updateScrollTop();
  return this.props.scrollTop;
};

/**
 * Update the current scrollTop when the height of  the containers has been changed
 * @returns {Number} scrollTop  Returns the applied scrollTop
 * @private
 */
Core.prototype._updateScrollTop = function () {
  // recalculate the scrollTopMin
  var scrollTopMin = Math.min(this.props.centerContainer.height - this.props.center.height, 0); // is negative or zero
  if (scrollTopMin != this.props.scrollTopMin) {
    // in case of bottom orientation, change the scrollTop such that the contents
    // do not move relative to the time axis at the bottom
    if (this.options.orientation.item != 'top') {
      this.props.scrollTop += scrollTopMin - this.props.scrollTopMin;
    }
    this.props.scrollTopMin = scrollTopMin;
  }

  // limit the scrollTop to the feasible scroll range
  if (this.props.scrollTop > 0) this.props.scrollTop = 0;
  if (this.props.scrollTop < scrollTopMin) this.props.scrollTop = scrollTopMin;

  return this.props.scrollTop;
};

/**
 * Get the current scrollTop
 * @returns {number} scrollTop
 * @private
 */
Core.prototype._getScrollTop = function () {
  return this.props.scrollTop;
};

/**
 * Load a configurator
 * @return {Object}
 * @private
 */
Core.prototype._createConfigurator = function () {
  throw new Error('Cannot invoke abstract method _createConfigurator');
};

module.exports = Core;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL0NvcmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUMzQyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUN6QyxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDMUMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzlCLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNwQyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdEMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQy9CLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQzdDLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQy9DLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQy9DLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNyQyxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsd0JBQXdCLENBQUMsQ0FBQzs7Ozs7O0FBTW5ELFNBQVMsSUFBSSxHQUFJLEVBQUU7OztBQUduQixPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7Ozs7Ozs7QUFTeEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsVUFBVSxTQUFTLEVBQUU7QUFDNUMsTUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUM7O0FBRWQsTUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcs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QUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ2xELE1BQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ25ELE1BQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3hDLE1BQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUUzQyxNQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN0RCxNQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNsRCxNQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFcEQsTUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDekQsTUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDNUQsTUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDM0QsTUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUM5RCxNQUFJLENBQUMsR0FBRyxD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O0FBQzFDLFVBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxJQUFLLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQUFBQyxDQUFDO0tBQ2xFO0FBQ0QsUUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO0dBQ3hDOzs7QUFHRCxNQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7QUFDdkQsTUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxZQUFZLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsWUFBWSxDQUFDOztBQUU3RSxTQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDO0NBQzdCLENBQUM7Ozs7Ozs7QUFPRixJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxZQUFZO0FBQ3pDLFNBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7Q0FDN0IsQ0FBQzs7Ozs7OztBQU9GLElBQUksQ0FBQyxTQUFTLENBQUMsbUJBQW1CLEdBQUcsWUFBWTtBQUMvQyxRQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7Q0FDdEUsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9Db3JlLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdlbWl0dGVyLWNvbXBvbmVudCcpO1xudmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciBoYW1tZXJVdGlsID0gcmVxdWlyZSgnLi4vaGFtbWVyVXRpbCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgRGF0YVNldCA9IHJlcXVpcmUoJy4uL0RhdGFTZXQnKTtcbnZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4uL0RhdGFWaWV3Jyk7XG52YXIgUmFuZ2UgPSByZXF1aXJlKCcuL1JhbmdlJyk7XG52YXIgSXRlbVNldCA9IHJlcXVpcmUoJy4vY29tcG9uZW50L0l0ZW1TZXQnKTtcbnZhciBUaW1lQXhpcyA9IHJlcXVpcmUoJy4vY29tcG9uZW50L1RpbWVBeGlzJyk7XG52YXIgQWN0aXZhdG9yID0gcmVxdWlyZSgnLi4vc2hhcmVkL0FjdGl2YXRvcicpO1xudmFyIERhdGVVdGlsID0gcmVxdWlyZSgnLi9EYXRlVXRpbCcpO1xudmFyIEN1c3RvbVRpbWUgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9DdXN0b21UaW1lJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgdGltZWxpbmUgdmlzdWFsaXphdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvcmUgKCkge31cblxuLy8gdHVybiBDb3JlIGludG8gYW4gZXZlbnQgZW1pdHRlclxuRW1pdHRlcihDb3JlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtYWluIERPTSBmb3IgdGhlIENvcmU6IGEgcm9vdCBwYW5lbCBjb250YWluaW5nIGxlZnQsIHJpZ2h0LFxuICogdG9wLCBib3R0b20sIGNvbnRlbnQsIGFuZCBiYWNrZ3JvdW5kIHBhbmVsLlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgIFRoZSBjb250YWluZXIgZWxlbWVudCB3aGVyZSB0aGUgQ29yZSB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgYXR0YWNoZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvcmUucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gIHRoaXMuZG9tID0ge307XG5cbiAgdGhpcy5kb20uY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gIHRoaXMuZG9tLnJvb3QgICAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmRWZXJ0aWNhbCAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lciAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmxlZnRDb250YWluZXIgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmNlbnRlciAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmxlZnQgICAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnJpZ2h0ICAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnRvcCAgICAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJvdHRvbSAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd1RvcCAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd0JvdHRvbSAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd1RvcExlZnQgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd0JvdHRvbUxlZnQgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd1RvcFJpZ2h0ICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd0JvdHRvbVJpZ2h0ICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgdGhpcy5kb20ucm9vdC5jbGFzc05hbWUgICAgICAgICAgICAgICAgID0gJ3Zpcy10aW1lbGluZSc7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQuY2xhc3NOYW1lICAgICAgICAgICA9ICd2aXMtcGFuZWwgdmlzLWJhY2tncm91bmQnO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuY2xhc3NOYW1lICAgPSAndmlzLXBhbmVsIHZpcy1iYWNrZ3JvdW5kIHZpcy12ZXJ0aWNhbCc7XG4gIHRoaXMuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLmNsYXNzTmFtZSA9ICd2aXMtcGFuZWwgdmlzLWJhY2tncm91bmQgdmlzLWhvcml6b250YWwnO1xuICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuY2xhc3NOYW1lICAgICAgPSAndmlzLXBhbmVsIHZpcy1jZW50ZXInO1xuICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyLmNsYXNzTmFtZSAgICAgICAgPSAndmlzLXBhbmVsIHZpcy1sZWZ0JztcbiAgdGhpcy5kb20ucmlnaHRDb250YWluZXIuY2xhc3NOYW1lICAgICAgID0gJ3Zpcy1wYW5lbCB2aXMtcmlnaHQnO1xuICB0aGlzLmRvbS50b3AuY2xhc3NOYW1lICAgICAgICAgICAgICAgICAgPSAndmlzLXBhbmVsIHZpcy10b3AnO1xuICB0aGlzLmRvbS5ib3R0b20uY2xhc3NOYW1lICAgICAgICAgICAgICAgPSAndmlzLXBhbmVsIHZpcy1ib3R0b20nO1xuICB0aGlzLmRvbS5sZWZ0LmNsYXNzTmFtZSAgICAgICAgICAgICAgICAgPSAndmlzLWNvbnRlbnQnO1xuICB0aGlzLmRvbS5jZW50ZXIuY2xhc3NOYW1lICAgICAgICAgICAgICAgPSAndmlzLWNvbnRlbnQnO1xuICB0aGlzLmRvbS5yaWdodC5jbGFzc05hbWUgICAgICAgICAgICAgICAgPSAndmlzLWNvbnRlbnQnO1xuICB0aGlzLmRvbS5zaGFkb3dUb3AuY2xhc3NOYW1lICAgICAgICAgICAgPSAndmlzLXNoYWRvdyB2aXMtdG9wJztcbiAgdGhpcy5kb20uc2hhZG93Qm90dG9tLmNsYXNzTmFtZSAgICAgICAgID0gJ3Zpcy1zaGFkb3cgdmlzLWJvdHRvbSc7XG4gIHRoaXMuZG9tLnNoYWRvd1RvcExlZnQuY2xhc3NOYW1lICAgICAgICA9ICd2aXMtc2hhZG93IHZpcy10b3AnO1xuICB0aGlzLmRvbS5zaGFkb3dCb3R0b21MZWZ0LmNsYXNzTmFtZSAgICAgPSAndmlzLXNoYWRvdyB2aXMtYm90dG9tJztcbiAgdGhpcy5kb20uc2hhZG93VG9wUmlnaHQuY2xhc3NOYW1lICAgICAgID0gJ3Zpcy1zaGFkb3cgdmlzLXRvcCc7XG4gIHRoaXMuZG9tLnNoYWRvd0JvdHRvbVJpZ2h0LmNsYXNzTmFtZSAgICA9ICd2aXMtc2hhZG93IHZpcy1ib3R0b20nO1xuXG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZCk7XG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZFZlcnRpY2FsKTtcbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbCk7XG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uY2VudGVyQ29udGFpbmVyKTtcbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5sZWZ0Q29udGFpbmVyKTtcbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5yaWdodENvbnRhaW5lcik7XG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20udG9wKTtcbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5ib3R0b20pO1xuXG4gIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5jZW50ZXIpO1xuICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLmxlZnQpO1xuICB0aGlzLmRvbS5yaWdodENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5yaWdodCk7XG5cbiAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd1RvcCk7XG4gIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dCb3R0b20pO1xuICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd1RvcExlZnQpO1xuICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd0JvdHRvbUxlZnQpO1xuICB0aGlzLmRvbS5yaWdodENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dUb3BSaWdodCk7XG4gIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd0JvdHRvbVJpZ2h0KTtcblxuICB0aGlzLm9uKCdyYW5nZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZWRyYXcoKTsgLy8gdGhpcyBhbGxvd3Mgb3ZlcnJpZGluZyB0aGUgX3JlZHJhdyBtZXRob2RcbiAgfS5iaW5kKHRoaXMpKTtcbiAgdGhpcy5vbigndG91Y2gnLCAgICAgICB0aGlzLl9vblRvdWNoLmJpbmQodGhpcykpO1xuICB0aGlzLm9uKCdwYW4nLCAgICAgICAgIHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpKTtcblxuICB2YXIgbWUgPSB0aGlzO1xuICB0aGlzLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgIGlmIChwcm9wZXJ0aWVzICYmIHByb3BlcnRpZXMucXVldWUgPT0gdHJ1ZSkge1xuICAgICAgLy8gcmVkcmF3IG9uY2Ugb24gbmV4dCB0aWNrXG4gICAgICBpZiAoIW1lLl9yZWRyYXdUaW1lcikge1xuICAgICAgICBtZS5fcmVkcmF3VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZS5fcmVkcmF3VGltZXIgPSBudWxsO1xuICAgICAgICAgIG1lLl9yZWRyYXcoKTtcbiAgICAgICAgfSwgMClcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyByZWRyYXcgaW1tZWRpYXRlbHlcbiAgICAgIG1lLl9yZWRyYXcoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNyZWF0ZSBldmVudCBsaXN0ZW5lcnMgZm9yIGFsbCBpbnRlcmVzdGluZyBldmVudHMsIHRoZXNlIGV2ZW50cyB3aWxsIGJlXG4gIC8vIGVtaXR0ZWQgdmlhIGVtaXR0ZXJcbiAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuZG9tLnJvb3QpO1xuICB0aGlzLmhhbW1lci5nZXQoJ3BpbmNoJykuc2V0KHtlbmFibGU6IHRydWV9KTtcbiAgdGhpcy5oYW1tZXIuZ2V0KCdwYW4nKS5zZXQoe3RocmVzaG9sZDo1LCBkaXJlY3Rpb246MzB9KTsgLy8gMzAgaXMgQUxMX0RJUkVDVElPTlMgaW4gaGFtbWVyLlxuICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuXG4gIHZhciBldmVudHMgPSBbXG4gICAgJ3RhcCcsICdkb3VibGV0YXAnLCAncHJlc3MnLFxuICAgICdwaW5jaCcsXG4gICAgJ3BhbicsICdwYW5zdGFydCcsICdwYW5tb3ZlJywgJ3BhbmVuZCdcbiAgICAgIC8vIFRPRE86IGNsZWFudXBcbiAgICAvLyd0b3VjaCcsICdwaW5jaCcsXG4gICAgLy8ndGFwJywgJ2RvdWJsZXRhcCcsICdob2xkJyxcbiAgICAvLydkcmFnc3RhcnQnLCAnZHJhZycsICdkcmFnZW5kJyxcbiAgICAvLydtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJyAvLyBET01Nb3VzZVNjcm9sbCBpcyBuZWVkZWQgZm9yIEZpcmVmb3hcbiAgXTtcbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChtZS5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIG1lLmVtaXQodHlwZSwgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgbWUuaGFtbWVyLm9uKHR5cGUsIGxpc3RlbmVyKTtcbiAgICBtZS5saXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgfSk7XG5cbiAgLy8gZW11bGF0ZSBhIHRvdWNoIGV2ZW50IChlbWl0dGVkIGJlZm9yZSB0aGUgc3RhcnQgb2YgYSBwYW4sIHBpbmNoLCB0YXAsIG9yIHByZXNzKVxuICBoYW1tZXJVdGlsLm9uVG91Y2godGhpcy5oYW1tZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIG1lLmVtaXQoJ3RvdWNoJywgZXZlbnQpO1xuICB9LmJpbmQodGhpcykpO1xuXG4gIC8vIGVtdWxhdGUgYSByZWxlYXNlIGV2ZW50IChlbWl0dGVkIGFmdGVyIGEgcGFuLCBwaW5jaCwgdGFwLCBvciBwcmVzcylcbiAgaGFtbWVyVXRpbC5vblJlbGVhc2UodGhpcy5oYW1tZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIG1lLmVtaXQoJ3JlbGVhc2UnLCBldmVudCk7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgZnVuY3Rpb24gb25Nb3VzZVdoZWVsKGV2ZW50KSB7XG4gICAgaWYgKG1lLmlzQWN0aXZlKCkpIHtcbiAgICAgIG1lLmVtaXQoJ21vdXNld2hlZWwnLCBldmVudCk7XG4gICAgfVxuICB9XG4gIHRoaXMuZG9tLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIG9uTW91c2VXaGVlbCk7XG4gIHRoaXMuZG9tLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBvbk1vdXNlV2hlZWwpO1xuXG4gIC8vIHNpemUgcHJvcGVydGllcyBvZiBlYWNoIG9mIHRoZSBwYW5lbHNcbiAgdGhpcy5wcm9wcyA9IHtcbiAgICByb290OiB7fSxcbiAgICBiYWNrZ3JvdW5kOiB7fSxcbiAgICBjZW50ZXJDb250YWluZXI6IHt9LFxuICAgIGxlZnRDb250YWluZXI6IHt9LFxuICAgIHJpZ2h0Q29udGFpbmVyOiB7fSxcbiAgICBjZW50ZXI6IHt9LFxuICAgIGxlZnQ6IHt9LFxuICAgIHJpZ2h0OiB7fSxcbiAgICB0b3A6IHt9LFxuICAgIGJvdHRvbToge30sXG4gICAgYm9yZGVyOiB7fSxcbiAgICBzY3JvbGxUb3A6IDAsXG4gICAgc2Nyb2xsVG9wTWluOiAwXG4gIH07XG5cbiAgdGhpcy5jdXN0b21UaW1lcyA9IFtdO1xuXG4gIC8vIHN0b3JlIHN0YXRlIGluZm9ybWF0aW9uIG5lZWRlZCBmb3IgdG91Y2ggZXZlbnRzXG4gIHRoaXMudG91Y2ggPSB7fTtcblxuICB0aGlzLnJlZHJhd0NvdW50ID0gMDtcblxuICAvLyBhdHRhY2ggdGhlIHJvb3QgcGFuZWwgdG8gdGhlIHByb3ZpZGVkIGNvbnRhaW5lclxuICBpZiAoIWNvbnRhaW5lcikgdGhyb3cgbmV3IEVycm9yKCdObyBjb250YWluZXIgcHJvdmlkZWQnKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnJvb3QpO1xufTtcblxuLyoqXG4gKiBTZXQgb3B0aW9ucy4gT3B0aW9ucyB3aWxsIGJlIHBhc3NlZCB0byBhbGwgY29tcG9uZW50cyBsb2FkZWQgaW4gdGhlIFRpbWVsaW5lLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBvcmllbnRhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZXJ0aWNhbCBvcmllbnRhdGlvbiBmb3IgdGhlIFRpbWVsaW5lLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW4gYmUgJ2JvdHRvbScgKGRlZmF1bHQpIG9yICd0b3AnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgTnVtYmVyfSB3aWR0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaWR0aCBmb3IgdGhlIHRpbWVsaW5lLCBhIG51bWJlciBpbiBwaXhlbHMgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzEwMDBweCcgb3IgJzc1JScuICcxMDAlJyBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgTnVtYmVyfSBoZWlnaHRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRml4ZWQgaGVpZ2h0IGZvciB0aGUgVGltZWxpbmUsIGEgbnVtYmVyIGluIHBpeGVscyBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGNzcyBzdHJpbmcgbGlrZSAnNDAwcHgnIG9yICc3NSUnLiBJZiB1bmRlZmluZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBUaW1lbGluZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2l6ZSBzdWNoIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRzIGNvbnRlbnRzIGZpdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gbWluSGVpZ2h0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1pbmltdW0gaGVpZ2h0IGZvciB0aGUgVGltZWxpbmUsIGEgbnVtYmVyIGluIHBpeGVscyBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGNzcyBzdHJpbmcgbGlrZSAnNDAwcHgnIG9yICc3NSUnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgTnVtYmVyfSBtYXhIZWlnaHRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF4aW11bSBoZWlnaHQgZm9yIHRoZSBUaW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgY3NzIHN0cmluZyBsaWtlICc0MDBweCcgb3IgJzc1JScuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBzdGFydFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdGFydCBkYXRlIGZvciB0aGUgdmlzaWJsZSB3aW5kb3dcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlciB8IERhdGUgfCBTdHJpbmd9IGVuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmQgZGF0ZSBmb3IgdGhlIHZpc2libGUgd2luZG93XG4gKi9cbkNvcmUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIC8vIGNvcHkgdGhlIGtub3duIG9wdGlvbnNcbiAgICB2YXIgZmllbGRzID0gW1xuICAgICAgJ3dpZHRoJywgJ2hlaWdodCcsICdtaW5IZWlnaHQnLCAnbWF4SGVpZ2h0JywgJ2F1dG9SZXNpemUnLFxuICAgICAgJ3N0YXJ0JywgJ2VuZCcsICdjbGlja1RvVXNlJywgJ2RhdGFBdHRyaWJ1dGVzJywgJ2hpZGRlbkRhdGVzJyxcbiAgICAgICdsb2NhbGUnLCAnbG9jYWxlcycsICdtb21lbnQnLFxuICAgICAgJ3Rocm90dGxlUmVkcmF3J1xuICAgIF07XG4gICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdvcmllbnRhdGlvbicgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPSB7XG4gICAgICAgICAgaXRlbTogb3B0aW9ucy5vcmllbnRhdGlvbixcbiAgICAgICAgICBheGlzOiBvcHRpb25zLm9yaWVudGF0aW9uXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKCdpdGVtJyBpbiBvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPSBvcHRpb25zLm9yaWVudGF0aW9uLml0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdheGlzJyBpbiBvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPSBvcHRpb25zLm9yaWVudGF0aW9uLmF4aXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPT09ICdib3RoJykge1xuICAgICAgaWYgKCF0aGlzLnRpbWVBeGlzMikge1xuICAgICAgICB2YXIgdGltZUF4aXMyID0gdGhpcy50aW1lQXhpczIgPSBuZXcgVGltZUF4aXModGhpcy5ib2R5KTtcbiAgICAgICAgdGltZUF4aXMyLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMgPyB1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucykgOiB7fTtcbiAgICAgICAgICBfb3B0aW9ucy5vcmllbnRhdGlvbiA9ICd0b3AnOyAvLyBvdmVycmlkZSB0aGUgb3JpZW50YXRpb24gb3B0aW9uLCBhbHdheXMgdG9wXG4gICAgICAgICAgVGltZUF4aXMucHJvdG90eXBlLnNldE9wdGlvbnMuY2FsbCh0aW1lQXhpczIsIF9vcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2godGltZUF4aXMyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodGhpcy50aW1lQXhpczIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb21wb25lbnRzLmluZGV4T2YodGhpcy50aW1lQXhpczIpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lQXhpczIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRpbWVBeGlzMiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGdyYXBoMmQncyBkcmF3UG9pbnRzIGlzIGEgZnVuY3Rpb24gZGVsZWdhdGUgdGhlIGNhbGxiYWNrIHRvIHRoZSBvblJlbmRlciBwcm9wZXJ0eVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kcmF3UG9pbnRzID09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMuZHJhd1BvaW50cyA9IHtcbiAgICAgICAgICBvblJlbmRlcjogb3B0aW9ucy5kcmF3UG9pbnRzXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgnaGlkZGVuRGF0ZXMnIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgRGF0ZVV0aWwuY29udmVydEhpZGRlbk9wdGlvbnModGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMuaGlkZGVuRGF0ZXMpO1xuICAgIH1cblxuICAgIGlmICgnY2xpY2tUb1VzZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuY2xpY2tUb1VzZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZhdG9yKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmF0b3IgPSBuZXcgQWN0aXZhdG9yKHRoaXMuZG9tLnJvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmF0b3IuZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmFjdGl2YXRvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgnc2hvd0N1c3RvbVRpbWUnIGluIG9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBzaG93Q3VzdG9tVGltZWAgaXMgZGVwcmVjYXRlZC4gQ3JlYXRlIGEgY3VzdG9tIHRpbWUgYmFyIHZpYSB0aW1lbGluZS5hZGRDdXN0b21UaW1lKHRpbWUgWywgaWRdKScpO1xuICAgIH1cblxuICAgIC8vIGVuYWJsZS9kaXNhYmxlIGF1dG9SZXNpemVcbiAgICB0aGlzLl9pbml0QXV0b1Jlc2l6ZSgpO1xuICB9XG5cbiAgLy8gcHJvcGFnYXRlIG9wdGlvbnMgdG8gYWxsIGNvbXBvbmVudHNcbiAgdGhpcy5jb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IGNvbXBvbmVudC5zZXRPcHRpb25zKG9wdGlvbnMpKTtcblxuICAvLyBlbmFibGUvZGlzYWJsZSBjb25maWd1cmVcbiAgaWYgKCdjb25maWd1cmUnIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlndXJhdG9yKSB7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRvciA9IHRoaXMuX2NyZWF0ZUNvbmZpZ3VyYXRvcigpO1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlndXJhdG9yLnNldE9wdGlvbnMob3B0aW9ucy5jb25maWd1cmUpO1xuXG4gICAgLy8gY29sbGVjdCB0aGUgc2V0dGluZ3Mgb2YgYWxsIGNvbXBvbmVudHMsIGFuZCBwYXNzIHRoZW0gdG8gdGhlIGNvbmZpZ3VyYXRpb24gc3lzdGVtXG4gICAgdmFyIGFwcGxpZWRPcHRpb25zID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHV0aWwuZGVlcEV4dGVuZChhcHBsaWVkT3B0aW9ucywgY29tcG9uZW50Lm9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHRoaXMuY29uZmlndXJhdG9yLnNldE1vZHVsZU9wdGlvbnMoe2dsb2JhbDogYXBwbGllZE9wdGlvbnN9KTtcbiAgfVxuXG4gIC8vIG92ZXJyaWRlIHJlZHJhdyB3aXRoIGEgdGhyb3R0bGVkIHZlcnNpb25cbiAgaWYgKCF0aGlzLl9vcmlnUmVkcmF3KSB7XG4gICAgdGhpcy5fb3JpZ1JlZHJhdyA9IHRoaXMuX3JlZHJhdy5iaW5kKHRoaXMpO1xuICB9XG4gIHRoaXMuX3JlZHJhdyA9IHV0aWwudGhyb3R0bGUodGhpcy5fb3JpZ1JlZHJhdywgdGhpcy5vcHRpb25zLnRocm90dGxlUmVkcmF3KTtcblxuICAvLyByZWRyYXcgZXZlcnl0aGluZ1xuICB0aGlzLl9yZWRyYXcoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIFRpbWVsaW5lIGlzIGFjdGl2ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Db3JlLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICF0aGlzLmFjdGl2YXRvciB8fCB0aGlzLmFjdGl2YXRvci5hY3RpdmU7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIENvcmUsIGNsZWFuIHVwIGFsbCBET00gZWxlbWVudHMgYW5kIGV2ZW50IGxpc3RlbmVycy5cbiAqL1xuQ29yZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdW5iaW5kIGRhdGFzZXRzXG4gIHRoaXMuc2V0SXRlbXMobnVsbCk7XG4gIHRoaXMuc2V0R3JvdXBzKG51bGwpO1xuXG4gIC8vIHJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gIHRoaXMub2ZmKCk7XG5cbiAgLy8gc3RvcCBjaGVja2luZyBmb3IgY2hhbmdlZCBzaXplXG4gIHRoaXMuX3N0b3BBdXRvUmVzaXplKCk7XG5cbiAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gIGlmICh0aGlzLmRvbS5yb290LnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmRvbS5yb290LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ucm9vdCk7XG4gIH1cbiAgdGhpcy5kb20gPSBudWxsO1xuXG4gIC8vIHJlbW92ZSBBY3RpdmF0b3JcbiAgaWYgKHRoaXMuYWN0aXZhdG9yKSB7XG4gICAgdGhpcy5hY3RpdmF0b3IuZGVzdHJveSgpO1xuICAgIGRlbGV0ZSB0aGlzLmFjdGl2YXRvcjtcbiAgfVxuXG4gIC8vIGNsZWFudXAgaGFtbWVyIHRvdWNoIGV2ZW50c1xuICBmb3IgKHZhciBldmVudCBpbiB0aGlzLmxpc3RlbmVycykge1xuICAgIGlmICh0aGlzLmxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG4gICAgfVxuICB9XG4gIHRoaXMubGlzdGVuZXJzID0gbnVsbDtcbiAgdGhpcy5oYW1tZXIgPSBudWxsO1xuXG4gIC8vIGdpdmUgYWxsIGNvbXBvbmVudHMgdGhlIG9wcG9ydHVuaXR5IHRvIGNsZWFudXBcbiAgdGhpcy5jb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IGNvbXBvbmVudC5kZXN0cm95KCkpO1xuXG4gIHRoaXMuYm9keSA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogU2V0IGEgY3VzdG9tIHRpbWUgYmFyXG4gKiBAcGFyYW0ge0RhdGV9IHRpbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaWQ9dW5kZWZpbmVkXSBPcHRpb25hbCBpZCBvZiB0aGUgY3VzdG9tIHRpbWUgYmFyIHRvIGJlIGFkanVzdGVkLlxuICovXG5Db3JlLnByb3RvdHlwZS5zZXRDdXN0b21UaW1lID0gZnVuY3Rpb24gKHRpbWUsIGlkKSB7XG4gIHZhciBjdXN0b21UaW1lcyA9IHRoaXMuY3VzdG9tVGltZXMuZmlsdGVyKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gaWQgPT09IGNvbXBvbmVudC5vcHRpb25zLmlkO1xuICB9KTtcblxuICBpZiAoY3VzdG9tVGltZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjdXN0b20gdGltZSBiYXIgZm91bmQgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKVxuICB9XG5cbiAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA+IDApIHtcbiAgICBjdXN0b21UaW1lc1swXS5zZXRDdXN0b21UaW1lKHRpbWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGN1c3RvbSB0aW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IFtpZD11bmRlZmluZWRdICAgIElkIG9mIHRoZSBjdXN0b20gdGltZSBiYXIuXG4gKiBAcmV0dXJuIHtEYXRlIHwgdW5kZWZpbmVkfSBjdXN0b21UaW1lXG4gKi9cbkNvcmUucHJvdG90eXBlLmdldEN1c3RvbVRpbWUgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgY3VzdG9tVGltZXMgPSB0aGlzLmN1c3RvbVRpbWVzLmZpbHRlcihmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5vcHRpb25zLmlkID09PSBpZDtcbiAgfSk7XG5cbiAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY3VzdG9tIHRpbWUgYmFyIGZvdW5kIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSlcbiAgfVxuICByZXR1cm4gY3VzdG9tVGltZXNbMF0uZ2V0Q3VzdG9tVGltZSgpO1xufTtcblxuLyoqXG4gKiBTZXQgYSBjdXN0b20gdGl0bGUgZm9yIHRoZSBjdXN0b20gdGltZSBiYXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gW3RpdGxlXSBDdXN0b20gdGl0bGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaWQ9dW5kZWZpbmVkXSAgICBJZCBvZiB0aGUgY3VzdG9tIHRpbWUgYmFyLlxuICovXG5Db3JlLnByb3RvdHlwZS5zZXRDdXN0b21UaW1lVGl0bGUgPSBmdW5jdGlvbih0aXRsZSwgaWQpIHtcbiAgdmFyIGN1c3RvbVRpbWVzID0gdGhpcy5jdXN0b21UaW1lcy5maWx0ZXIoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBjb21wb25lbnQub3B0aW9ucy5pZCA9PT0gaWQ7XG4gIH0pO1xuXG4gIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGN1c3RvbSB0aW1lIGJhciBmb3VuZCB3aXRoIGlkICcgKyBKU09OLnN0cmluZ2lmeShpZCkpXG4gIH1cbiAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY3VzdG9tVGltZXNbMF0uc2V0Q3VzdG9tVGl0bGUodGl0bGUpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIG1ldGEgaW5mb3JtYXRpb24gZnJvbSBhbiBldmVudC5cbiAqIFNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIENvcmVcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHJlbGF0ZWQgaW5mb3JtYXRpb24uXG4gKi9cbkNvcmUucHJvdG90eXBlLmdldEV2ZW50UHJvcGVydGllcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICByZXR1cm4geyBldmVudDogZXZlbnQgfTtcbn07XG5cbi8qKlxuICogQWRkIGN1c3RvbSB2ZXJ0aWNhbCBiYXJcbiAqIEBwYXJhbSB7RGF0ZSB8IFN0cmluZyB8IE51bWJlcn0gW3RpbWVdICBBIERhdGUsIHVuaXggdGltZXN0YW1wLCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElTTyBkYXRlIHN0cmluZy4gVGltZSBwb2ludCB3aGVyZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuZXcgYmFyIHNob3VsZCBiZSBwbGFjZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCBgbmV3IERhdGUoKWAgd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHVzZWQuXG4gKiBAcGFyYW0ge051bWJlciB8IFN0cmluZ30gW2lkPXVuZGVmaW5lZF0gSWQgb2YgdGhlIG5ldyBiYXIuIE9wdGlvbmFsXG4gKiBAcmV0dXJuIHtOdW1iZXIgfCBTdHJpbmd9ICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaWQgb2YgdGhlIG5ldyBiYXJcbiAqL1xuQ29yZS5wcm90b3R5cGUuYWRkQ3VzdG9tVGltZSA9IGZ1bmN0aW9uICh0aW1lLCBpZCkge1xuICB2YXIgdGltZXN0YW1wID0gdGltZSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpLnZhbHVlT2YoKVxuICAgICAgOiBuZXcgRGF0ZSgpO1xuXG4gIHZhciBleGlzdHMgPSB0aGlzLmN1c3RvbVRpbWVzLnNvbWUoZnVuY3Rpb24gKGN1c3RvbVRpbWUpIHtcbiAgICByZXR1cm4gY3VzdG9tVGltZS5vcHRpb25zLmlkID09PSBpZDtcbiAgfSk7XG4gIGlmIChleGlzdHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY3VzdG9tIHRpbWUgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpICsgJyBhbHJlYWR5IGV4aXN0cycpO1xuICB9XG5cbiAgdmFyIGN1c3RvbVRpbWUgPSBuZXcgQ3VzdG9tVGltZSh0aGlzLmJvZHksIHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIHtcbiAgICB0aW1lIDogdGltZXN0YW1wLFxuICAgIGlkIDogaWRcbiAgfSkpO1xuXG4gIHRoaXMuY3VzdG9tVGltZXMucHVzaChjdXN0b21UaW1lKTtcbiAgdGhpcy5jb21wb25lbnRzLnB1c2goY3VzdG9tVGltZSk7XG4gIHRoaXMuX3JlZHJhdygpO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHByZXZpb3VzbHkgYWRkZWQgY3VzdG9tIGJhclxuICogQHBhcmFtIHtpbnR9IGlkIElEIG9mIHRoZSBjdXN0b20gYmFyIHRvIGJlIHJlbW92ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGJhciBleGlzdHMgYW5kIGlzIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZVxuICovXG5Db3JlLnByb3RvdHlwZS5yZW1vdmVDdXN0b21UaW1lID0gZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBjdXN0b21UaW1lcyA9IHRoaXMuY3VzdG9tVGltZXMuZmlsdGVyKGZ1bmN0aW9uIChiYXIpIHtcbiAgICByZXR1cm4gKGJhci5vcHRpb25zLmlkID09PSBpZCk7XG4gIH0pO1xuXG4gIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGN1c3RvbSB0aW1lIGJhciBmb3VuZCB3aXRoIGlkICcgKyBKU09OLnN0cmluZ2lmeShpZCkpXG4gIH1cblxuICBjdXN0b21UaW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChjdXN0b21UaW1lKSB7XG4gICAgdGhpcy5jdXN0b21UaW1lcy5zcGxpY2UodGhpcy5jdXN0b21UaW1lcy5pbmRleE9mKGN1c3RvbVRpbWUpLCAxKTtcbiAgICB0aGlzLmNvbXBvbmVudHMuc3BsaWNlKHRoaXMuY29tcG9uZW50cy5pbmRleE9mKGN1c3RvbVRpbWUpLCAxKTtcbiAgICBjdXN0b21UaW1lLmRlc3Ryb3koKTtcbiAgfS5iaW5kKHRoaXMpKVxufTtcblxuXG4vKipcbiAqIEdldCB0aGUgaWQncyBvZiB0aGUgY3VycmVudGx5IHZpc2libGUgaXRlbXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBpZHMgb2YgdGhlIHZpc2libGUgaXRlbXNcbiAqL1xuQ29yZS5wcm90b3R5cGUuZ2V0VmlzaWJsZUl0ZW1zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLml0ZW1TZXQgJiYgdGhpcy5pdGVtU2V0LmdldFZpc2libGVJdGVtcygpIHx8IFtdO1xufTtcblxuLyoqXG4gKiBTZXQgQ29yZSB3aW5kb3cgc3VjaCB0aGF0IGl0IGZpdHMgYWxsIGl0ZW1zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gKi9cbkNvcmUucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIHJhbmdlID0gdGhpcy5nZXREYXRhUmFuZ2UoKTtcblxuICAvLyBza2lwIHJhbmdlIHNldCBpZiB0aGVyZSBpcyBubyBtaW4gYW5kIG1heCBkYXRlXG4gIGlmIChyYW5nZS5taW4gPT09IG51bGwgJiYgcmFuZ2UubWF4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYXBwbHkgYSBtYXJnaW4gb2YgMSUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIGRhdGFcbiAgdmFyIGludGVydmFsID0gcmFuZ2UubWF4IC0gcmFuZ2UubWluO1xuICB2YXIgbWluID0gbmV3IERhdGUocmFuZ2UubWluLnZhbHVlT2YoKSAtIGludGVydmFsICogMC4wMSk7XG4gIHZhciBtYXggPSBuZXcgRGF0ZShyYW5nZS5tYXgudmFsdWVPZigpICsgaW50ZXJ2YWwgKiAwLjAxKTtcblxuICB2YXIgYW5pbWF0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG4gIHRoaXMucmFuZ2Uuc2V0UmFuZ2UobWluLCBtYXgsIGFuaW1hdGlvbik7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZGF0YSByYW5nZSBvZiB0aGUgaXRlbXMgc3RhcnQgYW5kIGVuZCBkYXRlc1xuICogQHJldHVybnMge3ttaW46IERhdGUgfCBudWxsLCBtYXg6IERhdGUgfCBudWxsfX1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29yZS5wcm90b3R5cGUuZ2V0RGF0YVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gIC8vIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgVGltZWxpbmUgYW5kIEdyYXBoMmRcbiAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIGFic3RyYWN0IG1ldGhvZCBnZXREYXRhUmFuZ2UnKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB2aXNpYmxlIHdpbmRvdy4gQm90aCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbCwgeW91IGNhbiBjaGFuZ2Ugb25seVxuICogc3RhcnQgb3Igb25seSBlbmQuIFN5bnRheDpcbiAqXG4gKiAgICAgVGltZUxpbmUuc2V0V2luZG93KHN0YXJ0LCBlbmQpXG4gKiAgICAgVGltZUxpbmUuc2V0V2luZG93KHN0YXJ0LCBlbmQsIG9wdGlvbnMpXG4gKiAgICAgVGltZUxpbmUuc2V0V2luZG93KHJhbmdlKVxuICpcbiAqIFdoZXJlIHN0YXJ0IGFuZCBlbmQgY2FuIGJlIGEgRGF0ZSwgbnVtYmVyLCBvciBzdHJpbmcsIGFuZCByYW5nZSBpcyBhblxuICogb2JqZWN0IHdpdGggcHJvcGVydGllcyBzdGFydCBhbmQgZW5kLlxuICpcbiAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZyB8IE9iamVjdH0gW3N0YXJ0XSBTdGFydCBkYXRlIG9mIHZpc2libGUgd2luZG93XG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmd9IFtlbmRdICAgICAgICAgICAgRW5kIGRhdGUgb2YgdmlzaWJsZSB3aW5kb3dcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAqL1xuQ29yZS5wcm90b3R5cGUuc2V0V2luZG93ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgb3B0aW9ucykge1xuICB2YXIgYW5pbWF0aW9uO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgdmFyIHJhbmdlID0gYXJndW1lbnRzWzBdO1xuICAgIGFuaW1hdGlvbiA9IChyYW5nZS5hbmltYXRpb24gIT09IHVuZGVmaW5lZCkgPyByYW5nZS5hbmltYXRpb24gOiB0cnVlO1xuICAgIHRoaXMucmFuZ2Uuc2V0UmFuZ2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgYW5pbWF0aW9uKTtcbiAgfVxuICBlbHNlIHtcbiAgICBhbmltYXRpb24gPSAob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuYW5pbWF0aW9uIDogdHJ1ZTtcbiAgICB0aGlzLnJhbmdlLnNldFJhbmdlKHN0YXJ0LCBlbmQsIGFuaW1hdGlvbik7XG4gIH1cbn07XG5cbi8qKlxuICogTW92ZSB0aGUgd2luZG93IHN1Y2ggdGhhdCBnaXZlbiB0aW1lIGlzIGNlbnRlcmVkIG9uIHNjcmVlbi5cbiAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZ30gdGltZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICovXG5Db3JlLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih0aW1lLCBvcHRpb25zKSB7XG4gIHZhciBpbnRlcnZhbCA9IHRoaXMucmFuZ2UuZW5kIC0gdGhpcy5yYW5nZS5zdGFydDtcbiAgdmFyIHQgPSB1dGlsLmNvbnZlcnQodGltZSwgJ0RhdGUnKS52YWx1ZU9mKCk7XG5cbiAgdmFyIHN0YXJ0ID0gdCAtIGludGVydmFsIC8gMjtcbiAgdmFyIGVuZCA9IHQgKyBpbnRlcnZhbCAvIDI7XG4gIHZhciBhbmltYXRpb24gPSAob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuYW5pbWF0aW9uIDogdHJ1ZTtcblxuICB0aGlzLnJhbmdlLnNldFJhbmdlKHN0YXJ0LCBlbmQsIGFuaW1hdGlvbik7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmlzaWJsZSB3aW5kb3dcbiAqIEByZXR1cm4ge3tzdGFydDogRGF0ZSwgZW5kOiBEYXRlfX0gICBWaXNpYmxlIHJhbmdlXG4gKi9cbkNvcmUucHJvdG90eXBlLmdldFdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlLmdldFJhbmdlKCk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IG5ldyBEYXRlKHJhbmdlLnN0YXJ0KSxcbiAgICBlbmQ6IG5ldyBEYXRlKHJhbmdlLmVuZClcbiAgfTtcbn07XG5cbi8qKlxuICogRm9yY2UgYSByZWRyYXcuIENhbiBiZSBvdmVycmlkZGVuIGJ5IGltcGxlbWVudGF0aW9ucyBvZiBDb3JlXG4gKlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIG92ZXJyaWRkZW4gb24gY29uc3RydWN0aW9uIHdpdGggYSB0cm90dGxlZCB2ZXJzaW9uXG4gKi9cbkNvcmUucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZWRyYXcoKTtcbn07XG5cbi8qKlxuICogUmVkcmF3IGZvciBpbnRlcm5hbCB1c2UuIFJlZHJhd3MgYWxsIGNvbXBvbmVudHMuIFNlZSBhbHNvIHRoZSBwdWJsaWNcbiAqIG1ldGhvZCByZWRyYXcuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvcmUucHJvdG90eXBlLl9yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc2l6ZWQgPSBmYWxzZTtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gIHZhciBkb20gPSB0aGlzLmRvbTtcblxuICBpZiAoIWRvbSkgcmV0dXJuOyAvLyB3aGVuIGRlc3Ryb3llZFxuXG4gIERhdGVVdGlsLnVwZGF0ZUhpZGRlbkRhdGVzKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmhpZGRlbkRhdGVzKTtcblxuICAvLyB1cGRhdGUgY2xhc3MgbmFtZXNcbiAgaWYgKG9wdGlvbnMub3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICB1dGlsLmFkZENsYXNzTmFtZShkb20ucm9vdCwgJ3Zpcy10b3AnKTtcbiAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZShkb20ucm9vdCwgJ3Zpcy1ib3R0b20nKTtcbiAgfVxuICBlbHNlIHtcbiAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZShkb20ucm9vdCwgJ3Zpcy10b3AnKTtcbiAgICB1dGlsLmFkZENsYXNzTmFtZShkb20ucm9vdCwgJ3Zpcy1ib3R0b20nKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSByb290IHdpZHRoIGFuZCBoZWlnaHQgb3B0aW9uc1xuICBkb20ucm9vdC5zdHlsZS5tYXhIZWlnaHQgPSB1dGlsLm9wdGlvbi5hc1NpemUob3B0aW9ucy5tYXhIZWlnaHQsICcnKTtcbiAgZG9tLnJvb3Quc3R5bGUubWluSGVpZ2h0ID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMubWluSGVpZ2h0LCAnJyk7XG4gIGRvbS5yb290LnN0eWxlLndpZHRoID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMud2lkdGgsICcnKTtcblxuICAvLyBjYWxjdWxhdGUgYm9yZGVyIHdpZHRoc1xuICBwcm9wcy5ib3JkZXIubGVmdCAgID0gKGRvbS5jZW50ZXJDb250YWluZXIub2Zmc2V0V2lkdGggLSBkb20uY2VudGVyQ29udGFpbmVyLmNsaWVudFdpZHRoKSAvIDI7XG4gIHByb3BzLmJvcmRlci5yaWdodCAgPSBwcm9wcy5ib3JkZXIubGVmdDtcbiAgcHJvcHMuYm9yZGVyLnRvcCAgICA9IChkb20uY2VudGVyQ29udGFpbmVyLm9mZnNldEhlaWdodCAtIGRvbS5jZW50ZXJDb250YWluZXIuY2xpZW50SGVpZ2h0KSAvIDI7XG4gIHByb3BzLmJvcmRlci5ib3R0b20gPSBwcm9wcy5ib3JkZXIudG9wO1xuICB2YXIgYm9yZGVyUm9vdEhlaWdodD0gZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0IC0gZG9tLnJvb3QuY2xpZW50SGVpZ2h0O1xuICB2YXIgYm9yZGVyUm9vdFdpZHRoID0gZG9tLnJvb3Qub2Zmc2V0V2lkdGggLSBkb20ucm9vdC5jbGllbnRXaWR0aDtcblxuICAvLyB3b3JrYXJvdW5kIGZvciBhIGJ1ZyBpbiBJRTogdGhlIGNsaWVudFdpZHRoIG9mIGFuIGVsZW1lbnQgd2l0aFxuICAvLyBhIGhlaWdodDowcHggYW5kIG92ZXJmbG93OmhpZGRlbiBpcyBub3QgY2FsY3VsYXRlZCBhbmQgYWx3YXlzIGhhcyB2YWx1ZSAwXG4gIGlmIChkb20uY2VudGVyQ29udGFpbmVyLmNsaWVudEhlaWdodCA9PT0gMCkge1xuICAgIHByb3BzLmJvcmRlci5sZWZ0ID0gcHJvcHMuYm9yZGVyLnRvcDtcbiAgICBwcm9wcy5ib3JkZXIucmlnaHQgID0gcHJvcHMuYm9yZGVyLmxlZnQ7XG4gIH1cbiAgaWYgKGRvbS5yb290LmNsaWVudEhlaWdodCA9PT0gMCkge1xuICAgIGJvcmRlclJvb3RXaWR0aCA9IGJvcmRlclJvb3RIZWlnaHQ7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIGhlaWdodHMuIElmIGFueSBvZiB0aGUgc2lkZSBwYW5lbHMgaXMgZW1wdHksIHdlIHNldCB0aGUgaGVpZ2h0IHRvXG4gIC8vIG1pbnVzIHRoZSBib3JkZXIgd2lkdGgsIHN1Y2ggdGhhdCB0aGUgYm9yZGVyIHdpbGwgYmUgaW52aXNpYmxlXG4gIHByb3BzLmNlbnRlci5oZWlnaHQgPSBkb20uY2VudGVyLm9mZnNldEhlaWdodDtcbiAgcHJvcHMubGVmdC5oZWlnaHQgICA9IGRvbS5sZWZ0Lm9mZnNldEhlaWdodDtcbiAgcHJvcHMucmlnaHQuaGVpZ2h0ICA9IGRvbS5yaWdodC5vZmZzZXRIZWlnaHQ7XG4gIHByb3BzLnRvcC5oZWlnaHQgICAgPSBkb20udG9wLmNsaWVudEhlaWdodCAgICB8fCAtcHJvcHMuYm9yZGVyLnRvcDtcbiAgcHJvcHMuYm90dG9tLmhlaWdodCA9IGRvbS5ib3R0b20uY2xpZW50SGVpZ2h0IHx8IC1wcm9wcy5ib3JkZXIuYm90dG9tO1xuXG4gIC8vIFRPRE86IGNvbXBlbnNhdGUgYm9yZGVycyB3aGVuIGFueSBvZiB0aGUgcGFuZWxzIGlzIGVtcHR5LlxuXG4gIC8vIGFwcGx5IGF1dG8gaGVpZ2h0XG4gIC8vIFRPRE86IG9ubHkgY2FsY3VsYXRlIGF1dG9IZWlnaHQgd2hlbiBuZWVkZWQgKGVsc2Ugd2UgY2F1c2UgYW4gZXh0cmEgcmVmbG93L3JlcGFpbnQgb2YgdGhlIERPTSlcbiAgdmFyIGNvbnRlbnRIZWlnaHQgPSBNYXRoLm1heChwcm9wcy5sZWZ0LmhlaWdodCwgcHJvcHMuY2VudGVyLmhlaWdodCwgcHJvcHMucmlnaHQuaGVpZ2h0KTtcbiAgdmFyIGF1dG9IZWlnaHQgPSBwcm9wcy50b3AuaGVpZ2h0ICsgY29udGVudEhlaWdodCArIHByb3BzLmJvdHRvbS5oZWlnaHQgK1xuICAgIGJvcmRlclJvb3RIZWlnaHQgKyBwcm9wcy5ib3JkZXIudG9wICsgcHJvcHMuYm9yZGVyLmJvdHRvbTtcbiAgZG9tLnJvb3Quc3R5bGUuaGVpZ2h0ID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMuaGVpZ2h0LCBhdXRvSGVpZ2h0ICsgJ3B4Jyk7XG5cbiAgLy8gY2FsY3VsYXRlIGhlaWdodHMgb2YgdGhlIGNvbnRlbnQgcGFuZWxzXG4gIHByb3BzLnJvb3QuaGVpZ2h0ID0gZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0O1xuICBwcm9wcy5iYWNrZ3JvdW5kLmhlaWdodCA9IHByb3BzLnJvb3QuaGVpZ2h0IC0gYm9yZGVyUm9vdEhlaWdodDtcbiAgdmFyIGNvbnRhaW5lckhlaWdodCA9IHByb3BzLnJvb3QuaGVpZ2h0IC0gcHJvcHMudG9wLmhlaWdodCAtIHByb3BzLmJvdHRvbS5oZWlnaHQgLVxuICAgIGJvcmRlclJvb3RIZWlnaHQ7XG4gIHByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgID0gY29udGFpbmVySGVpZ2h0O1xuICBwcm9wcy5sZWZ0Q29udGFpbmVyLmhlaWdodCAgICA9IGNvbnRhaW5lckhlaWdodDtcbiAgcHJvcHMucmlnaHRDb250YWluZXIuaGVpZ2h0ICAgPSBwcm9wcy5sZWZ0Q29udGFpbmVyLmhlaWdodDtcblxuICAvLyBjYWxjdWxhdGUgdGhlIHdpZHRocyBvZiB0aGUgcGFuZWxzXG4gIHByb3BzLnJvb3Qud2lkdGggPSBkb20ucm9vdC5vZmZzZXRXaWR0aDtcbiAgcHJvcHMuYmFja2dyb3VuZC53aWR0aCA9IHByb3BzLnJvb3Qud2lkdGggLSBib3JkZXJSb290V2lkdGg7XG4gIHByb3BzLmxlZnQud2lkdGggPSBkb20ubGVmdENvbnRhaW5lci5jbGllbnRXaWR0aCAgIHx8IC1wcm9wcy5ib3JkZXIubGVmdDtcbiAgcHJvcHMubGVmdENvbnRhaW5lci53aWR0aCA9IHByb3BzLmxlZnQud2lkdGg7XG4gIHByb3BzLnJpZ2h0LndpZHRoID0gZG9tLnJpZ2h0Q29udGFpbmVyLmNsaWVudFdpZHRoIHx8IC1wcm9wcy5ib3JkZXIucmlnaHQ7XG4gIHByb3BzLnJpZ2h0Q29udGFpbmVyLndpZHRoID0gcHJvcHMucmlnaHQud2lkdGg7XG4gIHZhciBjZW50ZXJXaWR0aCA9IHByb3BzLnJvb3Qud2lkdGggLSBwcm9wcy5sZWZ0LndpZHRoIC0gcHJvcHMucmlnaHQud2lkdGggLSBib3JkZXJSb290V2lkdGg7XG4gIHByb3BzLmNlbnRlci53aWR0aCAgICAgICAgICA9IGNlbnRlcldpZHRoO1xuICBwcm9wcy5jZW50ZXJDb250YWluZXIud2lkdGggPSBjZW50ZXJXaWR0aDtcbiAgcHJvcHMudG9wLndpZHRoICAgICAgICAgICAgID0gY2VudGVyV2lkdGg7XG4gIHByb3BzLmJvdHRvbS53aWR0aCAgICAgICAgICA9IGNlbnRlcldpZHRoO1xuXG4gIC8vIHJlc2l6ZSB0aGUgcGFuZWxzXG4gIGRvbS5iYWNrZ3JvdW5kLnN0eWxlLmhlaWdodCAgICAgICAgICAgPSBwcm9wcy5iYWNrZ3JvdW5kLmhlaWdodCArICdweCc7XG4gIGRvbS5iYWNrZ3JvdW5kVmVydGljYWwuc3R5bGUuaGVpZ2h0ICAgPSBwcm9wcy5iYWNrZ3JvdW5kLmhlaWdodCArICdweCc7XG4gIGRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5zdHlsZS5oZWlnaHQgPSBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLmNlbnRlckNvbnRhaW5lci5zdHlsZS5oZWlnaHQgICAgICA9IHByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuICBkb20ubGVmdENvbnRhaW5lci5zdHlsZS5oZWlnaHQgICAgICAgID0gcHJvcHMubGVmdENvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuICBkb20ucmlnaHRDb250YWluZXIuc3R5bGUuaGVpZ2h0ICAgICAgID0gcHJvcHMucmlnaHRDb250YWluZXIuaGVpZ2h0ICsgJ3B4JztcblxuICBkb20uYmFja2dyb3VuZC5zdHlsZS53aWR0aCAgICAgICAgICAgID0gcHJvcHMuYmFja2dyb3VuZC53aWR0aCArICdweCc7XG4gIGRvbS5iYWNrZ3JvdW5kVmVydGljYWwuc3R5bGUud2lkdGggICAgPSBwcm9wcy5jZW50ZXJDb250YWluZXIud2lkdGggKyAncHgnO1xuICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUud2lkdGggID0gcHJvcHMuYmFja2dyb3VuZC53aWR0aCArICdweCc7XG4gIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUud2lkdGggICAgICAgPSBwcm9wcy5jZW50ZXIud2lkdGggKyAncHgnO1xuICBkb20udG9wLnN0eWxlLndpZHRoICAgICAgICAgICAgICAgICAgID0gcHJvcHMudG9wLndpZHRoICsgJ3B4JztcbiAgZG9tLmJvdHRvbS5zdHlsZS53aWR0aCAgICAgICAgICAgICAgICA9IHByb3BzLmJvdHRvbS53aWR0aCArICdweCc7XG5cbiAgLy8gcmVwb3NpdGlvbiB0aGUgcGFuZWxzXG4gIGRvbS5iYWNrZ3JvdW5kLnN0eWxlLmxlZnQgICAgICAgICAgID0gJzAnO1xuICBkb20uYmFja2dyb3VuZC5zdHlsZS50b3AgICAgICAgICAgICA9ICcwJztcbiAgZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5zdHlsZS5sZWZ0ICAgPSAocHJvcHMubGVmdC53aWR0aCArIHByb3BzLmJvcmRlci5sZWZ0KSArICdweCc7XG4gIGRvbS5iYWNrZ3JvdW5kVmVydGljYWwuc3R5bGUudG9wICAgID0gJzAnO1xuICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUubGVmdCA9ICcwJztcbiAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLnRvcCAgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLmNlbnRlckNvbnRhaW5lci5zdHlsZS5sZWZ0ICAgICAgPSBwcm9wcy5sZWZ0LndpZHRoICsgJ3B4JztcbiAgZG9tLmNlbnRlckNvbnRhaW5lci5zdHlsZS50b3AgICAgICAgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLmxlZnRDb250YWluZXIuc3R5bGUubGVmdCAgICAgICAgPSAnMCc7XG4gIGRvbS5sZWZ0Q29udGFpbmVyLnN0eWxlLnRvcCAgICAgICAgID0gcHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIGRvbS5yaWdodENvbnRhaW5lci5zdHlsZS5sZWZ0ICAgICAgID0gKHByb3BzLmxlZnQud2lkdGggKyBwcm9wcy5jZW50ZXIud2lkdGgpICsgJ3B4JztcbiAgZG9tLnJpZ2h0Q29udGFpbmVyLnN0eWxlLnRvcCAgICAgICAgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLnRvcC5zdHlsZS5sZWZ0ICAgICAgICAgICAgICAgICAgPSBwcm9wcy5sZWZ0LndpZHRoICsgJ3B4JztcbiAgZG9tLnRvcC5zdHlsZS50b3AgICAgICAgICAgICAgICAgICAgPSAnMCc7XG4gIGRvbS5ib3R0b20uc3R5bGUubGVmdCAgICAgICAgICAgICAgID0gcHJvcHMubGVmdC53aWR0aCArICdweCc7XG4gIGRvbS5ib3R0b20uc3R5bGUudG9wICAgICAgICAgICAgICAgID0gKHByb3BzLnRvcC5oZWlnaHQgKyBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0KSArICdweCc7XG5cbiAgLy8gdXBkYXRlIHRoZSBzY3JvbGxUb3AsIGZlYXNpYmxlIHJhbmdlIGZvciB0aGUgb2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gIC8vIHdoZW4gdGhlIGhlaWdodCBvZiB0aGUgQ29yZSBvciBvZiB0aGUgY29udGVudHMgb2YgdGhlIGNlbnRlciBjaGFuZ2VkXG4gIHRoaXMuX3VwZGF0ZVNjcm9sbFRvcCgpO1xuXG4gIC8vIHJlcG9zaXRpb24gdGhlIHNjcm9sbGFibGUgY29udGVudHNcbiAgdmFyIG9mZnNldCA9IHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xuICBpZiAob3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtICE9ICd0b3AnKSB7XG4gICAgb2Zmc2V0ICs9IE1hdGgubWF4KHRoaXMucHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCAtIHRoaXMucHJvcHMuY2VudGVyLmhlaWdodCAtXG4gICAgICB0aGlzLnByb3BzLmJvcmRlci50b3AgLSB0aGlzLnByb3BzLmJvcmRlci5ib3R0b20sIDApO1xuICB9XG4gIGRvbS5jZW50ZXIuc3R5bGUubGVmdCA9ICcwJztcbiAgZG9tLmNlbnRlci5zdHlsZS50b3AgID0gb2Zmc2V0ICsgJ3B4JztcbiAgZG9tLmxlZnQuc3R5bGUubGVmdCAgID0gJzAnO1xuICBkb20ubGVmdC5zdHlsZS50b3AgICAgPSBvZmZzZXQgKyAncHgnO1xuICBkb20ucmlnaHQuc3R5bGUubGVmdCAgPSAnMCc7XG4gIGRvbS5yaWdodC5zdHlsZS50b3AgICA9IG9mZnNldCArICdweCc7XG5cbiAgLy8gc2hvdyBzaGFkb3dzIHdoZW4gdmVydGljYWwgc2Nyb2xsaW5nIGlzIGF2YWlsYWJsZVxuICB2YXIgdmlzaWJpbGl0eVRvcCA9IHRoaXMucHJvcHMuc2Nyb2xsVG9wID09IDAgPyAnaGlkZGVuJyA6ICcnO1xuICB2YXIgdmlzaWJpbGl0eUJvdHRvbSA9IHRoaXMucHJvcHMuc2Nyb2xsVG9wID09IHRoaXMucHJvcHMuc2Nyb2xsVG9wTWluID8gJ2hpZGRlbicgOiAnJztcbiAgZG9tLnNoYWRvd1RvcC5zdHlsZS52aXNpYmlsaXR5ICAgICAgICAgID0gdmlzaWJpbGl0eVRvcDtcbiAgZG9tLnNoYWRvd0JvdHRvbS5zdHlsZS52aXNpYmlsaXR5ICAgICAgID0gdmlzaWJpbGl0eUJvdHRvbTtcbiAgZG9tLnNoYWRvd1RvcExlZnQuc3R5bGUudmlzaWJpbGl0eSAgICAgID0gdmlzaWJpbGl0eVRvcDtcbiAgZG9tLnNoYWRvd0JvdHRvbUxlZnQuc3R5bGUudmlzaWJpbGl0eSAgID0gdmlzaWJpbGl0eUJvdHRvbTtcbiAgZG9tLnNoYWRvd1RvcFJpZ2h0LnN0eWxlLnZpc2liaWxpdHkgICAgID0gdmlzaWJpbGl0eVRvcDtcbiAgZG9tLnNoYWRvd0JvdHRvbVJpZ2h0LnN0eWxlLnZpc2liaWxpdHkgID0gdmlzaWJpbGl0eUJvdHRvbTtcblxuICAvLyByZWRyYXcgYWxsIGNvbXBvbmVudHNcbiAgdGhpcy5jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHJlc2l6ZWQgPSBjb21wb25lbnQucmVkcmF3KCkgfHwgcmVzaXplZDtcbiAgfSk7XG4gIGlmIChyZXNpemVkKSB7XG4gICAgLy8ga2VlcCByZXBhaW50aW5nIHVudGlsIGFsbCBzaXplcyBhcmUgc2V0dGxlZFxuICAgIHZhciBNQVhfUkVEUkFXUyA9IDM7IC8vIG1heGltdW0gbnVtYmVyIG9mIGNvbnNlY3V0aXZlIHJlZHJhd3NcbiAgICBpZiAodGhpcy5yZWRyYXdDb3VudCA8IE1BWF9SRURSQVdTKSB7XG4gICAgICB0aGlzLnJlZHJhd0NvdW50Kys7XG4gICAgICB0aGlzLl9yZWRyYXcoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnV0FSTklORzogaW5maW5pdGUgbG9vcCBpbiByZWRyYXc/Jyk7XG4gICAgfVxuICAgIHRoaXMucmVkcmF3Q291bnQgPSAwO1xuICB9XG59O1xuXG4vLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xLjAsIHJlbW92ZSBzb21lIGRheVxuQ29yZS5wcm90b3R5cGUucmVwYWludCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiByZXBhaW50IGlzIGRlcHJlY2F0ZWQuIFVzZSByZWRyYXcgaW5zdGVhZC4nKTtcbn07XG5cbi8qKlxuICogU2V0IGEgY3VycmVudCB0aW1lLiBUaGlzIGNhbiBiZSB1c2VkIGZvciBleGFtcGxlIHRvIGVuc3VyZSB0aGF0IGEgY2xpZW50J3NcbiAqIHRpbWUgaXMgc3luY2hyb25pemVkIHdpdGggYSBzaGFyZWQgc2VydmVyIHRpbWUuXG4gKiBPbmx5IGFwcGxpY2FibGUgd2hlbiBvcHRpb24gYHNob3dDdXJyZW50VGltZWAgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7RGF0ZSB8IFN0cmluZyB8IE51bWJlcn0gdGltZSAgICAgQSBEYXRlLCB1bml4IHRpbWVzdGFtcCwgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSVNPIGRhdGUgc3RyaW5nLlxuICovXG5Db3JlLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgaWYgKCF0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gc2hvd0N1cnJlbnRUaW1lIG11c3QgYmUgdHJ1ZScpO1xuICB9XG5cbiAgdGhpcy5jdXJyZW50VGltZS5zZXRDdXJyZW50VGltZSh0aW1lKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHRpbWUuXG4gKiBPbmx5IGFwcGxpY2FibGUgd2hlbiBvcHRpb24gYHNob3dDdXJyZW50VGltZWAgaXMgdHJ1ZS5cbiAqIEByZXR1cm4ge0RhdGV9IFJldHVybnMgdGhlIGN1cnJlbnQgdGltZS5cbiAqL1xuQ29yZS5wcm90b3R5cGUuZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gc2hvd0N1cnJlbnRUaW1lIG11c3QgYmUgdHJ1ZScpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUuZ2V0Q3VycmVudFRpbWUoKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHBvc2l0aW9uIG9uIHNjcmVlbiAocGl4ZWxzKSB0byBhIGRhdGV0aW1lXG4gKiBAcGFyYW0ge2ludH0gICAgIHggICAgUG9zaXRpb24gb24gdGhlIHNjcmVlbiBpbiBwaXhlbHNcbiAqIEByZXR1cm4ge0RhdGV9ICAgdGltZSBUaGUgZGF0ZXRpbWUgdGhlIGNvcnJlc3BvbmRzIHdpdGggZ2l2ZW4gcG9zaXRpb24geFxuICogQHByb3RlY3RlZFxuICovXG4vLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gdG8gUmFuZ2VcbkNvcmUucHJvdG90eXBlLl90b1RpbWUgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBEYXRlVXRpbC50b1RpbWUodGhpcywgeCwgdGhpcy5wcm9wcy5jZW50ZXIud2lkdGgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgcG9zaXRpb24gb24gdGhlIGdsb2JhbCBzY3JlZW4gKHBpeGVscykgdG8gYSBkYXRldGltZVxuICogQHBhcmFtIHtpbnR9ICAgICB4ICAgIFBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gaW4gcGl4ZWxzXG4gKiBAcmV0dXJuIHtEYXRlfSAgIHRpbWUgVGhlIGRhdGV0aW1lIHRoZSBjb3JyZXNwb25kcyB3aXRoIGdpdmVuIHBvc2l0aW9uIHhcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIFJhbmdlXG5Db3JlLnByb3RvdHlwZS5fdG9HbG9iYWxUaW1lID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gRGF0ZVV0aWwudG9UaW1lKHRoaXMsIHgsIHRoaXMucHJvcHMucm9vdC53aWR0aCk7XG4gIC8vdmFyIGNvbnZlcnNpb24gPSB0aGlzLnJhbmdlLmNvbnZlcnNpb24odGhpcy5wcm9wcy5yb290LndpZHRoKTtcbiAgLy9yZXR1cm4gbmV3IERhdGUoeCAvIGNvbnZlcnNpb24uc2NhbGUgKyBjb252ZXJzaW9uLm9mZnNldCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRldGltZSAoRGF0ZSBvYmplY3QpIGludG8gYSBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuXG4gKiBAcGFyYW0ge0RhdGV9ICAgdGltZSBBIGRhdGVcbiAqIEByZXR1cm4ge2ludH0gICB4ICAgIFRoZSBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuIGluIHBpeGVscyB3aGljaCBjb3JyZXNwb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIFJhbmdlXG5Db3JlLnByb3RvdHlwZS5fdG9TY3JlZW4gPSBmdW5jdGlvbih0aW1lKSB7XG4gIHJldHVybiBEYXRlVXRpbC50b1NjcmVlbih0aGlzLCB0aW1lLCB0aGlzLnByb3BzLmNlbnRlci53aWR0aCk7XG59O1xuXG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgZGF0ZXRpbWUgKERhdGUgb2JqZWN0KSBpbnRvIGEgcG9zaXRpb24gb24gdGhlIHJvb3RcbiAqIFRoaXMgaXMgdXNlZCB0byBnZXQgdGhlIHBpeGVsIGRlbnNpdHkgZXN0aW1hdGUgZm9yIHRoZSBzY3JlZW4sIG5vdCB0aGUgY2VudGVyIHBhbmVsXG4gKiBAcGFyYW0ge0RhdGV9ICAgdGltZSBBIGRhdGVcbiAqIEByZXR1cm4ge2ludH0gICB4ICAgIFRoZSBwb3NpdGlvbiBvbiByb290IGluIHBpeGVscyB3aGljaCBjb3JyZXNwb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIFJhbmdlXG5Db3JlLnByb3RvdHlwZS5fdG9HbG9iYWxTY3JlZW4gPSBmdW5jdGlvbih0aW1lKSB7XG4gIHJldHVybiBEYXRlVXRpbC50b1NjcmVlbih0aGlzLCB0aW1lLCB0aGlzLnByb3BzLnJvb3Qud2lkdGgpO1xuICAvL3ZhciBjb252ZXJzaW9uID0gdGhpcy5yYW5nZS5jb252ZXJzaW9uKHRoaXMucHJvcHMucm9vdC53aWR0aCk7XG4gIC8vcmV0dXJuICh0aW1lLnZhbHVlT2YoKSAtIGNvbnZlcnNpb24ub2Zmc2V0KSAqIGNvbnZlcnNpb24uc2NhbGU7XG59O1xuXG5cbi8qKlxuICogSW5pdGlhbGl6ZSB3YXRjaGluZyB3aGVuIG9wdGlvbiBhdXRvUmVzaXplIGlzIHRydWVcbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl9pbml0QXV0b1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUmVzaXplID09IHRydWUpIHtcbiAgICB0aGlzLl9zdGFydEF1dG9SZXNpemUoKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhdGNoIGZvciBjaGFuZ2VzIGluIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIuIE9uIHJlc2l6ZSwgdGhlIFBhbmVsIHdpbGxcbiAqIGF1dG9tYXRpY2FsbHkgcmVkcmF3IGl0c2VsZi5cbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl9zdGFydEF1dG9SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgdGhpcy5fc3RvcEF1dG9SZXNpemUoKTtcblxuICB0aGlzLl9vblJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChtZS5vcHRpb25zLmF1dG9SZXNpemUgIT0gdHJ1ZSkge1xuICAgICAgLy8gc3RvcCB3YXRjaGluZyB3aGVuIHRoZSBvcHRpb24gYXV0b1Jlc2l6ZSBpcyBjaGFuZ2VkIHRvIGZhbHNlXG4gICAgICBtZS5fc3RvcEF1dG9SZXNpemUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWUuZG9tLnJvb3QpIHtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGZyYW1lIGlzIHJlc2l6ZWRcbiAgICAgIC8vIE5vdGU6IHdlIGNvbXBhcmUgb2Zmc2V0V2lkdGggaGVyZSwgbm90IGNsaWVudFdpZHRoLiBGb3Igc29tZSByZWFzb24sXG4gICAgICAvLyBJRSBkb2VzIG5vdCByZXN0b3JlIHRoZSBjbGllbnRXaWR0aCBmcm9tIDAgdG8gdGhlIGFjdHVhbCB3aWR0aCBhZnRlclxuICAgICAgLy8gY2hhbmdpbmcgdGhlIHRpbWVsaW5lJ3MgY29udGFpbmVyIGRpc3BsYXkgc3R5bGUgZnJvbSBub25lIHRvIHZpc2libGVcbiAgICAgIGlmICgobWUuZG9tLnJvb3Qub2Zmc2V0V2lkdGggIT0gbWUucHJvcHMubGFzdFdpZHRoKSB8fFxuICAgICAgICAobWUuZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0ICE9IG1lLnByb3BzLmxhc3RIZWlnaHQpKSB7XG4gICAgICAgIG1lLnByb3BzLmxhc3RXaWR0aCA9IG1lLmRvbS5yb290Lm9mZnNldFdpZHRoO1xuICAgICAgICBtZS5wcm9wcy5sYXN0SGVpZ2h0ID0gbWUuZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIG1lLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBhZGQgZXZlbnQgbGlzdGVuZXIgdG8gd2luZG93IHJlc2l6ZVxuICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuXG4gIHRoaXMud2F0Y2hUaW1lciA9IHNldEludGVydmFsKHRoaXMuX29uUmVzaXplLCAxMDAwKTtcbn07XG5cbi8qKlxuICogU3RvcCB3YXRjaGluZyBmb3IgYSByZXNpemUgb2YgdGhlIGZyYW1lLlxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX3N0b3BBdXRvUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy53YXRjaFRpbWVyKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLndhdGNoVGltZXIpO1xuICAgIHRoaXMud2F0Y2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3cucmVzaXplXG4gIGlmICh0aGlzLl9vblJlc2l6ZSkge1xuICAgIHV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgdGhpcy5fb25SZXNpemUgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0IG1vdmluZyB0aGUgdGltZWxpbmUgdmVydGljYWxseVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl9vblRvdWNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHRoaXMudG91Y2guYWxsb3dEcmFnZ2luZyA9IHRydWU7XG4gIHRoaXMudG91Y2guaW5pdGlhbFNjcm9sbFRvcCA9IHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xufTtcblxuLyoqXG4gKiBTdGFydCBtb3ZpbmcgdGhlIHRpbWVsaW5lIHZlcnRpY2FsbHlcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fb25QaW5jaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB0aGlzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogTW92ZSB0aGUgdGltZWxpbmUgdmVydGljYWxseVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gcmVmdXNlIHRvIGRyYWcgd2hlbiB3ZSB3aGVyZSBwaW5jaGluZyB0byBwcmV2ZW50IHRoZSB0aW1lbGluZSBtYWtlIGEganVtcFxuICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgaWYgKCF0aGlzLnRvdWNoLmFsbG93RHJhZ2dpbmcpIHJldHVybjtcblxuICB2YXIgZGVsdGEgPSBldmVudC5kZWx0YVk7XG5cbiAgdmFyIG9sZFNjcm9sbFRvcCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpO1xuICB2YXIgbmV3U2Nyb2xsVG9wID0gdGhpcy5fc2V0U2Nyb2xsVG9wKHRoaXMudG91Y2guaW5pdGlhbFNjcm9sbFRvcCArIGRlbHRhKTtcblxuXG4gIGlmIChuZXdTY3JvbGxUb3AgIT0gb2xkU2Nyb2xsVG9wKSB7XG4gICAgdGhpcy5fcmVkcmF3KCk7IC8vIFRPRE86IHRoaXMgY2F1c2VzIHR3byByZWRyYXdzIHdoZW4gZHJhZ2dpbmcsIHRoZSBvdGhlciBpcyB0cmlnZ2VyZWQgYnkgcmFuZ2VjaGFuZ2UgYWxyZWFkeVxuICAgIHRoaXMuZW1pdChcInZlcnRpY2FsRHJhZ1wiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBseSBhIHNjcm9sbFRvcFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbFRvcFxuICogQHJldHVybnMge051bWJlcn0gc2Nyb2xsVG9wICBSZXR1cm5zIHRoZSBhcHBsaWVkIHNjcm9sbFRvcFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX3NldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHtcbiAgdGhpcy5wcm9wcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gIHRoaXMuX3VwZGF0ZVNjcm9sbFRvcCgpO1xuICByZXR1cm4gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY3VycmVudCBzY3JvbGxUb3Agd2hlbiB0aGUgaGVpZ2h0IG9mICB0aGUgY29udGFpbmVycyBoYXMgYmVlbiBjaGFuZ2VkXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzY3JvbGxUb3AgIFJldHVybnMgdGhlIGFwcGxpZWQgc2Nyb2xsVG9wXG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fdXBkYXRlU2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAvLyByZWNhbGN1bGF0ZSB0aGUgc2Nyb2xsVG9wTWluXG4gIHZhciBzY3JvbGxUb3BNaW4gPSBNYXRoLm1pbih0aGlzLnByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgLSB0aGlzLnByb3BzLmNlbnRlci5oZWlnaHQsIDApOyAvLyBpcyBuZWdhdGl2ZSBvciB6ZXJvXG4gIGlmIChzY3JvbGxUb3BNaW4gIT0gdGhpcy5wcm9wcy5zY3JvbGxUb3BNaW4pIHtcbiAgICAvLyBpbiBjYXNlIG9mIGJvdHRvbSBvcmllbnRhdGlvbiwgY2hhbmdlIHRoZSBzY3JvbGxUb3Agc3VjaCB0aGF0IHRoZSBjb250ZW50c1xuICAgIC8vIGRvIG5vdCBtb3ZlIHJlbGF0aXZlIHRvIHRoZSB0aW1lIGF4aXMgYXQgdGhlIGJvdHRvbVxuICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSAhPSAndG9wJykge1xuICAgICAgdGhpcy5wcm9wcy5zY3JvbGxUb3AgKz0gKHNjcm9sbFRvcE1pbiAtIHRoaXMucHJvcHMuc2Nyb2xsVG9wTWluKTtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5zY3JvbGxUb3BNaW4gPSBzY3JvbGxUb3BNaW47XG4gIH1cblxuICAvLyBsaW1pdCB0aGUgc2Nyb2xsVG9wIHRvIHRoZSBmZWFzaWJsZSBzY3JvbGwgcmFuZ2VcbiAgaWYgKHRoaXMucHJvcHMuc2Nyb2xsVG9wID4gMCkgdGhpcy5wcm9wcy5zY3JvbGxUb3AgPSAwO1xuICBpZiAodGhpcy5wcm9wcy5zY3JvbGxUb3AgPCBzY3JvbGxUb3BNaW4pIHRoaXMucHJvcHMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wTWluO1xuXG4gIHJldHVybiB0aGlzLnByb3BzLnNjcm9sbFRvcDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHNjcm9sbFRvcFxuICogQHJldHVybnMge251bWJlcn0gc2Nyb2xsVG9wXG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG59O1xuXG4vKipcbiAqIExvYWQgYSBjb25maWd1cmF0b3JcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl9jcmVhdGVDb25maWd1cmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBhYnN0cmFjdCBtZXRob2QgX2NyZWF0ZUNvbmZpZ3VyYXRvcicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb3JlO1xuIl19
},{"../DataSet":15,"../DataView":16,"../hammerUtil":18,"../module/hammer":19,"../shared/Activator":22,"../util":46,"./DateUtil":27,"./Range":28,"./component/CustomTime":35,"./component/ItemSet":37,"./component/TimeAxis":38,"emitter-component":10}],27:[function(require,module,exports){

/**
 * used in Core to convert the options into a volatile variable
 * 
 * @param {function} moment
 * @param {Object} body
 * @param {Array | Object} hiddenDates
 */
"use strict";

exports.convertHiddenOptions = function (moment, body, hiddenDates) {
  if (hiddenDates && !Array.isArray(hiddenDates)) {
    return exports.convertHiddenOptions(moment, body, [hiddenDates]);
  }

  body.hiddenDates = [];
  if (hiddenDates) {
    if (Array.isArray(hiddenDates) == true) {
      for (var i = 0; i < hiddenDates.length; i++) {
        if (hiddenDates[i].repeat === undefined) {
          var dateItem = {};
          dateItem.start = moment(hiddenDates[i].start).toDate().valueOf();
          dateItem.end = moment(hiddenDates[i].end).toDate().valueOf();
          body.hiddenDates.push(dateItem);
        }
      }
      body.hiddenDates.sort(function (a, b) {
        return a.start - b.start;
      }); // sort by start time
    }
  }
};

/**
 * create new entrees for the repeating hidden dates
 * @param {function} moment
 * @param {Object} body
 * @param {Array | Object} hiddenDates
 */
exports.updateHiddenDates = function (moment, body, hiddenDates) {
  if (hiddenDates && !Array.isArray(hiddenDates)) {
    return exports.updateHiddenDates(moment, body, [hiddenDates]);
  }

  if (hiddenDates && body.domProps.centerContainer.width !== undefined) {
    exports.convertHiddenOptions(moment, body, hiddenDates);

    var start = moment(body.range.start);
    var end = moment(body.range.end);

    var totalRange = body.range.end - body.range.start;
    var pixelTime = totalRange / body.domProps.centerContainer.width;

    for (var i = 0; i < hiddenDates.length; i++) {
      if (hiddenDates[i].repeat !== undefined) {
        var startDate = moment(hiddenDates[i].start);
        var endDate = moment(hiddenDates[i].end);

        if (startDate._d == "Invalid Date") {
          throw new Error("Supplied start date is not valid: " + hiddenDates[i].start);
        }
        if (endDate._d == "Invalid Date") {
          throw new Error("Supplied end date is not valid: " + hiddenDates[i].end);
        }

        var duration = endDate - startDate;
        if (duration >= 4 * pixelTime) {

          var offset = 0;
          var runUntil = end.clone();
          switch (hiddenDates[i].repeat) {
            case "daily":
              // case of time
              if (startDate.day() != endDate.day()) {
                offset = 1;
              }
              startDate.dayOfYear(start.dayOfYear());
              startDate.year(start.year());
              startDate.subtract(7, 'days');

              endDate.dayOfYear(start.dayOfYear());
              endDate.year(start.year());
              endDate.subtract(7 - offset, 'days');

              runUntil.add(1, 'weeks');
              break;
            case "weekly":
              var dayOffset = endDate.diff(startDate, 'days');
              var day = startDate.day();

              // set the start date to the range.start
              startDate.date(start.date());
              startDate.month(start.month());
              startDate.year(start.year());
              endDate = startDate.clone();

              // force
              startDate.day(day);
              endDate.day(day);
              endDate.add(dayOffset, 'days');

              startDate.subtract(1, 'weeks');
              endDate.subtract(1, 'weeks');

              runUntil.add(1, 'weeks');
              break;
            case "monthly":
              if (startDate.month() != endDate.month()) {
                offset = 1;
              }
              startDate.month(start.month());
              startDate.year(start.year());
              startDate.subtract(1, 'months');

              endDate.month(start.month());
              endDate.year(start.year());
              endDate.subtract(1, 'months');
              endDate.add(offset, 'months');

              runUntil.add(1, 'months');
              break;
            case "yearly":
              if (startDate.year() != endDate.year()) {
                offset = 1;
              }
              startDate.year(start.year());
              startDate.subtract(1, 'years');
              endDate.year(start.year());
              endDate.subtract(1, 'years');
              endDate.add(offset, 'years');

              runUntil.add(1, 'years');
              break;
            default:
              console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
              return;
          }
          while (startDate < runUntil) {
            body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
            switch (hiddenDates[i].repeat) {
              case "daily":
                startDate.add(1, 'days');
                endDate.add(1, 'days');
                break;
              case "weekly":
                startDate.add(1, 'weeks');
                endDate.add(1, 'weeks');
                break;
              case "monthly":
                startDate.add(1, 'months');
                endDate.add(1, 'months');
                break;
              case "yearly":
                startDate.add(1, 'y');
                endDate.add(1, 'y');
                break;
              default:
                console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                return;
            }
          }
          body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
        }
      }
    }
    // remove duplicates, merge where possible
    exports.removeDuplicates(body);
    // ensure the new positions are not on hidden dates
    var startHidden = exports.isHidden(body.range.start, body.hiddenDates);
    var endHidden = exports.isHidden(body.range.end, body.hiddenDates);
    var rangeStart = body.range.start;
    var rangeEnd = body.range.end;
    if (startHidden.hidden == true) {
      rangeStart = body.range.startToFront == true ? startHidden.startDate - 1 : startHidden.endDate + 1;
    }
    if (endHidden.hidden == true) {
      rangeEnd = body.range.endToFront == true ? endHidden.startDate - 1 : endHidden.endDate + 1;
    }
    if (startHidden.hidden == true || endHidden.hidden == true) {
      body.range._applyRange(rangeStart, rangeEnd);
    }
  }
};

/**
 * remove duplicates from the hidden dates list. Duplicates are evil. They mess everything up.
 * Scales with N^2
 * @param body
 */
exports.removeDuplicates = function (body) {
  var hiddenDates = body.hiddenDates;
  var safeDates = [];
  for (var i = 0; i < hiddenDates.length; i++) {
    for (var j = 0; j < hiddenDates.length; j++) {
      if (i != j && hiddenDates[j].remove != true && hiddenDates[i].remove != true) {
        // j inside i
        if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
          hiddenDates[j].remove = true;
        }
        // j start inside i
        else if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].start <= hiddenDates[i].end) {
            hiddenDates[i].end = hiddenDates[j].end;
            hiddenDates[j].remove = true;
          }
          // j end inside i
          else if (hiddenDates[j].end >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
              hiddenDates[i].start = hiddenDates[j].start;
              hiddenDates[j].remove = true;
            }
      }
    }
  }

  for (var i = 0; i < hiddenDates.length; i++) {
    if (hiddenDates[i].remove !== true) {
      safeDates.push(hiddenDates[i]);
    }
  }

  body.hiddenDates = safeDates;
  body.hiddenDates.sort(function (a, b) {
    return a.start - b.start;
  }); // sort by start time
};

exports.printDates = function (dates) {
  for (var i = 0; i < dates.length; i++) {
    console.log(i, new Date(dates[i].start), new Date(dates[i].end), dates[i].start, dates[i].end, dates[i].remove);
  }
};

/**
 * Used in TimeStep to avoid the hidden times.
 * @param {function} moment
 * @param {TimeStep} timeStep
 * @param previousTime
 */
exports.stepOverHiddenDates = function (moment, timeStep, previousTime) {
  var stepInHidden = false;
  var currentValue = timeStep.current.valueOf();
  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
    var startDate = timeStep.hiddenDates[i].start;
    var endDate = timeStep.hiddenDates[i].end;
    if (currentValue >= startDate && currentValue < endDate) {
      stepInHidden = true;
      break;
    }
  }

  if (stepInHidden == true && currentValue < timeStep._end.valueOf() && currentValue != previousTime) {
    var prevValue = moment(previousTime);
    var newValue = moment(endDate);
    //check if the next step should be major
    if (prevValue.year() != newValue.year()) {
      timeStep.switchedYear = true;
    } else if (prevValue.month() != newValue.month()) {
      timeStep.switchedMonth = true;
    } else if (prevValue.dayOfYear() != newValue.dayOfYear()) {
      timeStep.switchedDay = true;
    }

    timeStep.current = newValue;
  }
};

///**
// * Used in TimeStep to avoid the hidden times.
// * @param timeStep
// * @param previousTime
// */
//exports.checkFirstStep = function(timeStep) {
//  var stepInHidden = false;
//  var currentValue = timeStep.current.valueOf();
//  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
//    var startDate = timeStep.hiddenDates[i].start;
//    var endDate = timeStep.hiddenDates[i].end;
//    if (currentValue >= startDate && currentValue < endDate) {
//      stepInHidden = true;
//      break;
//    }
//  }
//
//  if (stepInHidden == true && currentValue <= timeStep._end.valueOf()) {
//    var newValue = moment(endDate);
//    timeStep.current = newValue.toDate();
//  }
//};

/**
 * replaces the Core toScreen methods
 * @param Core
 * @param time
 * @param width
 * @returns {number}
 */
exports.toScreen = function (Core, time, width) {
  if (Core.body.hiddenDates.length == 0) {
    var conversion = Core.range.conversion(width);
    return (time.valueOf() - conversion.offset) * conversion.scale;
  } else {
    var hidden = exports.isHidden(time, Core.body.hiddenDates);
    if (hidden.hidden == true) {
      time = hidden.startDate;
    }

    var duration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
    time = exports.correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, Core.range, time);

    var conversion = Core.range.conversion(width, duration);
    return (time.valueOf() - conversion.offset) * conversion.scale;
  }
};

/**
 * Replaces the core toTime methods
 * @param body
 * @param range
 * @param x
 * @param width
 * @returns {Date}
 */
exports.toTime = function (Core, x, width) {
  if (Core.body.hiddenDates.length == 0) {
    var conversion = Core.range.conversion(width);
    return new Date(x / conversion.scale + conversion.offset);
  } else {
    var hiddenDuration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
    var totalDuration = Core.range.end - Core.range.start - hiddenDuration;
    var partialDuration = totalDuration * x / width;
    var accumulatedHiddenDuration = exports.getAccumulatedHiddenDuration(Core.body.hiddenDates, Core.range, partialDuration);

    var newTime = new Date(accumulatedHiddenDuration + partialDuration + Core.range.start);
    return newTime;
  }
};

/**
 * Support function
 *
 * @param hiddenDates
 * @param range
 * @returns {number}
 */
exports.getHiddenDurationBetween = function (hiddenDates, start, end) {
  var duration = 0;
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= start && endDate < end) {
      duration += endDate - startDate;
    }
  }
  return duration;
};

/**
 * Support function
 * @param moment
 * @param hiddenDates
 * @param range
 * @param time
 * @returns {{duration: number, time: *, offset: number}}
 */
exports.correctTimeForHidden = function (moment, hiddenDates, range, time) {
  time = moment(time).toDate().valueOf();
  time -= exports.getHiddenDurationBefore(moment, hiddenDates, range, time);
  return time;
};

exports.getHiddenDurationBefore = function (moment, hiddenDates, range, time) {
  var timeOffset = 0;
  time = moment(time).toDate().valueOf();

  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= range.start && endDate < range.end) {
      if (time >= endDate) {
        timeOffset += endDate - startDate;
      }
    }
  }
  return timeOffset;
};

/**
 * sum the duration from start to finish, including the hidden duration,
 * until the required amount has been reached, return the accumulated hidden duration
 * @param hiddenDates
 * @param range
 * @param time
 * @returns {{duration: number, time: *, offset: number}}
 */
exports.getAccumulatedHiddenDuration = function (hiddenDates, range, requiredDuration) {
  var hiddenDuration = 0;
  var duration = 0;
  var previousPoint = range.start;
  //exports.printDates(hiddenDates)
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= range.start && endDate < range.end) {
      duration += startDate - previousPoint;
      previousPoint = endDate;
      if (duration >= requiredDuration) {
        break;
      } else {
        hiddenDuration += endDate - startDate;
      }
    }
  }

  return hiddenDuration;
};

/**
 * used to step over to either side of a hidden block. Correction is disabled on tablets, might be set to true
 * @param hiddenDates
 * @param time
 * @param direction
 * @param correctionEnabled
 * @returns {*}
 */
exports.snapAwayFromHidden = function (hiddenDates, time, direction, correctionEnabled) {
  var isHidden = exports.isHidden(time, hiddenDates);
  if (isHidden.hidden == true) {
    if (direction < 0) {
      if (correctionEnabled == true) {
        return isHidden.startDate - (isHidden.endDate - time) - 1;
      } else {
        return isHidden.startDate - 1;
      }
    } else {
      if (correctionEnabled == true) {
        return isHidden.endDate + (time - isHidden.startDate) + 1;
      } else {
        return isHidden.endDate + 1;
      }
    }
  } else {
    return time;
  }
};

/**
 * Check if a time is hidden
 *
 * @param time
 * @param hiddenDates
 * @returns {{hidden: boolean, startDate: Window.start, endDate: *}}
 */
exports.isHidden = function (time, hiddenDates) {
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;

    if (time >= startDate && time < endDate) {
      // if the start is entering a hidden zone
      return { hidden: true, startDate: startDate, endDate: endDate };
      break;
    }
  }
  return { hidden: false, startDate: startDate, endDate: endDate };
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL0RhdGVVdGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFRQSxPQUFPLENBQUMsb0JBQW9CLEdBQUcsVUFBUyxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRTtBQUNqRSxNQUFJLFdBQVcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUU7QUFDOUMsV0FBTyxPQUFPLENBQUMsb0JBQW9CLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUE7R0FDakU7O0FBRUQsTUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7QUFDdEIsTUFBSSxXQUFXLEVBQUU7QUFDZixRQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksSUFBSSxFQUFFO0FBQ3RDLFdBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzNDLFlBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7QUFDdkMsY0FBSSxRQUFRLEdBQUcsRUFBRSxDQUFDO0FBQ2xCLGtCQUFRLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDakUsa0JBQVEsQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUM3RCxjQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNqQztPQUNGO0FBQ0QsVUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ3BDLGVBQU8sQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDO09BQzFCLENBQUMsQ0FBQztLQUNKO0dBQ0Y7Q0FDRixDQUFDOzs7Ozs7OztBQVNGLE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxVQUFVLE1BQU0sRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO0FBQy9ELE1BQUksV0FBVyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRTtBQUM5QyxXQUFPLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQTtHQUM5RDs7QUFFRCxNQUFJLFdBQVcsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFO0FBQ3BFLFdBQU8sQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDOztBQUV4RCxRQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNyQyxRQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFFakMsUUFBSSxVQUFVLEdBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEFBQUMsQ0FBQztBQUNyRCxRQUFJLFNBQVMsR0FBRyxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDOztBQUVqRSxTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMzQyxVQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO0FBQ3ZDLFlBQUksU0FBUyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDN0MsWUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFFekMsWUFBSSxTQUFTLENBQUMsRUFBRSxJQUFJLGNBQWMsRUFBRTtBQUNsQyxnQkFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDOUU7QUFDRCxZQUFJLE9BQU8sQ0FBQyxFQUFFLElBQUksY0FBYyxFQUFFO0FBQ2hDLGdCQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMxRTs7QUFFRCxZQUFJLFFBQVEsR0FBRyxPQUFPLEdBQUcsU0FBUyxDQUFDO0FBQ25DLFlBQUksUUFBUSxJQUFJLENBQUMsR0FBRyxTQUFTLEVBQUU7O0FBRTdCLGNBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztBQUNmLGNBQUksUUFBUSxHQUFHLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUMzQixrQkFBUSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTTtBQUMzQixpQkFBSyxPQUFPOztBQUNWLGtCQUFJLFNBQVMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUU7QUFDcEMsc0JBQU0sR0FBRyxDQUFDLENBQUM7ZUFDWjtBQUNELHVCQUFTLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0FBQ3ZDLHVCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQzdCLHVCQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBQyxNQUFNLENBQUMsQ0FBQzs7QUFFN0IscUJBQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7QUFDckMscUJBQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7QUFDM0IscUJBQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBQyxNQUFNLENBQUMsQ0FBQzs7QUFFcEMsc0JBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3pCLG9CQUFNO0FBQUEsQUFDUixpQkFBSyxRQUFRO0FBQ1gsa0JBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFDLE1BQU0sQ0FBQyxDQUFBO0FBQzlDLGtCQUFJLEdBQUcsR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7OztBQUcxQix1QkFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUM3Qix1QkFBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztBQUMvQix1QkFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUM3QixxQkFBTyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQzs7O0FBRzVCLHVCQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ25CLHFCQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2pCLHFCQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBQyxNQUFNLENBQUMsQ0FBQzs7QUFFOUIsdUJBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzlCLHFCQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBQyxPQUFPLENBQUMsQ0FBQzs7QUFFNUIsc0JBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3pCLG9CQUFLO0FBQUEsQUFDUCxpQkFBSyxTQUFTO0FBQ1osa0JBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRTtBQUN4QyxzQkFBTSxHQUFHLENBQUMsQ0FBQztlQUNaO0FBQ0QsdUJBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7QUFDL0IsdUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7QUFDN0IsdUJBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUUvQixxQkFBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztBQUM3QixxQkFBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUMzQixxQkFBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUMsUUFBUSxDQUFDLENBQUM7QUFDN0IscUJBQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUU3QixzQkFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDMUIsb0JBQU07QUFBQSxBQUNSLGlCQUFLLFFBQVE7QUFDWCxrQkFBSSxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFO0FBQ3RDLHNCQUFNLEdBQUcsQ0FBQyxDQUFDO2VBQ1o7QUFDRCx1QkFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUM3Qix1QkFBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUMsT0FBTyxDQUFDLENBQUM7QUFDOUIscUJBQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7QUFDM0IscUJBQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzVCLHFCQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBQyxPQUFPLENBQUMsQ0FBQzs7QUFFNUIsc0JBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3pCLG9CQUFNO0FBQUEsQUFDUjtBQUNFLHFCQUFPLENBQUMsR0FBRyxDQUFDLDBFQUEwRSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMvRyxxQkFBTztBQUFBLFdBQ1Y7QUFDRCxpQkFBTyxTQUFTLEdBQUcsUUFBUSxFQUFFO0FBQzNCLGdCQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsT0FBTyxFQUFFLEVBQUUsR0FBRyxFQUFFLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBQyxDQUFDLENBQUM7QUFDNUUsb0JBQVEsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU07QUFDM0IsbUJBQUssT0FBTztBQUNWLHlCQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUN6Qix1QkFBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDdkIsc0JBQU07QUFBQSxBQUNSLG1CQUFLLFFBQVE7QUFDWCx5QkFBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDMUIsdUJBQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3hCLHNCQUFNO0FBQUEsQUFDUixtQkFBSyxTQUFTO0FBQ1oseUJBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQzNCLHVCQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztBQUN6QixzQkFBTTtBQUFBLEFBQ1IsbUJBQUssUUFBUTtBQUNYLHlCQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUN0Qix1QkFBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDcEIsc0JBQU07QUFBQSxBQUNSO0FBQ0UsdUJBQU8sQ0FBQyxHQUFHLENBQUMsMEVBQTBFLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQy9HLHVCQUFPO0FBQUEsYUFDVjtXQUNGO0FBQ0QsY0FBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLE9BQU8sRUFBRSxFQUFFLEdBQUcsRUFBRSxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUMsQ0FBQyxDQUFDO1NBQzdFO09BQ0Y7S0FDRjs7QUFFRCxXQUFPLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRS9CLFFBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3ZFLFFBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ2xFLFFBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO0FBQ2xDLFFBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO0FBQzlCLFFBQUksV0FBVyxDQUFDLE1BQU0sSUFBSSxJQUFJLEVBQUU7QUFBQyxnQkFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxJQUFJLElBQUksR0FBRyxXQUFXLENBQUMsU0FBUyxHQUFHLENBQUMsR0FBRyxXQUFXLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQztLQUFDO0FBQ3JJLFFBQUksU0FBUyxDQUFDLE1BQU0sSUFBSSxJQUFJLEVBQUk7QUFBQyxjQUFRLEdBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLElBQUksSUFBSSxHQUFLLFNBQVMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxHQUFLLFNBQVMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0tBQUM7QUFDbkksUUFBSSxXQUFXLENBQUMsTUFBTSxJQUFJLElBQUksSUFBSSxTQUFTLENBQUMsTUFBTSxJQUFJLElBQUksRUFBRTtBQUMxRCxVQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7S0FDOUM7R0FDRjtDQUVGLENBQUE7Ozs7Ozs7QUFRRCxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsVUFBUyxJQUFJLEVBQUU7QUFDeEMsTUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztBQUNuQyxNQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDbkIsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDM0MsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDM0MsVUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksSUFBSSxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksSUFBSSxFQUFFOztBQUU1RSxZQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUU7QUFDNUYscUJBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1NBQzlCOzthQUVJLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRTtBQUNuRyx1QkFBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ3hDLHVCQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztXQUM5Qjs7ZUFFSSxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUU7QUFDL0YseUJBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUM1Qyx5QkFBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7YUFDOUI7T0FDRjtLQUNGO0dBQ0Y7O0FBRUQsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDM0MsUUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLElBQUksRUFBRTtBQUNsQyxlQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2hDO0dBQ0Y7O0FBRUQsTUFBSSxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUM7QUFDN0IsTUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ3BDLFdBQU8sQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDO0dBQzFCLENBQUMsQ0FBQztDQUNKLENBQUM7O0FBRUYsT0FBTyxDQUFDLFVBQVUsR0FBRyxVQUFTLEtBQUssRUFBRTtBQUNuQyxPQUFLLElBQUksQ0FBQyxHQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNwQyxXQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7R0FDaEg7Q0FDRixDQUFDOzs7Ozs7OztBQVFGLE9BQU8sQ0FBQyxtQkFBbUIsR0FBRyxVQUFTLE1BQU0sRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFO0FBQ3JFLE1BQUksWUFBWSxHQUFHLEtBQUssQ0FBQztBQUN6QixNQUFJLFlBQVksR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQzlDLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNwRCxRQUFJLFNBQVMsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUM5QyxRQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUMxQyxRQUFJLFlBQVksSUFBSSxTQUFTLElBQUksWUFBWSxHQUFHLE9BQU8sRUFBRTtBQUN2RCxrQkFBWSxHQUFHLElBQUksQ0FBQztBQUNwQixZQUFNO0tBQ1A7R0FDRjs7QUFFRCxNQUFJLFlBQVksSUFBSSxJQUFJLElBQUksWUFBWSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksWUFBWSxJQUFJLFlBQVksRUFBRTtBQUNsRyxRQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDckMsUUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQUUvQixRQUFJLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUU7QUFBQyxjQUFRLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztLQUFDLE1BQ25FLElBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLFFBQVEsQ0FBQyxLQUFLLEVBQUUsRUFBRTtBQUFDLGNBQVEsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO0tBQUMsTUFDM0UsSUFBSSxTQUFTLENBQUMsU0FBUyxFQUFFLElBQUksUUFBUSxDQUFDLFNBQVMsRUFBRSxFQUFFO0FBQUMsY0FBUSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7S0FBQzs7QUFFdEYsWUFBUSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUM7R0FDN0I7Q0FDRixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDRixPQUFPLENBQUMsUUFBUSxHQUFHLFVBQVMsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7QUFDN0MsTUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO0FBQ3JDLFFBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzlDLFdBQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQSxHQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUM7R0FDaEUsTUFDSTtBQUNILFFBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDM0QsUUFBSSxNQUFNLENBQUMsTUFBTSxJQUFJLElBQUksRUFBRTtBQUN6QixVQUFJLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztLQUN6Qjs7QUFFRCxRQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN6RyxRQUFJLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7O0FBRWxHLFFBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztBQUN4RCxXQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUEsR0FBSSxVQUFVLENBQUMsS0FBSyxDQUFDO0dBQ2hFO0NBQ0YsQ0FBQzs7Ozs7Ozs7OztBQVdGLE9BQU8sQ0FBQyxNQUFNLEdBQUcsVUFBUyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRTtBQUN4QyxNQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7QUFDckMsUUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDOUMsV0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7R0FDM0QsTUFDSTtBQUNILFFBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQy9HLFFBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLGNBQWMsQ0FBQztBQUN2RSxRQUFJLGVBQWUsR0FBRyxhQUFhLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztBQUNoRCxRQUFJLHlCQUF5QixHQUFHLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLGVBQWUsQ0FBQyxDQUFDOztBQUV6SCxRQUFJLE9BQU8sR0FBRyxJQUFJLElBQUksQ0FBQyx5QkFBeUIsR0FBRyxlQUFlLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN2RixXQUFPLE9BQU8sQ0FBQztHQUNoQjtDQUNGLENBQUM7Ozs7Ozs7OztBQVVGLE9BQU8sQ0FBQyx3QkFBd0IsR0FBRyxVQUFTLFdBQVcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFO0FBQ25FLE1BQUksUUFBUSxHQUFHLENBQUMsQ0FBQztBQUNqQixPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMzQyxRQUFJLFNBQVMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ3JDLFFBQUksT0FBTyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7O0FBRWpDLFFBQUksU0FBUyxJQUFJLEtBQUssSUFBSSxPQUFPLEdBQUcsR0FBRyxFQUFFO0FBQ3ZDLGNBQVEsSUFBSSxPQUFPLEdBQUcsU0FBUyxDQUFDO0tBQ2pDO0dBQ0Y7QUFDRCxTQUFPLFFBQVEsQ0FBQztDQUNqQixDQUFDOzs7Ozs7Ozs7O0FBV0YsT0FBTyxDQUFDLG9CQUFvQixHQUFHLFVBQVMsTUFBTSxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFO0FBQ3hFLE1BQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDdkMsTUFBSSxJQUFJLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxNQUFNLEVBQUUsV0FBVyxFQUFDLEtBQUssRUFBQyxJQUFJLENBQUMsQ0FBQztBQUN4RSxTQUFPLElBQUksQ0FBQztDQUNiLENBQUM7O0FBRUYsT0FBTyxDQUFDLHVCQUF1QixHQUFHLFVBQVMsTUFBTSxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFO0FBQzNFLE1BQUksVUFBVSxHQUFHLENBQUMsQ0FBQztBQUNuQixNQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDOztBQUV2QyxPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMzQyxRQUFJLFNBQVMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ3JDLFFBQUksT0FBTyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7O0FBRWpDLFFBQUksU0FBUyxJQUFJLEtBQUssQ0FBQyxLQUFLLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUU7QUFDbkQsVUFBSSxJQUFJLElBQUksT0FBTyxFQUFFO0FBQ25CLGtCQUFVLElBQUssT0FBTyxHQUFHLFNBQVMsQUFBQyxDQUFDO09BQ3JDO0tBQ0Y7R0FDRjtBQUNELFNBQU8sVUFBVSxDQUFDO0NBQ25CLENBQUE7Ozs7Ozs7Ozs7QUFVRCxPQUFPLENBQUMsNEJBQTRCLEdBQUcsVUFBUyxXQUFXLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFO0FBQ3BGLE1BQUksY0FBYyxHQUFHLENBQUMsQ0FBQztBQUN2QixNQUFJLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFDakIsTUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQzs7QUFFaEMsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDM0MsUUFBSSxTQUFTLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNyQyxRQUFJLE9BQU8sR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDOztBQUVqQyxRQUFJLFNBQVMsSUFBSSxLQUFLLENBQUMsS0FBSyxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsR0FBRyxFQUFFO0FBQ25ELGNBQVEsSUFBSSxTQUFTLEdBQUcsYUFBYSxDQUFDO0FBQ3RDLG1CQUFhLEdBQUcsT0FBTyxDQUFDO0FBQ3hCLFVBQUksUUFBUSxJQUFJLGdCQUFnQixFQUFFO0FBQ2hDLGNBQU07T0FDUCxNQUNJO0FBQ0gsc0JBQWMsSUFBSSxPQUFPLEdBQUcsU0FBUyxDQUFDO09BQ3ZDO0tBQ0Y7R0FDRjs7QUFFRCxTQUFPLGNBQWMsQ0FBQztDQUN2QixDQUFDOzs7Ozs7Ozs7O0FBWUYsT0FBTyxDQUFDLGtCQUFrQixHQUFHLFVBQVMsV0FBVyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsaUJBQWlCLEVBQUU7QUFDckYsTUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDbkQsTUFBSSxRQUFRLENBQUMsTUFBTSxJQUFJLElBQUksRUFBRTtBQUMzQixRQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUU7QUFDakIsVUFBSSxpQkFBaUIsSUFBSSxJQUFJLEVBQUU7QUFDN0IsZUFBTyxRQUFRLENBQUMsU0FBUyxJQUFJLFFBQVEsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFBLEFBQUMsR0FBRyxDQUFDLENBQUM7T0FDM0QsTUFDSTtBQUNILGVBQU8sUUFBUSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7T0FDL0I7S0FDRixNQUNJO0FBQ0gsVUFBSSxpQkFBaUIsSUFBSSxJQUFJLEVBQUU7QUFDN0IsZUFBTyxRQUFRLENBQUMsT0FBTyxJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFBLEFBQUMsR0FBRyxDQUFDLENBQUM7T0FDM0QsTUFDSTtBQUNILGVBQU8sUUFBUSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7T0FDN0I7S0FDRjtHQUNGLE1BQ0k7QUFDSCxXQUFPLElBQUksQ0FBQztHQUNiO0NBRUYsQ0FBQTs7Ozs7Ozs7O0FBVUQsT0FBTyxDQUFDLFFBQVEsR0FBRyxVQUFTLElBQUksRUFBRSxXQUFXLEVBQUU7QUFDN0MsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDM0MsUUFBSSxTQUFTLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNyQyxRQUFJLE9BQU8sR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDOztBQUVqQyxRQUFJLElBQUksSUFBSSxTQUFTLElBQUksSUFBSSxHQUFHLE9BQU8sRUFBRTs7QUFDdkMsYUFBTyxFQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFDLENBQUM7QUFDOUQsWUFBTTtLQUNQO0dBQ0Y7QUFDRCxTQUFPLEVBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUMsQ0FBQztDQUNoRSxDQUFBIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL0RhdGVVdGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIHVzZWQgaW4gQ29yZSB0byBjb252ZXJ0IHRoZSBvcHRpb25zIGludG8gYSB2b2xhdGlsZSB2YXJpYWJsZVxuICogXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb21lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gKiBAcGFyYW0ge0FycmF5IHwgT2JqZWN0fSBoaWRkZW5EYXRlc1xuICovXG5leHBvcnRzLmNvbnZlcnRIaWRkZW5PcHRpb25zID0gZnVuY3Rpb24obW9tZW50LCBib2R5LCBoaWRkZW5EYXRlcykge1xuICBpZiAoaGlkZGVuRGF0ZXMgJiYgIUFycmF5LmlzQXJyYXkoaGlkZGVuRGF0ZXMpKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29udmVydEhpZGRlbk9wdGlvbnMobW9tZW50LCBib2R5LCBbaGlkZGVuRGF0ZXNdKVxuICB9XG5cbiAgYm9keS5oaWRkZW5EYXRlcyA9IFtdO1xuICBpZiAoaGlkZGVuRGF0ZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoaWRkZW5EYXRlcykgPT0gdHJ1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGlkZGVuRGF0ZXNbaV0ucmVwZWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZGF0ZUl0ZW0gPSB7fTtcbiAgICAgICAgICBkYXRlSXRlbS5zdGFydCA9IG1vbWVudChoaWRkZW5EYXRlc1tpXS5zdGFydCkudG9EYXRlKCkudmFsdWVPZigpO1xuICAgICAgICAgIGRhdGVJdGVtLmVuZCA9IG1vbWVudChoaWRkZW5EYXRlc1tpXS5lbmQpLnRvRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgICBib2R5LmhpZGRlbkRhdGVzLnB1c2goZGF0ZUl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBib2R5LmhpZGRlbkRhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgICAgfSk7IC8vIHNvcnQgYnkgc3RhcnQgdGltZVxuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIGNyZWF0ZSBuZXcgZW50cmVlcyBmb3IgdGhlIHJlcGVhdGluZyBoaWRkZW4gZGF0ZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAqIEBwYXJhbSB7QXJyYXkgfCBPYmplY3R9IGhpZGRlbkRhdGVzXG4gKi9cbmV4cG9ydHMudXBkYXRlSGlkZGVuRGF0ZXMgPSBmdW5jdGlvbiAobW9tZW50LCBib2R5LCBoaWRkZW5EYXRlcykge1xuICBpZiAoaGlkZGVuRGF0ZXMgJiYgIUFycmF5LmlzQXJyYXkoaGlkZGVuRGF0ZXMpKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudXBkYXRlSGlkZGVuRGF0ZXMobW9tZW50LCBib2R5LCBbaGlkZGVuRGF0ZXNdKVxuICB9XG5cbiAgaWYgKGhpZGRlbkRhdGVzICYmIGJvZHkuZG9tUHJvcHMuY2VudGVyQ29udGFpbmVyLndpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHBvcnRzLmNvbnZlcnRIaWRkZW5PcHRpb25zKG1vbWVudCwgYm9keSwgaGlkZGVuRGF0ZXMpO1xuXG4gICAgdmFyIHN0YXJ0ID0gbW9tZW50KGJvZHkucmFuZ2Uuc3RhcnQpO1xuICAgIHZhciBlbmQgPSBtb21lbnQoYm9keS5yYW5nZS5lbmQpO1xuXG4gICAgdmFyIHRvdGFsUmFuZ2UgPSAoYm9keS5yYW5nZS5lbmQgLSBib2R5LnJhbmdlLnN0YXJ0KTtcbiAgICB2YXIgcGl4ZWxUaW1lID0gdG90YWxSYW5nZSAvIGJvZHkuZG9tUHJvcHMuY2VudGVyQ29udGFpbmVyLndpZHRoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhpZGRlbkRhdGVzW2ldLnJlcGVhdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzdGFydERhdGUgPSBtb21lbnQoaGlkZGVuRGF0ZXNbaV0uc3RhcnQpO1xuICAgICAgICB2YXIgZW5kRGF0ZSA9IG1vbWVudChoaWRkZW5EYXRlc1tpXS5lbmQpO1xuXG4gICAgICAgIGlmIChzdGFydERhdGUuX2QgPT0gXCJJbnZhbGlkIERhdGVcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cHBsaWVkIHN0YXJ0IGRhdGUgaXMgbm90IHZhbGlkOiBcIiArIGhpZGRlbkRhdGVzW2ldLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kRGF0ZS5fZCA9PSBcIkludmFsaWQgRGF0ZVwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VwcGxpZWQgZW5kIGRhdGUgaXMgbm90IHZhbGlkOiBcIiArIGhpZGRlbkRhdGVzW2ldLmVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHVyYXRpb24gPSBlbmREYXRlIC0gc3RhcnREYXRlO1xuICAgICAgICBpZiAoZHVyYXRpb24gPj0gNCAqIHBpeGVsVGltZSkge1xuXG4gICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgdmFyIHJ1blVudGlsID0gZW5kLmNsb25lKCk7XG4gICAgICAgICAgc3dpdGNoIChoaWRkZW5EYXRlc1tpXS5yZXBlYXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkYWlseVwiOiAvLyBjYXNlIG9mIHRpbWVcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0RGF0ZS5kYXkoKSAhPSBlbmREYXRlLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGFydERhdGUuZGF5T2ZZZWFyKHN0YXJ0LmRheU9mWWVhcigpKTtcbiAgICAgICAgICAgICAgc3RhcnREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgc3RhcnREYXRlLnN1YnRyYWN0KDcsJ2RheXMnKTtcblxuICAgICAgICAgICAgICBlbmREYXRlLmRheU9mWWVhcihzdGFydC5kYXlPZlllYXIoKSk7XG4gICAgICAgICAgICAgIGVuZERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICBlbmREYXRlLnN1YnRyYWN0KDcgLSBvZmZzZXQsJ2RheXMnKTtcblxuICAgICAgICAgICAgICBydW5VbnRpbC5hZGQoMSwgJ3dlZWtzJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIndlZWtseVwiOlxuICAgICAgICAgICAgICB2YXIgZGF5T2Zmc2V0ID0gZW5kRGF0ZS5kaWZmKHN0YXJ0RGF0ZSwnZGF5cycpXG4gICAgICAgICAgICAgIHZhciBkYXkgPSBzdGFydERhdGUuZGF5KCk7XG5cbiAgICAgICAgICAgICAgLy8gc2V0IHRoZSBzdGFydCBkYXRlIHRvIHRoZSByYW5nZS5zdGFydFxuICAgICAgICAgICAgICBzdGFydERhdGUuZGF0ZShzdGFydC5kYXRlKCkpO1xuICAgICAgICAgICAgICBzdGFydERhdGUubW9udGgoc3RhcnQubW9udGgoKSk7XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgIGVuZERhdGUgPSBzdGFydERhdGUuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAvLyBmb3JjZVxuICAgICAgICAgICAgICBzdGFydERhdGUuZGF5KGRheSk7XG4gICAgICAgICAgICAgIGVuZERhdGUuZGF5KGRheSk7XG4gICAgICAgICAgICAgIGVuZERhdGUuYWRkKGRheU9mZnNldCwnZGF5cycpO1xuXG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zdWJ0cmFjdCgxLCd3ZWVrcycpO1xuICAgICAgICAgICAgICBlbmREYXRlLnN1YnRyYWN0KDEsJ3dlZWtzJyk7XG5cbiAgICAgICAgICAgICAgcnVuVW50aWwuYWRkKDEsICd3ZWVrcycpO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBcIm1vbnRobHlcIjpcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0RGF0ZS5tb250aCgpICE9IGVuZERhdGUubW9udGgoKSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhcnREYXRlLm1vbnRoKHN0YXJ0Lm1vbnRoKCkpO1xuICAgICAgICAgICAgICBzdGFydERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICBzdGFydERhdGUuc3VidHJhY3QoMSwnbW9udGhzJyk7XG5cbiAgICAgICAgICAgICAgZW5kRGF0ZS5tb250aChzdGFydC5tb250aCgpKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgIGVuZERhdGUuc3VidHJhY3QoMSwnbW9udGhzJyk7XG4gICAgICAgICAgICAgIGVuZERhdGUuYWRkKG9mZnNldCwnbW9udGhzJyk7XG5cbiAgICAgICAgICAgICAgcnVuVW50aWwuYWRkKDEsICdtb250aHMnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwieWVhcmx5XCI6XG4gICAgICAgICAgICAgIGlmIChzdGFydERhdGUueWVhcigpICE9IGVuZERhdGUueWVhcigpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGFydERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICBzdGFydERhdGUuc3VidHJhY3QoMSwneWVhcnMnKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgIGVuZERhdGUuc3VidHJhY3QoMSwneWVhcnMnKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQob2Zmc2V0LCd5ZWFycycpO1xuXG4gICAgICAgICAgICAgIHJ1blVudGlsLmFkZCgxLCAneWVhcnMnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldyb25nIHJlcGVhdCBmb3JtYXQsIGFsbG93ZWQgYXJlOiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCB5ZWFybHkuIEdpdmVuOlwiLCBoaWRkZW5EYXRlc1tpXS5yZXBlYXQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChzdGFydERhdGUgPCBydW5VbnRpbCkge1xuICAgICAgICAgICAgYm9keS5oaWRkZW5EYXRlcy5wdXNoKHtzdGFydDogc3RhcnREYXRlLnZhbHVlT2YoKSwgZW5kOiBlbmREYXRlLnZhbHVlT2YoKX0pO1xuICAgICAgICAgICAgc3dpdGNoIChoaWRkZW5EYXRlc1tpXS5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImRhaWx5XCI6XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLmFkZCgxLCAnZGF5cycpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuYWRkKDEsICdkYXlzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ3ZWVrbHlcIjpcbiAgICAgICAgICAgICAgICBzdGFydERhdGUuYWRkKDEsICd3ZWVrcycpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuYWRkKDEsICd3ZWVrcycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwibW9udGhseVwiOlxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5hZGQoMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuYWRkKDEsICdtb250aHMnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInllYXJseVwiOlxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5hZGQoMSwgJ3knKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLmFkZCgxLCAneScpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV3JvbmcgcmVwZWF0IGZvcm1hdCwgYWxsb3dlZCBhcmU6IGRhaWx5LCB3ZWVrbHksIG1vbnRobHksIHllYXJseS4gR2l2ZW46XCIsIGhpZGRlbkRhdGVzW2ldLnJlcGVhdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBib2R5LmhpZGRlbkRhdGVzLnB1c2goe3N0YXJ0OiBzdGFydERhdGUudmFsdWVPZigpLCBlbmQ6IGVuZERhdGUudmFsdWVPZigpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZXMsIG1lcmdlIHdoZXJlIHBvc3NpYmxlXG4gICAgZXhwb3J0cy5yZW1vdmVEdXBsaWNhdGVzKGJvZHkpO1xuICAgIC8vIGVuc3VyZSB0aGUgbmV3IHBvc2l0aW9ucyBhcmUgbm90IG9uIGhpZGRlbiBkYXRlc1xuICAgIHZhciBzdGFydEhpZGRlbiA9IGV4cG9ydHMuaXNIaWRkZW4oYm9keS5yYW5nZS5zdGFydCwgYm9keS5oaWRkZW5EYXRlcyk7XG4gICAgdmFyIGVuZEhpZGRlbiA9IGV4cG9ydHMuaXNIaWRkZW4oYm9keS5yYW5nZS5lbmQsYm9keS5oaWRkZW5EYXRlcyk7XG4gICAgdmFyIHJhbmdlU3RhcnQgPSBib2R5LnJhbmdlLnN0YXJ0O1xuICAgIHZhciByYW5nZUVuZCA9IGJvZHkucmFuZ2UuZW5kO1xuICAgIGlmIChzdGFydEhpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkge3JhbmdlU3RhcnQgPSBib2R5LnJhbmdlLnN0YXJ0VG9Gcm9udCA9PSB0cnVlID8gc3RhcnRIaWRkZW4uc3RhcnREYXRlIC0gMSA6IHN0YXJ0SGlkZGVuLmVuZERhdGUgKyAxO31cbiAgICBpZiAoZW5kSGlkZGVuLmhpZGRlbiA9PSB0cnVlKSAgIHtyYW5nZUVuZCAgID0gYm9keS5yYW5nZS5lbmRUb0Zyb250ID09IHRydWUgPyAgIGVuZEhpZGRlbi5zdGFydERhdGUgLSAxICAgOiBlbmRIaWRkZW4uZW5kRGF0ZSArIDE7fVxuICAgIGlmIChzdGFydEhpZGRlbi5oaWRkZW4gPT0gdHJ1ZSB8fCBlbmRIaWRkZW4uaGlkZGVuID09IHRydWUpIHtcbiAgICAgIGJvZHkucmFuZ2UuX2FwcGx5UmFuZ2UocmFuZ2VTdGFydCwgcmFuZ2VFbmQpO1xuICAgIH1cbiAgfVxuXG59XG5cblxuLyoqXG4gKiByZW1vdmUgZHVwbGljYXRlcyBmcm9tIHRoZSBoaWRkZW4gZGF0ZXMgbGlzdC4gRHVwbGljYXRlcyBhcmUgZXZpbC4gVGhleSBtZXNzIGV2ZXJ5dGhpbmcgdXAuXG4gKiBTY2FsZXMgd2l0aCBOXjJcbiAqIEBwYXJhbSBib2R5XG4gKi9cbmV4cG9ydHMucmVtb3ZlRHVwbGljYXRlcyA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgdmFyIGhpZGRlbkRhdGVzID0gYm9keS5oaWRkZW5EYXRlcztcbiAgdmFyIHNhZmVEYXRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGkgIT0gaiAmJiBoaWRkZW5EYXRlc1tqXS5yZW1vdmUgIT0gdHJ1ZSAmJiBoaWRkZW5EYXRlc1tpXS5yZW1vdmUgIT0gdHJ1ZSkge1xuICAgICAgICAvLyBqIGluc2lkZSBpXG4gICAgICAgIGlmIChoaWRkZW5EYXRlc1tqXS5zdGFydCA+PSBoaWRkZW5EYXRlc1tpXS5zdGFydCAmJiBoaWRkZW5EYXRlc1tqXS5lbmQgPD0gaGlkZGVuRGF0ZXNbaV0uZW5kKSB7XG4gICAgICAgICAgaGlkZGVuRGF0ZXNbal0ucmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBqIHN0YXJ0IGluc2lkZSBpXG4gICAgICAgIGVsc2UgaWYgKGhpZGRlbkRhdGVzW2pdLnN0YXJ0ID49IGhpZGRlbkRhdGVzW2ldLnN0YXJ0ICYmIGhpZGRlbkRhdGVzW2pdLnN0YXJ0IDw9IGhpZGRlbkRhdGVzW2ldLmVuZCkge1xuICAgICAgICAgIGhpZGRlbkRhdGVzW2ldLmVuZCA9IGhpZGRlbkRhdGVzW2pdLmVuZDtcbiAgICAgICAgICBoaWRkZW5EYXRlc1tqXS5yZW1vdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGogZW5kIGluc2lkZSBpXG4gICAgICAgIGVsc2UgaWYgKGhpZGRlbkRhdGVzW2pdLmVuZCA+PSBoaWRkZW5EYXRlc1tpXS5zdGFydCAmJiBoaWRkZW5EYXRlc1tqXS5lbmQgPD0gaGlkZGVuRGF0ZXNbaV0uZW5kKSB7XG4gICAgICAgICAgaGlkZGVuRGF0ZXNbaV0uc3RhcnQgPSBoaWRkZW5EYXRlc1tqXS5zdGFydDtcbiAgICAgICAgICBoaWRkZW5EYXRlc1tqXS5yZW1vdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChoaWRkZW5EYXRlc1tpXS5yZW1vdmUgIT09IHRydWUpIHtcbiAgICAgIHNhZmVEYXRlcy5wdXNoKGhpZGRlbkRhdGVzW2ldKTtcbiAgICB9XG4gIH1cblxuICBib2R5LmhpZGRlbkRhdGVzID0gc2FmZURhdGVzO1xuICBib2R5LmhpZGRlbkRhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG4gIH0pOyAvLyBzb3J0IGJ5IHN0YXJ0IHRpbWVcbn07XG5cbmV4cG9ydHMucHJpbnREYXRlcyA9IGZ1bmN0aW9uKGRhdGVzKSB7XG4gIGZvciAodmFyIGkgPTA7IGkgPCBkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnNvbGUubG9nKGksIG5ldyBEYXRlKGRhdGVzW2ldLnN0YXJ0KSxuZXcgRGF0ZShkYXRlc1tpXS5lbmQpLCBkYXRlc1tpXS5zdGFydCwgZGF0ZXNbaV0uZW5kLCBkYXRlc1tpXS5yZW1vdmUpO1xuICB9XG59O1xuXG4vKipcbiAqIFVzZWQgaW4gVGltZVN0ZXAgdG8gYXZvaWQgdGhlIGhpZGRlbiB0aW1lcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vbWVudFxuICogQHBhcmFtIHtUaW1lU3RlcH0gdGltZVN0ZXBcbiAqIEBwYXJhbSBwcmV2aW91c1RpbWVcbiAqL1xuZXhwb3J0cy5zdGVwT3ZlckhpZGRlbkRhdGVzID0gZnVuY3Rpb24obW9tZW50LCB0aW1lU3RlcCwgcHJldmlvdXNUaW1lKSB7XG4gIHZhciBzdGVwSW5IaWRkZW4gPSBmYWxzZTtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRpbWVTdGVwLmN1cnJlbnQudmFsdWVPZigpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVTdGVwLmhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0YXJ0RGF0ZSA9IHRpbWVTdGVwLmhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgIHZhciBlbmREYXRlID0gdGltZVN0ZXAuaGlkZGVuRGF0ZXNbaV0uZW5kO1xuICAgIGlmIChjdXJyZW50VmFsdWUgPj0gc3RhcnREYXRlICYmIGN1cnJlbnRWYWx1ZSA8IGVuZERhdGUpIHtcbiAgICAgIHN0ZXBJbkhpZGRlbiA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RlcEluSGlkZGVuID09IHRydWUgJiYgY3VycmVudFZhbHVlIDwgdGltZVN0ZXAuX2VuZC52YWx1ZU9mKCkgJiYgY3VycmVudFZhbHVlICE9IHByZXZpb3VzVGltZSkge1xuICAgIHZhciBwcmV2VmFsdWUgPSBtb21lbnQocHJldmlvdXNUaW1lKTtcbiAgICB2YXIgbmV3VmFsdWUgPSBtb21lbnQoZW5kRGF0ZSk7XG4gICAgLy9jaGVjayBpZiB0aGUgbmV4dCBzdGVwIHNob3VsZCBiZSBtYWpvclxuICAgIGlmIChwcmV2VmFsdWUueWVhcigpICE9IG5ld1ZhbHVlLnllYXIoKSkge3RpbWVTdGVwLnN3aXRjaGVkWWVhciA9IHRydWU7fVxuICAgIGVsc2UgaWYgKHByZXZWYWx1ZS5tb250aCgpICE9IG5ld1ZhbHVlLm1vbnRoKCkpIHt0aW1lU3RlcC5zd2l0Y2hlZE1vbnRoID0gdHJ1ZTt9XG4gICAgZWxzZSBpZiAocHJldlZhbHVlLmRheU9mWWVhcigpICE9IG5ld1ZhbHVlLmRheU9mWWVhcigpKSB7dGltZVN0ZXAuc3dpdGNoZWREYXkgPSB0cnVlO31cblxuICAgIHRpbWVTdGVwLmN1cnJlbnQgPSBuZXdWYWx1ZTtcbiAgfVxufTtcblxuXG4vLy8qKlxuLy8gKiBVc2VkIGluIFRpbWVTdGVwIHRvIGF2b2lkIHRoZSBoaWRkZW4gdGltZXMuXG4vLyAqIEBwYXJhbSB0aW1lU3RlcFxuLy8gKiBAcGFyYW0gcHJldmlvdXNUaW1lXG4vLyAqL1xuLy9leHBvcnRzLmNoZWNrRmlyc3RTdGVwID0gZnVuY3Rpb24odGltZVN0ZXApIHtcbi8vICB2YXIgc3RlcEluSGlkZGVuID0gZmFsc2U7XG4vLyAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRpbWVTdGVwLmN1cnJlbnQudmFsdWVPZigpO1xuLy8gIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVN0ZXAuaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbi8vICAgIHZhciBzdGFydERhdGUgPSB0aW1lU3RlcC5oaWRkZW5EYXRlc1tpXS5zdGFydDtcbi8vICAgIHZhciBlbmREYXRlID0gdGltZVN0ZXAuaGlkZGVuRGF0ZXNbaV0uZW5kO1xuLy8gICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBzdGFydERhdGUgJiYgY3VycmVudFZhbHVlIDwgZW5kRGF0ZSkge1xuLy8gICAgICBzdGVwSW5IaWRkZW4gPSB0cnVlO1xuLy8gICAgICBicmVhaztcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIGlmIChzdGVwSW5IaWRkZW4gPT0gdHJ1ZSAmJiBjdXJyZW50VmFsdWUgPD0gdGltZVN0ZXAuX2VuZC52YWx1ZU9mKCkpIHtcbi8vICAgIHZhciBuZXdWYWx1ZSA9IG1vbWVudChlbmREYXRlKTtcbi8vICAgIHRpbWVTdGVwLmN1cnJlbnQgPSBuZXdWYWx1ZS50b0RhdGUoKTtcbi8vICB9XG4vL307XG5cbi8qKlxuICogcmVwbGFjZXMgdGhlIENvcmUgdG9TY3JlZW4gbWV0aG9kc1xuICogQHBhcmFtIENvcmVcbiAqIEBwYXJhbSB0aW1lXG4gKiBAcGFyYW0gd2lkdGhcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMudG9TY3JlZW4gPSBmdW5jdGlvbihDb3JlLCB0aW1lLCB3aWR0aCkge1xuICBpZiAoQ29yZS5ib2R5LmhpZGRlbkRhdGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgdmFyIGNvbnZlcnNpb24gPSBDb3JlLnJhbmdlLmNvbnZlcnNpb24od2lkdGgpO1xuICAgIHJldHVybiAodGltZS52YWx1ZU9mKCkgLSBjb252ZXJzaW9uLm9mZnNldCkgKiBjb252ZXJzaW9uLnNjYWxlO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBoaWRkZW4gPSBleHBvcnRzLmlzSGlkZGVuKHRpbWUsIENvcmUuYm9keS5oaWRkZW5EYXRlcyk7XG4gICAgaWYgKGhpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkge1xuICAgICAgdGltZSA9IGhpZGRlbi5zdGFydERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uID0gZXhwb3J0cy5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4oQ29yZS5ib2R5LmhpZGRlbkRhdGVzLCBDb3JlLnJhbmdlLnN0YXJ0LCBDb3JlLnJhbmdlLmVuZCk7XG4gICAgdGltZSA9IGV4cG9ydHMuY29ycmVjdFRpbWVGb3JIaWRkZW4oQ29yZS5vcHRpb25zLm1vbWVudCwgQ29yZS5ib2R5LmhpZGRlbkRhdGVzLCBDb3JlLnJhbmdlLCB0aW1lKTtcblxuICAgIHZhciBjb252ZXJzaW9uID0gQ29yZS5yYW5nZS5jb252ZXJzaW9uKHdpZHRoLCBkdXJhdGlvbik7XG4gICAgcmV0dXJuICh0aW1lLnZhbHVlT2YoKSAtIGNvbnZlcnNpb24ub2Zmc2V0KSAqIGNvbnZlcnNpb24uc2NhbGU7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXBsYWNlcyB0aGUgY29yZSB0b1RpbWUgbWV0aG9kc1xuICogQHBhcmFtIGJvZHlcbiAqIEBwYXJhbSByYW5nZVxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSB3aWR0aFxuICogQHJldHVybnMge0RhdGV9XG4gKi9cbmV4cG9ydHMudG9UaW1lID0gZnVuY3Rpb24oQ29yZSwgeCwgd2lkdGgpIHtcbiAgaWYgKENvcmUuYm9keS5oaWRkZW5EYXRlcy5sZW5ndGggPT0gMCkge1xuICAgIHZhciBjb252ZXJzaW9uID0gQ29yZS5yYW5nZS5jb252ZXJzaW9uKHdpZHRoKTtcbiAgICByZXR1cm4gbmV3IERhdGUoeCAvIGNvbnZlcnNpb24uc2NhbGUgKyBjb252ZXJzaW9uLm9mZnNldCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGhpZGRlbkR1cmF0aW9uID0gZXhwb3J0cy5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4oQ29yZS5ib2R5LmhpZGRlbkRhdGVzLCBDb3JlLnJhbmdlLnN0YXJ0LCBDb3JlLnJhbmdlLmVuZCk7XG4gICAgdmFyIHRvdGFsRHVyYXRpb24gPSBDb3JlLnJhbmdlLmVuZCAtIENvcmUucmFuZ2Uuc3RhcnQgLSBoaWRkZW5EdXJhdGlvbjtcbiAgICB2YXIgcGFydGlhbER1cmF0aW9uID0gdG90YWxEdXJhdGlvbiAqIHggLyB3aWR0aDtcbiAgICB2YXIgYWNjdW11bGF0ZWRIaWRkZW5EdXJhdGlvbiA9IGV4cG9ydHMuZ2V0QWNjdW11bGF0ZWRIaWRkZW5EdXJhdGlvbihDb3JlLmJvZHkuaGlkZGVuRGF0ZXMsIENvcmUucmFuZ2UsIHBhcnRpYWxEdXJhdGlvbik7XG5cbiAgICB2YXIgbmV3VGltZSA9IG5ldyBEYXRlKGFjY3VtdWxhdGVkSGlkZGVuRHVyYXRpb24gKyBwYXJ0aWFsRHVyYXRpb24gKyBDb3JlLnJhbmdlLnN0YXJ0KTtcbiAgICByZXR1cm4gbmV3VGltZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFN1cHBvcnQgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gaGlkZGVuRGF0ZXNcbiAqIEBwYXJhbSByYW5nZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5nZXRIaWRkZW5EdXJhdGlvbkJldHdlZW4gPSBmdW5jdGlvbihoaWRkZW5EYXRlcywgc3RhcnQsIGVuZCkge1xuICB2YXIgZHVyYXRpb24gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgIHZhciBlbmREYXRlID0gaGlkZGVuRGF0ZXNbaV0uZW5kO1xuICAgIC8vIGlmIHRpbWUgYWZ0ZXIgdGhlIGN1dG91dCwgYW5kIHRoZVxuICAgIGlmIChzdGFydERhdGUgPj0gc3RhcnQgJiYgZW5kRGF0ZSA8IGVuZCkge1xuICAgICAgZHVyYXRpb24gKz0gZW5kRGF0ZSAtIHN0YXJ0RGF0ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR1cmF0aW9uO1xufTtcblxuXG4vKipcbiAqIFN1cHBvcnQgZnVuY3Rpb25cbiAqIEBwYXJhbSBtb21lbnRcbiAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICogQHBhcmFtIHJhbmdlXG4gKiBAcGFyYW0gdGltZVxuICogQHJldHVybnMge3tkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiAqLCBvZmZzZXQ6IG51bWJlcn19XG4gKi9cbmV4cG9ydHMuY29ycmVjdFRpbWVGb3JIaWRkZW4gPSBmdW5jdGlvbihtb21lbnQsIGhpZGRlbkRhdGVzLCByYW5nZSwgdGltZSkge1xuICB0aW1lID0gbW9tZW50KHRpbWUpLnRvRGF0ZSgpLnZhbHVlT2YoKTtcbiAgdGltZSAtPSBleHBvcnRzLmdldEhpZGRlbkR1cmF0aW9uQmVmb3JlKG1vbWVudCwgaGlkZGVuRGF0ZXMscmFuZ2UsdGltZSk7XG4gIHJldHVybiB0aW1lO1xufTtcblxuZXhwb3J0cy5nZXRIaWRkZW5EdXJhdGlvbkJlZm9yZSA9IGZ1bmN0aW9uKG1vbWVudCwgaGlkZGVuRGF0ZXMsIHJhbmdlLCB0aW1lKSB7XG4gIHZhciB0aW1lT2Zmc2V0ID0gMDtcbiAgdGltZSA9IG1vbWVudCh0aW1lKS50b0RhdGUoKS52YWx1ZU9mKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydERhdGUgPSBoaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICB2YXIgZW5kRGF0ZSA9IGhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgICAvLyBpZiB0aW1lIGFmdGVyIHRoZSBjdXRvdXQsIGFuZCB0aGVcbiAgICBpZiAoc3RhcnREYXRlID49IHJhbmdlLnN0YXJ0ICYmIGVuZERhdGUgPCByYW5nZS5lbmQpIHtcbiAgICAgIGlmICh0aW1lID49IGVuZERhdGUpIHtcbiAgICAgICAgdGltZU9mZnNldCArPSAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aW1lT2Zmc2V0O1xufVxuXG4vKipcbiAqIHN1bSB0aGUgZHVyYXRpb24gZnJvbSBzdGFydCB0byBmaW5pc2gsIGluY2x1ZGluZyB0aGUgaGlkZGVuIGR1cmF0aW9uLFxuICogdW50aWwgdGhlIHJlcXVpcmVkIGFtb3VudCBoYXMgYmVlbiByZWFjaGVkLCByZXR1cm4gdGhlIGFjY3VtdWxhdGVkIGhpZGRlbiBkdXJhdGlvblxuICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gKiBAcGFyYW0gcmFuZ2VcbiAqIEBwYXJhbSB0aW1lXG4gKiBAcmV0dXJucyB7e2R1cmF0aW9uOiBudW1iZXIsIHRpbWU6ICosIG9mZnNldDogbnVtYmVyfX1cbiAqL1xuZXhwb3J0cy5nZXRBY2N1bXVsYXRlZEhpZGRlbkR1cmF0aW9uID0gZnVuY3Rpb24oaGlkZGVuRGF0ZXMsIHJhbmdlLCByZXF1aXJlZER1cmF0aW9uKSB7XG4gIHZhciBoaWRkZW5EdXJhdGlvbiA9IDA7XG4gIHZhciBkdXJhdGlvbiA9IDA7XG4gIHZhciBwcmV2aW91c1BvaW50ID0gcmFuZ2Uuc3RhcnQ7XG4gIC8vZXhwb3J0cy5wcmludERhdGVzKGhpZGRlbkRhdGVzKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgIHZhciBlbmREYXRlID0gaGlkZGVuRGF0ZXNbaV0uZW5kO1xuICAgIC8vIGlmIHRpbWUgYWZ0ZXIgdGhlIGN1dG91dCwgYW5kIHRoZVxuICAgIGlmIChzdGFydERhdGUgPj0gcmFuZ2Uuc3RhcnQgJiYgZW5kRGF0ZSA8IHJhbmdlLmVuZCkge1xuICAgICAgZHVyYXRpb24gKz0gc3RhcnREYXRlIC0gcHJldmlvdXNQb2ludDtcbiAgICAgIHByZXZpb3VzUG9pbnQgPSBlbmREYXRlO1xuICAgICAgaWYgKGR1cmF0aW9uID49IHJlcXVpcmVkRHVyYXRpb24pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaGlkZGVuRHVyYXRpb24gKz0gZW5kRGF0ZSAtIHN0YXJ0RGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGlkZGVuRHVyYXRpb247XG59O1xuXG5cblxuLyoqXG4gKiB1c2VkIHRvIHN0ZXAgb3ZlciB0byBlaXRoZXIgc2lkZSBvZiBhIGhpZGRlbiBibG9jay4gQ29ycmVjdGlvbiBpcyBkaXNhYmxlZCBvbiB0YWJsZXRzLCBtaWdodCBiZSBzZXQgdG8gdHJ1ZVxuICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gKiBAcGFyYW0gdGltZVxuICogQHBhcmFtIGRpcmVjdGlvblxuICogQHBhcmFtIGNvcnJlY3Rpb25FbmFibGVkXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5zbmFwQXdheUZyb21IaWRkZW4gPSBmdW5jdGlvbihoaWRkZW5EYXRlcywgdGltZSwgZGlyZWN0aW9uLCBjb3JyZWN0aW9uRW5hYmxlZCkge1xuICB2YXIgaXNIaWRkZW4gPSBleHBvcnRzLmlzSGlkZGVuKHRpbWUsIGhpZGRlbkRhdGVzKTtcbiAgaWYgKGlzSGlkZGVuLmhpZGRlbiA9PSB0cnVlKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICAgIGlmIChjb3JyZWN0aW9uRW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBpc0hpZGRlbi5zdGFydERhdGUgLSAoaXNIaWRkZW4uZW5kRGF0ZSAtIHRpbWUpIC0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNIaWRkZW4uc3RhcnREYXRlIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY29ycmVjdGlvbkVuYWJsZWQgPT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gaXNIaWRkZW4uZW5kRGF0ZSArICh0aW1lIC0gaXNIaWRkZW4uc3RhcnREYXRlKSArIDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzSGlkZGVuLmVuZERhdGUgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdGltZTtcbiAgfVxuXG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRpbWUgaXMgaGlkZGVuXG4gKlxuICogQHBhcmFtIHRpbWVcbiAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICogQHJldHVybnMge3toaWRkZW46IGJvb2xlYW4sIHN0YXJ0RGF0ZTogV2luZG93LnN0YXJ0LCBlbmREYXRlOiAqfX1cbiAqL1xuZXhwb3J0cy5pc0hpZGRlbiA9IGZ1bmN0aW9uKHRpbWUsIGhpZGRlbkRhdGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhcnREYXRlID0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4gICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG5cbiAgICBpZiAodGltZSA+PSBzdGFydERhdGUgJiYgdGltZSA8IGVuZERhdGUpIHsgLy8gaWYgdGhlIHN0YXJ0IGlzIGVudGVyaW5nIGEgaGlkZGVuIHpvbmVcbiAgICAgIHJldHVybiB7aGlkZGVuOiB0cnVlLCBzdGFydERhdGU6IHN0YXJ0RGF0ZSwgZW5kRGF0ZTogZW5kRGF0ZX07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtoaWRkZW46IGZhbHNlLCBzdGFydERhdGU6IHN0YXJ0RGF0ZSwgZW5kRGF0ZTogZW5kRGF0ZX07XG59Il19
},{}],28:[function(require,module,exports){
'use strict';

var util = require('../util');
var hammerUtil = require('../hammerUtil');
var moment = require('../module/moment');
var Component = require('./component/Component');
var DateUtil = require('./DateUtil');

/**
 * @constructor Range
 * A Range controls a numeric range with a start and end value.
 * The Range adjusts the range based on mouse events or programmatic changes,
 * and triggers events when the range is changing or has been changed.
 * @param {{dom: Object, domProps: Object, emitter: Emitter}} body
 * @param {Object} [options]    See description at Range.setOptions
 */
function Range(body, options) {
  var now = moment().hours(0).minutes(0).seconds(0).milliseconds(0);
  this.start = now.clone().add(-3, 'days').valueOf(); // Number
  this.end = now.clone().add(4, 'days').valueOf(); // Number

  this.body = body;
  this.deltaDifference = 0;
  this.scaleOffset = 0;
  this.startToFront = false;
  this.endToFront = true;

  // default options
  this.defaultOptions = {
    start: null,
    end: null,
    moment: moment,
    direction: 'horizontal', // 'horizontal' or 'vertical'
    moveable: true,
    zoomable: true,
    min: null,
    max: null,
    zoomMin: 10, // milliseconds
    zoomMax: 1000 * 60 * 60 * 24 * 365 * 10000 // milliseconds
  };
  this.options = util.extend({}, this.defaultOptions);

  this.props = {
    touch: {}
  };
  this.animationTimer = null;

  // drag listeners for dragging
  this.body.emitter.on('panstart', this._onDragStart.bind(this));
  this.body.emitter.on('panmove', this._onDrag.bind(this));
  this.body.emitter.on('panend', this._onDragEnd.bind(this));

  // mouse wheel for zooming
  this.body.emitter.on('mousewheel', this._onMouseWheel.bind(this));

  // pinch to zoom
  this.body.emitter.on('touch', this._onTouch.bind(this));
  this.body.emitter.on('pinch', this._onPinch.bind(this));

  this.setOptions(options);
}

Range.prototype = new Component();

/**
 * Set options for the range controller
 * @param {Object} options      Available options:
 *                              {Number | Date | String} start  Start date for the range
 *                              {Number | Date | String} end    End date for the range
 *                              {Number} min    Minimum value for start
 *                              {Number} max    Maximum value for end
 *                              {Number} zoomMin    Set a minimum value for
 *                                                  (end - start).
 *                              {Number} zoomMax    Set a maximum value for
 *                                                  (end - start).
 *                              {Boolean} moveable Enable moving of the range
 *                                                 by dragging. True by default
 *                              {Boolean} zoomable Enable zooming of the range
 *                                                 by pinching/scrolling. True by default
 */
Range.prototype.setOptions = function (options) {
  if (options) {
    // copy the options that we know
    var fields = ['direction', 'min', 'max', 'zoomMin', 'zoomMax', 'moveable', 'zoomable', 'moment', 'activate', 'hiddenDates', 'zoomKey'];
    util.selectiveExtend(fields, this.options, options);

    if ('start' in options || 'end' in options) {
      // apply a new range. both start and end are optional
      this.setRange(options.start, options.end);
    }
  }
};

/**
 * Test whether direction has a valid value
 * @param {String} direction    'horizontal' or 'vertical'
 */
function validateDirection(direction) {
  if (direction != 'horizontal' && direction != 'vertical') {
    throw new TypeError('Unknown direction "' + direction + '". ' + 'Choose "horizontal" or "vertical".');
  }
}

/**
 * Set a new start and end range
 * @param {Date | Number | String} [start]
 * @param {Date | Number | String} [end]
 * @param {boolean | {duration: number, easingFunction: string}} [animation=false]
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 * @param {Boolean} [byUser=false]
 *
 */
Range.prototype.setRange = function (start, end, animation, byUser) {
  if (byUser !== true) {
    byUser = false;
  }
  var finalStart = start != undefined ? util.convert(start, 'Date').valueOf() : null;
  var finalEnd = end != undefined ? util.convert(end, 'Date').valueOf() : null;
  this._cancelAnimation();

  if (animation) {
    // true or an Object
    var me = this;
    var initStart = this.start;
    var initEnd = this.end;
    var duration = typeof animation === 'object' && 'duration' in animation ? animation.duration : 500;
    var easingName = typeof animation === 'object' && 'easingFunction' in animation ? animation.easingFunction : 'easeInOutQuad';
    var easingFunction = util.easingFunctions[easingName];
    if (!easingFunction) {
      throw new Error('Unknown easing function ' + JSON.stringify(easingName) + '. ' + 'Choose from: ' + Object.keys(util.easingFunctions).join(', '));
    }

    var initTime = new Date().valueOf();
    var anyChanged = false;

    var next = function next() {
      if (!me.props.touch.dragging) {
        var now = new Date().valueOf();
        var time = now - initTime;
        var ease = easingFunction(time / duration);
        var done = time > duration;
        var s = done || finalStart === null ? finalStart : initStart + (finalStart - initStart) * ease;
        var e = done || finalEnd === null ? finalEnd : initEnd + (finalEnd - initEnd) * ease;

        changed = me._applyRange(s, e);
        DateUtil.updateHiddenDates(me.options.moment, me.body, me.options.hiddenDates);
        anyChanged = anyChanged || changed;
        if (changed) {
          me.body.emitter.emit('rangechange', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
        }

        if (done) {
          if (anyChanged) {
            me.body.emitter.emit('rangechanged', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
          }
        } else {
          // animate with as high as possible frame rate, leave 20 ms in between
          // each to prevent the browser from blocking
          me.animationTimer = setTimeout(next, 20);
        }
      }
    };

    return next();
  } else {
    var changed = this._applyRange(finalStart, finalEnd);
    DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);
    if (changed) {
      var params = { start: new Date(this.start), end: new Date(this.end), byUser: byUser };
      this.body.emitter.emit('rangechange', params);
      this.body.emitter.emit('rangechanged', params);
    }
  }
};

/**
 * Stop an animation
 * @private
 */
Range.prototype._cancelAnimation = function () {
  if (this.animationTimer) {
    clearTimeout(this.animationTimer);
    this.animationTimer = null;
  }
};

/**
 * Set a new start and end range. This method is the same as setRange, but
 * does not trigger a range change and range changed event, and it returns
 * true when the range is changed
 * @param {Number} [start]
 * @param {Number} [end]
 * @return {Boolean} changed
 * @private
 */
Range.prototype._applyRange = function (start, end) {
  var newStart = start != null ? util.convert(start, 'Date').valueOf() : this.start,
      newEnd = end != null ? util.convert(end, 'Date').valueOf() : this.end,
      max = this.options.max != null ? util.convert(this.options.max, 'Date').valueOf() : null,
      min = this.options.min != null ? util.convert(this.options.min, 'Date').valueOf() : null,
      diff;

  // check for valid number
  if (isNaN(newStart) || newStart === null) {
    throw new Error('Invalid start "' + start + '"');
  }
  if (isNaN(newEnd) || newEnd === null) {
    throw new Error('Invalid end "' + end + '"');
  }

  // prevent start < end
  if (newEnd < newStart) {
    newEnd = newStart;
  }

  // prevent start < min
  if (min !== null) {
    if (newStart < min) {
      diff = min - newStart;
      newStart += diff;
      newEnd += diff;

      // prevent end > max
      if (max != null) {
        if (newEnd > max) {
          newEnd = max;
        }
      }
    }
  }

  // prevent end > max
  if (max !== null) {
    if (newEnd > max) {
      diff = newEnd - max;
      newStart -= diff;
      newEnd -= diff;

      // prevent start < min
      if (min != null) {
        if (newStart < min) {
          newStart = min;
        }
      }
    }
  }

  // prevent (end-start) < zoomMin
  if (this.options.zoomMin !== null) {
    var zoomMin = parseFloat(this.options.zoomMin);
    if (zoomMin < 0) {
      zoomMin = 0;
    }
    if (newEnd - newStart < zoomMin) {
      if (this.end - this.start === zoomMin && newStart > this.start && newEnd < this.end) {
        // ignore this action, we are already zoomed to the minimum
        newStart = this.start;
        newEnd = this.end;
      } else {
        // zoom to the minimum
        diff = zoomMin - (newEnd - newStart);
        newStart -= diff / 2;
        newEnd += diff / 2;
      }
    }
  }

  // prevent (end-start) > zoomMax
  if (this.options.zoomMax !== null) {
    var zoomMax = parseFloat(this.options.zoomMax);
    if (zoomMax < 0) {
      zoomMax = 0;
    }

    if (newEnd - newStart > zoomMax) {
      if (this.end - this.start === zoomMax && newStart < this.start && newEnd > this.end) {
        // ignore this action, we are already zoomed to the maximum
        newStart = this.start;
        newEnd = this.end;
      } else {
        // zoom to the maximum
        diff = newEnd - newStart - zoomMax;
        newStart += diff / 2;
        newEnd -= diff / 2;
      }
    }
  }

  var changed = this.start != newStart || this.end != newEnd;

  // if the new range does NOT overlap with the old range, emit checkRangedItems to avoid not showing ranged items (ranged meaning has end time, not necessarily of type Range)
  if (!(newStart >= this.start && newStart <= this.end || newEnd >= this.start && newEnd <= this.end) && !(this.start >= newStart && this.start <= newEnd || this.end >= newStart && this.end <= newEnd)) {
    this.body.emitter.emit('checkRangedItems');
  }

  this.start = newStart;
  this.end = newEnd;
  return changed;
};

/**
 * Retrieve the current range.
 * @return {Object} An object with start and end properties
 */
Range.prototype.getRange = function () {
  return {
    start: this.start,
    end: this.end
  };
};

/**
 * Calculate the conversion offset and scale for current range, based on
 * the provided width
 * @param {Number} width
 * @returns {{offset: number, scale: number}} conversion
 */
Range.prototype.conversion = function (width, totalHidden) {
  return Range.conversion(this.start, this.end, width, totalHidden);
};

/**
 * Static method to calculate the conversion offset and scale for a range,
 * based on the provided start, end, and width
 * @param {Number} start
 * @param {Number} end
 * @param {Number} width
 * @returns {{offset: number, scale: number}} conversion
 */
Range.conversion = function (start, end, width, totalHidden) {
  if (totalHidden === undefined) {
    totalHidden = 0;
  }
  if (width != 0 && end - start != 0) {
    return {
      offset: start,
      scale: width / (end - start - totalHidden)
    };
  } else {
    return {
      offset: 0,
      scale: 1
    };
  }
};

/**
 * Start dragging horizontally or vertically
 * @param {Event} event
 * @private
 */
Range.prototype._onDragStart = function (event) {
  this.deltaDifference = 0;
  this.previousDelta = 0;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // only start dragging when the mouse is inside the current range
  if (!this._isInsideRange(event)) return;

  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  this.props.touch.start = this.start;
  this.props.touch.end = this.end;
  this.props.touch.dragging = true;

  if (this.body.dom.root) {
    this.body.dom.root.style.cursor = 'move';
  }
};

/**
 * Perform dragging operation
 * @param {Event} event
 * @private
 */
Range.prototype._onDrag = function (event) {
  if (!this.props.touch.dragging) return;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // TODO: this may be redundant in hammerjs2
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  var direction = this.options.direction;
  validateDirection(direction);
  var delta = direction == 'horizontal' ? event.deltaX : event.deltaY;
  delta -= this.deltaDifference;
  var interval = this.props.touch.end - this.props.touch.start;

  // normalize dragging speed if cutout is in between.
  var duration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  interval -= duration;

  var width = direction == 'horizontal' ? this.body.domProps.center.width : this.body.domProps.center.height;
  var diffRange = -delta / width * interval;
  var newStart = this.props.touch.start + diffRange;
  var newEnd = this.props.touch.end + diffRange;

  // snapping times away from hidden zones
  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, this.previousDelta - delta, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, this.previousDelta - delta, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    this.deltaDifference += delta;
    this.props.touch.start = safeStart;
    this.props.touch.end = safeEnd;
    this._onDrag(event);
    return;
  }

  this.previousDelta = delta;
  this._applyRange(newStart, newEnd);

  // fire a rangechange event
  this.body.emitter.emit('rangechange', {
    start: new Date(this.start),
    end: new Date(this.end),
    byUser: true
  });
};

/**
 * Stop dragging operation
 * @param {event} event
 * @private
 */
Range.prototype._onDragEnd = function (event) {
  if (!this.props.touch.dragging) return;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // TODO: this may be redundant in hammerjs2
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  this.props.touch.dragging = false;
  if (this.body.dom.root) {
    this.body.dom.root.style.cursor = 'auto';
  }

  // fire a rangechanged event
  this.body.emitter.emit('rangechanged', {
    start: new Date(this.start),
    end: new Date(this.end),
    byUser: true
  });
};

/**
 * Event handler for mouse wheel event, used to zoom
 * Code from http://adomas.org/javascript-mouse-wheel/
 * @param {Event} event
 * @private
 */
Range.prototype._onMouseWheel = function (event) {
  // only allow zooming when configured as zoomable and moveable
  if (!(this.options.zoomable && this.options.moveable)) return;

  // only zoom when the mouse is inside the current range
  if (!this._isInsideRange(event)) return;

  // only zoom when the according key is pressed and the zoomKey option is set
  if (this.options.zoomKey && !event[this.options.zoomKey]) return;

  // retrieve delta
  var delta = 0;
  if (event.wheelDelta) {
    /* IE/Opera. */
    delta = event.wheelDelta / 120;
  } else if (event.detail) {
    /* Mozilla case. */
    // In Mozilla, sign of delta is different than in IE.
    // Also, delta is multiple of 3.
    delta = -event.detail / 3;
  }

  // If delta is nonzero, handle it.
  // Basically, delta is now positive if wheel was scrolled up,
  // and negative, if wheel was scrolled down.
  if (delta) {
    // perform the zoom action. Delta is normally 1 or -1

    // adjust a negative delta such that zooming in with delta 0.1
    // equals zooming out with a delta -0.1
    var scale;
    if (delta < 0) {
      scale = 1 - delta / 5;
    } else {
      scale = 1 / (1 + delta / 5);
    }

    // calculate center, the date to zoom around
    var pointer = getPointer({ x: event.clientX, y: event.clientY }, this.body.dom.center);
    var pointerDate = this._pointerToDate(pointer);

    this.zoom(scale, pointerDate, delta);
  }

  // Prevent default actions caused by mouse wheel
  // (else the page and timeline both zoom and scroll)
  event.preventDefault();
};

/**
 * Start of a touch gesture
 * @private
 */
Range.prototype._onTouch = function (event) {
  this.props.touch.start = this.start;
  this.props.touch.end = this.end;
  this.props.touch.allowDragging = true;
  this.props.touch.center = null;
  this.scaleOffset = 0;
  this.deltaDifference = 0;
};

/**
 * Handle pinch event
 * @param {Event} event
 * @private
 */
Range.prototype._onPinch = function (event) {
  // only allow zooming when configured as zoomable and moveable
  if (!(this.options.zoomable && this.options.moveable)) return;

  this.props.touch.allowDragging = false;

  if (!this.props.touch.center) {
    this.props.touch.center = getPointer(event.center, this.body.dom.center);
  }

  var scale = 1 / (event.scale + this.scaleOffset);
  var centerDate = this._pointerToDate(this.props.touch.center);

  var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, centerDate);
  var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

  // calculate new start and end
  var newStart = centerDate - hiddenDurationBefore + (this.props.touch.start - (centerDate - hiddenDurationBefore)) * scale;
  var newEnd = centerDate + hiddenDurationAfter + (this.props.touch.end - (centerDate + hiddenDurationAfter)) * scale;

  // snapping times away from hidden zones
  this.startToFront = 1 - scale <= 0; // used to do the right auto correction with periodic hidden times
  this.endToFront = scale - 1 <= 0; // used to do the right auto correction with periodic hidden times

  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, 1 - scale, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, scale - 1, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    this.props.touch.start = safeStart;
    this.props.touch.end = safeEnd;
    this.scaleOffset = 1 - event.scale;
    newStart = safeStart;
    newEnd = safeEnd;
  }

  this.setRange(newStart, newEnd, false, true);

  this.startToFront = false; // revert to default
  this.endToFront = true; // revert to default
};

/**
 * Test whether the mouse from a mouse event is inside the visible window,
 * between the current start and end date
 * @param {Object} event
 * @return {boolean} Returns true when inside the visible window
 * @private
 */
Range.prototype._isInsideRange = function (event) {
  // calculate the time where the mouse is, check whether inside
  // and no scroll action should happen.
  var clientX = event.center ? event.center.x : event.clientX;
  var x = clientX - util.getAbsoluteLeft(this.body.dom.centerContainer);
  var time = this.body.util.toTime(x);

  return time >= this.start && time <= this.end;
};

/**
 * Helper function to calculate the center date for zooming
 * @param {{x: Number, y: Number}} pointer
 * @return {number} date
 * @private
 */
Range.prototype._pointerToDate = function (pointer) {
  var conversion;
  var direction = this.options.direction;

  validateDirection(direction);

  if (direction == 'horizontal') {
    return this.body.util.toTime(pointer.x).valueOf();
  } else {
    var height = this.body.domProps.center.height;
    conversion = this.conversion(height);
    return pointer.y / conversion.scale + conversion.offset;
  }
};

/**
 * Get the pointer location relative to the location of the dom element
 * @param {{x: Number, y: Number}} touch
 * @param {Element} element   HTML DOM element
 * @return {{x: Number, y: Number}} pointer
 * @private
 */
function getPointer(touch, element) {
  return {
    x: touch.x - util.getAbsoluteLeft(element),
    y: touch.y - util.getAbsoluteTop(element)
  };
}

/**
 * Zoom the range the given scale in or out. Start and end date will
 * be adjusted, and the timeline will be redrawn. You can optionally give a
 * date around which to zoom.
 * For example, try scale = 0.9 or 1.1
 * @param {Number} scale      Scaling factor. Values above 1 will zoom out,
 *                            values below 1 will zoom in.
 * @param {Number} [center]   Value representing a date around which will
 *                            be zoomed.
 */
Range.prototype.zoom = function (scale, center, delta) {
  // if centerDate is not provided, take it half between start Date and end Date
  if (center == null) {
    center = (this.start + this.end) / 2;
  }

  var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, center);
  var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

  // calculate new start and end
  var newStart = center - hiddenDurationBefore + (this.start - (center - hiddenDurationBefore)) * scale;
  var newEnd = center + hiddenDurationAfter + (this.end - (center + hiddenDurationAfter)) * scale;

  // snapping times away from hidden zones
  this.startToFront = delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
  this.endToFront = -delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, delta, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, -delta, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    newStart = safeStart;
    newEnd = safeEnd;
  }

  this.setRange(newStart, newEnd, false, true);

  this.startToFront = false; // revert to default
  this.endToFront = true; // revert to default
};

/**
 * Move the range with a given delta to the left or right. Start and end
 * value will be adjusted. For example, try delta = 0.1 or -0.1
 * @param {Number}  delta     Moving amount. Positive value will move right,
 *                            negative value will move left
 */
Range.prototype.move = function (delta) {
  // zoom start Date and end Date relative to the centerDate
  var diff = this.end - this.start;

  // apply new values
  var newStart = this.start + diff * delta;
  var newEnd = this.end + diff * delta;

  // TODO: reckon with min and max range

  this.start = newStart;
  this.end = newEnd;
};

/**
 * Move the range to a new center point
 * @param {Number} moveTo      New center point of the range
 */
Range.prototype.moveTo = function (moveTo) {
  var center = (this.start + this.end) / 2;

  var diff = center - moveTo;

  // calculate new start and end
  var newStart = this.start - diff;
  var newEnd = this.end - diff;

  this.setRange(newStart, newEnd);
};

module.exports = Range;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL1JhbmdlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzlCLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUMxQyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUN6QyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUNqRCxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7Ozs7Ozs7Ozs7QUFVckMsU0FBUyxLQUFLLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUM1QixNQUFJLEdBQUcsR0FBRyxNQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEUsTUFBSSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ25ELE1BQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7O0FBRWhELE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLE1BQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO0FBQ3pCLE1BQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBQ3JCLE1BQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxD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QUssR0FBRyxRQUFRLENBQUM7QUFDdEIsTUFBSSxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUM7Q0FDbkIsQ0FBQzs7Ozs7O0FBTUYsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsVUFBUyxNQUFNLEVBQUU7QUFDeEMsTUFBSSxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUEsR0FBSSxDQUFDLENBQUM7O0FBRXpDLE1BQUksSUFBSSxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUM7OztBQUczQixNQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztBQUNqQyxNQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQzs7QUFFN0IsTUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7Q0FDakMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9SYW5nZS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIGhhbW1lclV0aWwgPSByZXF1aXJlKCcuLi9oYW1tZXJVdGlsJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnLi4vbW9kdWxlL21vbWVudCcpO1xudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcG9uZW50L0NvbXBvbmVudCcpO1xudmFyIERhdGVVdGlsID0gcmVxdWlyZSgnLi9EYXRlVXRpbCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBSYW5nZVxuICogQSBSYW5nZSBjb250cm9scyBhIG51bWVyaWMgcmFuZ2Ugd2l0aCBhIHN0YXJ0IGFuZCBlbmQgdmFsdWUuXG4gKiBUaGUgUmFuZ2UgYWRqdXN0cyB0aGUgcmFuZ2UgYmFzZWQgb24gbW91c2UgZXZlbnRzIG9yIHByb2dyYW1tYXRpYyBjaGFuZ2VzLFxuICogYW5kIHRyaWdnZXJzIGV2ZW50cyB3aGVuIHRoZSByYW5nZSBpcyBjaGFuZ2luZyBvciBoYXMgYmVlbiBjaGFuZ2VkLlxuICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXJ9fSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIFNlZSBkZXNjcmlwdGlvbiBhdCBSYW5nZS5zZXRPcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJhbmdlKGJvZHksIG9wdGlvbnMpIHtcbiAgdmFyIG5vdyA9IG1vbWVudCgpLmhvdXJzKDApLm1pbnV0ZXMoMCkuc2Vjb25kcygwKS5taWxsaXNlY29uZHMoMCk7XG4gIHRoaXMuc3RhcnQgPSBub3cuY2xvbmUoKS5hZGQoLTMsICdkYXlzJykudmFsdWVPZigpOyAvLyBOdW1iZXJcbiAgdGhpcy5lbmQgPSBub3cuY2xvbmUoKS5hZGQoNCwgJ2RheXMnKS52YWx1ZU9mKCk7ICAgLy8gTnVtYmVyXG5cbiAgdGhpcy5ib2R5ID0gYm9keTtcbiAgdGhpcy5kZWx0YURpZmZlcmVuY2UgPSAwO1xuICB0aGlzLnNjYWxlT2Zmc2V0ID0gMDtcbiAgdGhpcy5zdGFydFRvRnJvbnQgPSBmYWxzZTtcbiAgdGhpcy5lbmRUb0Zyb250ID0gdHJ1ZTtcblxuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBzdGFydDogbnVsbCxcbiAgICBlbmQ6IG51bGwsXG4gICAgbW9tZW50OiBtb21lbnQsXG4gICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsIC8vICdob3Jpem9udGFsJyBvciAndmVydGljYWwnXG4gICAgbW92ZWFibGU6IHRydWUsXG4gICAgem9vbWFibGU6IHRydWUsXG4gICAgbWluOiBudWxsLFxuICAgIG1heDogbnVsbCxcbiAgICB6b29tTWluOiAxMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pbGxpc2Vjb25kc1xuICAgIHpvb21NYXg6IDEwMDAgKiA2MCAqIDYwICogMjQgKiAzNjUgKiAxMDAwMCAgLy8gbWlsbGlzZWNvbmRzXG4gIH07XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICB0aGlzLnByb3BzID0ge1xuICAgIHRvdWNoOiB7fVxuICB9O1xuICB0aGlzLmFuaW1hdGlvblRpbWVyID0gbnVsbDtcblxuICAvLyBkcmFnIGxpc3RlbmVycyBmb3IgZHJhZ2dpbmdcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3BhbnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdwYW5tb3ZlJywgIHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3BhbmVuZCcsICAgdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcykpO1xuXG4gIC8vIG1vdXNlIHdoZWVsIGZvciB6b29taW5nXG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdtb3VzZXdoZWVsJywgdGhpcy5fb25Nb3VzZVdoZWVsLmJpbmQodGhpcykpO1xuXG4gIC8vIHBpbmNoIHRvIHpvb21cbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3RvdWNoJywgdGhpcy5fb25Ub3VjaC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3BpbmNoJywgdGhpcy5fb25QaW5jaC5iaW5kKHRoaXMpKTtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cblJhbmdlLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBmb3IgdGhlIHJhbmdlIGNvbnRyb2xsZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBzdGFydCAgU3RhcnQgZGF0ZSBmb3IgdGhlIHJhbmdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBlbmQgICAgRW5kIGRhdGUgZm9yIHRoZSByYW5nZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtaW4gICAgTWluaW11bSB2YWx1ZSBmb3Igc3RhcnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWF4ICAgIE1heGltdW0gdmFsdWUgZm9yIGVuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSB6b29tTWluICAgIFNldCBhIG1pbmltdW0gdmFsdWUgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVuZCAtIHN0YXJ0KS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gem9vbU1heCAgICBTZXQgYSBtYXhpbXVtIHZhbHVlIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbmQgLSBzdGFydCkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBtb3ZlYWJsZSBFbmFibGUgbW92aW5nIG9mIHRoZSByYW5nZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgZHJhZ2dpbmcuIFRydWUgYnkgZGVmYXVsdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gem9vbWFibGUgRW5hYmxlIHpvb21pbmcgb2YgdGhlIHJhbmdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSBwaW5jaGluZy9zY3JvbGxpbmcuIFRydWUgYnkgZGVmYXVsdFxuICovXG5SYW5nZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSB0aGUgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICB2YXIgZmllbGRzID0gW1xuICAgICAgJ2RpcmVjdGlvbicsICdtaW4nLCAnbWF4JywgJ3pvb21NaW4nLCAnem9vbU1heCcsICdtb3ZlYWJsZScsICd6b29tYWJsZScsXG4gICAgICAnbW9tZW50JywgJ2FjdGl2YXRlJywgJ2hpZGRlbkRhdGVzJywgJ3pvb21LZXknXG4gICAgXTtcbiAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ3N0YXJ0JyBpbiBvcHRpb25zIHx8ICdlbmQnIGluIG9wdGlvbnMpIHtcbiAgICAgIC8vIGFwcGx5IGEgbmV3IHJhbmdlLiBib3RoIHN0YXJ0IGFuZCBlbmQgYXJlIG9wdGlvbmFsXG4gICAgICB0aGlzLnNldFJhbmdlKG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMuZW5kKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGRpcmVjdGlvbiBoYXMgYSB2YWxpZCB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAgICAnaG9yaXpvbnRhbCcgb3IgJ3ZlcnRpY2FsJ1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGlvbiAoZGlyZWN0aW9uKSB7XG4gIGlmIChkaXJlY3Rpb24gIT0gJ2hvcml6b250YWwnICYmIGRpcmVjdGlvbiAhPSAndmVydGljYWwnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBkaXJlY3Rpb24gXCInICsgZGlyZWN0aW9uICsgJ1wiLiAnICtcbiAgICAgICAgJ0Nob29zZSBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBuZXcgc3RhcnQgYW5kIGVuZCByYW5nZVxuICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSBbc3RhcnRdXG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmd9IFtlbmRdXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ319IFthbmltYXRpb249ZmFsc2VdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J5VXNlcj1mYWxzZV1cbiAqXG4gKi9cblJhbmdlLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGFuaW1hdGlvbiwgYnlVc2VyKSB7XG4gIGlmIChieVVzZXIgIT09IHRydWUpIHtcbiAgICBieVVzZXIgPSBmYWxzZTtcbiAgfVxuICB2YXIgZmluYWxTdGFydCA9IHN0YXJ0ICE9IHVuZGVmaW5lZCA/IHV0aWwuY29udmVydChzdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiBudWxsO1xuICB2YXIgZmluYWxFbmQgICA9IGVuZCAhPSB1bmRlZmluZWQgICA/IHV0aWwuY29udmVydChlbmQsICdEYXRlJykudmFsdWVPZigpICAgOiBudWxsO1xuICB0aGlzLl9jYW5jZWxBbmltYXRpb24oKTtcblxuICBpZiAoYW5pbWF0aW9uKSB7IC8vIHRydWUgb3IgYW4gT2JqZWN0XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgaW5pdFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICB2YXIgaW5pdEVuZCA9IHRoaXMuZW5kO1xuICAgIHZhciBkdXJhdGlvbiA9ICh0eXBlb2YgYW5pbWF0aW9uID09PSAnb2JqZWN0JyAmJiAnZHVyYXRpb24nIGluIGFuaW1hdGlvbikgPyBhbmltYXRpb24uZHVyYXRpb24gOiA1MDA7XG4gICAgdmFyIGVhc2luZ05hbWUgPSAodHlwZW9mIGFuaW1hdGlvbiA9PT0gJ29iamVjdCcgJiYgJ2Vhc2luZ0Z1bmN0aW9uJyBpbiBhbmltYXRpb24pID8gYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uIDogJ2Vhc2VJbk91dFF1YWQnO1xuICAgIHZhciBlYXNpbmdGdW5jdGlvbiA9IHV0aWwuZWFzaW5nRnVuY3Rpb25zW2Vhc2luZ05hbWVdO1xuICAgIGlmICghZWFzaW5nRnVuY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlYXNpbmcgZnVuY3Rpb24gJyArIEpTT04uc3RyaW5naWZ5KGVhc2luZ05hbWUpICsgJy4gJyArXG4gICAgICAgICAgJ0Nob29zZSBmcm9tOiAnICsgT2JqZWN0LmtleXModXRpbC5lYXNpbmdGdW5jdGlvbnMpLmpvaW4oJywgJykpO1xuICAgIH1cblxuICAgIHZhciBpbml0VGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgIHZhciBhbnlDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghbWUucHJvcHMudG91Y2guZHJhZ2dpbmcpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB2YXIgdGltZSA9IG5vdyAtIGluaXRUaW1lO1xuICAgICAgICB2YXIgZWFzZSA9IGVhc2luZ0Z1bmN0aW9uKHRpbWUgLyBkdXJhdGlvbik7XG4gICAgICAgIHZhciBkb25lID0gdGltZSA+IGR1cmF0aW9uO1xuICAgICAgICB2YXIgcyA9IChkb25lIHx8IGZpbmFsU3RhcnQgPT09IG51bGwpID8gZmluYWxTdGFydCA6IGluaXRTdGFydCArIChmaW5hbFN0YXJ0IC0gaW5pdFN0YXJ0KSAqIGVhc2U7XG4gICAgICAgIHZhciBlID0gKGRvbmUgfHwgZmluYWxFbmQgICA9PT0gbnVsbCkgPyBmaW5hbEVuZCAgIDogaW5pdEVuZCAgICsgKGZpbmFsRW5kICAgLSBpbml0RW5kKSAgICogZWFzZTtcblxuICAgICAgICBjaGFuZ2VkID0gbWUuX2FwcGx5UmFuZ2UocywgZSk7XG4gICAgICAgIERhdGVVdGlsLnVwZGF0ZUhpZGRlbkRhdGVzKG1lLm9wdGlvbnMubW9tZW50LCBtZS5ib2R5LCBtZS5vcHRpb25zLmhpZGRlbkRhdGVzKTtcbiAgICAgICAgYW55Q2hhbmdlZCA9IGFueUNoYW5nZWQgfHwgY2hhbmdlZDtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2UnLCB7c3RhcnQ6IG5ldyBEYXRlKG1lLnN0YXJ0KSwgZW5kOiBuZXcgRGF0ZShtZS5lbmQpLCBieVVzZXI6YnlVc2VyfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGlmIChhbnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2VkJywge3N0YXJ0OiBuZXcgRGF0ZShtZS5zdGFydCksIGVuZDogbmV3IERhdGUobWUuZW5kKSwgYnlVc2VyOmJ5VXNlcn0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBhbmltYXRlIHdpdGggYXMgaGlnaCBhcyBwb3NzaWJsZSBmcmFtZSByYXRlLCBsZWF2ZSAyMCBtcyBpbiBiZXR3ZWVuXG4gICAgICAgICAgLy8gZWFjaCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gYmxvY2tpbmdcbiAgICAgICAgICBtZS5hbmltYXRpb25UaW1lciA9IHNldFRpbWVvdXQobmV4dCwgMjApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLl9hcHBseVJhbmdlKGZpbmFsU3RhcnQsIGZpbmFsRW5kKTtcbiAgICBEYXRlVXRpbC51cGRhdGVIaWRkZW5EYXRlcyh0aGlzLm9wdGlvbnMubW9tZW50LCB0aGlzLmJvZHksIHRoaXMub3B0aW9ucy5oaWRkZW5EYXRlcyk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB7c3RhcnQ6IG5ldyBEYXRlKHRoaXMuc3RhcnQpLCBlbmQ6IG5ldyBEYXRlKHRoaXMuZW5kKSwgYnlVc2VyOmJ5VXNlcn07XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZScsIHBhcmFtcyk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZWQnLCBwYXJhbXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTdG9wIGFuIGFuaW1hdGlvblxuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9jYW5jZWxBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFuaW1hdGlvblRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbWF0aW9uVGltZXIpO1xuICAgIHRoaXMuYW5pbWF0aW9uVGltZXIgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBhIG5ldyBzdGFydCBhbmQgZW5kIHJhbmdlLiBUaGlzIG1ldGhvZCBpcyB0aGUgc2FtZSBhcyBzZXRSYW5nZSwgYnV0XG4gKiBkb2VzIG5vdCB0cmlnZ2VyIGEgcmFuZ2UgY2hhbmdlIGFuZCByYW5nZSBjaGFuZ2VkIGV2ZW50LCBhbmQgaXQgcmV0dXJuc1xuICogdHJ1ZSB3aGVuIHRoZSByYW5nZSBpcyBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0XVxuICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRdXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX2FwcGx5UmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBuZXdTdGFydCA9IChzdGFydCAhPSBudWxsKSA/IHV0aWwuY29udmVydChzdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiB0aGlzLnN0YXJ0LFxuICAgICAgbmV3RW5kICAgPSAoZW5kICE9IG51bGwpICAgPyB1dGlsLmNvbnZlcnQoZW5kLCAnRGF0ZScpLnZhbHVlT2YoKSAgIDogdGhpcy5lbmQsXG4gICAgICBtYXggPSAodGhpcy5vcHRpb25zLm1heCAhPSBudWxsKSA/IHV0aWwuY29udmVydCh0aGlzLm9wdGlvbnMubWF4LCAnRGF0ZScpLnZhbHVlT2YoKSA6IG51bGwsXG4gICAgICBtaW4gPSAodGhpcy5vcHRpb25zLm1pbiAhPSBudWxsKSA/IHV0aWwuY29udmVydCh0aGlzLm9wdGlvbnMubWluLCAnRGF0ZScpLnZhbHVlT2YoKSA6IG51bGwsXG4gICAgICBkaWZmO1xuXG4gIC8vIGNoZWNrIGZvciB2YWxpZCBudW1iZXJcbiAgaWYgKGlzTmFOKG5ld1N0YXJ0KSB8fCBuZXdTdGFydCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGFydCBcIicgKyBzdGFydCArICdcIicpO1xuICB9XG4gIGlmIChpc05hTihuZXdFbmQpIHx8IG5ld0VuZCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmQgXCInICsgZW5kICsgJ1wiJyk7XG4gIH1cblxuICAvLyBwcmV2ZW50IHN0YXJ0IDwgZW5kXG4gIGlmIChuZXdFbmQgPCBuZXdTdGFydCkge1xuICAgIG5ld0VuZCA9IG5ld1N0YXJ0O1xuICB9XG5cbiAgLy8gcHJldmVudCBzdGFydCA8IG1pblxuICBpZiAobWluICE9PSBudWxsKSB7XG4gICAgaWYgKG5ld1N0YXJ0IDwgbWluKSB7XG4gICAgICBkaWZmID0gKG1pbiAtIG5ld1N0YXJ0KTtcbiAgICAgIG5ld1N0YXJ0ICs9IGRpZmY7XG4gICAgICBuZXdFbmQgKz0gZGlmZjtcblxuICAgICAgLy8gcHJldmVudCBlbmQgPiBtYXhcbiAgICAgIGlmIChtYXggIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV3RW5kID4gbWF4KSB7XG4gICAgICAgICAgbmV3RW5kID0gbWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcHJldmVudCBlbmQgPiBtYXhcbiAgaWYgKG1heCAhPT0gbnVsbCkge1xuICAgIGlmIChuZXdFbmQgPiBtYXgpIHtcbiAgICAgIGRpZmYgPSAobmV3RW5kIC0gbWF4KTtcbiAgICAgIG5ld1N0YXJ0IC09IGRpZmY7XG4gICAgICBuZXdFbmQgLT0gZGlmZjtcblxuICAgICAgLy8gcHJldmVudCBzdGFydCA8IG1pblxuICAgICAgaWYgKG1pbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXdTdGFydCA8IG1pbikge1xuICAgICAgICAgIG5ld1N0YXJ0ID0gbWluO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcHJldmVudCAoZW5kLXN0YXJ0KSA8IHpvb21NaW5cbiAgaWYgKHRoaXMub3B0aW9ucy56b29tTWluICE9PSBudWxsKSB7XG4gICAgdmFyIHpvb21NaW4gPSBwYXJzZUZsb2F0KHRoaXMub3B0aW9ucy56b29tTWluKTtcbiAgICBpZiAoem9vbU1pbiA8IDApIHtcbiAgICAgIHpvb21NaW4gPSAwO1xuICAgIH1cbiAgICBpZiAoKG5ld0VuZCAtIG5ld1N0YXJ0KSA8IHpvb21NaW4pIHtcbiAgICAgIGlmICgodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSA9PT0gem9vbU1pbiAmJiBuZXdTdGFydCA+IHRoaXMuc3RhcnQgJiYgbmV3RW5kIDwgdGhpcy5lbmQpIHtcbiAgICAgICAgLy8gaWdub3JlIHRoaXMgYWN0aW9uLCB3ZSBhcmUgYWxyZWFkeSB6b29tZWQgdG8gdGhlIG1pbmltdW1cbiAgICAgICAgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBuZXdFbmQgPSB0aGlzLmVuZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB6b29tIHRvIHRoZSBtaW5pbXVtXG4gICAgICAgIGRpZmYgPSAoem9vbU1pbiAtIChuZXdFbmQgLSBuZXdTdGFydCkpO1xuICAgICAgICBuZXdTdGFydCAtPSBkaWZmIC8gMjtcbiAgICAgICAgbmV3RW5kICs9IGRpZmYgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHByZXZlbnQgKGVuZC1zdGFydCkgPiB6b29tTWF4XG4gIGlmICh0aGlzLm9wdGlvbnMuem9vbU1heCAhPT0gbnVsbCkge1xuICAgIHZhciB6b29tTWF4ID0gcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnMuem9vbU1heCk7XG4gICAgaWYgKHpvb21NYXggPCAwKSB7XG4gICAgICB6b29tTWF4ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoKG5ld0VuZCAtIG5ld1N0YXJ0KSA+IHpvb21NYXgpIHtcbiAgICAgIGlmICgodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSA9PT0gem9vbU1heCAmJiBuZXdTdGFydCA8IHRoaXMuc3RhcnQgJiYgbmV3RW5kID4gdGhpcy5lbmQpIHtcbiAgICAgICAgLy8gaWdub3JlIHRoaXMgYWN0aW9uLCB3ZSBhcmUgYWxyZWFkeSB6b29tZWQgdG8gdGhlIG1heGltdW1cbiAgICAgICAgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBuZXdFbmQgPSB0aGlzLmVuZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB6b29tIHRvIHRoZSBtYXhpbXVtXG4gICAgICAgIGRpZmYgPSAoKG5ld0VuZCAtIG5ld1N0YXJ0KSAtIHpvb21NYXgpO1xuICAgICAgICBuZXdTdGFydCArPSBkaWZmIC8gMjtcbiAgICAgICAgbmV3RW5kIC09IGRpZmYgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFuZ2VkID0gKHRoaXMuc3RhcnQgIT0gbmV3U3RhcnQgfHwgdGhpcy5lbmQgIT0gbmV3RW5kKTtcblxuICAvLyBpZiB0aGUgbmV3IHJhbmdlIGRvZXMgTk9UIG92ZXJsYXAgd2l0aCB0aGUgb2xkIHJhbmdlLCBlbWl0IGNoZWNrUmFuZ2VkSXRlbXMgdG8gYXZvaWQgbm90IHNob3dpbmcgcmFuZ2VkIGl0ZW1zIChyYW5nZWQgbWVhbmluZyBoYXMgZW5kIHRpbWUsIG5vdCBuZWNlc3NhcmlseSBvZiB0eXBlIFJhbmdlKVxuICBpZiAoISgobmV3U3RhcnQgPj0gdGhpcy5zdGFydCAmJiBuZXdTdGFydCAgIDw9IHRoaXMuZW5kKSB8fCAobmV3RW5kICAgPj0gdGhpcy5zdGFydCAmJiBuZXdFbmQgICA8PSB0aGlzLmVuZCkpICYmXG4gICAgICAhKCh0aGlzLnN0YXJ0ID49IG5ld1N0YXJ0ICYmIHRoaXMuc3RhcnQgPD0gbmV3RW5kKSAgIHx8ICh0aGlzLmVuZCA+PSBuZXdTdGFydCAgICYmIHRoaXMuZW5kIDw9IG5ld0VuZCkgKSkge1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoZWNrUmFuZ2VkSXRlbXMnKTtcbiAgfVxuXG4gIHRoaXMuc3RhcnQgPSBuZXdTdGFydDtcbiAgdGhpcy5lbmQgPSBuZXdFbmQ7XG4gIHJldHVybiBjaGFuZ2VkO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCByYW5nZS5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzXG4gKi9cblJhbmdlLnByb3RvdHlwZS5nZXRSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgIGVuZDogdGhpcy5lbmRcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBjb252ZXJzaW9uIG9mZnNldCBhbmQgc2NhbGUgZm9yIGN1cnJlbnQgcmFuZ2UsIGJhc2VkIG9uXG4gKiB0aGUgcHJvdmlkZWQgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogQHJldHVybnMge3tvZmZzZXQ6IG51bWJlciwgc2NhbGU6IG51bWJlcn19IGNvbnZlcnNpb25cbiAqL1xuUmFuZ2UucHJvdG90eXBlLmNvbnZlcnNpb24gPSBmdW5jdGlvbiAod2lkdGgsIHRvdGFsSGlkZGVuKSB7XG4gIHJldHVybiBSYW5nZS5jb252ZXJzaW9uKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB3aWR0aCwgdG90YWxIaWRkZW4pO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIHRvIGNhbGN1bGF0ZSB0aGUgY29udmVyc2lvbiBvZmZzZXQgYW5kIHNjYWxlIGZvciBhIHJhbmdlLFxuICogYmFzZWQgb24gdGhlIHByb3ZpZGVkIHN0YXJ0LCBlbmQsIGFuZCB3aWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge051bWJlcn0gZW5kXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqIEByZXR1cm5zIHt7b2Zmc2V0OiBudW1iZXIsIHNjYWxlOiBudW1iZXJ9fSBjb252ZXJzaW9uXG4gKi9cblJhbmdlLmNvbnZlcnNpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgd2lkdGgsIHRvdGFsSGlkZGVuKSB7XG4gIGlmICh0b3RhbEhpZGRlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxIaWRkZW4gPSAwO1xuICB9XG4gIGlmICh3aWR0aCAhPSAwICYmIChlbmQgLSBzdGFydCAhPSAwKSkge1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgc2NhbGU6IHdpZHRoIC8gKGVuZCAtIHN0YXJ0IC0gdG90YWxIaWRkZW4pXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBzY2FsZTogMVxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnQgZHJhZ2dpbmcgaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHlcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdGhpcy5kZWx0YURpZmZlcmVuY2UgPSAwO1xuICB0aGlzLnByZXZpb3VzRGVsdGEgPSAwO1xuXG4gIC8vIG9ubHkgYWxsb3cgZHJhZ2dpbmcgd2hlbiBjb25maWd1cmVkIGFzIG1vdmFibGVcbiAgaWYgKCF0aGlzLm9wdGlvbnMubW92ZWFibGUpIHJldHVybjtcblxuICAvLyBvbmx5IHN0YXJ0IGRyYWdnaW5nIHdoZW4gdGhlIG1vdXNlIGlzIGluc2lkZSB0aGUgY3VycmVudCByYW5nZVxuICBpZiAoIXRoaXMuX2lzSW5zaWRlUmFuZ2UoZXZlbnQpKSByZXR1cm47XG5cbiAgLy8gcmVmdXNlIHRvIGRyYWcgd2hlbiB3ZSB3aGVyZSBwaW5jaGluZyB0byBwcmV2ZW50IHRoZSB0aW1lbGluZSBtYWtlIGEganVtcFxuICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcpIHJldHVybjtcblxuICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5wcm9wcy50b3VjaC5kcmFnZ2luZyA9IHRydWU7XG5cbiAgaWYgKHRoaXMuYm9keS5kb20ucm9vdCkge1xuICAgIHRoaXMuYm9keS5kb20ucm9vdC5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybSBkcmFnZ2luZyBvcGVyYXRpb25cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcpIHJldHVybjtcblxuICAvLyBvbmx5IGFsbG93IGRyYWdnaW5nIHdoZW4gY29uZmlndXJlZCBhcyBtb3ZhYmxlXG4gIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG5cbiAgLy8gVE9ETzogdGhpcyBtYXkgYmUgcmVkdW5kYW50IGluIGhhbW1lcmpzMlxuICAvLyByZWZ1c2UgdG8gZHJhZyB3aGVuIHdlIHdoZXJlIHBpbmNoaW5nIHRvIHByZXZlbnQgdGhlIHRpbWVsaW5lIG1ha2UgYSBqdW1wXG4gIC8vIHdoZW4gcmVsZWFzaW5nIHRoZSBmaW5nZXJzIGluIG9wcG9zaXRlIG9yZGVyIGZyb20gdGhlIHRvdWNoIHNjcmVlblxuICBpZiAoIXRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICB2YWxpZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pO1xuICB2YXIgZGVsdGEgPSAoZGlyZWN0aW9uID09ICdob3Jpem9udGFsJykgPyBldmVudC5kZWx0YVggOiBldmVudC5kZWx0YVk7XG4gIGRlbHRhIC09IHRoaXMuZGVsdGFEaWZmZXJlbmNlO1xuICB2YXIgaW50ZXJ2YWwgPSAodGhpcy5wcm9wcy50b3VjaC5lbmQgLSB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0KTtcblxuICAvLyBub3JtYWxpemUgZHJhZ2dpbmcgc3BlZWQgaWYgY3V0b3V0IGlzIGluIGJldHdlZW4uXG4gIHZhciBkdXJhdGlvbiA9IERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmV0d2Vlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgaW50ZXJ2YWwgLT0gZHVyYXRpb247XG5cbiAgdmFyIHdpZHRoID0gKGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpID8gdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlci53aWR0aCA6IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0O1xuICB2YXIgZGlmZlJhbmdlID0gLWRlbHRhIC8gd2lkdGggKiBpbnRlcnZhbDtcbiAgdmFyIG5ld1N0YXJ0ID0gdGhpcy5wcm9wcy50b3VjaC5zdGFydCArIGRpZmZSYW5nZTtcbiAgdmFyIG5ld0VuZCA9IHRoaXMucHJvcHMudG91Y2guZW5kICsgZGlmZlJhbmdlO1xuXG4gIC8vIHNuYXBwaW5nIHRpbWVzIGF3YXkgZnJvbSBoaWRkZW4gem9uZXNcbiAgdmFyIHNhZmVTdGFydCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld1N0YXJ0LCB0aGlzLnByZXZpb3VzRGVsdGEtZGVsdGEsIHRydWUpO1xuICB2YXIgc2FmZUVuZCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld0VuZCwgdGhpcy5wcmV2aW91c0RlbHRhLWRlbHRhLCB0cnVlKTtcbiAgaWYgKHNhZmVTdGFydCAhPSBuZXdTdGFydCB8fCBzYWZlRW5kICE9IG5ld0VuZCkge1xuICAgIHRoaXMuZGVsdGFEaWZmZXJlbmNlICs9IGRlbHRhO1xuICAgIHRoaXMucHJvcHMudG91Y2guc3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSBzYWZlRW5kO1xuICAgIHRoaXMuX29uRHJhZyhldmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5wcmV2aW91c0RlbHRhID0gZGVsdGE7XG4gIHRoaXMuX2FwcGx5UmFuZ2UobmV3U3RhcnQsIG5ld0VuZCk7XG5cbiAgLy8gZmlyZSBhIHJhbmdlY2hhbmdlIGV2ZW50XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlJywge1xuICAgIHN0YXJ0OiBuZXcgRGF0ZSh0aGlzLnN0YXJ0KSxcbiAgICBlbmQ6ICAgbmV3IERhdGUodGhpcy5lbmQpLFxuICAgIGJ5VXNlcjogdHJ1ZVxuICB9KTtcbn07XG5cbi8qKlxuICogU3RvcCBkcmFnZ2luZyBvcGVyYXRpb25cbiAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcpIHJldHVybjtcblxuICAvLyBvbmx5IGFsbG93IGRyYWdnaW5nIHdoZW4gY29uZmlndXJlZCBhcyBtb3ZhYmxlXG4gIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG5cbiAgLy8gVE9ETzogdGhpcyBtYXkgYmUgcmVkdW5kYW50IGluIGhhbW1lcmpzMlxuICAvLyByZWZ1c2UgdG8gZHJhZyB3aGVuIHdlIHdoZXJlIHBpbmNoaW5nIHRvIHByZXZlbnQgdGhlIHRpbWVsaW5lIG1ha2UgYSBqdW1wXG4gIC8vIHdoZW4gcmVsZWFzaW5nIHRoZSBmaW5nZXJzIGluIG9wcG9zaXRlIG9yZGVyIGZyb20gdGhlIHRvdWNoIHNjcmVlblxuICBpZiAoIXRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gIHRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcgPSBmYWxzZTtcbiAgaWYgKHRoaXMuYm9keS5kb20ucm9vdCkge1xuICAgIHRoaXMuYm9keS5kb20ucm9vdC5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG4gIH1cblxuICAvLyBmaXJlIGEgcmFuZ2VjaGFuZ2VkIGV2ZW50XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlZCcsIHtcbiAgICBzdGFydDogbmV3IERhdGUodGhpcy5zdGFydCksXG4gICAgZW5kOiAgIG5ldyBEYXRlKHRoaXMuZW5kKSxcbiAgICBieVVzZXI6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlIHdoZWVsIGV2ZW50LCB1c2VkIHRvIHpvb21cbiAqIENvZGUgZnJvbSBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsL1xuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fb25Nb3VzZVdoZWVsID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgLy8gb25seSBhbGxvdyB6b29taW5nIHdoZW4gY29uZmlndXJlZCBhcyB6b29tYWJsZSBhbmQgbW92ZWFibGVcbiAgaWYgKCEodGhpcy5vcHRpb25zLnpvb21hYmxlICYmIHRoaXMub3B0aW9ucy5tb3ZlYWJsZSkpIHJldHVybjtcblxuICAvLyBvbmx5IHpvb20gd2hlbiB0aGUgbW91c2UgaXMgaW5zaWRlIHRoZSBjdXJyZW50IHJhbmdlXG4gIGlmICghdGhpcy5faXNJbnNpZGVSYW5nZShldmVudCkpIHJldHVybjtcbiAgXG4gIC8vIG9ubHkgem9vbSB3aGVuIHRoZSBhY2NvcmRpbmcga2V5IGlzIHByZXNzZWQgYW5kIHRoZSB6b29tS2V5IG9wdGlvbiBpcyBzZXRcbiAgaWYgKHRoaXMub3B0aW9ucy56b29tS2V5ICYmICFldmVudFt0aGlzLm9wdGlvbnMuem9vbUtleV0pIHJldHVybjtcblxuICAvLyByZXRyaWV2ZSBkZWx0YVxuICB2YXIgZGVsdGEgPSAwO1xuICBpZiAoZXZlbnQud2hlZWxEZWx0YSkgeyAvKiBJRS9PcGVyYS4gKi9cbiAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGEgLyAxMjA7XG4gIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7IC8qIE1vemlsbGEgY2FzZS4gKi9cbiAgICAvLyBJbiBNb3ppbGxhLCBzaWduIG9mIGRlbHRhIGlzIGRpZmZlcmVudCB0aGFuIGluIElFLlxuICAgIC8vIEFsc28sIGRlbHRhIGlzIG11bHRpcGxlIG9mIDMuXG4gICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gMztcbiAgfVxuXG4gIC8vIElmIGRlbHRhIGlzIG5vbnplcm8sIGhhbmRsZSBpdC5cbiAgLy8gQmFzaWNhbGx5LCBkZWx0YSBpcyBub3cgcG9zaXRpdmUgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIHVwLFxuICAvLyBhbmQgbmVnYXRpdmUsIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCBkb3duLlxuICBpZiAoZGVsdGEpIHtcbiAgICAvLyBwZXJmb3JtIHRoZSB6b29tIGFjdGlvbi4gRGVsdGEgaXMgbm9ybWFsbHkgMSBvciAtMVxuXG4gICAgLy8gYWRqdXN0IGEgbmVnYXRpdmUgZGVsdGEgc3VjaCB0aGF0IHpvb21pbmcgaW4gd2l0aCBkZWx0YSAwLjFcbiAgICAvLyBlcXVhbHMgem9vbWluZyBvdXQgd2l0aCBhIGRlbHRhIC0wLjFcbiAgICB2YXIgc2NhbGU7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgc2NhbGUgPSAxIC0gKGRlbHRhIC8gNSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2NhbGUgPSAxIC8gKDEgKyAoZGVsdGEgLyA1KSkgO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBjZW50ZXIsIHRoZSBkYXRlIHRvIHpvb20gYXJvdW5kXG4gICAgdmFyIHBvaW50ZXIgPSBnZXRQb2ludGVyKHt4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZfSwgdGhpcy5ib2R5LmRvbS5jZW50ZXIpO1xuICAgIHZhciBwb2ludGVyRGF0ZSA9IHRoaXMuX3BvaW50ZXJUb0RhdGUocG9pbnRlcik7XG5cbiAgICB0aGlzLnpvb20oc2NhbGUsIHBvaW50ZXJEYXRlLCBkZWx0YSk7XG4gIH1cblxuICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9ucyBjYXVzZWQgYnkgbW91c2Ugd2hlZWxcbiAgLy8gKGVsc2UgdGhlIHBhZ2UgYW5kIHRpbWVsaW5lIGJvdGggem9vbSBhbmQgc2Nyb2xsKVxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuLyoqXG4gKiBTdGFydCBvZiBhIHRvdWNoIGdlc3R1cmVcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fb25Ub3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nID0gdHJ1ZTtcbiAgdGhpcy5wcm9wcy50b3VjaC5jZW50ZXIgPSBudWxsO1xuICB0aGlzLnNjYWxlT2Zmc2V0ID0gMDtcbiAgdGhpcy5kZWx0YURpZmZlcmVuY2UgPSAwO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgcGluY2ggZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uUGluY2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gb25seSBhbGxvdyB6b29taW5nIHdoZW4gY29uZmlndXJlZCBhcyB6b29tYWJsZSBhbmQgbW92ZWFibGVcbiAgaWYgKCEodGhpcy5vcHRpb25zLnpvb21hYmxlICYmIHRoaXMub3B0aW9ucy5tb3ZlYWJsZSkpIHJldHVybjtcblxuICB0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSBmYWxzZTtcblxuICBpZiAoIXRoaXMucHJvcHMudG91Y2guY2VudGVyKSB7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5jZW50ZXIgPSBnZXRQb2ludGVyKGV2ZW50LmNlbnRlciwgdGhpcy5ib2R5LmRvbS5jZW50ZXIpO1xuICB9XG5cbiAgdmFyIHNjYWxlID0gMSAvIChldmVudC5zY2FsZSArIHRoaXMuc2NhbGVPZmZzZXQpO1xuICB2YXIgY2VudGVyRGF0ZSA9IHRoaXMuX3BvaW50ZXJUb0RhdGUodGhpcy5wcm9wcy50b3VjaC5jZW50ZXIpO1xuXG4gIHZhciBoaWRkZW5EdXJhdGlvbiA9IERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmV0d2Vlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgdmFyIGhpZGRlbkR1cmF0aW9uQmVmb3JlID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUodGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLCBjZW50ZXJEYXRlKTtcbiAgdmFyIGhpZGRlbkR1cmF0aW9uQWZ0ZXIgPSBoaWRkZW5EdXJhdGlvbiAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlO1xuXG4gIC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgYW5kIGVuZFxuICB2YXIgbmV3U3RhcnQgPSAoY2VudGVyRGF0ZSAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlKSArICh0aGlzLnByb3BzLnRvdWNoLnN0YXJ0IC0gKGNlbnRlckRhdGUgLSBoaWRkZW5EdXJhdGlvbkJlZm9yZSkpICogc2NhbGU7XG4gIHZhciBuZXdFbmQgPSAoY2VudGVyRGF0ZSArIGhpZGRlbkR1cmF0aW9uQWZ0ZXIpICsgKHRoaXMucHJvcHMudG91Y2guZW5kIC0gKGNlbnRlckRhdGUgKyBoaWRkZW5EdXJhdGlvbkFmdGVyKSkgKiBzY2FsZTtcblxuICAvLyBzbmFwcGluZyB0aW1lcyBhd2F5IGZyb20gaGlkZGVuIHpvbmVzXG4gIHRoaXMuc3RhcnRUb0Zyb250ID0gMSAtIHNjYWxlIDw9IDA7IC8vIHVzZWQgdG8gZG8gdGhlIHJpZ2h0IGF1dG8gY29ycmVjdGlvbiB3aXRoIHBlcmlvZGljIGhpZGRlbiB0aW1lc1xuICB0aGlzLmVuZFRvRnJvbnQgPSBzY2FsZSAtIDEgPD0gMDsgICAvLyB1c2VkIHRvIGRvIHRoZSByaWdodCBhdXRvIGNvcnJlY3Rpb24gd2l0aCBwZXJpb2RpYyBoaWRkZW4gdGltZXNcblxuICB2YXIgc2FmZVN0YXJ0ID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3U3RhcnQsIDEgLSBzY2FsZSwgdHJ1ZSk7XG4gIHZhciBzYWZlRW5kID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3RW5kLCBzY2FsZSAtIDEsIHRydWUpO1xuICBpZiAoc2FmZVN0YXJ0ICE9IG5ld1N0YXJ0IHx8IHNhZmVFbmQgIT0gbmV3RW5kKSB7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5zdGFydCA9IHNhZmVTdGFydDtcbiAgICB0aGlzLnByb3BzLnRvdWNoLmVuZCA9IHNhZmVFbmQ7XG4gICAgdGhpcy5zY2FsZU9mZnNldCA9IDEgLSBldmVudC5zY2FsZTtcbiAgICBuZXdTdGFydCA9IHNhZmVTdGFydDtcbiAgICBuZXdFbmQgPSBzYWZlRW5kO1xuICB9XG5cbiAgdGhpcy5zZXRSYW5nZShuZXdTdGFydCwgbmV3RW5kLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgdGhpcy5zdGFydFRvRnJvbnQgPSBmYWxzZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbiAgdGhpcy5lbmRUb0Zyb250ID0gdHJ1ZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBtb3VzZSBmcm9tIGEgbW91c2UgZXZlbnQgaXMgaW5zaWRlIHRoZSB2aXNpYmxlIHdpbmRvdyxcbiAqIGJldHdlZW4gdGhlIGN1cnJlbnQgc3RhcnQgYW5kIGVuZCBkYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIGluc2lkZSB0aGUgdmlzaWJsZSB3aW5kb3dcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5faXNJbnNpZGVSYW5nZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIC8vIGNhbGN1bGF0ZSB0aGUgdGltZSB3aGVyZSB0aGUgbW91c2UgaXMsIGNoZWNrIHdoZXRoZXIgaW5zaWRlXG4gIC8vIGFuZCBubyBzY3JvbGwgYWN0aW9uIHNob3VsZCBoYXBwZW4uXG4gIHZhciBjbGllbnRYID0gZXZlbnQuY2VudGVyID8gZXZlbnQuY2VudGVyLnggOiBldmVudC5jbGllbnRYO1xuICB2YXIgeCA9IGNsaWVudFggLSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmJvZHkuZG9tLmNlbnRlckNvbnRhaW5lcik7XG4gIHZhciB0aW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuXG4gIHJldHVybiB0aW1lID49IHRoaXMuc3RhcnQgJiYgdGltZSA8PSB0aGlzLmVuZDtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgY2VudGVyIGRhdGUgZm9yIHpvb21pbmdcbiAqIEBwYXJhbSB7e3g6IE51bWJlciwgeTogTnVtYmVyfX0gcG9pbnRlclxuICogQHJldHVybiB7bnVtYmVyfSBkYXRlXG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX3BvaW50ZXJUb0RhdGUgPSBmdW5jdGlvbiAocG9pbnRlcikge1xuICB2YXIgY29udmVyc2lvbjtcbiAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG5cbiAgdmFsaWRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKTtcblxuICBpZiAoZGlyZWN0aW9uID09ICdob3Jpem9udGFsJykge1xuICAgIHJldHVybiB0aGlzLmJvZHkudXRpbC50b1RpbWUocG9pbnRlci54KS52YWx1ZU9mKCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0O1xuICAgIGNvbnZlcnNpb24gPSB0aGlzLmNvbnZlcnNpb24oaGVpZ2h0KTtcbiAgICByZXR1cm4gcG9pbnRlci55IC8gY29udmVyc2lvbi5zY2FsZSArIGNvbnZlcnNpb24ub2Zmc2V0O1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcG9pbnRlciBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgbG9jYXRpb24gb2YgdGhlIGRvbSBlbGVtZW50XG4gKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHRvdWNoXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIERPTSBlbGVtZW50XG4gKiBAcmV0dXJuIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb2ludGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRQb2ludGVyICh0b3VjaCwgZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHg6IHRvdWNoLnggLSB1dGlsLmdldEFic29sdXRlTGVmdChlbGVtZW50KSxcbiAgICB5OiB0b3VjaC55IC0gdXRpbC5nZXRBYnNvbHV0ZVRvcChlbGVtZW50KVxuICB9O1xufVxuXG4vKipcbiAqIFpvb20gdGhlIHJhbmdlIHRoZSBnaXZlbiBzY2FsZSBpbiBvciBvdXQuIFN0YXJ0IGFuZCBlbmQgZGF0ZSB3aWxsXG4gKiBiZSBhZGp1c3RlZCwgYW5kIHRoZSB0aW1lbGluZSB3aWxsIGJlIHJlZHJhd24uIFlvdSBjYW4gb3B0aW9uYWxseSBnaXZlIGFcbiAqIGRhdGUgYXJvdW5kIHdoaWNoIHRvIHpvb20uXG4gKiBGb3IgZXhhbXBsZSwgdHJ5IHNjYWxlID0gMC45IG9yIDEuMVxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlICAgICAgU2NhbGluZyBmYWN0b3IuIFZhbHVlcyBhYm92ZSAxIHdpbGwgem9vbSBvdXQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYmVsb3cgMSB3aWxsIHpvb20gaW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW2NlbnRlcl0gICBWYWx1ZSByZXByZXNlbnRpbmcgYSBkYXRlIGFyb3VuZCB3aGljaCB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSB6b29tZWQuXG4gKi9cblJhbmdlLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24oc2NhbGUsIGNlbnRlciwgZGVsdGEpIHtcbiAgLy8gaWYgY2VudGVyRGF0ZSBpcyBub3QgcHJvdmlkZWQsIHRha2UgaXQgaGFsZiBiZXR3ZWVuIHN0YXJ0IERhdGUgYW5kIGVuZCBEYXRlXG4gIGlmIChjZW50ZXIgPT0gbnVsbCkge1xuICAgIGNlbnRlciA9ICh0aGlzLnN0YXJ0ICsgdGhpcy5lbmQpIC8gMjtcbiAgfVxuXG4gIHZhciBoaWRkZW5EdXJhdGlvbiA9IERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmV0d2Vlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgdmFyIGhpZGRlbkR1cmF0aW9uQmVmb3JlID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUodGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLCBjZW50ZXIpO1xuICB2YXIgaGlkZGVuRHVyYXRpb25BZnRlciA9IGhpZGRlbkR1cmF0aW9uIC0gaGlkZGVuRHVyYXRpb25CZWZvcmU7XG5cbiAgLy8gY2FsY3VsYXRlIG5ldyBzdGFydCBhbmQgZW5kXG4gIHZhciBuZXdTdGFydCA9IChjZW50ZXItaGlkZGVuRHVyYXRpb25CZWZvcmUpICsgKHRoaXMuc3RhcnQgLSAoY2VudGVyLWhpZGRlbkR1cmF0aW9uQmVmb3JlKSkgKiBzY2FsZTtcbiAgdmFyIG5ld0VuZCAgID0gKGNlbnRlcitoaWRkZW5EdXJhdGlvbkFmdGVyKSArICh0aGlzLmVuZCAtIChjZW50ZXIraGlkZGVuRHVyYXRpb25BZnRlcikpICogc2NhbGU7XG5cbiAgLy8gc25hcHBpbmcgdGltZXMgYXdheSBmcm9tIGhpZGRlbiB6b25lc1xuICB0aGlzLnN0YXJ0VG9Gcm9udCA9IGRlbHRhID4gMCA/IGZhbHNlIDogdHJ1ZTsgLy8gdXNlZCB0byBkbyB0aGUgcmlnaHQgYXV0b2NvcnJlY3Rpb24gd2l0aCBwZXJpb2RpYyBoaWRkZW4gdGltZXNcbiAgdGhpcy5lbmRUb0Zyb250ID0gLWRlbHRhICA+IDAgPyBmYWxzZSA6IHRydWU7IC8vIHVzZWQgdG8gZG8gdGhlIHJpZ2h0IGF1dG9jb3JyZWN0aW9uIHdpdGggcGVyaW9kaWMgaGlkZGVuIHRpbWVzXG4gIHZhciBzYWZlU3RhcnQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdTdGFydCwgZGVsdGEsIHRydWUpO1xuICB2YXIgc2FmZUVuZCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld0VuZCwgLWRlbHRhLCB0cnVlKTtcbiAgaWYgKHNhZmVTdGFydCAhPSBuZXdTdGFydCB8fCBzYWZlRW5kICE9IG5ld0VuZCkge1xuICAgIG5ld1N0YXJ0ID0gc2FmZVN0YXJ0O1xuICAgIG5ld0VuZCA9IHNhZmVFbmQ7XG4gIH1cblxuICB0aGlzLnNldFJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQsIGZhbHNlLCB0cnVlKTtcblxuICB0aGlzLnN0YXJ0VG9Gcm9udCA9IGZhbHNlOyAvLyByZXZlcnQgdG8gZGVmYXVsdFxuICB0aGlzLmVuZFRvRnJvbnQgPSB0cnVlOyAvLyByZXZlcnQgdG8gZGVmYXVsdFxufTtcblxuXG5cbi8qKlxuICogTW92ZSB0aGUgcmFuZ2Ugd2l0aCBhIGdpdmVuIGRlbHRhIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0LiBTdGFydCBhbmQgZW5kXG4gKiB2YWx1ZSB3aWxsIGJlIGFkanVzdGVkLiBGb3IgZXhhbXBsZSwgdHJ5IGRlbHRhID0gMC4xIG9yIC0wLjFcbiAqIEBwYXJhbSB7TnVtYmVyfSAgZGVsdGEgICAgIE1vdmluZyBhbW91bnQuIFBvc2l0aXZlIHZhbHVlIHdpbGwgbW92ZSByaWdodCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlIHZhbHVlIHdpbGwgbW92ZSBsZWZ0XG4gKi9cblJhbmdlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oZGVsdGEpIHtcbiAgLy8gem9vbSBzdGFydCBEYXRlIGFuZCBlbmQgRGF0ZSByZWxhdGl2ZSB0byB0aGUgY2VudGVyRGF0ZVxuICB2YXIgZGlmZiA9ICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpO1xuXG4gIC8vIGFwcGx5IG5ldyB2YWx1ZXNcbiAgdmFyIG5ld1N0YXJ0ID0gdGhpcy5zdGFydCArIGRpZmYgKiBkZWx0YTtcbiAgdmFyIG5ld0VuZCA9IHRoaXMuZW5kICsgZGlmZiAqIGRlbHRhO1xuXG4gIC8vIFRPRE86IHJlY2tvbiB3aXRoIG1pbiBhbmQgbWF4IHJhbmdlXG5cbiAgdGhpcy5zdGFydCA9IG5ld1N0YXJ0O1xuICB0aGlzLmVuZCA9IG5ld0VuZDtcbn07XG5cbi8qKlxuICogTW92ZSB0aGUgcmFuZ2UgdG8gYSBuZXcgY2VudGVyIHBvaW50XG4gKiBAcGFyYW0ge051bWJlcn0gbW92ZVRvICAgICAgTmV3IGNlbnRlciBwb2ludCBvZiB0aGUgcmFuZ2VcbiAqL1xuUmFuZ2UucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKG1vdmVUbykge1xuICB2YXIgY2VudGVyID0gKHRoaXMuc3RhcnQgKyB0aGlzLmVuZCkgLyAyO1xuXG4gIHZhciBkaWZmID0gY2VudGVyIC0gbW92ZVRvO1xuXG4gIC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgYW5kIGVuZFxuICB2YXIgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0IC0gZGlmZjtcbiAgdmFyIG5ld0VuZCA9IHRoaXMuZW5kIC0gZGlmZjtcblxuICB0aGlzLnNldFJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZTtcbiJdfQ==
},{"../hammerUtil":18,"../module/moment":20,"../util":46,"./DateUtil":27,"./component/Component":33}],29:[function(require,module,exports){
// Utility functions for ordering and stacking of items
'use strict';

var EPSILON = 0.001; // used when checking collisions, to prevent round-off errors

/**
 * Order items by their start data
 * @param {Item[]} items
 */
exports.orderByStart = function (items) {
  items.sort(function (a, b) {
    return a.data.start - b.data.start;
  });
};

/**
 * Order items by their end date. If they have no end date, their start date
 * is used.
 * @param {Item[]} items
 */
exports.orderByEnd = function (items) {
  items.sort(function (a, b) {
    var aTime = 'end' in a.data ? a.data.end : a.data.start,
        bTime = 'end' in b.data ? b.data.end : b.data.start;

    return aTime - bTime;
  });
};

/**
 * Adjust vertical positions of the items such that they don't overlap each
 * other.
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 * @param {boolean} [force=false]
 *            If true, all items will be repositioned. If false (default), only
 *            items having a top===null will be re-stacked
 */
exports.stack = function (items, margin, force) {
  var i, iMax;

  if (force) {
    // reset top position of all items
    for (i = 0, iMax = items.length; i < iMax; i++) {
      items[i].top = null;
    }
  }

  // calculate new, non-overlapping positions
  for (i = 0, iMax = items.length; i < iMax; i++) {
    var item = items[i];
    if (item.stack && item.top === null) {
      // initialize top position
      item.top = margin.axis;

      do {
        // TODO: optimize checking for overlap. when there is a gap without items,
        //       you only need to check for items from the next item on, not from zero
        var collidingItem = null;
        for (var j = 0, jj = items.length; j < jj; j++) {
          var other = items[j];
          if (other.top !== null && other !== item && other.stack && exports.collision(item, other, margin.item)) {
            collidingItem = other;
            break;
          }
        }

        if (collidingItem != null) {
          // There is a collision. Reposition the items above the colliding element
          item.top = collidingItem.top + collidingItem.height + margin.item.vertical;
        }
      } while (collidingItem);
    }
  }
};

/**
 * Adjust vertical positions of the items without stacking them
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 */
exports.nostack = function (items, margin, subgroups) {
  var i, iMax, newTop;

  // reset top position of all items
  for (i = 0, iMax = items.length; i < iMax; i++) {
    if (items[i].data.subgroup !== undefined) {
      newTop = margin.axis;
      for (var subgroup in subgroups) {
        if (subgroups.hasOwnProperty(subgroup)) {
          if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroups[items[i].data.subgroup].index) {
            newTop += subgroups[subgroup].height + margin.item.vertical;
          }
        }
      }
      items[i].top = newTop;
    } else {
      items[i].top = margin.axis;
    }
  }
};

/**
 * Test if the two provided items collide
 * The items must have parameters left, width, top, and height.
 * @param {Item} a          The first item
 * @param {Item} b          The second item
 * @param {{horizontal: number, vertical: number}} margin
 *                          An object containing a horizontal and vertical
 *                          minimum required margin.
 * @return {boolean}        true if a and b collide, else false
 */
exports.collision = function (a, b, margin) {
  return a.left - margin.horizontal + EPSILON < b.left + b.width && a.left + a.width + margin.horizontal - EPSILON > b.left && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL1N0YWNrLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQzs7Ozs7O0FBTXBCLE9BQU8sQ0FBQyxZQUFZLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDckMsT0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDekIsV0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztHQUNwQyxDQUFDLENBQUM7Q0FDSixDQUFDOzs7Ozs7O0FBT0YsT0FBTyxDQUFDLFVBQVUsR0FBRyxVQUFTLEtBQUssRUFBRTtBQUNuQyxPQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUN6QixRQUFJLEtBQUssR0FBRyxBQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsSUFBSSxHQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSztRQUNyRCxLQUFLLEdBQUcsQUFBQyxLQUFLLElBQUksQ0FBQyxDQUFDLElBQUksR0FBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQzs7QUFFMUQsV0FBTyxLQUFLLEdBQUcsS0FBSyxDQUFDO0dBQ3RCLENBQUMsQ0FBQztDQUNKLENBQUM7Ozs7Ozs7Ozs7Ozs7QUFhRixPQUFPLENBQUMsS0FBSyxHQUFHLFVBQVMsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7QUFDN0MsTUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDOztBQUVaLE1BQUksS0FBSyxFQUFFOztBQUVULFNBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLEdBQUcs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QVEsQUFBQyxDQUFDLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxVQUFVLEdBQUcsT0FBTyxHQUFXLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEtBQUssQUFBQyxJQUNyRSxBQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsVUFBVSxHQUFHLE9BQU8sR0FBSSxDQUFDLENBQUMsSUFBSSxJQUN6RCxBQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLFFBQVEsR0FBRyxPQUFPLEdBQWtCLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQUFBQyxJQUNyRSxBQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsUUFBUSxHQUFHLE9BQU8sR0FBTSxDQUFDLENBQUMsR0FBRyxDQUFFO0NBQy9ELENBQUMiLCJmaWxlIjoiL1VzZXJzL2VtaWx5YXNobGV5L1NUT1JZVE9PTFMvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvU3RhY2suanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igb3JkZXJpbmcgYW5kIHN0YWNraW5nIG9mIGl0ZW1zXG52YXIgRVBTSUxPTiA9IDAuMDAxOyAvLyB1c2VkIHdoZW4gY2hlY2tpbmcgY29sbGlzaW9ucywgdG8gcHJldmVudCByb3VuZC1vZmYgZXJyb3JzXG5cbi8qKlxuICogT3JkZXIgaXRlbXMgYnkgdGhlaXIgc3RhcnQgZGF0YVxuICogQHBhcmFtIHtJdGVtW119IGl0ZW1zXG4gKi9cbmV4cG9ydHMub3JkZXJCeVN0YXJ0ID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgaXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLmRhdGEuc3RhcnQgLSBiLmRhdGEuc3RhcnQ7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBPcmRlciBpdGVtcyBieSB0aGVpciBlbmQgZGF0ZS4gSWYgdGhleSBoYXZlIG5vIGVuZCBkYXRlLCB0aGVpciBzdGFydCBkYXRlXG4gKiBpcyB1c2VkLlxuICogQHBhcmFtIHtJdGVtW119IGl0ZW1zXG4gKi9cbmV4cG9ydHMub3JkZXJCeUVuZCA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYVRpbWUgPSAoJ2VuZCcgaW4gYS5kYXRhKSA/IGEuZGF0YS5lbmQgOiBhLmRhdGEuc3RhcnQsXG4gICAgICAgIGJUaW1lID0gKCdlbmQnIGluIGIuZGF0YSkgPyBiLmRhdGEuZW5kIDogYi5kYXRhLnN0YXJ0O1xuXG4gICAgcmV0dXJuIGFUaW1lIC0gYlRpbWU7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBZGp1c3QgdmVydGljYWwgcG9zaXRpb25zIG9mIHRoZSBpdGVtcyBzdWNoIHRoYXQgdGhleSBkb24ndCBvdmVybGFwIGVhY2hcbiAqIG90aGVyLlxuICogQHBhcmFtIHtJdGVtW119IGl0ZW1zXG4gKiAgICAgICAgICAgIEFsbCB2aXNpYmxlIGl0ZW1zXG4gKiBAcGFyYW0ge3tpdGVtOiB7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfSwgYXhpczogbnVtYmVyfX0gbWFyZ2luXG4gKiAgICAgICAgICAgIE1hcmdpbnMgYmV0d2VlbiBpdGVtcyBhbmQgYmV0d2VlbiBpdGVtcyBhbmQgdGhlIGF4aXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV1cbiAqICAgICAgICAgICAgSWYgdHJ1ZSwgYWxsIGl0ZW1zIHdpbGwgYmUgcmVwb3NpdGlvbmVkLiBJZiBmYWxzZSAoZGVmYXVsdCksIG9ubHlcbiAqICAgICAgICAgICAgaXRlbXMgaGF2aW5nIGEgdG9wPT09bnVsbCB3aWxsIGJlIHJlLXN0YWNrZWRcbiAqL1xuZXhwb3J0cy5zdGFjayA9IGZ1bmN0aW9uKGl0ZW1zLCBtYXJnaW4sIGZvcmNlKSB7XG4gIHZhciBpLCBpTWF4O1xuXG4gIGlmIChmb3JjZSkge1xuICAgIC8vIHJlc2V0IHRvcCBwb3NpdGlvbiBvZiBhbGwgaXRlbXNcbiAgICBmb3IgKGkgPSAwLCBpTWF4ID0gaXRlbXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBpdGVtc1tpXS50b3AgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSBuZXcsIG5vbi1vdmVybGFwcGluZyBwb3NpdGlvbnNcbiAgZm9yIChpID0gMCwgaU1heCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgaWYgKGl0ZW0uc3RhY2sgJiYgaXRlbS50b3AgPT09IG51bGwpIHtcbiAgICAgIC8vIGluaXRpYWxpemUgdG9wIHBvc2l0aW9uXG4gICAgICBpdGVtLnRvcCA9IG1hcmdpbi5heGlzO1xuXG4gICAgICBkbyB7XG4gICAgICAgIC8vIFRPRE86IG9wdGltaXplIGNoZWNraW5nIGZvciBvdmVybGFwLiB3aGVuIHRoZXJlIGlzIGEgZ2FwIHdpdGhvdXQgaXRlbXMsXG4gICAgICAgIC8vICAgICAgIHlvdSBvbmx5IG5lZWQgdG8gY2hlY2sgZm9yIGl0ZW1zIGZyb20gdGhlIG5leHQgaXRlbSBvbiwgbm90IGZyb20gemVyb1xuICAgICAgICB2YXIgY29sbGlkaW5nSXRlbSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGl0ZW1zLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICB2YXIgb3RoZXIgPSBpdGVtc1tqXTtcbiAgICAgICAgICBpZiAob3RoZXIudG9wICE9PSBudWxsICYmIG90aGVyICE9PSBpdGVtICYmIG90aGVyLnN0YWNrICYmIGV4cG9ydHMuY29sbGlzaW9uKGl0ZW0sIG90aGVyLCBtYXJnaW4uaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbGxpZGluZ0l0ZW0gPSBvdGhlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2xsaWRpbmdJdGVtICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBhIGNvbGxpc2lvbi4gUmVwb3NpdGlvbiB0aGUgaXRlbXMgYWJvdmUgdGhlIGNvbGxpZGluZyBlbGVtZW50XG4gICAgICAgICAgaXRlbS50b3AgPSBjb2xsaWRpbmdJdGVtLnRvcCArIGNvbGxpZGluZ0l0ZW0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKGNvbGxpZGluZ0l0ZW0pO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIEFkanVzdCB2ZXJ0aWNhbCBwb3NpdGlvbnMgb2YgdGhlIGl0ZW1zIHdpdGhvdXQgc3RhY2tpbmcgdGhlbVxuICogQHBhcmFtIHtJdGVtW119IGl0ZW1zXG4gKiAgICAgICAgICAgIEFsbCB2aXNpYmxlIGl0ZW1zXG4gKiBAcGFyYW0ge3tpdGVtOiB7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfSwgYXhpczogbnVtYmVyfX0gbWFyZ2luXG4gKiAgICAgICAgICAgIE1hcmdpbnMgYmV0d2VlbiBpdGVtcyBhbmQgYmV0d2VlbiBpdGVtcyBhbmQgdGhlIGF4aXMuXG4gKi9cbmV4cG9ydHMubm9zdGFjayA9IGZ1bmN0aW9uKGl0ZW1zLCBtYXJnaW4sIHN1Ymdyb3Vwcykge1xuICB2YXIgaSwgaU1heCwgbmV3VG9wO1xuXG4gIC8vIHJlc2V0IHRvcCBwb3NpdGlvbiBvZiBhbGwgaXRlbXNcbiAgZm9yIChpID0gMCwgaU1heCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgIGlmIChpdGVtc1tpXS5kYXRhLnN1Ymdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1RvcCA9IG1hcmdpbi5heGlzO1xuICAgICAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gc3ViZ3JvdXBzKSB7XG4gICAgICAgIGlmIChzdWJncm91cHMuaGFzT3duUHJvcGVydHkoc3ViZ3JvdXApKSB7XG4gICAgICAgICAgaWYgKHN1Ymdyb3Vwc1tzdWJncm91cF0udmlzaWJsZSA9PSB0cnVlICYmIHN1Ymdyb3Vwc1tzdWJncm91cF0uaW5kZXggPCBzdWJncm91cHNbaXRlbXNbaV0uZGF0YS5zdWJncm91cF0uaW5kZXgpIHtcbiAgICAgICAgICAgIG5ld1RvcCArPSBzdWJncm91cHNbc3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXRlbXNbaV0udG9wID0gbmV3VG9wO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGl0ZW1zW2ldLnRvcCA9IG1hcmdpbi5heGlzO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUZXN0IGlmIHRoZSB0d28gcHJvdmlkZWQgaXRlbXMgY29sbGlkZVxuICogVGhlIGl0ZW1zIG11c3QgaGF2ZSBwYXJhbWV0ZXJzIGxlZnQsIHdpZHRoLCB0b3AsIGFuZCBoZWlnaHQuXG4gKiBAcGFyYW0ge0l0ZW19IGEgICAgICAgICAgVGhlIGZpcnN0IGl0ZW1cbiAqIEBwYXJhbSB7SXRlbX0gYiAgICAgICAgICBUaGUgc2Vjb25kIGl0ZW1cbiAqIEBwYXJhbSB7e2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn19IG1hcmdpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIGEgaG9yaXpvbnRhbCBhbmQgdmVydGljYWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtIHJlcXVpcmVkIG1hcmdpbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICB0cnVlIGlmIGEgYW5kIGIgY29sbGlkZSwgZWxzZSBmYWxzZVxuICovXG5leHBvcnRzLmNvbGxpc2lvbiA9IGZ1bmN0aW9uKGEsIGIsIG1hcmdpbikge1xuICByZXR1cm4gKChhLmxlZnQgLSBtYXJnaW4uaG9yaXpvbnRhbCArIEVQU0lMT04pICAgICAgIDwgKGIubGVmdCArIGIud2lkdGgpICYmXG4gICAgICAoYS5sZWZ0ICsgYS53aWR0aCArIG1hcmdpbi5ob3Jpem9udGFsIC0gRVBTSUxPTikgPiBiLmxlZnQgJiZcbiAgICAgIChhLnRvcCAtIG1hcmdpbi52ZXJ0aWNhbCArIEVQU0lMT04pICAgICAgICAgICAgICA8IChiLnRvcCArIGIuaGVpZ2h0KSAmJlxuICAgICAgKGEudG9wICsgYS5oZWlnaHQgKyBtYXJnaW4udmVydGljYWwgLSBFUFNJTE9OKSAgID4gYi50b3ApO1xufTtcbiJdfQ==
},{}],30:[function(require,module,exports){
'use strict';

var moment = require('../module/moment');
var DateUtil = require('./DateUtil');
var util = require('../util');

/**
 * @constructor  TimeStep
 * The class TimeStep is an iterator for dates. You provide a start date and an
 * end date. The class itself determines the best scale (step size) based on the
 * provided start Date, end Date, and minimumStep.
 *
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 *
 * Alternatively, you can set a scale by hand.
 * After creation, you can initialize the class by executing first(). Then you
 * can iterate from the start date to the end date via next(). You can check if
 * the end date is reached with the function hasNext(). After each step, you can
 * retrieve the current date via getCurrent().
 * The TimeStep has scales ranging from milliseconds, seconds, minutes, hours,
 * days, to years.
 *
 * Version: 1.2
 *
 * @param {Date} [start]         The start date, for example new Date(2010, 9, 21)
 *                               or new Date(2010, 9, 21, 23, 45, 00)
 * @param {Date} [end]           The end date
 * @param {Number} [minimumStep] Optional. Minimum step size in milliseconds
 */
function TimeStep(start, end, minimumStep, hiddenDates) {
  this.moment = moment;

  // variables
  this.current = this.moment();
  this._start = this.moment();
  this._end = this.moment();

  this.autoScale = true;
  this.scale = 'day';
  this.step = 1;

  // initialize the range
  this.setRange(start, end, minimumStep);

  // hidden Dates options
  this.switchedDay = false;
  this.switchedMonth = false;
  this.switchedYear = false;
  if (Array.isArray(hiddenDates)) {
    this.hiddenDates = hiddenDates;
  } else if (hiddenDates != undefined) {
    this.hiddenDates = [hiddenDates];
  } else {
    this.hiddenDates = [];
  }

  this.format = TimeStep.FORMAT; // default formatting
}

// Time formatting
TimeStep.FORMAT = {
  minorLabels: {
    millisecond: 'SSS',
    second: 's',
    minute: 'HH:mm',
    hour: 'HH:mm',
    weekday: 'ddd D',
    day: 'D',
    month: 'MMM',
    year: 'YYYY'
  },
  majorLabels: {
    millisecond: 'HH:mm:ss',
    second: 'D MMMM HH:mm',
    minute: 'ddd D MMMM',
    hour: 'ddd D MMMM',
    weekday: 'MMMM YYYY',
    day: 'MMMM YYYY',
    month: 'YYYY',
    year: ''
  }
};

/**
 * Set custom constructor function for moment. Can be used to set dates
 * to UTC or to set a utcOffset.
 * @param {function} moment
 */
TimeStep.prototype.setMoment = function (moment) {
  this.moment = moment;

  // update the date properties, can have a new utcOffset
  this.current = this.moment(this.current);
  this._start = this.moment(this._start);
  this._end = this.moment(this._end);
};

/**
 * Set custom formatting for the minor an major labels of the TimeStep.
 * Both `minorLabels` and `majorLabels` are an Object with properties:
 * 'millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
 * @param {{minorLabels: Object, majorLabels: Object}} format
 */
TimeStep.prototype.setFormat = function (format) {
  var defaultFormat = util.deepExtend({}, TimeStep.FORMAT);
  this.format = util.deepExtend(defaultFormat, format);
};

/**
 * Set a new range
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 * @param {Date} [start]      The start date and time.
 * @param {Date} [end]        The end date and time.
 * @param {int} [minimumStep] Optional. Minimum step size in milliseconds
 */
TimeStep.prototype.setRange = function (start, end, minimumStep) {
  if (!(start instanceof Date) || !(end instanceof Date)) {
    throw "No legal start or end date in method setRange";
  }

  this._start = start != undefined ? this.moment(start.valueOf()) : new Date();
  this._end = end != undefined ? this.moment(end.valueOf()) : new Date();

  if (this.autoScale) {
    this.setMinimumStep(minimumStep);
  }
};

/**
 * Set the range iterator to the start date.
 */
TimeStep.prototype.start = function () {
  this.current = this._start.clone();
  this.roundToMinor();
};

/**
 * Round the current date to the first minor date value
 * This must be executed once when the current date is set to start Date
 */
TimeStep.prototype.roundToMinor = function () {
  // round to floor
  // IMPORTANT: we have no breaks in this switch! (this is no bug)
  // noinspection FallThroughInSwitchStatementJS
  switch (this.scale) {
    case 'year':
      this.current.year(this.step * Math.floor(this.current.year() / this.step));
      this.current.month(0);
    case 'month':
      this.current.date(1);
    case 'day': // intentional fall through
    case 'weekday':
      this.current.hours(0);
    case 'hour':
      this.current.minutes(0);
    case 'minute':
      this.current.seconds(0);
    case 'second':
      this.current.milliseconds(0);
    //case 'millisecond': // nothing to do for milliseconds
  }

  if (this.step != 1) {
    // round down to the first minor value that is a multiple of the current step size
    switch (this.scale) {
      case 'millisecond':
        this.current.subtract(this.current.milliseconds() % this.step, 'milliseconds');break;
      case 'second':
        this.current.subtract(this.current.seconds() % this.step, 'seconds');break;
      case 'minute':
        this.current.subtract(this.current.minutes() % this.step, 'minutes');break;
      case 'hour':
        this.current.subtract(this.current.hours() % this.step, 'hours');break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.subtract((this.current.date() - 1) % this.step, 'day');break;
      case 'month':
        this.current.subtract(this.current.month() % this.step, 'month');break;
      case 'year':
        this.current.subtract(this.current.year() % this.step, 'year');break;
      default:
        break;
    }
  }
};

/**
 * Check if the there is a next step
 * @return {boolean}  true if the current date has not passed the end date
 */
TimeStep.prototype.hasNext = function () {
  return this.current.valueOf() <= this._end.valueOf();
};

/**
 * Do the next step
 */
TimeStep.prototype.next = function () {
  var prev = this.current.valueOf();

  // Two cases, needed to prevent issues with switching daylight savings
  // (end of March and end of October)
  if (this.current.month() < 6) {
    switch (this.scale) {
      case 'millisecond':
        this.current.add(this.step, 'millisecond');break;
      case 'second':
        this.current.add(this.step, 'second');break;
      case 'minute':
        this.current.add(this.step, 'minute');break;
      case 'hour':
        this.current.add(this.step, 'hour');
        // in case of skipping an hour for daylight savings, adjust the hour again (else you get: 0h 5h 9h ... instead of 0h 4h 8h ...)
        // TODO: is this still needed now we use the function of moment.js?
        this.current.subtract(this.current.hours() % this.step, 'hour');
        break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.add(this.step, 'day');break;
      case 'month':
        this.current.add(this.step, 'month');break;
      case 'year':
        this.current.add(this.step, 'year');break;
      default:
        break;
    }
  } else {
    switch (this.scale) {
      case 'millisecond':
        this.current.add(this.step, 'millisecond');break;
      case 'second':
        this.current.add(this.step, 'second');break;
      case 'minute':
        this.current.add(this.step, 'minute');break;
      case 'hour':
        this.current.add(this.step, 'hour');break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.add(this.step, 'day');break;
      case 'month':
        this.current.add(this.step, 'month');break;
      case 'year':
        this.current.add(this.step, 'year');break;
      default:
        break;
    }
  }

  if (this.step != 1) {
    // round down to the correct major value
    switch (this.scale) {
      case 'millisecond':
        if (this.current.milliseconds() < this.step) this.current.milliseconds(0);break;
      case 'second':
        if (this.current.seconds() < this.step) this.current.seconds(0);break;
      case 'minute':
        if (this.current.minutes() < this.step) this.current.minutes(0);break;
      case 'hour':
        if (this.current.hours() < this.step) this.current.hours(0);break;
      case 'weekday': // intentional fall through
      case 'day':
        if (this.current.date() < this.step + 1) this.current.date(1);break;
      case 'month':
        if (this.current.month() < this.step) this.current.month(0);break;
      case 'year':
        break; // nothing to do for year
      default:
        break;
    }
  }

  // safety mechanism: if current time is still unchanged, move to the end
  if (this.current.valueOf() == prev) {
    this.current = this._end.clone();
  }

  DateUtil.stepOverHiddenDates(this.moment, this, prev);
};

/**
 * Get the current datetime
 * @return {Moment}  current The current date
 */
TimeStep.prototype.getCurrent = function () {
  return this.current;
};

/**
 * Set a custom scale. Autoscaling will be disabled.
 * For example setScale('minute', 5) will result
 * in minor steps of 5 minutes, and major steps of an hour.
 *
 * @param {{scale: string, step: number}} params
 *                               An object containing two properties:
 *                               - A string 'scale'. Choose from 'millisecond', 'second',
 *                                 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
 *                               - A number 'step'. A step size, by default 1.
 *                                 Choose for example 1, 2, 5, or 10.
 */
TimeStep.prototype.setScale = function (params) {
  if (params && typeof params.scale == 'string') {
    this.scale = params.scale;
    this.step = params.step > 0 ? params.step : 1;
    this.autoScale = false;
  }
};

/**
 * Enable or disable autoscaling
 * @param {boolean} enable  If true, autoascaling is set true
 */
TimeStep.prototype.setAutoScale = function (enable) {
  this.autoScale = enable;
};

/**
 * Automatically determine the scale that bests fits the provided minimum step
 * @param {Number} [minimumStep]  The minimum step size in milliseconds
 */
TimeStep.prototype.setMinimumStep = function (minimumStep) {
  if (minimumStep == undefined) {
    return;
  }

  //var b = asc + ds;

  var stepYear = 1000 * 60 * 60 * 24 * 30 * 12;
  var stepMonth = 1000 * 60 * 60 * 24 * 30;
  var stepDay = 1000 * 60 * 60 * 24;
  var stepHour = 1000 * 60 * 60;
  var stepMinute = 1000 * 60;
  var stepSecond = 1000;
  var stepMillisecond = 1;

  // find the smallest step that is larger than the provided minimumStep
  if (stepYear * 1000 > minimumStep) {
    this.scale = 'year';this.step = 1000;
  }
  if (stepYear * 500 > minimumStep) {
    this.scale = 'year';this.step = 500;
  }
  if (stepYear * 100 > minimumStep) {
    this.scale = 'year';this.step = 100;
  }
  if (stepYear * 50 > minimumStep) {
    this.scale = 'year';this.step = 50;
  }
  if (stepYear * 10 > minimumStep) {
    this.scale = 'year';this.step = 10;
  }
  if (stepYear * 5 > minimumStep) {
    this.scale = 'year';this.step = 5;
  }
  if (stepYear > minimumStep) {
    this.scale = 'year';this.step = 1;
  }
  if (stepMonth * 3 > minimumStep) {
    this.scale = 'month';this.step = 3;
  }
  if (stepMonth > minimumStep) {
    this.scale = 'month';this.step = 1;
  }
  if (stepDay * 5 > minimumStep) {
    this.scale = 'day';this.step = 5;
  }
  if (stepDay * 2 > minimumStep) {
    this.scale = 'day';this.step = 2;
  }
  if (stepDay > minimumStep) {
    this.scale = 'day';this.step = 1;
  }
  if (stepDay / 2 > minimumStep) {
    this.scale = 'weekday';this.step = 1;
  }
  if (stepHour * 4 > minimumStep) {
    this.scale = 'hour';this.step = 4;
  }
  if (stepHour > minimumStep) {
    this.scale = 'hour';this.step = 1;
  }
  if (stepMinute * 15 > minimumStep) {
    this.scale = 'minute';this.step = 15;
  }
  if (stepMinute * 10 > minimumStep) {
    this.scale = 'minute';this.step = 10;
  }
  if (stepMinute * 5 > minimumStep) {
    this.scale = 'minute';this.step = 5;
  }
  if (stepMinute > minimumStep) {
    this.scale = 'minute';this.step = 1;
  }
  if (stepSecond * 15 > minimumStep) {
    this.scale = 'second';this.step = 15;
  }
  if (stepSecond * 10 > minimumStep) {
    this.scale = 'second';this.step = 10;
  }
  if (stepSecond * 5 > minimumStep) {
    this.scale = 'second';this.step = 5;
  }
  if (stepSecond > minimumStep) {
    this.scale = 'second';this.step = 1;
  }
  if (stepMillisecond * 200 > minimumStep) {
    this.scale = 'millisecond';this.step = 200;
  }
  if (stepMillisecond * 100 > minimumStep) {
    this.scale = 'millisecond';this.step = 100;
  }
  if (stepMillisecond * 50 > minimumStep) {
    this.scale = 'millisecond';this.step = 50;
  }
  if (stepMillisecond * 10 > minimumStep) {
    this.scale = 'millisecond';this.step = 10;
  }
  if (stepMillisecond * 5 > minimumStep) {
    this.scale = 'millisecond';this.step = 5;
  }
  if (stepMillisecond > minimumStep) {
    this.scale = 'millisecond';this.step = 1;
  }
};

/**
 * Snap a date to a rounded value.
 * The snap intervals are dependent on the current scale and step.
 * Static function
 * @param {Date} date    the date to be snapped.
 * @param {string} scale Current scale, can be 'millisecond', 'second',
 *                       'minute', 'hour', 'weekday, 'day', 'month', 'year'.
 * @param {number} step  Current step (1, 2, 4, 5, ...
 * @return {Date} snappedDate
 */
TimeStep.snap = function (date, scale, step) {
  var clone = moment(date);

  if (scale == 'year') {
    var year = clone.year() + Math.round(clone.month() / 12);
    clone.year(Math.round(year / step) * step);
    clone.month(0);
    clone.date(0);
    clone.hours(0);
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'month') {
    if (clone.date() > 15) {
      clone.date(1);
      clone.add(1, 'month');
      // important: first set Date to 1, after that change the month.
    } else {
        clone.date(1);
      }

    clone.hours(0);
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'day') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 5:
      case 2:
        clone.hours(Math.round(clone.hours() / 24) * 24);break;
      default:
        clone.hours(Math.round(clone.hours() / 12) * 12);break;
    }
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'weekday') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 5:
      case 2:
        clone.hours(Math.round(clone.hours() / 12) * 12);break;
      default:
        clone.hours(Math.round(clone.hours() / 6) * 6);break;
    }
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'hour') {
    switch (step) {
      case 4:
        clone.minutes(Math.round(clone.minutes() / 60) * 60);break;
      default:
        clone.minutes(Math.round(clone.minutes() / 30) * 30);break;
    }
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'minute') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 15:
      case 10:
        clone.minutes(Math.round(clone.minutes() / 5) * 5);
        clone.seconds(0);
        break;
      case 5:
        clone.seconds(Math.round(clone.seconds() / 60) * 60);break;
      default:
        clone.seconds(Math.round(clone.seconds() / 30) * 30);break;
    }
    clone.milliseconds(0);
  } else if (scale == 'second') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 15:
      case 10:
        clone.seconds(Math.round(clone.seconds() / 5) * 5);
        clone.milliseconds(0);
        break;
      case 5:
        clone.milliseconds(Math.round(clone.milliseconds() / 1000) * 1000);break;
      default:
        clone.milliseconds(Math.round(clone.milliseconds() / 500) * 500);break;
    }
  } else if (scale == 'millisecond') {
    var _step = step > 5 ? step / 2 : 1;
    clone.milliseconds(Math.round(clone.milliseconds() / _step) * _step);
  }

  return clone;
};

/**
 * Check if the current value is a major value (for example when the step
 * is DAY, a major value is each first day of the MONTH)
 * @return {boolean} true if current date is major, else false.
 */
TimeStep.prototype.isMajor = function () {
  if (this.switchedYear == true) {
    this.switchedYear = false;
    switch (this.scale) {
      case 'year':
      case 'month':
      case 'weekday':
      case 'day':
      case 'hour':
      case 'minute':
      case 'second':
      case 'millisecond':
        return true;
      default:
        return false;
    }
  } else if (this.switchedMonth == true) {
    this.switchedMonth = false;
    switch (this.scale) {
      case 'weekday':
      case 'day':
      case 'hour':
      case 'minute':
      case 'second':
      case 'millisecond':
        return true;
      default:
        return false;
    }
  } else if (this.switchedDay == true) {
    this.switchedDay = false;
    switch (this.scale) {
      case 'millisecond':
      case 'second':
      case 'minute':
      case 'hour':
        return true;
      default:
        return false;
    }
  }

  var date = this.moment(this.current);
  switch (this.scale) {
    case 'millisecond':
      return date.milliseconds() == 0;
    case 'second':
      return date.seconds() == 0;
    case 'minute':
      return date.hours() == 0 && date.minutes() == 0;
    case 'hour':
      return date.hours() == 0;
    case 'weekday': // intentional fall through
    case 'day':
      return date.date() == 1;
    case 'month':
      return date.month() == 0;
    case 'year':
      return false;
    default:
      return false;
  }
};

/**
 * Returns formatted text for the minor axislabel, depending on the current
 * date and the scale. For example when scale is MINUTE, the current time is
 * formatted as "hh:mm".
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
TimeStep.prototype.getLabelMinor = function (date) {
  if (date == undefined) {
    date = this.current;
  }

  var format = this.format.minorLabels[this.scale];
  return format && format.length > 0 ? this.moment(date).format(format) : '';
};

/**
 * Returns formatted text for the major axis label, depending on the current
 * date and the scale. For example when scale is MINUTE, the major scale is
 * hours, and the hour will be formatted as "hh".
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
TimeStep.prototype.getLabelMajor = function (date) {
  if (date == undefined) {
    date = this.current;
  }

  var format = this.format.majorLabels[this.scale];
  return format && format.length > 0 ? this.moment(date).format(format) : '';
};

TimeStep.prototype.getClassName = function () {
  var _moment = this.moment;
  var m = this.moment(this.current);
  var current = m.locale ? m.locale('en') : m.lang('en'); // old versions of moment have .lang() function
  var step = this.step;

  function even(value) {
    return value / step % 2 == 0 ? ' vis-even' : ' vis-odd';
  }

  function today(date) {
    if (date.isSame(new Date(), 'day')) {
      return ' vis-today';
    }
    if (date.isSame(_moment().add(1, 'day'), 'day')) {
      return ' vis-tomorrow';
    }
    if (date.isSame(_moment().add(-1, 'day'), 'day')) {
      return ' vis-yesterday';
    }
    return '';
  }

  function currentWeek(date) {
    return date.isSame(new Date(), 'week') ? ' vis-current-week' : '';
  }

  function currentMonth(date) {
    return date.isSame(new Date(), 'month') ? ' vis-current-month' : '';
  }

  function currentYear(date) {
    return date.isSame(new Date(), 'year') ? ' vis-current-year' : '';
  }

  switch (this.scale) {
    case 'millisecond':
      return even(current.milliseconds()).trim();

    case 'second':
      return even(current.seconds()).trim();

    case 'minute':
      return even(current.minutes()).trim();

    case 'hour':
      var hours = current.hours();
      if (this.step == 4) {
        hours = hours + '-h' + (hours + 4);
      }
      return 'vis-h' + hours + today(current) + even(current.hours());

    case 'weekday':
      return 'vis-' + current.format('dddd').toLowerCase() + today(current) + currentWeek(current) + even(current.date());

    case 'day':
      var day = current.date();
      var month = current.format('MMMM').toLowerCase();
      return 'vis-day' + day + ' vis-' + month + currentMonth(current) + even(day - 1);

    case 'month':
      return 'vis-' + current.format('MMMM').toLowerCase() + currentMonth(current) + even(current.month());

    case 'year':
      var year = current.year();
      return 'vis-year' + year + currentYear(current) + even(year);

    default:
      return '';
  }
};

module.exports = TimeStep;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL1RpbWVTdGVwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDekMsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3JDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCOUIsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFO0FBQ3RELE1BQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDOzs7QUFHckIsTUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDN0IsTUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDNUIsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7O0FBRTFCLE1BQUksQ0FBQyxTQUFTLEdBQUksSUFBSSxDQUFDO0FBQ3ZCLE1BQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ25CLE1BQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDOzs7QUFHZCxNQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsV0FBVyxDQUFDLENBQUM7OztBQUd2QyxNQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztBQUN6QixNQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztBQUMzQixNQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztBQUMxQixNQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUU7QUFDOUIsUUFBSSxDQUFDLFdB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QUFJLEdBQUcsR0FBRyxDQUFDO0dBQUM7QUFDdEYsTUFBSSxRQUFRLEdBQUMsRUFBRSxHQUFHLFdBQVcsRUFBVztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEFBQVEsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7R0FBQztBQUNyRixNQUFJLFFBQVEsR0FBQyxFQUFFLEdBQUcsV0FBVyxFQUFXO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQUFBUSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztHQUFDO0FBQ3JGLE1BQUksUUFBUSxHQUFDLENBQUMsR0FBRyxXQUFXLEVBQVk7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxBQUFRLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxRQUFRLEdBQUcsV0FBVyxFQUFjO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQUFBUSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksU0FBUyxHQUFDLENBQUMsR0FBRyxXQUFXLEVBQVc7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxBQUFPLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxTQUFTLEdBQUcsV0FBVyxFQUFhO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsQUFBTyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksT0FBTyxHQUFDLENBQUMsR0FBRyxXQUFXLEVBQWE7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxBQUFTLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxPQUFPLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBYTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEFBQVMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLE9BQU8sR0FBRyxXQUFXLEVBQWU7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxBQUFTLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxPQUFPLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBYTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDLEFBQUssSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFFBQVEsR0FBQyxDQUFDLEdBQUcsV0FBVyxFQUFZO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQUFBUSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksUUFBUSxHQUFHLFdBQVcsRUFBYztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEFBQVEsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFVBQVUsR0FBQyxFQUFFLEdBQUcsV0FBVyxFQUFTO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsQUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztHQUFDO0FBQ3JGLE1BQUksVUFBVSxHQUFDLEVBQUUsR0FBRyxXQUFXLEVBQVM7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxBQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQUM7QUFDckYsTUFBSSxVQUFVLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBVTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEFBQU0sSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFVBQVUsR0FBRyxXQUFXLEVBQVk7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxBQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxVQUFVLEdBQUMsRUFBRSxHQUFHLFdBQVcsRUFBUztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEFBQU0sSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7R0FBQztBQUNyRixNQUFJLFVBQVUsR0FBQyxFQUFFLEdBQUcsV0FBVyxFQUFTO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsQUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztHQUFDO0FBQ3JGLE1BQUksVUFBVSxHQUFDLENBQUMsR0FBRyxXQUFXLEVBQVU7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxBQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxVQUFVLEdBQUcsV0FBVyxFQUFZO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsQUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksZUFBZSxHQUFDLEdBQUcsR0FBRyxXQUFXLEVBQUc7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQyxBQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO0dBQUM7QUFDdEYsTUFBSSxlQUFlLEdBQUMsR0FBRyxHQUFHLFdBQVcsRUFBRztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsYUFBYSxDQUFDLEFBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7R0FBQztBQUN0RixNQUFJLGVBQWUsR0FBQyxFQUFFLEdBQUcsV0FBVyxFQUFJO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxhQUFhLENBQUMsQUFBQyxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztHQUFDO0FBQ3JGLE1BQUksZUFBZSxHQUFDLEVBQUUsR0FBRyxXQUFXLEVBQUk7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLGFB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LENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDakQsYUFBTyxTQUFTLEdBQUcsR0FBRyxHQUFHLE9BQU8sR0FBRyxLQUFLLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7O0FBQUEsQUFFbkYsU0FBSyxPQUFPO0FBQ1YsYUFBTyxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FDaEQsWUFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQzs7QUFBQSxBQUVwRCxTQUFLLE1BQU07QUFDVCxVQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDMUIsYUFBTyxVQUFVLEdBQUcsSUFBSSxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBQUEsQUFFOUQ7QUFDRSxhQUFPLEVBQUUsQ0FBQztBQUFBLEdBQ2I7Q0FDRixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL1RpbWVTdGVwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG1vbWVudCA9IHJlcXVpcmUoJy4uL21vZHVsZS9tb21lbnQnKTtcbnZhciBEYXRlVXRpbCA9IHJlcXVpcmUoJy4vRGF0ZVV0aWwnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciAgVGltZVN0ZXBcbiAqIFRoZSBjbGFzcyBUaW1lU3RlcCBpcyBhbiBpdGVyYXRvciBmb3IgZGF0ZXMuIFlvdSBwcm92aWRlIGEgc3RhcnQgZGF0ZSBhbmQgYW5cbiAqIGVuZCBkYXRlLiBUaGUgY2xhc3MgaXRzZWxmIGRldGVybWluZXMgdGhlIGJlc3Qgc2NhbGUgKHN0ZXAgc2l6ZSkgYmFzZWQgb24gdGhlXG4gKiBwcm92aWRlZCBzdGFydCBEYXRlLCBlbmQgRGF0ZSwgYW5kIG1pbmltdW1TdGVwLlxuICpcbiAqIElmIG1pbmltdW1TdGVwIGlzIHByb3ZpZGVkLCB0aGUgc3RlcCBzaXplIGlzIGNob3NlbiBhcyBjbG9zZSBhcyBwb3NzaWJsZVxuICogdG8gdGhlIG1pbmltdW1TdGVwIGJ1dCBsYXJnZXIgdGhhbiBtaW5pbXVtU3RlcC4gSWYgbWluaW11bVN0ZXAgaXMgbm90XG4gKiBwcm92aWRlZCwgdGhlIHNjYWxlIGlzIHNldCB0byAxIERBWS5cbiAqIFRoZSBtaW5pbXVtU3RlcCBzaG91bGQgY29ycmVzcG9uZCB3aXRoIHRoZSBvbnNjcmVlbiBzaXplIG9mIGFib3V0IDYgY2hhcmFjdGVyc1xuICpcbiAqIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gc2V0IGEgc2NhbGUgYnkgaGFuZC5cbiAqIEFmdGVyIGNyZWF0aW9uLCB5b3UgY2FuIGluaXRpYWxpemUgdGhlIGNsYXNzIGJ5IGV4ZWN1dGluZyBmaXJzdCgpLiBUaGVuIHlvdVxuICogY2FuIGl0ZXJhdGUgZnJvbSB0aGUgc3RhcnQgZGF0ZSB0byB0aGUgZW5kIGRhdGUgdmlhIG5leHQoKS4gWW91IGNhbiBjaGVjayBpZlxuICogdGhlIGVuZCBkYXRlIGlzIHJlYWNoZWQgd2l0aCB0aGUgZnVuY3Rpb24gaGFzTmV4dCgpLiBBZnRlciBlYWNoIHN0ZXAsIHlvdSBjYW5cbiAqIHJldHJpZXZlIHRoZSBjdXJyZW50IGRhdGUgdmlhIGdldEN1cnJlbnQoKS5cbiAqIFRoZSBUaW1lU3RlcCBoYXMgc2NhbGVzIHJhbmdpbmcgZnJvbSBtaWxsaXNlY29uZHMsIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLFxuICogZGF5cywgdG8geWVhcnMuXG4gKlxuICogVmVyc2lvbjogMS4yXG4gKlxuICogQHBhcmFtIHtEYXRlfSBbc3RhcnRdICAgICAgICAgVGhlIHN0YXJ0IGRhdGUsIGZvciBleGFtcGxlIG5ldyBEYXRlKDIwMTAsIDksIDIxKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgbmV3IERhdGUoMjAxMCwgOSwgMjEsIDIzLCA0NSwgMDApXG4gKiBAcGFyYW0ge0RhdGV9IFtlbmRdICAgICAgICAgICBUaGUgZW5kIGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluaW11bVN0ZXBdIE9wdGlvbmFsLiBNaW5pbXVtIHN0ZXAgc2l6ZSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZnVuY3Rpb24gVGltZVN0ZXAoc3RhcnQsIGVuZCwgbWluaW11bVN0ZXAsIGhpZGRlbkRhdGVzKSB7XG4gIHRoaXMubW9tZW50ID0gbW9tZW50O1xuXG4gIC8vIHZhcmlhYmxlc1xuICB0aGlzLmN1cnJlbnQgPSB0aGlzLm1vbWVudCgpO1xuICB0aGlzLl9zdGFydCA9IHRoaXMubW9tZW50KCk7XG4gIHRoaXMuX2VuZCA9IHRoaXMubW9tZW50KCk7XG5cbiAgdGhpcy5hdXRvU2NhbGUgID0gdHJ1ZTtcbiAgdGhpcy5zY2FsZSA9ICdkYXknO1xuICB0aGlzLnN0ZXAgPSAxO1xuXG4gIC8vIGluaXRpYWxpemUgdGhlIHJhbmdlXG4gIHRoaXMuc2V0UmFuZ2Uoc3RhcnQsIGVuZCwgbWluaW11bVN0ZXApO1xuXG4gIC8vIGhpZGRlbiBEYXRlcyBvcHRpb25zXG4gIHRoaXMuc3dpdGNoZWREYXkgPSBmYWxzZTtcbiAgdGhpcy5zd2l0Y2hlZE1vbnRoID0gZmFsc2U7XG4gIHRoaXMuc3dpdGNoZWRZZWFyID0gZmFsc2U7XG4gIGlmIChBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSkge1xuICAgIHRoaXMuaGlkZGVuRGF0ZXMgPSBoaWRkZW5EYXRlcztcbiAgfVxuICBlbHNlIGlmIChoaWRkZW5EYXRlcyAhPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmhpZGRlbkRhdGVzID0gW2hpZGRlbkRhdGVzXTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmhpZGRlbkRhdGVzID0gW107XG4gIH1cblxuICB0aGlzLmZvcm1hdCA9IFRpbWVTdGVwLkZPUk1BVDsgLy8gZGVmYXVsdCBmb3JtYXR0aW5nXG59XG5cbi8vIFRpbWUgZm9ybWF0dGluZ1xuVGltZVN0ZXAuRk9STUFUID0ge1xuICBtaW5vckxhYmVsczoge1xuICAgIG1pbGxpc2Vjb25kOidTU1MnLFxuICAgIHNlY29uZDogICAgICdzJyxcbiAgICBtaW51dGU6ICAgICAnSEg6bW0nLFxuICAgIGhvdXI6ICAgICAgICdISDptbScsXG4gICAgd2Vla2RheTogICAgJ2RkZCBEJyxcbiAgICBkYXk6ICAgICAgICAnRCcsXG4gICAgbW9udGg6ICAgICAgJ01NTScsXG4gICAgeWVhcjogICAgICAgJ1lZWVknXG4gIH0sXG4gIG1ham9yTGFiZWxzOiB7XG4gICAgbWlsbGlzZWNvbmQ6J0hIOm1tOnNzJyxcbiAgICBzZWNvbmQ6ICAgICAnRCBNTU1NIEhIOm1tJyxcbiAgICBtaW51dGU6ICAgICAnZGRkIEQgTU1NTScsXG4gICAgaG91cjogICAgICAgJ2RkZCBEIE1NTU0nLFxuICAgIHdlZWtkYXk6ICAgICdNTU1NIFlZWVknLFxuICAgIGRheTogICAgICAgICdNTU1NIFlZWVknLFxuICAgIG1vbnRoOiAgICAgICdZWVlZJyxcbiAgICB5ZWFyOiAgICAgICAnJ1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBjdXN0b20gY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIG1vbWVudC4gQ2FuIGJlIHVzZWQgdG8gc2V0IGRhdGVzXG4gKiB0byBVVEMgb3IgdG8gc2V0IGEgdXRjT2Zmc2V0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbW9tZW50XG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zZXRNb21lbnQgPSBmdW5jdGlvbiAobW9tZW50KSB7XG4gIHRoaXMubW9tZW50ID0gbW9tZW50O1xuXG4gIC8vIHVwZGF0ZSB0aGUgZGF0ZSBwcm9wZXJ0aWVzLCBjYW4gaGF2ZSBhIG5ldyB1dGNPZmZzZXRcbiAgdGhpcy5jdXJyZW50ID0gdGhpcy5tb21lbnQodGhpcy5jdXJyZW50KTtcbiAgdGhpcy5fc3RhcnQgPSB0aGlzLm1vbWVudCh0aGlzLl9zdGFydCk7XG4gIHRoaXMuX2VuZCA9IHRoaXMubW9tZW50KHRoaXMuX2VuZCk7XG59O1xuXG4vKipcbiAqIFNldCBjdXN0b20gZm9ybWF0dGluZyBmb3IgdGhlIG1pbm9yIGFuIG1ham9yIGxhYmVscyBvZiB0aGUgVGltZVN0ZXAuXG4gKiBCb3RoIGBtaW5vckxhYmVsc2AgYW5kIGBtYWpvckxhYmVsc2AgYXJlIGFuIE9iamVjdCB3aXRoIHByb3BlcnRpZXM6XG4gKiAnbWlsbGlzZWNvbmQnLCAnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ3dlZWtkYXknLCAnZGF5JywgJ21vbnRoJywgJ3llYXInLlxuICogQHBhcmFtIHt7bWlub3JMYWJlbHM6IE9iamVjdCwgbWFqb3JMYWJlbHM6IE9iamVjdH19IGZvcm1hdFxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc2V0Rm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICB2YXIgZGVmYXVsdEZvcm1hdCA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgVGltZVN0ZXAuRk9STUFUKTtcbiAgdGhpcy5mb3JtYXQgPSB1dGlsLmRlZXBFeHRlbmQoZGVmYXVsdEZvcm1hdCwgZm9ybWF0KTtcbn07XG5cbi8qKlxuICogU2V0IGEgbmV3IHJhbmdlXG4gKiBJZiBtaW5pbXVtU3RlcCBpcyBwcm92aWRlZCwgdGhlIHN0ZXAgc2l6ZSBpcyBjaG9zZW4gYXMgY2xvc2UgYXMgcG9zc2libGVcbiAqIHRvIHRoZSBtaW5pbXVtU3RlcCBidXQgbGFyZ2VyIHRoYW4gbWluaW11bVN0ZXAuIElmIG1pbmltdW1TdGVwIGlzIG5vdFxuICogcHJvdmlkZWQsIHRoZSBzY2FsZSBpcyBzZXQgdG8gMSBEQVkuXG4gKiBUaGUgbWluaW11bVN0ZXAgc2hvdWxkIGNvcnJlc3BvbmQgd2l0aCB0aGUgb25zY3JlZW4gc2l6ZSBvZiBhYm91dCA2IGNoYXJhY3RlcnNcbiAqIEBwYXJhbSB7RGF0ZX0gW3N0YXJ0XSAgICAgIFRoZSBzdGFydCBkYXRlIGFuZCB0aW1lLlxuICogQHBhcmFtIHtEYXRlfSBbZW5kXSAgICAgICAgVGhlIGVuZCBkYXRlIGFuZCB0aW1lLlxuICogQHBhcmFtIHtpbnR9IFttaW5pbXVtU3RlcF0gT3B0aW9uYWwuIE1pbmltdW0gc3RlcCBzaXplIGluIG1pbGxpc2Vjb25kc1xuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc2V0UmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBtaW5pbXVtU3RlcCkge1xuICBpZiAoIShzdGFydCBpbnN0YW5jZW9mIERhdGUpIHx8ICEoZW5kIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICB0aHJvdyAgXCJObyBsZWdhbCBzdGFydCBvciBlbmQgZGF0ZSBpbiBtZXRob2Qgc2V0UmFuZ2VcIjtcbiAgfVxuXG4gIHRoaXMuX3N0YXJ0ID0gKHN0YXJ0ICE9IHVuZGVmaW5lZCkgPyB0aGlzLm1vbWVudChzdGFydC52YWx1ZU9mKCkpIDogbmV3IERhdGUoKTtcbiAgdGhpcy5fZW5kID0gKGVuZCAhPSB1bmRlZmluZWQpID8gdGhpcy5tb21lbnQoZW5kLnZhbHVlT2YoKSkgOiBuZXcgRGF0ZSgpO1xuXG4gIGlmICh0aGlzLmF1dG9TY2FsZSkge1xuICAgIHRoaXMuc2V0TWluaW11bVN0ZXAobWluaW11bVN0ZXApO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgcmFuZ2UgaXRlcmF0b3IgdG8gdGhlIHN0YXJ0IGRhdGUuXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmN1cnJlbnQgPSB0aGlzLl9zdGFydC5jbG9uZSgpO1xuICB0aGlzLnJvdW5kVG9NaW5vcigpO1xufTtcblxuLyoqXG4gKiBSb3VuZCB0aGUgY3VycmVudCBkYXRlIHRvIHRoZSBmaXJzdCBtaW5vciBkYXRlIHZhbHVlXG4gKiBUaGlzIG11c3QgYmUgZXhlY3V0ZWQgb25jZSB3aGVuIHRoZSBjdXJyZW50IGRhdGUgaXMgc2V0IHRvIHN0YXJ0IERhdGVcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLnJvdW5kVG9NaW5vciA9IGZ1bmN0aW9uKCkge1xuICAvLyByb3VuZCB0byBmbG9vclxuICAvLyBJTVBPUlRBTlQ6IHdlIGhhdmUgbm8gYnJlYWtzIGluIHRoaXMgc3dpdGNoISAodGhpcyBpcyBubyBidWcpXG4gIC8vIG5vaW5zcGVjdGlvbiBGYWxsVGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgY2FzZSAneWVhcic6XG4gICAgICB0aGlzLmN1cnJlbnQueWVhcih0aGlzLnN0ZXAgKiBNYXRoLmZsb29yKHRoaXMuY3VycmVudC55ZWFyKCkgLyB0aGlzLnN0ZXApKTtcbiAgICAgIHRoaXMuY3VycmVudC5tb250aCgwKTtcbiAgICBjYXNlICdtb250aCc6ICAgICAgICB0aGlzLmN1cnJlbnQuZGF0ZSgxKTtcbiAgICBjYXNlICdkYXknOiAgICAgICAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICBjYXNlICd3ZWVrZGF5JzogICAgICB0aGlzLmN1cnJlbnQuaG91cnMoMCk7XG4gICAgY2FzZSAnaG91cic6ICAgICAgICAgdGhpcy5jdXJyZW50Lm1pbnV0ZXMoMCk7XG4gICAgY2FzZSAnbWludXRlJzogICAgICAgdGhpcy5jdXJyZW50LnNlY29uZHMoMCk7XG4gICAgY2FzZSAnc2Vjb25kJzogICAgICAgdGhpcy5jdXJyZW50Lm1pbGxpc2Vjb25kcygwKTtcbiAgICAvL2Nhc2UgJ21pbGxpc2Vjb25kJzogLy8gbm90aGluZyB0byBkbyBmb3IgbWlsbGlzZWNvbmRzXG4gIH1cblxuICBpZiAodGhpcy5zdGVwICE9IDEpIHtcbiAgICAvLyByb3VuZCBkb3duIHRvIHRoZSBmaXJzdCBtaW5vciB2YWx1ZSB0aGF0IGlzIGEgbXVsdGlwbGUgb2YgdGhlIGN1cnJlbnQgc3RlcCBzaXplXG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6ICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50Lm1pbGxpc2Vjb25kcygpICUgdGhpcy5zdGVwLCAnbWlsbGlzZWNvbmRzJyk7ICBicmVhaztcbiAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQuc2Vjb25kcygpICUgdGhpcy5zdGVwLCAnc2Vjb25kcycpOyBicmVhaztcbiAgICAgIGNhc2UgJ21pbnV0ZSc6ICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQubWludXRlcygpICUgdGhpcy5zdGVwLCAnbWludXRlcycpOyBicmVhaztcbiAgICAgIGNhc2UgJ2hvdXInOiAgICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQuaG91cnMoKSAlIHRoaXMuc3RlcCwgJ2hvdXJzJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnd2Vla2RheSc6ICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlICdkYXknOiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QoKHRoaXMuY3VycmVudC5kYXRlKCkgLSAxKSAlIHRoaXMuc3RlcCwgJ2RheScpOyBicmVhaztcbiAgICAgIGNhc2UgJ21vbnRoJzogICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQubW9udGgoKSAlIHRoaXMuc3RlcCwgJ21vbnRoJyk7ICBicmVhaztcbiAgICAgIGNhc2UgJ3llYXInOiAgICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQueWVhcigpICUgdGhpcy5zdGVwLCAneWVhcicpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdGhlcmUgaXMgYSBuZXh0IHN0ZXBcbiAqIEByZXR1cm4ge2Jvb2xlYW59ICB0cnVlIGlmIHRoZSBjdXJyZW50IGRhdGUgaGFzIG5vdCBwYXNzZWQgdGhlIGVuZCBkYXRlXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMuY3VycmVudC52YWx1ZU9mKCkgPD0gdGhpcy5fZW5kLnZhbHVlT2YoKSk7XG59O1xuXG4vKipcbiAqIERvIHRoZSBuZXh0IHN0ZXBcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQudmFsdWVPZigpO1xuXG4gIC8vIFR3byBjYXNlcywgbmVlZGVkIHRvIHByZXZlbnQgaXNzdWVzIHdpdGggc3dpdGNoaW5nIGRheWxpZ2h0IHNhdmluZ3NcbiAgLy8gKGVuZCBvZiBNYXJjaCBhbmQgZW5kIG9mIE9jdG9iZXIpXG4gIGlmICh0aGlzLmN1cnJlbnQubW9udGgoKSA8IDYpICAge1xuICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaWxsaXNlY29uZCcpOyBicmVhaztcbiAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnc2Vjb25kJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnbWludXRlJzogICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaW51dGUnKTsgYnJlYWs7XG4gICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdob3VyJyk7XG4gICAgICAgIC8vIGluIGNhc2Ugb2Ygc2tpcHBpbmcgYW4gaG91ciBmb3IgZGF5bGlnaHQgc2F2aW5ncywgYWRqdXN0IHRoZSBob3VyIGFnYWluIChlbHNlIHlvdSBnZXQ6IDBoIDVoIDloIC4uLiBpbnN0ZWFkIG9mIDBoIDRoIDhoIC4uLilcbiAgICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIHN0aWxsIG5lZWRlZCBub3cgd2UgdXNlIHRoZSBmdW5jdGlvbiBvZiBtb21lbnQuanM/XG4gICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQuaG91cnMoKSAlIHRoaXMuc3RlcCwgJ2hvdXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3ZWVrZGF5JzogICAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgJ2RheSc6ICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnZGF5Jyk7IGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGgnOiAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtb250aCcpOyBicmVhaztcbiAgICAgIGNhc2UgJ3llYXInOiAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAneWVhcicpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbWlsbGlzZWNvbmQnKTsgYnJlYWs7XG4gICAgICBjYXNlICdzZWNvbmQnOiAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ3NlY29uZCcpOyBicmVhaztcbiAgICAgIGNhc2UgJ21pbnV0ZSc6ICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbWludXRlJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnaG91cic6ICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdob3VyJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnd2Vla2RheSc6ICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlICdkYXknOiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ2RheScpOyBicmVhaztcbiAgICAgIGNhc2UgJ21vbnRoJzogICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbW9udGgnKTsgYnJlYWs7XG4gICAgICBjYXNlICd5ZWFyJzogICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ3llYXInKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAgICAgICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5zdGVwICE9IDEpIHtcbiAgICAvLyByb3VuZCBkb3duIHRvIHRoZSBjb3JyZWN0IG1ham9yIHZhbHVlXG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6ICBpZih0aGlzLmN1cnJlbnQubWlsbGlzZWNvbmRzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5taWxsaXNlY29uZHMoMCk7ICBicmVhaztcbiAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgIGlmKHRoaXMuY3VycmVudC5zZWNvbmRzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5zZWNvbmRzKDApOyAgYnJlYWs7XG4gICAgICBjYXNlICdtaW51dGUnOiAgICAgICBpZih0aGlzLmN1cnJlbnQubWludXRlcygpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQubWludXRlcygwKTsgIGJyZWFrO1xuICAgICAgY2FzZSAnaG91cic6ICAgICAgICAgaWYodGhpcy5jdXJyZW50LmhvdXJzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5ob3VycygwKTsgIGJyZWFrO1xuICAgICAgY2FzZSAnd2Vla2RheSc6ICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlICdkYXknOiAgICAgICAgICBpZih0aGlzLmN1cnJlbnQuZGF0ZSgpIDwgdGhpcy5zdGVwKzEpIHRoaXMuY3VycmVudC5kYXRlKDEpOyBicmVhaztcbiAgICAgIGNhc2UgJ21vbnRoJzogICAgICAgIGlmKHRoaXMuY3VycmVudC5tb250aCgpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQubW9udGgoMCk7ICBicmVhaztcbiAgICAgIGNhc2UgJ3llYXInOiAgICAgICAgIGJyZWFrOyAvLyBub3RoaW5nIHRvIGRvIGZvciB5ZWFyXG4gICAgICBkZWZhdWx0OiAgICAgICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBzYWZldHkgbWVjaGFuaXNtOiBpZiBjdXJyZW50IHRpbWUgaXMgc3RpbGwgdW5jaGFuZ2VkLCBtb3ZlIHRvIHRoZSBlbmRcbiAgaWYgKHRoaXMuY3VycmVudC52YWx1ZU9mKCkgPT0gcHJldikge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuX2VuZC5jbG9uZSgpO1xuICB9XG5cbiAgRGF0ZVV0aWwuc3RlcE92ZXJIaWRkZW5EYXRlcyh0aGlzLm1vbWVudCwgdGhpcywgcHJldik7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGRhdGV0aW1lXG4gKiBAcmV0dXJuIHtNb21lbnR9ICBjdXJyZW50IFRoZSBjdXJyZW50IGRhdGVcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLmdldEN1cnJlbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VycmVudDtcbn07XG5cbi8qKlxuICogU2V0IGEgY3VzdG9tIHNjYWxlLiBBdXRvc2NhbGluZyB3aWxsIGJlIGRpc2FibGVkLlxuICogRm9yIGV4YW1wbGUgc2V0U2NhbGUoJ21pbnV0ZScsIDUpIHdpbGwgcmVzdWx0XG4gKiBpbiBtaW5vciBzdGVwcyBvZiA1IG1pbnV0ZXMsIGFuZCBtYWpvciBzdGVwcyBvZiBhbiBob3VyLlxuICpcbiAqIEBwYXJhbSB7e3NjYWxlOiBzdHJpbmcsIHN0ZXA6IG51bWJlcn19IHBhcmFtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIHByb3BlcnRpZXM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgc3RyaW5nICdzY2FsZScuIENob29zZSBmcm9tICdtaWxsaXNlY29uZCcsICdzZWNvbmQnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWludXRlJywgJ2hvdXInLCAnd2Vla2RheScsICdkYXknLCAnbW9udGgnLCAneWVhcicuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgbnVtYmVyICdzdGVwJy4gQSBzdGVwIHNpemUsIGJ5IGRlZmF1bHQgMS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hvb3NlIGZvciBleGFtcGxlIDEsIDIsIDUsIG9yIDEwLlxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgaWYgKHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zLnNjYWxlID09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5zY2FsZSA9IHBhcmFtcy5zY2FsZTtcbiAgICB0aGlzLnN0ZXAgPSBwYXJhbXMuc3RlcCA+IDAgPyBwYXJhbXMuc3RlcCA6IDE7XG4gICAgdGhpcy5hdXRvU2NhbGUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvc2NhbGluZ1xuICogQHBhcmFtIHtib29sZWFufSBlbmFibGUgIElmIHRydWUsIGF1dG9hc2NhbGluZyBpcyBzZXQgdHJ1ZVxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc2V0QXV0b1NjYWxlID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICB0aGlzLmF1dG9TY2FsZSA9IGVuYWJsZTtcbn07XG5cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IGRldGVybWluZSB0aGUgc2NhbGUgdGhhdCBiZXN0cyBmaXRzIHRoZSBwcm92aWRlZCBtaW5pbXVtIHN0ZXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluaW11bVN0ZXBdICBUaGUgbWluaW11bSBzdGVwIHNpemUgaW4gbWlsbGlzZWNvbmRzXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zZXRNaW5pbXVtU3RlcCA9IGZ1bmN0aW9uKG1pbmltdW1TdGVwKSB7XG4gIGlmIChtaW5pbXVtU3RlcCA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvL3ZhciBiID0gYXNjICsgZHM7XG5cbiAgdmFyIHN0ZXBZZWFyICAgICAgID0gKDEwMDAgKiA2MCAqIDYwICogMjQgKiAzMCAqIDEyKTtcbiAgdmFyIHN0ZXBNb250aCAgICAgID0gKDEwMDAgKiA2MCAqIDYwICogMjQgKiAzMCk7XG4gIHZhciBzdGVwRGF5ICAgICAgICA9ICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbiAgdmFyIHN0ZXBIb3VyICAgICAgID0gKDEwMDAgKiA2MCAqIDYwKTtcbiAgdmFyIHN0ZXBNaW51dGUgICAgID0gKDEwMDAgKiA2MCk7XG4gIHZhciBzdGVwU2Vjb25kICAgICA9ICgxMDAwKTtcbiAgdmFyIHN0ZXBNaWxsaXNlY29uZD0gKDEpO1xuXG4gIC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0ZXAgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGUgcHJvdmlkZWQgbWluaW11bVN0ZXBcbiAgaWYgKHN0ZXBZZWFyKjEwMDAgPiBtaW5pbXVtU3RlcCkgICAgICAgIHt0aGlzLnNjYWxlID0gJ3llYXInOyAgICAgICAgdGhpcy5zdGVwID0gMTAwMDt9XG4gIGlmIChzdGVwWWVhcio1MDAgPiBtaW5pbXVtU3RlcCkgICAgICAgICB7dGhpcy5zY2FsZSA9ICd5ZWFyJzsgICAgICAgIHRoaXMuc3RlcCA9IDUwMDt9XG4gIGlmIChzdGVwWWVhcioxMDAgPiBtaW5pbXVtU3RlcCkgICAgICAgICB7dGhpcy5zY2FsZSA9ICd5ZWFyJzsgICAgICAgIHRoaXMuc3RlcCA9IDEwMDt9XG4gIGlmIChzdGVwWWVhcio1MCA+IG1pbmltdW1TdGVwKSAgICAgICAgICB7dGhpcy5zY2FsZSA9ICd5ZWFyJzsgICAgICAgIHRoaXMuc3RlcCA9IDUwO31cbiAgaWYgKHN0ZXBZZWFyKjEwID4gbWluaW11bVN0ZXApICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3llYXInOyAgICAgICAgdGhpcy5zdGVwID0gMTA7fVxuICBpZiAoc3RlcFllYXIqNSA+IG1pbmltdW1TdGVwKSAgICAgICAgICAge3RoaXMuc2NhbGUgPSAneWVhcic7ICAgICAgICB0aGlzLnN0ZXAgPSA1O31cbiAgaWYgKHN0ZXBZZWFyID4gbWluaW11bVN0ZXApICAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3llYXInOyAgICAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwTW9udGgqMyA+IG1pbmltdW1TdGVwKSAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdtb250aCc7ICAgICAgIHRoaXMuc3RlcCA9IDM7fVxuICBpZiAoc3RlcE1vbnRoID4gbWluaW11bVN0ZXApICAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnbW9udGgnOyAgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBEYXkqNSA+IG1pbmltdW1TdGVwKSAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ2RheSc7ICAgICAgICAgdGhpcy5zdGVwID0gNTt9XG4gIGlmIChzdGVwRGF5KjIgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdkYXknOyAgICAgICAgIHRoaXMuc3RlcCA9IDI7fVxuICBpZiAoc3RlcERheSA+IG1pbmltdW1TdGVwKSAgICAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnZGF5JzsgICAgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBEYXkvMiA+IG1pbmltdW1TdGVwKSAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3dlZWtkYXknOyAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwSG91cio0ID4gbWluaW11bVN0ZXApICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdob3VyJzsgICAgICAgIHRoaXMuc3RlcCA9IDQ7fVxuICBpZiAoc3RlcEhvdXIgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnaG91cic7ICAgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBNaW51dGUqMTUgPiBtaW5pbXVtU3RlcCkgICAgICAgIHt0aGlzLnNjYWxlID0gJ21pbnV0ZSc7ICAgICAgdGhpcy5zdGVwID0gMTU7fVxuICBpZiAoc3RlcE1pbnV0ZSoxMCA+IG1pbmltdW1TdGVwKSAgICAgICAge3RoaXMuc2NhbGUgPSAnbWludXRlJzsgICAgICB0aGlzLnN0ZXAgPSAxMDt9XG4gIGlmIChzdGVwTWludXRlKjUgPiBtaW5pbXVtU3RlcCkgICAgICAgICB7dGhpcy5zY2FsZSA9ICdtaW51dGUnOyAgICAgIHRoaXMuc3RlcCA9IDU7fVxuICBpZiAoc3RlcE1pbnV0ZSA+IG1pbmltdW1TdGVwKSAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnbWludXRlJzsgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBTZWNvbmQqMTUgPiBtaW5pbXVtU3RlcCkgICAgICAgIHt0aGlzLnNjYWxlID0gJ3NlY29uZCc7ICAgICAgdGhpcy5zdGVwID0gMTU7fVxuICBpZiAoc3RlcFNlY29uZCoxMCA+IG1pbmltdW1TdGVwKSAgICAgICAge3RoaXMuc2NhbGUgPSAnc2Vjb25kJzsgICAgICB0aGlzLnN0ZXAgPSAxMDt9XG4gIGlmIChzdGVwU2Vjb25kKjUgPiBtaW5pbXVtU3RlcCkgICAgICAgICB7dGhpcy5zY2FsZSA9ICdzZWNvbmQnOyAgICAgIHRoaXMuc3RlcCA9IDU7fVxuICBpZiAoc3RlcFNlY29uZCA+IG1pbmltdW1TdGVwKSAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnc2Vjb25kJzsgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCoyMDAgPiBtaW5pbXVtU3RlcCkgIHt0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzsgdGhpcy5zdGVwID0gMjAwO31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCoxMDAgPiBtaW5pbXVtU3RlcCkgIHt0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzsgdGhpcy5zdGVwID0gMTAwO31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCo1MCA+IG1pbmltdW1TdGVwKSAgIHt0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzsgdGhpcy5zdGVwID0gNTA7fVxuICBpZiAoc3RlcE1pbGxpc2Vjb25kKjEwID4gbWluaW11bVN0ZXApICAge3RoaXMuc2NhbGUgPSAnbWlsbGlzZWNvbmQnOyB0aGlzLnN0ZXAgPSAxMDt9XG4gIGlmIChzdGVwTWlsbGlzZWNvbmQqNSA+IG1pbmltdW1TdGVwKSAgICB7dGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7IHRoaXMuc3RlcCA9IDU7fVxuICBpZiAoc3RlcE1pbGxpc2Vjb25kID4gbWluaW11bVN0ZXApICAgICAge3RoaXMuc2NhbGUgPSAnbWlsbGlzZWNvbmQnOyB0aGlzLnN0ZXAgPSAxO31cbn07XG5cbi8qKlxuICogU25hcCBhIGRhdGUgdG8gYSByb3VuZGVkIHZhbHVlLlxuICogVGhlIHNuYXAgaW50ZXJ2YWxzIGFyZSBkZXBlbmRlbnQgb24gdGhlIGN1cnJlbnQgc2NhbGUgYW5kIHN0ZXAuXG4gKiBTdGF0aWMgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSAgICB0aGUgZGF0ZSB0byBiZSBzbmFwcGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHNjYWxlIEN1cnJlbnQgc2NhbGUsIGNhbiBiZSAnbWlsbGlzZWNvbmQnLCAnc2Vjb25kJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAnbWludXRlJywgJ2hvdXInLCAnd2Vla2RheSwgJ2RheScsICdtb250aCcsICd5ZWFyJy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwICBDdXJyZW50IHN0ZXAgKDEsIDIsIDQsIDUsIC4uLlxuICogQHJldHVybiB7RGF0ZX0gc25hcHBlZERhdGVcbiAqL1xuVGltZVN0ZXAuc25hcCA9IGZ1bmN0aW9uKGRhdGUsIHNjYWxlLCBzdGVwKSB7XG4gIHZhciBjbG9uZSA9IG1vbWVudChkYXRlKTtcblxuICBpZiAoc2NhbGUgPT0gJ3llYXInKSB7XG4gICAgdmFyIHllYXIgPSBjbG9uZS55ZWFyKCkgKyBNYXRoLnJvdW5kKGNsb25lLm1vbnRoKCkgLyAxMik7XG4gICAgY2xvbmUueWVhcihNYXRoLnJvdW5kKHllYXIgLyBzdGVwKSAqIHN0ZXApO1xuICAgIGNsb25lLm1vbnRoKDApO1xuICAgIGNsb25lLmRhdGUoMCk7XG4gICAgY2xvbmUuaG91cnMoMCk7XG4gICAgY2xvbmUubWludXRlcygwKTtcbiAgICBjbG9uZS5zZWNvbmRzKDApO1xuICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgfVxuICBlbHNlIGlmIChzY2FsZSA9PSAnbW9udGgnKSB7XG4gICAgaWYgKGNsb25lLmRhdGUoKSA+IDE1KSB7XG4gICAgICBjbG9uZS5kYXRlKDEpO1xuICAgICAgY2xvbmUuYWRkKDEsICdtb250aCcpO1xuICAgICAgLy8gaW1wb3J0YW50OiBmaXJzdCBzZXQgRGF0ZSB0byAxLCBhZnRlciB0aGF0IGNoYW5nZSB0aGUgbW9udGguXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2xvbmUuZGF0ZSgxKTtcbiAgICB9XG5cbiAgICBjbG9uZS5ob3VycygwKTtcbiAgICBjbG9uZS5taW51dGVzKDApO1xuICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICB9XG4gIGVsc2UgaWYgKHNjYWxlID09ICdkYXknKSB7XG4gICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGNsb25lLmhvdXJzKE1hdGgucm91bmQoY2xvbmUuaG91cnMoKSAvIDI0KSAqIDI0KTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjbG9uZS5ob3VycyhNYXRoLnJvdW5kKGNsb25lLmhvdXJzKCkgLyAxMikgKiAxMik7IGJyZWFrO1xuICAgIH1cbiAgICBjbG9uZS5taW51dGVzKDApO1xuICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICB9XG4gIGVsc2UgaWYgKHNjYWxlID09ICd3ZWVrZGF5Jykge1xuICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSA1OlxuICAgICAgY2FzZSAyOlxuICAgICAgICBjbG9uZS5ob3VycyhNYXRoLnJvdW5kKGNsb25lLmhvdXJzKCkgLyAxMikgKiAxMik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2xvbmUuaG91cnMoTWF0aC5yb3VuZChjbG9uZS5ob3VycygpIC8gNikgKiA2KTsgYnJlYWs7XG4gICAgfVxuICAgIGNsb25lLm1pbnV0ZXMoMCk7XG4gICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gIH1cbiAgZWxzZSBpZiAoc2NhbGUgPT0gJ2hvdXInKSB7XG4gICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGNsb25lLm1pbnV0ZXMoTWF0aC5yb3VuZChjbG9uZS5taW51dGVzKCkgLyA2MCkgKiA2MCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2xvbmUubWludXRlcyhNYXRoLnJvdW5kKGNsb25lLm1pbnV0ZXMoKSAvIDMwKSAqIDMwKTsgYnJlYWs7XG4gICAgfVxuICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICB9IGVsc2UgaWYgKHNjYWxlID09ICdtaW51dGUnKSB7XG4gICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICBjYXNlIDE1OlxuICAgICAgY2FzZSAxMDpcbiAgICAgICAgY2xvbmUubWludXRlcyhNYXRoLnJvdW5kKGNsb25lLm1pbnV0ZXMoKSAvIDUpICogNSk7XG4gICAgICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBjbG9uZS5zZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuc2Vjb25kcygpIC8gNjApICogNjApOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNsb25lLnNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5zZWNvbmRzKCkgLyAzMCkgKiAzMCk7IGJyZWFrO1xuICAgIH1cbiAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gIH1cbiAgZWxzZSBpZiAoc2NhbGUgPT0gJ3NlY29uZCcpIHtcbiAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgIGNhc2UgMTU6XG4gICAgICBjYXNlIDEwOlxuICAgICAgICBjbG9uZS5zZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuc2Vjb25kcygpIC8gNSkgKiA1KTtcbiAgICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKE1hdGgucm91bmQoY2xvbmUubWlsbGlzZWNvbmRzKCkgLyAxMDAwKSAqIDEwMDApOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNsb25lLm1pbGxpc2Vjb25kcyhNYXRoLnJvdW5kKGNsb25lLm1pbGxpc2Vjb25kcygpIC8gNTAwKSAqIDUwMCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChzY2FsZSA9PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgdmFyIF9zdGVwID0gc3RlcCA+IDUgPyBzdGVwIC8gMiA6IDE7XG4gICAgY2xvbmUubWlsbGlzZWNvbmRzKE1hdGgucm91bmQoY2xvbmUubWlsbGlzZWNvbmRzKCkgLyBfc3RlcCkgKiBfc3RlcCk7XG4gIH1cbiAgXG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYSBtYWpvciB2YWx1ZSAoZm9yIGV4YW1wbGUgd2hlbiB0aGUgc3RlcFxuICogaXMgREFZLCBhIG1ham9yIHZhbHVlIGlzIGVhY2ggZmlyc3QgZGF5IG9mIHRoZSBNT05USClcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgY3VycmVudCBkYXRlIGlzIG1ham9yLCBlbHNlIGZhbHNlLlxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuaXNNYWpvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zd2l0Y2hlZFllYXIgPT0gdHJ1ZSkge1xuICAgIHRoaXMuc3dpdGNoZWRZZWFyID0gZmFsc2U7XG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgY2FzZSAnZGF5JzpcbiAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmICh0aGlzLnN3aXRjaGVkTW9udGggPT0gdHJ1ZSkge1xuICAgIHRoaXMuc3dpdGNoZWRNb250aCA9IGZhbHNlO1xuICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgY2FzZSAnd2Vla2RheSc6XG4gICAgICBjYXNlICdkYXknOlxuICAgICAgY2FzZSAnaG91cic6XG4gICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHRoaXMuc3dpdGNoZWREYXkgPT0gdHJ1ZSkge1xuICAgIHRoaXMuc3dpdGNoZWREYXkgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkYXRlID0gdGhpcy5tb21lbnQodGhpcy5jdXJyZW50KTtcbiAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgcmV0dXJuIChkYXRlLm1pbGxpc2Vjb25kcygpID09IDApO1xuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICByZXR1cm4gKGRhdGUuc2Vjb25kcygpID09IDApO1xuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICByZXR1cm4gKGRhdGUuaG91cnMoKSA9PSAwKSAmJiAoZGF0ZS5taW51dGVzKCkgPT0gMCk7XG4gICAgY2FzZSAnaG91cic6XG4gICAgICByZXR1cm4gKGRhdGUuaG91cnMoKSA9PSAwKTtcbiAgICBjYXNlICd3ZWVrZGF5JzogLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgY2FzZSAnZGF5JzpcbiAgICAgIHJldHVybiAoZGF0ZS5kYXRlKCkgPT0gMSk7XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgcmV0dXJuIChkYXRlLm1vbnRoKCkgPT0gMCk7XG4gICAgY2FzZSAneWVhcic6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgZm9ybWF0dGVkIHRleHQgZm9yIHRoZSBtaW5vciBheGlzbGFiZWwsIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudFxuICogZGF0ZSBhbmQgdGhlIHNjYWxlLiBGb3IgZXhhbXBsZSB3aGVuIHNjYWxlIGlzIE1JTlVURSwgdGhlIGN1cnJlbnQgdGltZSBpc1xuICogZm9ybWF0dGVkIGFzIFwiaGg6bW1cIi5cbiAqIEBwYXJhbSB7RGF0ZX0gW2RhdGVdIGN1c3RvbSBkYXRlLiBpZiBub3QgcHJvdmlkZWQsIGN1cnJlbnQgZGF0ZSBpcyB0YWtlblxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuZ2V0TGFiZWxNaW5vciA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgaWYgKGRhdGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgZGF0ZSA9IHRoaXMuY3VycmVudDtcbiAgfVxuXG4gIHZhciBmb3JtYXQgPSB0aGlzLmZvcm1hdC5taW5vckxhYmVsc1t0aGlzLnNjYWxlXTtcbiAgcmV0dXJuIChmb3JtYXQgJiYgZm9ybWF0Lmxlbmd0aCA+IDApID8gdGhpcy5tb21lbnQoZGF0ZSkuZm9ybWF0KGZvcm1hdCkgOiAnJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBmb3JtYXR0ZWQgdGV4dCBmb3IgdGhlIG1ham9yIGF4aXMgbGFiZWwsIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudFxuICogZGF0ZSBhbmQgdGhlIHNjYWxlLiBGb3IgZXhhbXBsZSB3aGVuIHNjYWxlIGlzIE1JTlVURSwgdGhlIG1ham9yIHNjYWxlIGlzXG4gKiBob3VycywgYW5kIHRoZSBob3VyIHdpbGwgYmUgZm9ybWF0dGVkIGFzIFwiaGhcIi5cbiAqIEBwYXJhbSB7RGF0ZX0gW2RhdGVdIGN1c3RvbSBkYXRlLiBpZiBub3QgcHJvdmlkZWQsIGN1cnJlbnQgZGF0ZSBpcyB0YWtlblxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuZ2V0TGFiZWxNYWpvciA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgaWYgKGRhdGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgZGF0ZSA9IHRoaXMuY3VycmVudDtcbiAgfVxuXG4gIHZhciBmb3JtYXQgPSB0aGlzLmZvcm1hdC5tYWpvckxhYmVsc1t0aGlzLnNjYWxlXTtcbiAgcmV0dXJuIChmb3JtYXQgJiYgZm9ybWF0Lmxlbmd0aCA+IDApID8gdGhpcy5tb21lbnQoZGF0ZSkuZm9ybWF0KGZvcm1hdCkgOiAnJztcbn07XG5cblRpbWVTdGVwLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9tb21lbnQgPSB0aGlzLm1vbWVudDtcbiAgdmFyIG0gPSB0aGlzLm1vbWVudCh0aGlzLmN1cnJlbnQpO1xuICB2YXIgY3VycmVudCA9IG0ubG9jYWxlID8gbS5sb2NhbGUoJ2VuJykgOiBtLmxhbmcoJ2VuJyk7IC8vIG9sZCB2ZXJzaW9ucyBvZiBtb21lbnQgaGF2ZSAubGFuZygpIGZ1bmN0aW9uXG4gIHZhciBzdGVwID0gdGhpcy5zdGVwO1xuXG4gIGZ1bmN0aW9uIGV2ZW4odmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlIC8gc3RlcCAlIDIgPT0gMCkgPyAnIHZpcy1ldmVuJyA6ICcgdmlzLW9kZCc7XG4gIH1cblxuICBmdW5jdGlvbiB0b2RheShkYXRlKSB7XG4gICAgaWYgKGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICdkYXknKSkge1xuICAgICAgcmV0dXJuICcgdmlzLXRvZGF5JztcbiAgICB9XG4gICAgaWYgKGRhdGUuaXNTYW1lKF9tb21lbnQoKS5hZGQoMSwgJ2RheScpLCAnZGF5JykpIHtcbiAgICAgIHJldHVybiAnIHZpcy10b21vcnJvdyc7XG4gICAgfVxuICAgIGlmIChkYXRlLmlzU2FtZShfbW9tZW50KCkuYWRkKC0xLCAnZGF5JyksICdkYXknKSkge1xuICAgICAgcmV0dXJuICcgdmlzLXllc3RlcmRheSc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGN1cnJlbnRXZWVrKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5pc1NhbWUobmV3IERhdGUoKSwgJ3dlZWsnKSA/ICcgdmlzLWN1cnJlbnQtd2VlaycgOiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGN1cnJlbnRNb250aChkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICdtb250aCcpID8gJyB2aXMtY3VycmVudC1tb250aCcgOiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGN1cnJlbnRZZWFyKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5pc1NhbWUobmV3IERhdGUoKSwgJ3llYXInKSA/ICcgdmlzLWN1cnJlbnQteWVhcicgOiAnJztcbiAgfVxuXG4gIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgIHJldHVybiBldmVuKGN1cnJlbnQubWlsbGlzZWNvbmRzKCkpLnRyaW0oKTtcblxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICByZXR1cm4gZXZlbihjdXJyZW50LnNlY29uZHMoKSkudHJpbSgpO1xuXG4gICAgY2FzZSAnbWludXRlJzpcbiAgICAgIHJldHVybiBldmVuKGN1cnJlbnQubWludXRlcygpKS50cmltKCk7XG5cbiAgICBjYXNlICdob3VyJzpcbiAgICAgIHZhciBob3VycyA9IGN1cnJlbnQuaG91cnMoKTtcbiAgICAgIGlmICh0aGlzLnN0ZXAgPT0gNCkge1xuICAgICAgICBob3VycyA9IGhvdXJzICsgJy1oJyArIChob3VycyArIDQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICd2aXMtaCcgKyBob3VycyArIHRvZGF5KGN1cnJlbnQpICsgZXZlbihjdXJyZW50LmhvdXJzKCkpO1xuXG4gICAgY2FzZSAnd2Vla2RheSc6XG4gICAgICByZXR1cm4gJ3Zpcy0nICsgY3VycmVudC5mb3JtYXQoJ2RkZGQnKS50b0xvd2VyQ2FzZSgpICtcbiAgICAgICAgICB0b2RheShjdXJyZW50KSArIGN1cnJlbnRXZWVrKGN1cnJlbnQpICsgZXZlbihjdXJyZW50LmRhdGUoKSk7XG5cbiAgICBjYXNlICdkYXknOlxuICAgICAgdmFyIGRheSA9IGN1cnJlbnQuZGF0ZSgpO1xuICAgICAgdmFyIG1vbnRoID0gY3VycmVudC5mb3JtYXQoJ01NTU0nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuICd2aXMtZGF5JyArIGRheSArICcgdmlzLScgKyBtb250aCArIGN1cnJlbnRNb250aChjdXJyZW50KSArIGV2ZW4oZGF5IC0gMSk7XG5cbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gJ3Zpcy0nICsgY3VycmVudC5mb3JtYXQoJ01NTU0nKS50b0xvd2VyQ2FzZSgpICtcbiAgICAgICAgICBjdXJyZW50TW9udGgoY3VycmVudCkgKyBldmVuKGN1cnJlbnQubW9udGgoKSk7XG5cbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIHZhciB5ZWFyID0gY3VycmVudC55ZWFyKCk7XG4gICAgICByZXR1cm4gJ3Zpcy15ZWFyJyArIHllYXIgKyBjdXJyZW50WWVhcihjdXJyZW50KSsgZXZlbih5ZWFyKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZVN0ZXA7XG4iXX0=
},{"../module/moment":20,"../util":46,"./DateUtil":27}],31:[function(require,module,exports){
'use strict';

var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var moment = require('../module/moment');
var util = require('../util');
var DataSet = require('../DataSet');
var DataView = require('../DataView');
var Range = require('./Range');
var Core = require('./Core');
var TimeAxis = require('./component/TimeAxis');
var CurrentTime = require('./component/CurrentTime');
var CustomTime = require('./component/CustomTime');
var ItemSet = require('./component/ItemSet');

var Configurator = require('../shared/Configurator');
var Validator = require('../shared/Validator')['default'];
var printStyle = require('../shared/Validator').printStyle;
var allOptions = require('./optionsTimeline').allOptions;
var configureOptions = require('./optionsTimeline').configureOptions;

/**
 * Create a timeline visualization
 * @param {HTMLElement} container
 * @param {vis.DataSet | vis.DataView | Array} [items]
 * @param {vis.DataSet | vis.DataView | Array} [groups]
 * @param {Object} [options]  See Timeline.setOptions for the available options.
 * @constructor
 * @extends Core
 */
function Timeline(container, items, groups, options) {
  if (!(this instanceof Timeline)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // if the third element is options, the forth is groups (optionally);
  if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
    var forthArgument = options;
    options = groups;
    groups = forthArgument;
  }

  var me = this;
  this.defaultOptions = {
    start: null,
    end: null,

    autoResize: true,
    throttleRedraw: 0, // ms

    orientation: {
      axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'
      item: 'bottom' // not relevant
    },

    moment: moment,

    width: null,
    height: null,
    maxHeight: null,
    minHeight: null
  };
  this.options = util.deepExtend({}, this.defaultOptions);

  // Create the DOM, props, and emitter
  this._create(container);

  // all components listed here will be repainted automatically
  this.components = [];

  this.body = {
    dom: this.dom,
    domProps: this.props,
    emitter: {
      on: this.on.bind(this),
      off: this.off.bind(this),
      emit: this.emit.bind(this)
    },
    hiddenDates: [],
    util: {
      getScale: function getScale() {
        return me.timeAxis.step.scale;
      },
      getStep: function getStep() {
        return me.timeAxis.step.step;
      },

      toScreen: me._toScreen.bind(me),
      toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to the root.width
      toTime: me._toTime.bind(me),
      toGlobalTime: me._toGlobalTime.bind(me)
    }
  };

  // range
  this.range = new Range(this.body);
  this.components.push(this.range);
  this.body.range = this.range;

  // time axis
  this.timeAxis = new TimeAxis(this.body);
  this.timeAxis2 = null; // used in case of orientation option 'both'
  this.components.push(this.timeAxis);

  // current time bar
  this.currentTime = new CurrentTime(this.body);
  this.components.push(this.currentTime);

  // item set
  this.itemSet = new ItemSet(this.body);
  this.components.push(this.itemSet);

  this.itemsData = null; // DataSet
  this.groupsData = null; // DataSet

  this.on('tap', function (event) {
    me.emit('click', me.getEventProperties(event));
  });
  this.on('doubletap', function (event) {
    me.emit('doubleClick', me.getEventProperties(event));
  });
  this.dom.root.oncontextmenu = function (event) {
    me.emit('contextmenu', me.getEventProperties(event));
  };

  // apply options
  if (options) {
    this.setOptions(options);
  }

  // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!
  if (groups) {
    this.setGroups(groups);
  }

  // create itemset
  if (items) {
    this.setItems(items);
  } else {
    this._redraw();
  }
}

// Extend the functionality from Core
Timeline.prototype = new Core();

/**
 * Load a configurator
 * @return {Object}
 * @private
 */
Timeline.prototype._createConfigurator = function () {
  return new Configurator(this, this.dom.container, configureOptions);
};

/**
 * Force a redraw. The size of all items will be recalculated.
 * Can be useful to manually redraw when option autoResize=false and the window
 * has been resized, or when the items CSS has been changed.
 *
 * Note: this function will be overridden on construction with a trottled version
 */
Timeline.prototype.redraw = function () {
  this.itemSet && this.itemSet.markDirty({ refreshItems: true });
  this._redraw();
};

Timeline.prototype.setOptions = function (options) {
  // validate options
  var errorFound = Validator.validate(options, allOptions);
  if (errorFound === true) {
    console.log('%cErrors have been found in the supplied options object.', printStyle);
  }

  Core.prototype.setOptions.call(this, options);

  if ('type' in options) {
    if (options.type !== this.options.type) {
      this.options.type = options.type;

      // force recreation of all items
      var itemsData = this.itemsData;
      if (itemsData) {
        var selection = this.getSelection();
        this.setItems(null); // remove all
        this.setItems(itemsData); // add all
        this.setSelection(selection); // restore selection
      }
    }
  }
};

/**
 * Set items
 * @param {vis.DataSet | Array | null} items
 */
Timeline.prototype.setItems = function (items) {
  var initialLoad = this.itemsData == null;

  // convert to type DataSet when needed
  var newDataSet;
  if (!items) {
    newDataSet = null;
  } else if (items instanceof DataSet || items instanceof DataView) {
    newDataSet = items;
  } else {
    // turn an array into a dataset
    newDataSet = new DataSet(items, {
      type: {
        start: 'Date',
        end: 'Date'
      }
    });
  }

  // set items
  this.itemsData = newDataSet;
  this.itemSet && this.itemSet.setItems(newDataSet);

  if (initialLoad) {
    if (this.options.start != undefined || this.options.end != undefined) {
      if (this.options.start == undefined || this.options.end == undefined) {
        var range = this.getItemRange();
      }

      var start = this.options.start != undefined ? this.options.start : range.min;
      var end = this.options.end != undefined ? this.options.end : range.max;

      this.setWindow(start, end, { animation: false });
    } else {
      this.fit({ animation: false });
    }
  }
};

/**
 * Set groups
 * @param {vis.DataSet | Array} groups
 */
Timeline.prototype.setGroups = function (groups) {
  // convert to type DataSet when needed
  var newDataSet;
  if (!groups) {
    newDataSet = null;
  } else if (groups instanceof DataSet || groups instanceof DataView) {
    newDataSet = groups;
  } else {
    // turn an array into a dataset
    newDataSet = new DataSet(groups);
  }

  this.groupsData = newDataSet;
  this.itemSet.setGroups(newDataSet);
};

/**
 * Set both items and groups in one go
 * @param {{items: Array | vis.DataSet, groups: Array | vis.DataSet}} data
 */
Timeline.prototype.setData = function (data) {
  if (data && data.groups) {
    this.setGroups(data.groups);
  }

  if (data && data.items) {
    this.setItems(data.items);
  }
};

/**
 * Set selected items by their id. Replaces the current selection
 * Unknown id's are silently ignored.
 * @param {string[] | string} [ids]  An array with zero or more id's of the items to be
 *                                selected. If ids is an empty array, all items will be
 *                                unselected.
 * @param {Object} [options]      Available options:
 *                                `focus: boolean`
 *                                    If true, focus will be set to the selected item(s)
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 *                                    Only applicable when option focus is true.
 */
Timeline.prototype.setSelection = function (ids, options) {
  this.itemSet && this.itemSet.setSelection(ids);

  if (options && options.focus) {
    this.focus(ids, options);
  }
};

/**
 * Get the selected items by their id
 * @return {Array} ids  The ids of the selected items
 */
Timeline.prototype.getSelection = function () {
  return this.itemSet && this.itemSet.getSelection() || [];
};

/**
 * Adjust the visible window such that the selected item (or multiple items)
 * are centered on screen.
 * @param {String | String[]} id     An item id or array with item ids
 * @param {Object} [options]      Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Timeline.prototype.focus = function (id, options) {
  if (!this.itemsData || id == undefined) return;

  var ids = Array.isArray(id) ? id : [id];

  // get the specified item(s)
  var itemsData = this.itemsData.getDataSet().get(ids, {
    type: {
      start: 'Date',
      end: 'Date'
    }
  });

  // calculate minimum start and maximum end of specified items
  var start = null;
  var end = null;
  itemsData.forEach(function (itemData) {
    var s = itemData.start.valueOf();
    var e = 'end' in itemData ? itemData.end.valueOf() : itemData.start.valueOf();

    if (start === null || s < start) {
      start = s;
    }

    if (end === null || e > end) {
      end = e;
    }
  });

  if (start !== null && end !== null) {
    // calculate the new middle and interval for the window
    var middle = (start + end) / 2;
    var interval = Math.max(this.range.end - this.range.start, (end - start) * 1.1);

    var animation = options && options.animation !== undefined ? options.animation : true;
    this.range.setRange(middle - interval / 2, middle + interval / 2, animation);
  }
};

/**
 * Set Timeline window such that it fits all items
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Timeline.prototype.fit = function (options) {
  var animation = options && options.animation !== undefined ? options.animation : true;
  var range = this.getItemRange();
  this.range.setRange(range.min, range.max, animation);
};

/**
 * Determine the range of the items, taking into account their actual width
 * and a margin of 10 pixels on both sides.
 * @return {{min: Date | null, max: Date | null}}
 */
Timeline.prototype.getItemRange = function () {
  var _this = this;

  // get a rough approximation for the range based on the items start and end dates
  var range = this.getDataRange();
  var min = range.min;
  var max = range.max;
  var minItem = null;
  var maxItem = null;

  if (min != null && max != null) {
    var interval;
    var factor;
    var lhs;
    var rhs;
    var delta;

    (function () {
      var getStart = function getStart(item) {
        return util.convert(item.data.start, 'Date').valueOf();
      };

      var getEnd = function getEnd(item) {
        var end = item.data.end != undefined ? item.data.end : item.data.start;
        return util.convert(end, 'Date').valueOf();
      }

      // calculate the date of the left side and right side of the items given
      ;

      interval = max - min;
      // ms
      if (interval <= 0) {
        interval = 10;
      }
      factor = interval / _this.props.center.width;
      util.forEach(_this.itemSet.items, (function (item) {
        item.show();

        var start = getStart(item);
        var end = getEnd(item);

        var left = new Date(start - (item.getWidthLeft() + 10) * factor);
        var right = new Date(end + (item.getWidthRight() + 10) * factor);

        if (left < min) {
          min = left;
          minItem = item;
        }
        if (right > max) {
          max = right;
          maxItem = item;
        }
      }).bind(_this));

      if (minItem && maxItem) {
        lhs = minItem.getWidthLeft() + 10;
        rhs = maxItem.getWidthRight() + 10;
        delta = _this.props.center.width - lhs - rhs;
        // px

        if (delta > 0) {
          min = getStart(minItem) - lhs * interval / delta; // ms
          max = getEnd(maxItem) + rhs * interval / delta; // ms
        }
      }
    })();
  }

  return {
    min: min != null ? new Date(min) : null,
    max: max != null ? new Date(max) : null
  };
};

/**
 * Calculate the data range of the items start and end dates
 * @returns {{min: Date | null, max: Date | null}}
 */
Timeline.prototype.getDataRange = function () {
  var min = null;
  var max = null;

  var dataset = this.itemsData && this.itemsData.getDataSet();
  if (dataset) {
    dataset.forEach(function (item) {
      var start = util.convert(item.start, 'Date').valueOf();
      var end = util.convert(item.end != undefined ? item.end : item.start, 'Date').valueOf();
      if (min === null || start < min) {
        min = start;
      }
      if (max === null || end > max) {
        max = start;
      }
    });
  }

  return {
    min: min != null ? new Date(min) : null,
    max: max != null ? new Date(max) : null
  };
};

/**
 * Generate Timeline related information from an event
 * @param {Event} event
 * @return {Object} An object with related information, like on which area
 *                  The event happened, whether clicked on an item, etc.
 */
Timeline.prototype.getEventProperties = function (event) {
  var clientX = event.center ? event.center.x : event.clientX;
  var clientY = event.center ? event.center.y : event.clientY;
  var x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
  var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);

  var item = this.itemSet.itemFromTarget(event);
  var group = this.itemSet.groupFromTarget(event);
  var customTime = CustomTime.customTimeFromTarget(event);

  var snap = this.itemSet.options.snap || null;
  var scale = this.body.util.getScale();
  var step = this.body.util.getStep();
  var time = this._toTime(x);
  var snappedTime = snap ? snap(time, scale, step) : time;

  var element = util.getTarget(event);
  var what = null;
  if (item != null) {
    what = 'item';
  } else if (customTime != null) {
    what = 'custom-time';
  } else if (util.hasParent(element, this.timeAxis.dom.foreground)) {
    what = 'axis';
  } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
    what = 'axis';
  } else if (util.hasParent(element, this.itemSet.dom.labelSet)) {
    what = 'group-label';
  } else if (util.hasParent(element, this.currentTime.bar)) {
    what = 'current-time';
  } else if (util.hasParent(element, this.dom.center)) {
    what = 'background';
  }

  return {
    event: event,
    item: item ? item.id : null,
    group: group ? group.groupId : null,
    what: what,
    pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
    pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
    x: x,
    y: y,
    time: time,
    snappedTime: snappedTime
  };
};

module.exports = Timeline;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL1RpbWVsaW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDM0MsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDekMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDekMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzlCLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNwQyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdEMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQy9CLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM3QixJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUMvQyxJQUFJLFdBQVcsR0FBRyxPQUFPLENBQUMseUJBQXlCLENBQUMsQ0FBQztBQUNyRCxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQUNuRCxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQzs7QUFFN0MsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUM7QUFDckQsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLFdBQVEsQ0FBQztBQUN2RCxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQyxVQUFVLENBQUM7QUFDM0QsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixD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LENBQUMsT0FBTyxHQUFHLElBQUk7QUFDbkMsUUFBSSxFQUFFLElBQUk7QUFDVixTQUFLLEVBQUUsS0FBSyxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSztBQUMxRCxTQUFLLEVBQUUsS0FBSyxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSztBQUMxRCxLQUFDLEVBQUUsQ0FBQztBQUNKLEtBQUMsRUFBRSxDQUFDO0FBQ0osUUFBSSxFQUFFLElBQUk7QUFDVixlQUFXLEVBQUUsV0FBVztHQUN6QixDQUFBO0NBQ0YsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9UaW1lbGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlci1jb21wb25lbnQnKTtcbnZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnLi4vbW9kdWxlL21vbWVudCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgRGF0YVNldCA9IHJlcXVpcmUoJy4uL0RhdGFTZXQnKTtcbnZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4uL0RhdGFWaWV3Jyk7XG52YXIgUmFuZ2UgPSByZXF1aXJlKCcuL1JhbmdlJyk7XG52YXIgQ29yZSA9IHJlcXVpcmUoJy4vQ29yZScpO1xudmFyIFRpbWVBeGlzID0gcmVxdWlyZSgnLi9jb21wb25lbnQvVGltZUF4aXMnKTtcbnZhciBDdXJyZW50VGltZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50L0N1cnJlbnRUaW1lJyk7XG52YXIgQ3VzdG9tVGltZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50L0N1c3RvbVRpbWUnKTtcbnZhciBJdGVtU2V0ID0gcmVxdWlyZSgnLi9jb21wb25lbnQvSXRlbVNldCcpO1xuXG52YXIgQ29uZmlndXJhdG9yID0gcmVxdWlyZSgnLi4vc2hhcmVkL0NvbmZpZ3VyYXRvcicpO1xudmFyIFZhbGlkYXRvciA9IHJlcXVpcmUoJy4uL3NoYXJlZC9WYWxpZGF0b3InKS5kZWZhdWx0O1xudmFyIHByaW50U3R5bGUgPSByZXF1aXJlKCcuLi9zaGFyZWQvVmFsaWRhdG9yJykucHJpbnRTdHlsZTtcbnZhciBhbGxPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zVGltZWxpbmUnKS5hbGxPcHRpb25zO1xudmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnNUaW1lbGluZScpLmNvbmZpZ3VyZU9wdGlvbnM7XG5cbi8qKlxuICogQ3JlYXRlIGEgdGltZWxpbmUgdmlzdWFsaXphdGlvblxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgdmlzLkRhdGFWaWV3IHwgQXJyYXl9IFtpdGVtc11cbiAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCB2aXMuRGF0YVZpZXcgfCBBcnJheX0gW2dyb3Vwc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIFNlZSBUaW1lbGluZS5zZXRPcHRpb25zIGZvciB0aGUgYXZhaWxhYmxlIG9wdGlvbnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENvcmVcbiAqL1xuZnVuY3Rpb24gVGltZWxpbmUgKGNvbnRhaW5lciwgaXRlbXMsIGdyb3Vwcywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGltZWxpbmUpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIC8vIGlmIHRoZSB0aGlyZCBlbGVtZW50IGlzIG9wdGlvbnMsIHRoZSBmb3J0aCBpcyBncm91cHMgKG9wdGlvbmFsbHkpO1xuICBpZiAoIShBcnJheS5pc0FycmF5KGdyb3VwcykgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhVmlldykgJiYgZ3JvdXBzIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgdmFyIGZvcnRoQXJndW1lbnQgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBncm91cHM7XG4gICAgZ3JvdXBzID0gZm9ydGhBcmd1bWVudDtcbiAgfVxuXG4gIHZhciBtZSA9IHRoaXM7XG4gIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc3RhcnQ6IG51bGwsXG4gICAgZW5kOiAgIG51bGwsXG5cbiAgICBhdXRvUmVzaXplOiB0cnVlLFxuICAgIHRocm90dGxlUmVkcmF3OiAwLCAvLyBtc1xuXG4gICAgb3JpZW50YXRpb246IHtcbiAgICAgIGF4aXM6ICdib3R0b20nLCAgIC8vIGF4aXMgb3JpZW50YXRpb246ICdib3R0b20nLCAndG9wJywgb3IgJ2JvdGgnXG4gICAgICBpdGVtOiAnYm90dG9tJyAgICAvLyBub3QgcmVsZXZhbnRcbiAgICB9LFxuXG4gICAgbW9tZW50OiBtb21lbnQsXG5cbiAgICB3aWR0aDogbnVsbCxcbiAgICBoZWlnaHQ6IG51bGwsXG4gICAgbWF4SGVpZ2h0OiBudWxsLFxuICAgIG1pbkhlaWdodDogbnVsbFxuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmRlZXBFeHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gIC8vIENyZWF0ZSB0aGUgRE9NLCBwcm9wcywgYW5kIGVtaXR0ZXJcbiAgdGhpcy5fY3JlYXRlKGNvbnRhaW5lcik7XG5cbiAgLy8gYWxsIGNvbXBvbmVudHMgbGlzdGVkIGhlcmUgd2lsbCBiZSByZXBhaW50ZWQgYXV0b21hdGljYWxseVxuICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcblxuICB0aGlzLmJvZHkgPSB7XG4gICAgZG9tOiB0aGlzLmRvbSxcbiAgICBkb21Qcm9wczogdGhpcy5wcm9wcyxcbiAgICBlbWl0dGVyOiB7XG4gICAgICBvbjogdGhpcy5vbi5iaW5kKHRoaXMpLFxuICAgICAgb2ZmOiB0aGlzLm9mZi5iaW5kKHRoaXMpLFxuICAgICAgZW1pdDogdGhpcy5lbWl0LmJpbmQodGhpcylcbiAgICB9LFxuICAgIGhpZGRlbkRhdGVzOiBbXSxcbiAgICB1dGlsOiB7XG4gICAgICBnZXRTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWUudGltZUF4aXMuc3RlcC5zY2FsZTtcbiAgICAgIH0sXG4gICAgICBnZXRTdGVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZS50aW1lQXhpcy5zdGVwLnN0ZXA7XG4gICAgICB9LFxuXG4gICAgICB0b1NjcmVlbjogbWUuX3RvU2NyZWVuLmJpbmQobWUpLFxuICAgICAgdG9HbG9iYWxTY3JlZW46IG1lLl90b0dsb2JhbFNjcmVlbi5iaW5kKG1lKSwgLy8gdGhpcyByZWZlcnMgdG8gdGhlIHJvb3Qud2lkdGhcbiAgICAgIHRvVGltZTogbWUuX3RvVGltZS5iaW5kKG1lKSxcbiAgICAgIHRvR2xvYmFsVGltZSA6IG1lLl90b0dsb2JhbFRpbWUuYmluZChtZSlcbiAgICB9XG4gIH07XG5cbiAgLy8gcmFuZ2VcbiAgdGhpcy5yYW5nZSA9IG5ldyBSYW5nZSh0aGlzLmJvZHkpO1xuICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLnJhbmdlKTtcbiAgdGhpcy5ib2R5LnJhbmdlID0gdGhpcy5yYW5nZTtcblxuICAvLyB0aW1lIGF4aXNcbiAgdGhpcy50aW1lQXhpcyA9IG5ldyBUaW1lQXhpcyh0aGlzLmJvZHkpO1xuICB0aGlzLnRpbWVBeGlzMiA9IG51bGw7IC8vIHVzZWQgaW4gY2FzZSBvZiBvcmllbnRhdGlvbiBvcHRpb24gJ2JvdGgnXG4gIHRoaXMuY29tcG9uZW50cy5wdXNoKHRoaXMudGltZUF4aXMpO1xuXG4gIC8vIGN1cnJlbnQgdGltZSBiYXJcbiAgdGhpcy5jdXJyZW50VGltZSA9IG5ldyBDdXJyZW50VGltZSh0aGlzLmJvZHkpO1xuICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLmN1cnJlbnRUaW1lKTtcblxuICAvLyBpdGVtIHNldFxuICB0aGlzLml0ZW1TZXQgPSBuZXcgSXRlbVNldCh0aGlzLmJvZHkpO1xuICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLml0ZW1TZXQpO1xuXG4gIHRoaXMuaXRlbXNEYXRhID0gbnVsbDsgICAgICAvLyBEYXRhU2V0XG4gIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7ICAgICAvLyBEYXRhU2V0XG5cbiAgdGhpcy5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbWUuZW1pdCgnY2xpY2snLCBtZS5nZXRFdmVudFByb3BlcnRpZXMoZXZlbnQpKVxuICB9KTtcbiAgdGhpcy5vbignZG91YmxldGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbWUuZW1pdCgnZG91YmxlQ2xpY2snLCBtZS5nZXRFdmVudFByb3BlcnRpZXMoZXZlbnQpKVxuICB9KTtcbiAgdGhpcy5kb20ucm9vdC5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbWUuZW1pdCgnY29udGV4dG1lbnUnLCBtZS5nZXRFdmVudFByb3BlcnRpZXMoZXZlbnQpKVxuICB9O1xuXG4gIC8vIGFwcGx5IG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICAvLyBJTVBPUlRBTlQ6IFRISVMgSEFQUEVOUyBCRUZPUkUgU0VUIElURU1TIVxuICBpZiAoZ3JvdXBzKSB7XG4gICAgdGhpcy5zZXRHcm91cHMoZ3JvdXBzKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBpdGVtc2V0XG4gIGlmIChpdGVtcykge1xuICAgIHRoaXMuc2V0SXRlbXMoaXRlbXMpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX3JlZHJhdygpO1xuICB9XG59XG5cbi8vIEV4dGVuZCB0aGUgZnVuY3Rpb25hbGl0eSBmcm9tIENvcmVcblRpbWVsaW5lLnByb3RvdHlwZSA9IG5ldyBDb3JlKCk7XG5cbi8qKlxuICogTG9hZCBhIGNvbmZpZ3VyYXRvclxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLl9jcmVhdGVDb25maWd1cmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgQ29uZmlndXJhdG9yKHRoaXMsIHRoaXMuZG9tLmNvbnRhaW5lciwgY29uZmlndXJlT3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEZvcmNlIGEgcmVkcmF3LiBUaGUgc2l6ZSBvZiBhbGwgaXRlbXMgd2lsbCBiZSByZWNhbGN1bGF0ZWQuXG4gKiBDYW4gYmUgdXNlZnVsIHRvIG1hbnVhbGx5IHJlZHJhdyB3aGVuIG9wdGlvbiBhdXRvUmVzaXplPWZhbHNlIGFuZCB0aGUgd2luZG93XG4gKiBoYXMgYmVlbiByZXNpemVkLCBvciB3aGVuIHRoZSBpdGVtcyBDU1MgaGFzIGJlZW4gY2hhbmdlZC5cbiAqXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgb3ZlcnJpZGRlbiBvbiBjb25zdHJ1Y3Rpb24gd2l0aCBhIHRyb3R0bGVkIHZlcnNpb25cbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLml0ZW1TZXQgJiYgdGhpcy5pdGVtU2V0Lm1hcmtEaXJ0eSh7cmVmcmVzaEl0ZW1zOiB0cnVlfSk7XG4gIHRoaXMuX3JlZHJhdygpO1xufTtcblxuVGltZWxpbmUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLyB2YWxpZGF0ZSBvcHRpb25zXG4gIGxldCBlcnJvckZvdW5kID0gVmFsaWRhdG9yLnZhbGlkYXRlKG9wdGlvbnMsIGFsbE9wdGlvbnMpO1xuICBpZiAoZXJyb3JGb3VuZCA9PT0gdHJ1ZSkge1xuICAgIGNvbnNvbGUubG9nKCclY0Vycm9ycyBoYXZlIGJlZW4gZm91bmQgaW4gdGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0LicsIHByaW50U3R5bGUpO1xuICB9XG5cbiAgQ29yZS5wcm90b3R5cGUuc2V0T3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmICgndHlwZScgaW4gb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnR5cGUgIT09IHRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudHlwZSA9IG9wdGlvbnMudHlwZTtcblxuICAgICAgLy8gZm9yY2UgcmVjcmVhdGlvbiBvZiBhbGwgaXRlbXNcbiAgICAgIHZhciBpdGVtc0RhdGEgPSB0aGlzLml0ZW1zRGF0YTtcbiAgICAgIGlmIChpdGVtc0RhdGEpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2V0SXRlbXMobnVsbCk7ICAgICAgICAgIC8vIHJlbW92ZSBhbGxcbiAgICAgICAgdGhpcy5zZXRJdGVtcyhpdGVtc0RhdGEpOyAgICAgLy8gYWRkIGFsbFxuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pOyAvLyByZXN0b3JlIHNlbGVjdGlvblxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgaXRlbXNcbiAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCBBcnJheSB8IG51bGx9IGl0ZW1zXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5zZXRJdGVtcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gIHZhciBpbml0aWFsTG9hZCA9ICh0aGlzLml0ZW1zRGF0YSA9PSBudWxsKTtcblxuICAvLyBjb252ZXJ0IHRvIHR5cGUgRGF0YVNldCB3aGVuIG5lZWRlZFxuICB2YXIgbmV3RGF0YVNldDtcbiAgaWYgKCFpdGVtcykge1xuICAgIG5ld0RhdGFTZXQgPSBudWxsO1xuICB9XG4gIGVsc2UgaWYgKGl0ZW1zIGluc3RhbmNlb2YgRGF0YVNldCB8fCBpdGVtcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgbmV3RGF0YVNldCA9IGl0ZW1zO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIHR1cm4gYW4gYXJyYXkgaW50byBhIGRhdGFzZXRcbiAgICBuZXdEYXRhU2V0ID0gbmV3IERhdGFTZXQoaXRlbXMsIHtcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgc3RhcnQ6ICdEYXRlJyxcbiAgICAgICAgZW5kOiAnRGF0ZSdcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIHNldCBpdGVtc1xuICB0aGlzLml0ZW1zRGF0YSA9IG5ld0RhdGFTZXQ7XG4gIHRoaXMuaXRlbVNldCAmJiB0aGlzLml0ZW1TZXQuc2V0SXRlbXMobmV3RGF0YVNldCk7XG5cbiAgaWYgKGluaXRpYWxMb2FkKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdGFydCAhPSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhcnQgPT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5lbmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0SXRlbVJhbmdlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMub3B0aW9ucy5zdGFydCAhPSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuc3RhcnQgOiByYW5nZS5taW47XG4gICAgICB2YXIgZW5kICAgPSB0aGlzLm9wdGlvbnMuZW5kICE9IHVuZGVmaW5lZCAgID8gdGhpcy5vcHRpb25zLmVuZCAgIDogcmFuZ2UubWF4O1xuXG4gICAgICB0aGlzLnNldFdpbmRvdyhzdGFydCwgZW5kLCB7YW5pbWF0aW9uOiBmYWxzZX0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZml0KHthbmltYXRpb246IGZhbHNlfSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNldCBncm91cHNcbiAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCBBcnJheX0gZ3JvdXBzXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5zZXRHcm91cHMgPSBmdW5jdGlvbihncm91cHMpIHtcbiAgLy8gY29udmVydCB0byB0eXBlIERhdGFTZXQgd2hlbiBuZWVkZWRcbiAgdmFyIG5ld0RhdGFTZXQ7XG4gIGlmICghZ3JvdXBzKSB7XG4gICAgbmV3RGF0YVNldCA9IG51bGw7XG4gIH1cbiAgZWxzZSBpZiAoZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIG5ld0RhdGFTZXQgPSBncm91cHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gdHVybiBhbiBhcnJheSBpbnRvIGEgZGF0YXNldFxuICAgIG5ld0RhdGFTZXQgPSBuZXcgRGF0YVNldChncm91cHMpO1xuICB9XG5cbiAgdGhpcy5ncm91cHNEYXRhID0gbmV3RGF0YVNldDtcbiAgdGhpcy5pdGVtU2V0LnNldEdyb3VwcyhuZXdEYXRhU2V0KTtcbn07XG5cbi8qKlxuICogU2V0IGJvdGggaXRlbXMgYW5kIGdyb3VwcyBpbiBvbmUgZ29cbiAqIEBwYXJhbSB7e2l0ZW1zOiBBcnJheSB8IHZpcy5EYXRhU2V0LCBncm91cHM6IEFycmF5IHwgdmlzLkRhdGFTZXR9fSBkYXRhXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgaWYgKGRhdGEgJiYgZGF0YS5ncm91cHMpIHtcbiAgICB0aGlzLnNldEdyb3VwcyhkYXRhLmdyb3Vwcyk7XG4gIH1cblxuICBpZiAoZGF0YSAmJiBkYXRhLml0ZW1zKSB7XG4gICAgdGhpcy5zZXRJdGVtcyhkYXRhLml0ZW1zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWQuIFJlcGxhY2VzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICogVW5rbm93biBpZCdzIGFyZSBzaWxlbnRseSBpZ25vcmVkLlxuICogQHBhcmFtIHtzdHJpbmdbXSB8IHN0cmluZ30gW2lkc10gIEFuIGFycmF5IHdpdGggemVybyBvciBtb3JlIGlkJ3Mgb2YgdGhlIGl0ZW1zIHRvIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQuIElmIGlkcyBpcyBhbiBlbXB0eSBhcnJheSwgYWxsIGl0ZW1zIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnNlbGVjdGVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBmb2N1czogYm9vbGVhbmBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSwgZm9jdXMgd2lsbCBiZSBzZXQgdG8gdGhlIHNlbGVjdGVkIGl0ZW0ocylcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgYXBwbGljYWJsZSB3aGVuIG9wdGlvbiBmb2N1cyBpcyB0cnVlLlxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oaWRzLCBvcHRpb25zKSB7XG4gIHRoaXMuaXRlbVNldCAmJiB0aGlzLml0ZW1TZXQuc2V0U2VsZWN0aW9uKGlkcyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mb2N1cykge1xuICAgIHRoaXMuZm9jdXMoaWRzLCBvcHRpb25zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNlbGVjdGVkIGl0ZW1zIGJ5IHRoZWlyIGlkXG4gKiBAcmV0dXJuIHtBcnJheX0gaWRzICBUaGUgaWRzIG9mIHRoZSBzZWxlY3RlZCBpdGVtc1xuICovXG5UaW1lbGluZS5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLml0ZW1TZXQgJiYgdGhpcy5pdGVtU2V0LmdldFNlbGVjdGlvbigpIHx8IFtdO1xufTtcblxuLyoqXG4gKiBBZGp1c3QgdGhlIHZpc2libGUgd2luZG93IHN1Y2ggdGhhdCB0aGUgc2VsZWN0ZWQgaXRlbSAob3IgbXVsdGlwbGUgaXRlbXMpXG4gKiBhcmUgY2VudGVyZWQgb24gc2NyZWVuLlxuICogQHBhcmFtIHtTdHJpbmcgfCBTdHJpbmdbXX0gaWQgICAgIEFuIGl0ZW0gaWQgb3IgYXJyYXkgd2l0aCBpdGVtIGlkc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24oaWQsIG9wdGlvbnMpIHtcbiAgaWYgKCF0aGlzLml0ZW1zRGF0YSB8fCBpZCA9PSB1bmRlZmluZWQpIHJldHVybjtcblxuICB2YXIgaWRzID0gQXJyYXkuaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG5cbiAgLy8gZ2V0IHRoZSBzcGVjaWZpZWQgaXRlbShzKVxuICB2YXIgaXRlbXNEYXRhID0gdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpLmdldChpZHMsIHtcbiAgICB0eXBlOiB7XG4gICAgICBzdGFydDogJ0RhdGUnLFxuICAgICAgZW5kOiAnRGF0ZSdcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNhbGN1bGF0ZSBtaW5pbXVtIHN0YXJ0IGFuZCBtYXhpbXVtIGVuZCBvZiBzcGVjaWZpZWQgaXRlbXNcbiAgdmFyIHN0YXJ0ID0gbnVsbDtcbiAgdmFyIGVuZCA9IG51bGw7XG4gIGl0ZW1zRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgIHZhciBzID0gaXRlbURhdGEuc3RhcnQudmFsdWVPZigpO1xuICAgIHZhciBlID0gJ2VuZCcgaW4gaXRlbURhdGEgPyBpdGVtRGF0YS5lbmQudmFsdWVPZigpIDogaXRlbURhdGEuc3RhcnQudmFsdWVPZigpO1xuXG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IHMgPCBzdGFydCkge1xuICAgICAgc3RhcnQgPSBzO1xuICAgIH1cblxuICAgIGlmIChlbmQgPT09IG51bGwgfHwgZSA+IGVuZCkge1xuICAgICAgZW5kID0gZTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChzdGFydCAhPT0gbnVsbCAmJiBlbmQgIT09IG51bGwpIHtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIG5ldyBtaWRkbGUgYW5kIGludGVydmFsIGZvciB0aGUgd2luZG93XG4gICAgdmFyIG1pZGRsZSA9IChzdGFydCArIGVuZCkgLyAyO1xuICAgIHZhciBpbnRlcnZhbCA9IE1hdGgubWF4KCh0aGlzLnJhbmdlLmVuZCAtIHRoaXMucmFuZ2Uuc3RhcnQpLCAoZW5kIC0gc3RhcnQpICogMS4xKTtcblxuICAgIHZhciBhbmltYXRpb24gPSAob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuYW5pbWF0aW9uIDogdHJ1ZTtcbiAgICB0aGlzLnJhbmdlLnNldFJhbmdlKG1pZGRsZSAtIGludGVydmFsIC8gMiwgbWlkZGxlICsgaW50ZXJ2YWwgLyAyLCBhbmltYXRpb24pO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBUaW1lbGluZSB3aW5kb3cgc3VjaCB0aGF0IGl0IGZpdHMgYWxsIGl0ZW1zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgYW5pbWF0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG4gIHZhciByYW5nZSA9IHRoaXMuZ2V0SXRlbVJhbmdlKCk7XG4gIHRoaXMucmFuZ2Uuc2V0UmFuZ2UocmFuZ2UubWluLCByYW5nZS5tYXgsIGFuaW1hdGlvbik7XG59O1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgcmFuZ2Ugb2YgdGhlIGl0ZW1zLCB0YWtpbmcgaW50byBhY2NvdW50IHRoZWlyIGFjdHVhbCB3aWR0aFxuICogYW5kIGEgbWFyZ2luIG9mIDEwIHBpeGVscyBvbiBib3RoIHNpZGVzLlxuICogQHJldHVybiB7e21pbjogRGF0ZSB8IG51bGwsIG1heDogRGF0ZSB8IG51bGx9fVxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuZ2V0SXRlbVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAvLyBnZXQgYSByb3VnaCBhcHByb3hpbWF0aW9uIGZvciB0aGUgcmFuZ2UgYmFzZWQgb24gdGhlIGl0ZW1zIHN0YXJ0IGFuZCBlbmQgZGF0ZXNcbiAgdmFyIHJhbmdlID0gdGhpcy5nZXREYXRhUmFuZ2UoKTtcbiAgdmFyIG1pbiA9IHJhbmdlLm1pbjtcbiAgdmFyIG1heCA9IHJhbmdlLm1heDtcbiAgdmFyIG1pbkl0ZW0gPSBudWxsO1xuICB2YXIgbWF4SXRlbSA9IG51bGw7XG5cbiAgaWYgKG1pbiAhPSBudWxsICYmIG1heCAhPSBudWxsKSB7XG4gICAgdmFyIGludGVydmFsID0gKG1heCAtIG1pbik7IC8vIG1zXG4gICAgaWYgKGludGVydmFsIDw9IDApIHtcbiAgICAgIGludGVydmFsID0gMTA7XG4gICAgfVxuICAgIHZhciBmYWN0b3IgPSBpbnRlcnZhbCAvIHRoaXMucHJvcHMuY2VudGVyLndpZHRoO1xuXG4gICAgZnVuY3Rpb24gZ2V0U3RhcnQoaXRlbSkge1xuICAgICAgcmV0dXJuIHV0aWwuY29udmVydChpdGVtLmRhdGEuc3RhcnQsICdEYXRlJykudmFsdWVPZigpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RW5kKGl0ZW0pIHtcbiAgICAgIHZhciBlbmQgPSBpdGVtLmRhdGEuZW5kICE9IHVuZGVmaW5lZCA/IGl0ZW0uZGF0YS5lbmQgOiBpdGVtLmRhdGEuc3RhcnQ7XG4gICAgICByZXR1cm4gdXRpbC5jb252ZXJ0KGVuZCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBkYXRlIG9mIHRoZSBsZWZ0IHNpZGUgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIGl0ZW1zIGdpdmVuXG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbVNldC5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGl0ZW0uc2hvdygpO1xuXG4gICAgICB2YXIgc3RhcnQgPSBnZXRTdGFydChpdGVtKTtcbiAgICAgIHZhciBlbmQgPSBnZXRFbmQoaXRlbSk7XG5cbiAgICAgIHZhciBsZWZ0ICA9IG5ldyBEYXRlKHN0YXJ0IC0gKGl0ZW0uZ2V0V2lkdGhMZWZ0KCkgKyAxMCkgKiBmYWN0b3IpO1xuICAgICAgdmFyIHJpZ2h0ID0gbmV3IERhdGUoZW5kICAgKyAoaXRlbS5nZXRXaWR0aFJpZ2h0KCkgKyAxMCkgKiBmYWN0b3IpO1xuXG4gICAgICBpZiAobGVmdCA8IG1pbikge1xuICAgICAgICBtaW4gPSBsZWZ0O1xuICAgICAgICBtaW5JdGVtID0gaXRlbTtcbiAgICAgIH1cbiAgICAgIGlmIChyaWdodCA+IG1heCkge1xuICAgICAgICBtYXggPSByaWdodDtcbiAgICAgICAgbWF4SXRlbSA9IGl0ZW07XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIGlmIChtaW5JdGVtICYmIG1heEl0ZW0pIHtcbiAgICAgIHZhciBsaHMgPSBtaW5JdGVtLmdldFdpZHRoTGVmdCgpICsgMTA7XG4gICAgICB2YXIgcmhzID0gbWF4SXRlbS5nZXRXaWR0aFJpZ2h0KCkgKyAxMDtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMucHJvcHMuY2VudGVyLndpZHRoIC0gbGhzIC0gcmhzOyAgLy8gcHhcblxuICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICBtaW4gPSBnZXRTdGFydChtaW5JdGVtKSAtIGxocyAqIGludGVydmFsIC8gZGVsdGE7IC8vIG1zXG4gICAgICAgIG1heCA9IGdldEVuZChtYXhJdGVtKSAgICsgcmhzICogaW50ZXJ2YWwgLyBkZWx0YTsgLy8gbXNcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1pbjogbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbCxcbiAgICBtYXg6IG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGxcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGRhdGEgcmFuZ2Ugb2YgdGhlIGl0ZW1zIHN0YXJ0IGFuZCBlbmQgZGF0ZXNcbiAqIEByZXR1cm5zIHt7bWluOiBEYXRlIHwgbnVsbCwgbWF4OiBEYXRlIHwgbnVsbH19XG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5nZXREYXRhUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1pbiA9IG51bGw7XG4gIHZhciBtYXggPSBudWxsO1xuXG4gIHZhciBkYXRhc2V0ID0gdGhpcy5pdGVtc0RhdGEgJiYgdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpO1xuICBpZiAoZGF0YXNldCkge1xuICAgIGRhdGFzZXQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHN0YXJ0ID0gdXRpbC5jb252ZXJ0KGl0ZW0uc3RhcnQsICdEYXRlJykudmFsdWVPZigpO1xuICAgICAgdmFyIGVuZCAgID0gdXRpbC5jb252ZXJ0KGl0ZW0uZW5kICE9IHVuZGVmaW5lZCA/IGl0ZW0uZW5kIDogaXRlbS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICBpZiAobWluID09PSBudWxsIHx8IHN0YXJ0IDwgbWluKSB7XG4gICAgICAgIG1pbiA9IHN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBlbmQgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gc3RhcnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1pbjogbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbCxcbiAgICBtYXg6IG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGxcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBUaW1lbGluZSByZWxhdGVkIGluZm9ybWF0aW9uIGZyb20gYW4gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHJlbGF0ZWQgaW5mb3JtYXRpb24sIGxpa2Ugb24gd2hpY2ggYXJlYVxuICogICAgICAgICAgICAgICAgICBUaGUgZXZlbnQgaGFwcGVuZWQsIHdoZXRoZXIgY2xpY2tlZCBvbiBhbiBpdGVtLCBldGMuXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5nZXRFdmVudFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGNsaWVudFggPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueCA6IGV2ZW50LmNsaWVudFg7XG4gIHZhciBjbGllbnRZID0gZXZlbnQuY2VudGVyID8gZXZlbnQuY2VudGVyLnkgOiBldmVudC5jbGllbnRZO1xuICB2YXIgeCA9IGNsaWVudFggLSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5jZW50ZXJDb250YWluZXIpO1xuICB2YXIgeSA9IGNsaWVudFkgLSB1dGlsLmdldEFic29sdXRlVG9wKHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lcik7XG5cbiAgdmFyIGl0ZW0gID0gdGhpcy5pdGVtU2V0Lml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcbiAgdmFyIGdyb3VwID0gdGhpcy5pdGVtU2V0Lmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gIHZhciBjdXN0b21UaW1lID0gQ3VzdG9tVGltZS5jdXN0b21UaW1lRnJvbVRhcmdldChldmVudCk7XG5cbiAgdmFyIHNuYXAgPSB0aGlzLml0ZW1TZXQub3B0aW9ucy5zbmFwIHx8IG51bGw7XG4gIHZhciBzY2FsZSA9IHRoaXMuYm9keS51dGlsLmdldFNjYWxlKCk7XG4gIHZhciBzdGVwID0gdGhpcy5ib2R5LnV0aWwuZ2V0U3RlcCgpO1xuICB2YXIgdGltZSA9IHRoaXMuX3RvVGltZSh4KTtcbiAgdmFyIHNuYXBwZWRUaW1lID0gc25hcCA/IHNuYXAodGltZSwgc2NhbGUsIHN0ZXApIDogdGltZTtcblxuICB2YXIgZWxlbWVudCA9IHV0aWwuZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgdmFyIHdoYXQgPSBudWxsO1xuICBpZiAoaXRlbSAhPSBudWxsKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7d2hhdCA9ICdpdGVtJzt9XG4gIGVsc2UgaWYgKGN1c3RvbVRpbWUgIT0gbnVsbCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt3aGF0ID0gJ2N1c3RvbS10aW1lJzt9XG4gIGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMudGltZUF4aXMuZG9tLmZvcmVncm91bmQpKSAgICAgIHt3aGF0ID0gJ2F4aXMnO31cbiAgZWxzZSBpZiAodGhpcy50aW1lQXhpczIgJiYgdXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy50aW1lQXhpczIuZG9tLmZvcmVncm91bmQpKSB7d2hhdCA9ICdheGlzJzt9XG4gIGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMuaXRlbVNldC5kb20ubGFiZWxTZXQpKSAgICAgICAgIHt3aGF0ID0gJ2dyb3VwLWxhYmVsJzt9XG4gIGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMuY3VycmVudFRpbWUuYmFyKSkgICAgICAgICAgICAgIHt3aGF0ID0gJ2N1cnJlbnQtdGltZSc7fVxuICBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLmRvbS5jZW50ZXIpKSAgICAgICAgICAgICAgICAgICB7d2hhdCA9ICdiYWNrZ3JvdW5kJzt9XG5cbiAgcmV0dXJuIHtcbiAgICBldmVudDogZXZlbnQsXG4gICAgaXRlbTogaXRlbSA/IGl0ZW0uaWQgOiBudWxsLFxuICAgIGdyb3VwOiBncm91cCA/IGdyb3VwLmdyb3VwSWQgOiBudWxsLFxuICAgIHdoYXQ6IHdoYXQsXG4gICAgcGFnZVg6IGV2ZW50LnNyY0V2ZW50ID8gZXZlbnQuc3JjRXZlbnQucGFnZVggOiBldmVudC5wYWdlWCxcbiAgICBwYWdlWTogZXZlbnQuc3JjRXZlbnQgPyBldmVudC5zcmNFdmVudC5wYWdlWSA6IGV2ZW50LnBhZ2VZLFxuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB0aW1lOiB0aW1lLFxuICAgIHNuYXBwZWRUaW1lOiBzbmFwcGVkVGltZVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVsaW5lO1xuIl19
},{"../DataSet":15,"../DataView":16,"../module/hammer":19,"../module/moment":20,"../shared/Configurator":24,"../shared/Validator":25,"../util":46,"./Core":26,"./Range":28,"./component/CurrentTime":34,"./component/CustomTime":35,"./component/ItemSet":37,"./component/TimeAxis":38,"./optionsTimeline":45,"emitter-component":10}],32:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Group = require('./Group');

/**
 * @constructor BackgroundGroup
 * @param {Number | String} groupId
 * @param {Object} data
 * @param {ItemSet} itemSet
 */
function BackgroundGroup(groupId, data, itemSet) {
  Group.call(this, groupId, data, itemSet);

  this.width = 0;
  this.height = 0;
  this.top = 0;
  this.left = 0;
}

BackgroundGroup.prototype = Object.create(Group.prototype);

/**
 * Repaint this group
 * @param {{start: number, end: number}} range
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @param {boolean} [restack=false]  Force restacking of all items
 * @return {boolean} Returns true if the group is resized
 */
BackgroundGroup.prototype.redraw = function (range, margin, restack) {
  var resized = false;

  this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

  // calculate actual size
  this.width = this.dom.background.offsetWidth;

  // apply new height (just always zero for BackgroundGroup
  this.dom.background.style.height = '0';

  // update vertical position of items after they are re-stacked and the height of the group is calculated
  for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
    var item = this.visibleItems[i];
    item.repositionY(margin);
  }

  return resized;
};

/**
 * Show this group: attach to the DOM
 */
BackgroundGroup.prototype.show = function () {
  if (!this.dom.background.parentNode) {
    this.itemSet.dom.background.appendChild(this.dom.background);
  }
};

module.exports = BackgroundGroup;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9CYWNrZ3JvdW5kR3JvdXAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDakMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7Ozs7OztBQVEvQixTQUFTLGVBQWUsQ0FBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUNoRCxPQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDOztBQUV6QyxNQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNmLE1BQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ2hCLE1BQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ2IsTUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7Q0FDZjs7QUFFRCxlQUFlLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7Ozs7Ozs7QUFTM0QsZUFBZSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsVUFBUyxLQUFLLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRTtBQUNsRSxNQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7O0FBRXBCLE1BQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQzs7O0FBRzFGLE1BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDOzs7QUFHN0MsTUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBSSxHQUFHLENBQUM7OztBQUd4QyxPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMxRCxRQUFJLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hDLFFBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7R0FDMUI7O0FBRUQsU0FBTyxPQUFPLENBQUM7Q0FDaEIsQ0FBQzs7Ozs7QUFLRixlQUFlLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxZQUFXO0FBQzFDLE1BQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUU7QUFDbkMsUUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0dBQzlEO0NBQ0YsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLGVBQWUsQ0FBQyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQmFja2dyb3VuZEdyb3VwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgR3JvdXAgPSByZXF1aXJlKCcuL0dyb3VwJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEJhY2tncm91bmRHcm91cFxuICogQHBhcmFtIHtOdW1iZXIgfCBTdHJpbmd9IGdyb3VwSWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0l0ZW1TZXR9IGl0ZW1TZXRcbiAqL1xuZnVuY3Rpb24gQmFja2dyb3VuZEdyb3VwIChncm91cElkLCBkYXRhLCBpdGVtU2V0KSB7XG4gIEdyb3VwLmNhbGwodGhpcywgZ3JvdXBJZCwgZGF0YSwgaXRlbVNldCk7XG5cbiAgdGhpcy53aWR0aCA9IDA7XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgdGhpcy50b3AgPSAwO1xuICB0aGlzLmxlZnQgPSAwO1xufVxuXG5CYWNrZ3JvdW5kR3JvdXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcm91cC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFJlcGFpbnQgdGhpcyBncm91cFxuICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZVxuICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICogQHBhcmFtIHtib29sZWFufSBbcmVzdGFjaz1mYWxzZV0gIEZvcmNlIHJlc3RhY2tpbmcgb2YgYWxsIGl0ZW1zXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGdyb3VwIGlzIHJlc2l6ZWRcbiAqL1xuQmFja2dyb3VuZEdyb3VwLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbihyYW5nZSwgbWFyZ2luLCByZXN0YWNrKSB7XG4gIHZhciByZXNpemVkID0gZmFsc2U7XG5cbiAgdGhpcy52aXNpYmxlSXRlbXMgPSB0aGlzLl91cGRhdGVWaXNpYmxlSXRlbXModGhpcy5vcmRlcmVkSXRlbXMsIHRoaXMudmlzaWJsZUl0ZW1zLCByYW5nZSk7XG5cbiAgLy8gY2FsY3VsYXRlIGFjdHVhbCBzaXplXG4gIHRoaXMud2lkdGggPSB0aGlzLmRvbS5iYWNrZ3JvdW5kLm9mZnNldFdpZHRoO1xuXG4gIC8vIGFwcGx5IG5ldyBoZWlnaHQgKGp1c3QgYWx3YXlzIHplcm8gZm9yIEJhY2tncm91bmRHcm91cFxuICB0aGlzLmRvbS5iYWNrZ3JvdW5kLnN0eWxlLmhlaWdodCAgPSAnMCc7XG5cbiAgLy8gdXBkYXRlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIGl0ZW1zIGFmdGVyIHRoZXkgYXJlIHJlLXN0YWNrZWQgYW5kIHRoZSBoZWlnaHQgb2YgdGhlIGdyb3VwIGlzIGNhbGN1bGF0ZWRcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy52aXNpYmxlSXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIHZhciBpdGVtID0gdGhpcy52aXNpYmxlSXRlbXNbaV07XG4gICAgaXRlbS5yZXBvc2l0aW9uWShtYXJnaW4pO1xuICB9XG5cbiAgcmV0dXJuIHJlc2l6ZWQ7XG59O1xuXG4vKipcbiAqIFNob3cgdGhpcyBncm91cDogYXR0YWNoIHRvIHRoZSBET01cbiAqL1xuQmFja2dyb3VuZEdyb3VwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kb20uYmFja2dyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5pdGVtU2V0LmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tncm91bmRHcm91cDtcbiJdfQ==
},{"../../util":46,"./Group":36}],33:[function(require,module,exports){
/**
 * Prototype for visual components
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} [body]
 * @param {Object} [options]
 */
"use strict";

function Component(body, options) {
  this.options = null;
  this.props = null;
}

/**
 * Set options for the component. The new options will be merged into the
 * current options.
 * @param {Object} options
 */
Component.prototype.setOptions = function (options) {
  if (options) {
    util.extend(this.options, options);
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
Component.prototype.redraw = function () {
  // should be implemented by the component
  return false;
};

/**
 * Destroy the component. Cleanup DOM and event listeners
 */
Component.prototype.destroy = function () {
  // should be implemented by the component
};

/**
 * Test whether the component is resized since the last time _isResized() was
 * called.
 * @return {Boolean} Returns true if the component is resized
 * @protected
 */
Component.prototype._isResized = function () {
  var resized = this.props._previousWidth !== this.props.width || this.props._previousHeight !== this.props.height;

  this.props._previousWidth = this.props.width;
  this.props._previousHeight = this.props.height;

  return resized;
};

module.exports = Component;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9Db21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUtBLFNBQVMsU0FBUyxDQUFFLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDakMsTUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDcEIsTUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7Q0FDbkI7Ozs7Ozs7QUFPRCxTQUFTLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBRyxVQUFTLE9BQU8sRUFBRTtBQUNqRCxNQUFJLE9BQU8sRUFBRTtBQUNYLFFBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztHQUNwQztDQUNGLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFlBQVc7O0FBRXRDLFNBQU8sS0FBSyxDQUFDO0NBQ2QsQ0FBQzs7Ozs7QUFLRixTQUFTLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxZQUFXOztDQUV4QyxDQUFDOzs7Ozs7OztBQVFGLFNBQVMsQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLFlBQVc7QUFDMUMsTUFBSSxPQUFPLEdBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQ3pELElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxBQUFDLENBQUM7O0FBRXRELE1BQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO0FBQzdDLE1BQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDOztBQUUvQyxTQUFPLE9BQU8sQ0FBQztDQUNoQixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9Db21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByb3RvdHlwZSBmb3IgdmlzdWFsIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7e2RvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0LCBlbWl0dGVyOiBFbWl0dGVyLCByYW5nZTogUmFuZ2V9fSBbYm9keV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50IChib2R5LCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG51bGw7XG4gIHRoaXMucHJvcHMgPSBudWxsO1xufVxuXG4vKipcbiAqIFNldCBvcHRpb25zIGZvciB0aGUgY29tcG9uZW50LiBUaGUgbmV3IG9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgaW50byB0aGVcbiAqIGN1cnJlbnQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGNvbXBvbmVudFxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIGNvbXBvbmVudC4gQ2xlYW51cCBET00gYW5kIGV2ZW50IGxpc3RlbmVyc1xuICovXG5Db21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBjb21wb25lbnRcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZCBzaW5jZSB0aGUgbGFzdCB0aW1lIF9pc1Jlc2l6ZWQoKSB3YXNcbiAqIGNhbGxlZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5faXNSZXNpemVkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNpemVkID0gKHRoaXMucHJvcHMuX3ByZXZpb3VzV2lkdGggIT09IHRoaXMucHJvcHMud2lkdGggfHxcbiAgICAgIHRoaXMucHJvcHMuX3ByZXZpb3VzSGVpZ2h0ICE9PSB0aGlzLnByb3BzLmhlaWdodCk7XG5cbiAgdGhpcy5wcm9wcy5fcHJldmlvdXNXaWR0aCA9IHRoaXMucHJvcHMud2lkdGg7XG4gIHRoaXMucHJvcHMuX3ByZXZpb3VzSGVpZ2h0ID0gdGhpcy5wcm9wcy5oZWlnaHQ7XG5cbiAgcmV0dXJuIHJlc2l6ZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudDtcbiJdfQ==
},{}],34:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Component = require('./Component');
var moment = require('../../module/moment');
var locales = require('../locales');

/**
 * A current time bar
 * @param {{range: Range, dom: Object, domProps: Object}} body
 * @param {Object} [options]        Available parameters:
 *                                  {Boolean} [showCurrentTime]
 * @constructor CurrentTime
 * @extends Component
 */
function CurrentTime(body, options) {
  this.body = body;

  // default options
  this.defaultOptions = {
    showCurrentTime: true,

    moment: moment,
    locales: locales,
    locale: 'en'
  };
  this.options = util.extend({}, this.defaultOptions);
  this.offset = 0;

  this._create();

  this.setOptions(options);
}

CurrentTime.prototype = new Component();

/**
 * Create the HTML DOM for the current time bar
 * @private
 */
CurrentTime.prototype._create = function () {
  var bar = document.createElement('div');
  bar.className = 'vis-current-time';
  bar.style.position = 'absolute';
  bar.style.top = '0px';
  bar.style.height = '100%';

  this.bar = bar;
};

/**
 * Destroy the CurrentTime bar
 */
CurrentTime.prototype.destroy = function () {
  this.options.showCurrentTime = false;
  this.redraw(); // will remove the bar from the DOM and stop refreshing

  this.body = null;
};

/**
 * Set options for the component. Options will be merged in current options.
 * @param {Object} options  Available parameters:
 *                          {boolean} [showCurrentTime]
 */
CurrentTime.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['showCurrentTime', 'moment', 'locale', 'locales'], this.options, options);
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
CurrentTime.prototype.redraw = function () {
  if (this.options.showCurrentTime) {
    var parent = this.body.dom.backgroundVertical;
    if (this.bar.parentNode != parent) {
      // attach to the dom
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      parent.appendChild(this.bar);

      this.start();
    }

    var now = this.options.moment(new Date().valueOf() + this.offset);
    var x = this.body.util.toScreen(now);

    var locale = this.options.locales[this.options.locale];
    if (!locale) {
      if (!this.warned) {
        console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline.html#Localization');
        this.warned = true;
      }
      locale = this.options.locales['en']; // fall back on english when not available
    }
    var title = locale.current + ' ' + locale.time + ': ' + now.format('dddd, MMMM Do YYYY, H:mm:ss');
    title = title.charAt(0).toUpperCase() + title.substring(1);

    this.bar.style.left = x + 'px';
    this.bar.title = title;
  } else {
    // remove the line from the DOM
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
    this.stop();
  }

  return false;
};

/**
 * Start auto refreshing the current time bar
 */
CurrentTime.prototype.start = function () {
  var me = this;

  function update() {
    me.stop();

    // determine interval to refresh
    var scale = me.body.range.conversion(me.body.domProps.center.width).scale;
    var interval = 1 / scale / 10;
    if (interval < 30) interval = 30;
    if (interval > 1000) interval = 1000;

    me.redraw();

    // start a renderTimer to adjust for the new time
    me.currentTimeTimer = setTimeout(update, interval);
  }

  update();
};

/**
 * Stop auto refreshing the current time bar
 */
CurrentTime.prototype.stop = function () {
  if (this.currentTimeTimer !== undefined) {
    clearTimeout(this.currentTimeTimer);
    delete this.currentTimeTimer;
  }
};

/**
 * Set a current time. This can be used for example to ensure that a client's
 * time is synchronized with a shared server time.
 * @param {Date | String | Number} time     A Date, unix timestamp, or
 *                                          ISO date string.
 */
CurrentTime.prototype.setCurrentTime = function (time) {
  var t = util.convert(time, 'Date').valueOf();
  var now = new Date().valueOf();
  this.offset = t - now;
  this.redraw();
};

/**
 * Get the current time.
 * @return {Date} Returns the current time.
 */
CurrentTime.prototype.getCurrentTime = function () {
  return new Date(new Date().valueOf() + this.offset);
};

module.exports = CurrentTime;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9DdXJyZW50VGltZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNqQyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdkMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7QUFDNUMsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7Ozs7Ozs7O0FBVXBDLFNBQVMsV0FBVyxDQUFFLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDbkMsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7OztBQUdqQixNQUFJLENBQUMsY0FBYyxHQUFHO0FBQ3BCLG1CQUFlLEVBQUUsSUFBSTs7QUFFckIsVUFBTSxFQUFFLE1BQU07QUFDZCxXQUFPLEVBQUUsT0FBTztBQUNoQixVQUFNLEVBQUUsSUFBSTtHQUNiLENBQUM7QUFDRixNQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUNwRCxNQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQzs7QUFFaEIsTUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDOztBQUVmLE1BQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDMUI7O0FBRUQsV0FBVyxDQUFDLFNBQVMsR0FBRyxJQUFJLFNBQVMsRUFBRSxDQUFDOzs7Ozs7QUFNeEMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsWUFBVztBQUN6QyxNQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3hDLEtBQUcsQ0FB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QUFnQixDQUFDLENBQUM7QUFDcEMsV0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7R0FDOUI7Q0FDRixDQUFDOzs7Ozs7OztBQVFGLFdBQVcsQ0FBQyxTQUFTLENBQUMsY0FBYyxHQUFHLFVBQVMsSUFBSSxFQUFFO0FBQ3BELE1BQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQzdDLE1BQUksR0FBRyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDL0IsTUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQ3RCLE1BQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztDQUNmLENBQUM7Ozs7OztBQU1GLFdBQVcsQ0FBQyxTQUFTLENBQUMsY0FBYyxHQUFHLFlBQVc7QUFDaEQsU0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztDQUNyRCxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsV0FBVyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9DdXJyZW50VGltZS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlL21vbWVudCcpO1xudmFyIGxvY2FsZXMgPSByZXF1aXJlKCcuLi9sb2NhbGVzJyk7XG5cbi8qKlxuICogQSBjdXJyZW50IHRpbWUgYmFyXG4gKiBAcGFyYW0ge3tyYW5nZTogUmFuZ2UsIGRvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0fX0gYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQXZhaWxhYmxlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gW3Nob3dDdXJyZW50VGltZV1cbiAqIEBjb25zdHJ1Y3RvciBDdXJyZW50VGltZVxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIEN1cnJlbnRUaW1lIChib2R5LCBvcHRpb25zKSB7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc2hvd0N1cnJlbnRUaW1lOiB0cnVlLFxuXG4gICAgbW9tZW50OiBtb21lbnQsXG4gICAgbG9jYWxlczogbG9jYWxlcyxcbiAgICBsb2NhbGU6ICdlbidcbiAgfTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICB0aGlzLm9mZnNldCA9IDA7XG5cbiAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xufVxuXG5DdXJyZW50VGltZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBIVE1MIERPTSBmb3IgdGhlIGN1cnJlbnQgdGltZSBiYXJcbiAqIEBwcml2YXRlXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYmFyLmNsYXNzTmFtZSA9ICd2aXMtY3VycmVudC10aW1lJztcbiAgYmFyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgYmFyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICBiYXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gIHRoaXMuYmFyID0gYmFyO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBDdXJyZW50VGltZSBiYXJcbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub3B0aW9ucy5zaG93Q3VycmVudFRpbWUgPSBmYWxzZTtcbiAgdGhpcy5yZWRyYXcoKTsgLy8gd2lsbCByZW1vdmUgdGhlIGJhciBmcm9tIHRoZSBET00gYW5kIHN0b3AgcmVmcmVzaGluZ1xuXG4gIHRoaXMuYm9keSA9IG51bGw7XG59O1xuXG4vKipcbiAqIFNldCBvcHRpb25zIGZvciB0aGUgY29tcG9uZW50LiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIGluIGN1cnJlbnQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gW3Nob3dDdXJyZW50VGltZV1cbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ3Nob3dDdXJyZW50VGltZScsICdtb21lbnQnLCAnbG9jYWxlJywgJ2xvY2FsZXMnXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLnNob3dDdXJyZW50VGltZSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbDtcbiAgICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSAhPSBwYXJlbnQpIHtcbiAgICAgIC8vIGF0dGFjaCB0byB0aGUgZG9tXG4gICAgICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmJhci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmFyKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmJhcik7XG5cbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gdGhpcy5vcHRpb25zLm1vbWVudChuZXcgRGF0ZSgpLnZhbHVlT2YoKSArIHRoaXMub2Zmc2V0KTtcbiAgICB2YXIgeCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKG5vdyk7XG5cbiAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgaWYgKCFsb2NhbGUpIHtcbiAgICAgIGlmICghdGhpcy53YXJuZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IG9wdGlvbnMubG9jYWxlc1tcXCcnICsgdGhpcy5vcHRpb25zLmxvY2FsZSArICdcXCddIG5vdCBmb3VuZC4gU2VlIGh0dHA6Ly92aXNqcy5vcmcvZG9jcy90aW1lbGluZS5odG1sI0xvY2FsaXphdGlvbicpO1xuICAgICAgICB0aGlzLndhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXTsgLy8gZmFsbCBiYWNrIG9uIGVuZ2xpc2ggd2hlbiBub3QgYXZhaWxhYmxlXG4gICAgfVxuICAgIHZhciB0aXRsZSA9IGxvY2FsZS5jdXJyZW50ICsgJyAnICsgbG9jYWxlLnRpbWUgKyAnOiAnICsgbm93LmZvcm1hdCgnZGRkZCwgTU1NTSBEbyBZWVlZLCBIOm1tOnNzJyk7XG4gICAgdGl0bGUgPSB0aXRsZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRpdGxlLnN1YnN0cmluZygxKTtcblxuICAgIHRoaXMuYmFyLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICB0aGlzLmJhci50aXRsZSA9IHRpdGxlO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIHJlbW92ZSB0aGUgbGluZSBmcm9tIHRoZSBET01cbiAgICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5iYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhcik7XG4gICAgfVxuICAgIHRoaXMuc3RvcCgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTdGFydCBhdXRvIHJlZnJlc2hpbmcgdGhlIGN1cnJlbnQgdGltZSBiYXJcbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgICBtZS5zdG9wKCk7XG5cbiAgICAvLyBkZXRlcm1pbmUgaW50ZXJ2YWwgdG8gcmVmcmVzaFxuICAgIHZhciBzY2FsZSA9IG1lLmJvZHkucmFuZ2UuY29udmVyc2lvbihtZS5ib2R5LmRvbVByb3BzLmNlbnRlci53aWR0aCkuc2NhbGU7XG4gICAgdmFyIGludGVydmFsID0gMSAvIHNjYWxlIC8gMTA7XG4gICAgaWYgKGludGVydmFsIDwgMzApICAgaW50ZXJ2YWwgPSAzMDtcbiAgICBpZiAoaW50ZXJ2YWwgPiAxMDAwKSBpbnRlcnZhbCA9IDEwMDA7XG5cbiAgICBtZS5yZWRyYXcoKTtcblxuICAgIC8vIHN0YXJ0IGEgcmVuZGVyVGltZXIgdG8gYWRqdXN0IGZvciB0aGUgbmV3IHRpbWVcbiAgICBtZS5jdXJyZW50VGltZVRpbWVyID0gc2V0VGltZW91dCh1cGRhdGUsIGludGVydmFsKTtcbiAgfVxuXG4gIHVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBTdG9wIGF1dG8gcmVmcmVzaGluZyB0aGUgY3VycmVudCB0aW1lIGJhclxuICovXG5DdXJyZW50VGltZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jdXJyZW50VGltZVRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jdXJyZW50VGltZVRpbWVyKTtcbiAgICBkZWxldGUgdGhpcy5jdXJyZW50VGltZVRpbWVyO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBhIGN1cnJlbnQgdGltZS4gVGhpcyBjYW4gYmUgdXNlZCBmb3IgZXhhbXBsZSB0byBlbnN1cmUgdGhhdCBhIGNsaWVudCdzXG4gKiB0aW1lIGlzIHN5bmNocm9uaXplZCB3aXRoIGEgc2hhcmVkIHNlcnZlciB0aW1lLlxuICogQHBhcmFtIHtEYXRlIHwgU3RyaW5nIHwgTnVtYmVyfSB0aW1lICAgICBBIERhdGUsIHVuaXggdGltZXN0YW1wLCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJU08gZGF0ZSBzdHJpbmcuXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgdmFyIHQgPSB1dGlsLmNvbnZlcnQodGltZSwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gIHZhciBub3cgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgdGhpcy5vZmZzZXQgPSB0IC0gbm93O1xuICB0aGlzLnJlZHJhdygpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdGltZS5cbiAqIEByZXR1cm4ge0RhdGV9IFJldHVybnMgdGhlIGN1cnJlbnQgdGltZS5cbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLmdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnZhbHVlT2YoKSArIHRoaXMub2Zmc2V0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VycmVudFRpbWU7XG4iXX0=
},{"../../module/moment":20,"../../util":46,"../locales":44,"./Component":33}],35:[function(require,module,exports){
'use strict';

var Hammer = require('../../module/hammer');
var util = require('../../util');
var Component = require('./Component');
var moment = require('../../module/moment');
var locales = require('../locales');

/**
 * A custom time bar
 * @param {{range: Range, dom: Object}} body
 * @param {Object} [options]        Available parameters:
 *                                  {number | string} id
 *                                  {string} locales
 *                                  {string} locale
 * @constructor CustomTime
 * @extends Component
 */

function CustomTime(body, options) {
  this.body = body;

  // default options
  this.defaultOptions = {
    moment: moment,
    locales: locales,
    locale: 'en',
    id: undefined,
    title: undefined
  };
  this.options = util.extend({}, this.defaultOptions);

  if (options && options.time) {
    this.customTime = options.time;
  } else {
    this.customTime = new Date();
  }

  this.eventParams = {}; // stores state parameters while dragging the bar

  this.setOptions(options);

  // create the DOM
  this._create();
}

CustomTime.prototype = new Component();

/**
 * Set options for the component. Options will be merged in current options.
 * @param {Object} options  Available parameters:
 *                                  {number | string} id
 *                                  {string} locales
 *                                  {string} locale
 */
CustomTime.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['moment', 'locale', 'locales', 'id'], this.options, options);
  }
};

/**
 * Create the DOM for the custom time
 * @private
 */
CustomTime.prototype._create = function () {
  var bar = document.createElement('div');
  bar['custom-time'] = this;
  bar.className = 'vis-custom-time ' + (this.options.id || '');
  bar.style.position = 'absolute';
  bar.style.top = '0px';
  bar.style.height = '100%';
  this.bar = bar;

  var drag = document.createElement('div');
  drag.style.position = 'relative';
  drag.style.top = '0px';
  drag.style.left = '-10px';
  drag.style.height = '100%';
  drag.style.width = '20px';
  bar.appendChild(drag);

  // attach event listeners
  this.hammer = new Hammer(drag);
  this.hammer.on('panstart', this._onDragStart.bind(this));
  this.hammer.on('panmove', this._onDrag.bind(this));
  this.hammer.on('panend', this._onDragEnd.bind(this));
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.
};

/**
 * Destroy the CustomTime bar
 */
CustomTime.prototype.destroy = function () {
  this.hide();

  this.hammer.destroy();
  this.hammer = null;

  this.body = null;
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
CustomTime.prototype.redraw = function () {
  var parent = this.body.dom.backgroundVertical;
  if (this.bar.parentNode != parent) {
    // attach to the dom
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
    parent.appendChild(this.bar);
  }

  var x = this.body.util.toScreen(this.customTime);

  var locale = this.options.locales[this.options.locale];
  if (!locale) {
    if (!this.warned) {
      console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline.html#Localization');
      this.warned = true;
    }
    locale = this.options.locales['en']; // fall back on english when not available
  }

  var title = this.options.title;
  // To hide the title completely use empty string ''.
  if (title === undefined) {
    title = locale.time + ': ' + this.options.moment(this.customTime).format('dddd, MMMM Do YYYY, H:mm:ss');
    title = title.charAt(0).toUpperCase() + title.substring(1);
  }

  this.bar.style.left = x + 'px';
  this.bar.title = title;

  return false;
};

/**
 * Remove the CustomTime from the DOM
 */
CustomTime.prototype.hide = function () {
  // remove the line from the DOM
  if (this.bar.parentNode) {
    this.bar.parentNode.removeChild(this.bar);
  }
};

/**
 * Set custom time.
 * @param {Date | number | string} time
 */
CustomTime.prototype.setCustomTime = function (time) {
  this.customTime = util.convert(time, 'Date');
  this.redraw();
};

/**
 * Retrieve the current custom time.
 * @return {Date} customTime
 */
CustomTime.prototype.getCustomTime = function () {
  return new Date(this.customTime.valueOf());
};

/**
  * Set custom title.
  * @param {Date | number | string} title
  */
CustomTime.prototype.setCustomTitle = function (title) {
  this.options.title = title;
};

/**
 * Start moving horizontally
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDragStart = function (event) {
  this.eventParams.dragging = true;
  this.eventParams.customTime = this.customTime;

  event.stopPropagation();
};

/**
 * Perform moving operating.
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDrag = function (event) {
  if (!this.eventParams.dragging) return;

  var x = this.body.util.toScreen(this.eventParams.customTime) + event.deltaX;
  var time = this.body.util.toTime(x);

  this.setCustomTime(time);

  // fire a timechange event
  this.body.emitter.emit('timechange', {
    id: this.options.id,
    time: new Date(this.customTime.valueOf())
  });

  event.stopPropagation();
};

/**
 * Stop moving operating.
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDragEnd = function (event) {
  if (!this.eventParams.dragging) return;

  // fire a timechanged event
  this.body.emitter.emit('timechanged', {
    id: this.options.id,
    time: new Date(this.customTime.valueOf())
  });

  event.stopPropagation();
};

/**
 * Find a custom time from an event target:
 * searches for the attribute 'custom-time' in the event target's element tree
 * @param {Event} event
 * @return {CustomTime | null} customTime
 */
CustomTime.customTimeFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('custom-time')) {
      return target['custom-time'];
    }
    target = target.parentNode;
  }

  return null;
};

module.exports = CustomTime;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9DdXN0b21UaW1lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7QUFDNUMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2pDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN2QyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUM1QyxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7QUFhcEMsU0FBUyxVQUFVLENBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUNsQyxNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzs7O0FBR2pCLE1BQUksQ0FBQyxjQUFjLEdBQUc7QUFDcEIsVUFBTSxFQUFFLE1BQU07QUFDZCxXQUFPLEVBQUUsT0FBTztBQUNoQixVQUFNLEVBQUUsSUFBSTtBQUNaLE1BQUUsRUFBRSxTQUFTO0FBQ2IsU0FBSyxFQUFFLFNBQVM7R0FDakIsQ0FBQztBQUNGLE1BQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDOztBQUVwRCxNQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFO0FBQzNCLFFBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztHQUNoQyxNQUFNO0FBQ0wsUUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO0dBQzlCOztBQUVELE1BQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDOztBQUV0QixNQUFJLENBQUMsVUFBVSxD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SUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztHQUMxQyxDQUFDLENBQUM7O0FBRUgsT0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO0NBQ3pCLENBQUM7Ozs7Ozs7O0FBUUYsVUFBVSxDQUFDLG9CQUFvQixHQUFHLFVBQVMsS0FBSyxFQUFFO0FBQ2hELE1BQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7QUFDMUIsU0FBTyxNQUFNLEVBQUU7QUFDYixRQUFJLE1BQU0sQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLEVBQUU7QUFDeEMsYUFBTyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDOUI7QUFDRCxVQUFNLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztHQUM1Qjs7QUFFRCxTQUFPLElBQUksQ0FBQztDQUNiLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxVQUFVLENBQUMiLCJmaWxlIjoiL1VzZXJzL2VtaWx5YXNobGV5L1NUT1JZVE9PTFMvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0N1c3RvbVRpbWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGUvbW9tZW50Jyk7XG52YXIgbG9jYWxlcyA9IHJlcXVpcmUoJy4uL2xvY2FsZXMnKTtcblxuLyoqXG4gKiBBIGN1c3RvbSB0aW1lIGJhclxuICogQHBhcmFtIHt7cmFuZ2U6IFJhbmdlLCBkb206IE9iamVjdH19IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlciB8IHN0cmluZ30gaWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGxvY2FsZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGxvY2FsZVxuICogQGNvbnN0cnVjdG9yIEN1c3RvbVRpbWVcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbmZ1bmN0aW9uIEN1c3RvbVRpbWUgKGJvZHksIG9wdGlvbnMpIHtcbiAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb21lbnQ6IG1vbWVudCxcbiAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgIGxvY2FsZTogJ2VuJyxcbiAgICBpZDogdW5kZWZpbmVkLFxuICAgIHRpdGxlOiB1bmRlZmluZWRcbiAgfTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMudGltZSkge1xuICAgIHRoaXMuY3VzdG9tVGltZSA9IG9wdGlvbnMudGltZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmN1c3RvbVRpbWUgPSBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgdGhpcy5ldmVudFBhcmFtcyA9IHt9OyAvLyBzdG9yZXMgc3RhdGUgcGFyYW1ldGVycyB3aGlsZSBkcmFnZ2luZyB0aGUgYmFyXG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgRE9NXG4gIHRoaXMuX2NyZWF0ZSgpO1xufVxuXG5DdXN0b21UaW1lLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBmb3IgdGhlIGNvbXBvbmVudC4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCBpbiBjdXJyZW50IG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgQXZhaWxhYmxlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyIHwgc3RyaW5nfSBpZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbG9jYWxlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbG9jYWxlXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ21vbWVudCcsICdsb2NhbGUnLCAnbG9jYWxlcycsICdpZCddLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgRE9NIGZvciB0aGUgY3VzdG9tIHRpbWVcbiAqIEBwcml2YXRlXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBiYXJbJ2N1c3RvbS10aW1lJ10gPSB0aGlzO1xuICBiYXIuY2xhc3NOYW1lID0gJ3Zpcy1jdXN0b20tdGltZSAnICsgKHRoaXMub3B0aW9ucy5pZCB8fCAnJyk7XG4gIGJhci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGJhci5zdHlsZS50b3AgPSAnMHB4JztcbiAgYmFyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgdGhpcy5iYXIgPSBiYXI7XG5cbiAgdmFyIGRyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZHJhZy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGRyYWcuc3R5bGUudG9wID0gJzBweCc7XG4gIGRyYWcuc3R5bGUubGVmdCA9ICctMTBweCc7XG4gIGRyYWcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICBkcmFnLnN0eWxlLndpZHRoID0gJzIwcHgnO1xuICBiYXIuYXBwZW5kQ2hpbGQoZHJhZyk7XG5cbiAgLy8gYXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIoZHJhZyk7XG4gIHRoaXMuaGFtbWVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5vbigncGFubW92ZScsICB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG4gIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCAgIHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5oYW1tZXIuZ2V0KCdwYW4nKS5zZXQoe3RocmVzaG9sZDo1LCBkaXJlY3Rpb246MzB9KTsgLy8gMzAgaXMgQUxMX0RJUkVDVElPTlMgaW4gaGFtbWVyLlxufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBDdXN0b21UaW1lIGJhclxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhpZGUoKTtcblxuICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICB0aGlzLmJvZHkgPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWw7XG4gIGlmICh0aGlzLmJhci5wYXJlbnROb2RlICE9IHBhcmVudCkge1xuICAgIC8vIGF0dGFjaCB0byB0aGUgZG9tXG4gICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgIH1cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5iYXIpO1xuICB9XG5cbiAgdmFyIHggPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbih0aGlzLmN1c3RvbVRpbWUpO1xuXG4gIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgaWYgKCFsb2NhbGUpIHtcbiAgICBpZiAoIXRoaXMud2FybmVkKSB7XG4gICAgICBjb25zb2xlLmxvZygnV0FSTklORzogb3B0aW9ucy5sb2NhbGVzW1xcJycgKyB0aGlzLm9wdGlvbnMubG9jYWxlICsgJ1xcJ10gbm90IGZvdW5kLiBTZWUgaHR0cDovL3Zpc2pzLm9yZy9kb2NzL3RpbWVsaW5lLmh0bWwjTG9jYWxpemF0aW9uJyk7XG4gICAgICB0aGlzLndhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddOyAvLyBmYWxsIGJhY2sgb24gZW5nbGlzaCB3aGVuIG5vdCBhdmFpbGFibGVcbiAgfVxuXG4gIHZhciB0aXRsZSA9IHRoaXMub3B0aW9ucy50aXRsZTtcbiAgLy8gVG8gaGlkZSB0aGUgdGl0bGUgY29tcGxldGVseSB1c2UgZW1wdHkgc3RyaW5nICcnLlxuICBpZiAodGl0bGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRpdGxlID0gbG9jYWxlLnRpbWUgKyAnOiAnICsgdGhpcy5vcHRpb25zLm1vbWVudCh0aGlzLmN1c3RvbVRpbWUpLmZvcm1hdCgnZGRkZCwgTU1NTSBEbyBZWVlZLCBIOm1tOnNzJyk7XG4gICAgdGl0bGUgPSB0aXRsZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRpdGxlLnN1YnN0cmluZygxKTtcbiAgfVxuXG4gIHRoaXMuYmFyLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgdGhpcy5iYXIudGl0bGUgPSB0aXRsZTtcblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgQ3VzdG9tVGltZSBmcm9tIHRoZSBET01cbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gcmVtb3ZlIHRoZSBsaW5lIGZyb20gdGhlIERPTVxuICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBjdXN0b20gdGltZS5cbiAqIEBwYXJhbSB7RGF0ZSB8IG51bWJlciB8IHN0cmluZ30gdGltZVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5zZXRDdXN0b21UaW1lID0gZnVuY3Rpb24odGltZSkge1xuICB0aGlzLmN1c3RvbVRpbWUgPSB1dGlsLmNvbnZlcnQodGltZSwgJ0RhdGUnKTtcbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgY3VzdG9tIHRpbWUuXG4gKiBAcmV0dXJuIHtEYXRlfSBjdXN0b21UaW1lXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLmdldEN1c3RvbVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuY3VzdG9tVGltZS52YWx1ZU9mKCkpO1xufTtcblxuLyoqXG4gICogU2V0IGN1c3RvbSB0aXRsZS5cbiAgKiBAcGFyYW0ge0RhdGUgfCBudW1iZXIgfCBzdHJpbmd9IHRpdGxlXG4gICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5zZXRDdXN0b21UaXRsZSA9IGZ1bmN0aW9uKHRpdGxlKSB7XG4gIHRoaXMub3B0aW9ucy50aXRsZSA9IHRpdGxlO1xufTtcblxuLyoqXG4gKiBTdGFydCBtb3ZpbmcgaG9yaXpvbnRhbGx5XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdGhpcy5ldmVudFBhcmFtcy5kcmFnZ2luZyA9IHRydWU7XG4gIHRoaXMuZXZlbnRQYXJhbXMuY3VzdG9tVGltZSA9IHRoaXMuY3VzdG9tVGltZTtcblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBtb3Zpbmcgb3BlcmF0aW5nLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLmV2ZW50UGFyYW1zLmRyYWdnaW5nKSByZXR1cm47XG5cbiAgdmFyIHggPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbih0aGlzLmV2ZW50UGFyYW1zLmN1c3RvbVRpbWUpICsgZXZlbnQuZGVsdGFYO1xuICB2YXIgdGltZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4KTtcblxuICB0aGlzLnNldEN1c3RvbVRpbWUodGltZSk7XG5cbiAgLy8gZmlyZSBhIHRpbWVjaGFuZ2UgZXZlbnRcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgndGltZWNoYW5nZScsIHtcbiAgICBpZDogdGhpcy5vcHRpb25zLmlkLFxuICAgIHRpbWU6IG5ldyBEYXRlKHRoaXMuY3VzdG9tVGltZS52YWx1ZU9mKCkpXG4gIH0pO1xuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuLyoqXG4gKiBTdG9wIG1vdmluZyBvcGVyYXRpbmcuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMuZXZlbnRQYXJhbXMuZHJhZ2dpbmcpIHJldHVybjtcblxuICAvLyBmaXJlIGEgdGltZWNoYW5nZWQgZXZlbnRcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgndGltZWNoYW5nZWQnLCB7XG4gICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICB0aW1lOiBuZXcgRGF0ZSh0aGlzLmN1c3RvbVRpbWUudmFsdWVPZigpKVxuICB9KTtcblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbi8qKlxuICogRmluZCBhIGN1c3RvbSB0aW1lIGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICogc2VhcmNoZXMgZm9yIHRoZSBhdHRyaWJ1dGUgJ2N1c3RvbS10aW1lJyBpbiB0aGUgZXZlbnQgdGFyZ2V0J3MgZWxlbWVudCB0cmVlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Q3VzdG9tVGltZSB8IG51bGx9IGN1c3RvbVRpbWVcbiAqL1xuQ3VzdG9tVGltZS5jdXN0b21UaW1lRnJvbVRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCdjdXN0b20tdGltZScpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0WydjdXN0b20tdGltZSddO1xuICAgIH1cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDdXN0b21UaW1lO1xuIl19
},{"../../module/hammer":19,"../../module/moment":20,"../../util":46,"../locales":44,"./Component":33}],36:[function(require,module,exports){
'use strict';

var util = require('../../util');
var stack = require('../Stack');
var RangeItem = require('./item/RangeItem');

/**
 * @constructor Group
 * @param {Number | String} groupId
 * @param {Object} data
 * @param {ItemSet} itemSet
 */
function Group(groupId, data, itemSet) {
  this.groupId = groupId;
  this.subgroups = {};
  this.subgroupIndex = 0;
  this.subgroupOrderer = data && data.subgroupOrder;
  this.itemSet = itemSet;

  this.dom = {};
  this.props = {
    label: {
      width: 0,
      height: 0
    }
  };
  this.className = null;

  this.items = {}; // items filtered by groupId of this group
  this.visibleItems = []; // items currently visible in window
  this.orderedItems = {
    byStart: [],
    byEnd: []
  };
  this.checkRangedItems = false; // needed to refresh the ranged items if the window is programatically changed with NO overlap.
  var me = this;
  this.itemSet.body.emitter.on("checkRangedItems", function () {
    me.checkRangedItems = true;
  });

  this._create();

  this.setData(data);
}

/**
 * Create DOM elements for the group
 * @private
 */
Group.prototype._create = function () {
  var label = document.createElement('div');
  if (this.itemSet.options.groupEditable.order) {
    label.className = 'vis-label draggable';
  } else {
    label.className = 'vis-label';
  }
  this.dom.label = label;

  var inner = document.createElement('div');
  inner.className = 'vis-inner';
  label.appendChild(inner);
  this.dom.inner = inner;

  var foreground = document.createElement('div');
  foreground.className = 'vis-group';
  foreground['timeline-group'] = this;
  this.dom.foreground = foreground;

  this.dom.background = document.createElement('div');
  this.dom.background.className = 'vis-group';

  this.dom.axis = document.createElement('div');
  this.dom.axis.className = 'vis-group';

  // create a hidden marker to detect when the Timelines container is attached
  // to the DOM, or the style of a parent of the Timeline is changed from
  // display:none is changed to visible.
  this.dom.marker = document.createElement('div');
  this.dom.marker.style.visibility = 'hidden';
  this.dom.marker.innerHTML = '?';
  this.dom.background.appendChild(this.dom.marker);
};

/**
 * Set the group data for this group
 * @param {Object} data   Group data, can contain properties content and className
 */
Group.prototype.setData = function (data) {
  // update contents
  var content;
  if (this.itemSet.options && this.itemSet.options.groupTemplate) {
    content = this.itemSet.options.groupTemplate(data);
  } else {
    content = data && data.content;
  }

  if (content instanceof Element) {
    this.dom.inner.appendChild(content);
    while (this.dom.inner.firstChild) {
      this.dom.inner.removeChild(this.dom.inner.firstChild);
    }
    this.dom.inner.appendChild(content);
  } else if (content !== undefined && content !== null) {
    this.dom.inner.innerHTML = content;
  } else {
    this.dom.inner.innerHTML = this.groupId || ''; // groupId can be null
  }

  // update title
  this.dom.label.title = data && data.title || '';

  if (!this.dom.inner.firstChild) {
    util.addClassName(this.dom.inner, 'vis-hidden');
  } else {
    util.removeClassName(this.dom.inner, 'vis-hidden');
  }

  // update className
  var className = data && data.className || null;
  if (className != this.className) {
    if (this.className) {
      util.removeClassName(this.dom.label, this.className);
      util.removeClassName(this.dom.foreground, this.className);
      util.removeClassName(this.dom.background, this.className);
      util.removeClassName(this.dom.axis, this.className);
    }
    util.addClassName(this.dom.label, className);
    util.addClassName(this.dom.foreground, className);
    util.addClassName(this.dom.background, className);
    util.addClassName(this.dom.axis, className);
    this.className = className;
  }

  // update style
  if (this.style) {
    util.removeCssText(this.dom.label, this.style);
    this.style = null;
  }
  if (data && data.style) {
    util.addCssText(this.dom.label, data.style);
    this.style = data.style;
  }
};

/**
 * Get the width of the group label
 * @return {number} width
 */
Group.prototype.getLabelWidth = function () {
  return this.props.label.width;
};

/**
 * Repaint this group
 * @param {{start: number, end: number}} range
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @param {boolean} [restack=false]  Force restacking of all items
 * @return {boolean} Returns true if the group is resized
 */
Group.prototype.redraw = function (range, margin, restack) {
  var resized = false;

  // force recalculation of the height of the items when the marker height changed
  // (due to the Timeline being attached to the DOM or changed from display:none to visible)
  var markerHeight = this.dom.marker.clientHeight;
  if (markerHeight != this.lastMarkerHeight) {
    this.lastMarkerHeight = markerHeight;

    util.forEach(this.items, function (item) {
      item.dirty = true;
      if (item.displayed) item.redraw();
    });

    restack = true;
  }

  // reposition visible items vertically
  if (typeof this.itemSet.options.order === 'function') {
    // a custom order function

    if (restack) {
      // brute force restack of all items

      // show all items
      var me = this;
      var limitSize = false;
      util.forEach(this.items, function (item) {
        if (!item.displayed) {
          item.redraw();
          me.visibleItems.push(item);
        }
        item.repositionX(limitSize);
      });

      // order all items and force a restacking
      var customOrderedItems = this.orderedItems.byStart.slice().sort(function (a, b) {
        return me.itemSet.options.order(a.data, b.data);
      });
      stack.stack(customOrderedItems, margin, true /* restack=true */);
    }

    this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);
  } else {
    // no custom order function, lazy stacking
    this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

    if (this.itemSet.options.stack) {
      // TODO: ugly way to access options...
      stack.stack(this.visibleItems, margin, restack);
    } else {
      // no stacking
      stack.nostack(this.visibleItems, margin, this.subgroups);
    }
  }

  // recalculate the height of the group
  var height = this._calculateHeight(margin);

  // calculate actual size and position
  var foreground = this.dom.foreground;
  this.top = foreground.offsetTop;
  this.left = foreground.offsetLeft;
  this.width = foreground.offsetWidth;
  resized = util.updateProperty(this, 'height', height) || resized;

  // recalculate size of label
  resized = util.updateProperty(this.props.label, 'width', this.dom.inner.clientWidth) || resized;
  resized = util.updateProperty(this.props.label, 'height', this.dom.inner.clientHeight) || resized;

  // apply new height
  this.dom.background.style.height = height + 'px';
  this.dom.foreground.style.height = height + 'px';
  this.dom.label.style.height = height + 'px';

  // update vertical position of items after they are re-stacked and the height of the group is calculated
  for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
    var item = this.visibleItems[i];
    item.repositionY(margin);
  }

  return resized;
};

/**
 * recalculate the height of the group
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @returns {number} Returns the height
 * @private
 */
Group.prototype._calculateHeight = function (margin) {
  // recalculate the height of the group
  var height;
  var visibleItems = this.visibleItems;
  //var visibleSubgroups = [];
  //this.visibleSubgroups = 0;
  this.resetSubgroups();
  var me = this;
  if (visibleItems.length > 0) {
    var min = visibleItems[0].top;
    var max = visibleItems[0].top + visibleItems[0].height;
    util.forEach(visibleItems, function (item) {
      min = Math.min(min, item.top);
      max = Math.max(max, item.top + item.height);
      if (item.data.subgroup !== undefined) {
        me.subgroups[item.data.subgroup].height = Math.max(me.subgroups[item.data.subgroup].height, item.height);
        me.subgroups[item.data.subgroup].visible = true;
      }
    });
    if (min > margin.axis) {
      // there is an empty gap between the lowest item and the axis
      var offset = min - margin.axis;
      max -= offset;
      util.forEach(visibleItems, function (item) {
        item.top -= offset;
      });
    }
    height = max + margin.item.vertical / 2;
  } else {
    height = 0;
  }
  height = Math.max(height, this.props.label.height);

  return height;
};

/**
 * Show this group: attach to the DOM
 */
Group.prototype.show = function () {
  if (!this.dom.label.parentNode) {
    this.itemSet.dom.labelSet.appendChild(this.dom.label);
  }

  if (!this.dom.foreground.parentNode) {
    this.itemSet.dom.foreground.appendChild(this.dom.foreground);
  }

  if (!this.dom.background.parentNode) {
    this.itemSet.dom.background.appendChild(this.dom.background);
  }

  if (!this.dom.axis.parentNode) {
    this.itemSet.dom.axis.appendChild(this.dom.axis);
  }
};

/**
 * Hide this group: remove from the DOM
 */
Group.prototype.hide = function () {
  var label = this.dom.label;
  if (label.parentNode) {
    label.parentNode.removeChild(label);
  }

  var foreground = this.dom.foreground;
  if (foreground.parentNode) {
    foreground.parentNode.removeChild(foreground);
  }

  var background = this.dom.background;
  if (background.parentNode) {
    background.parentNode.removeChild(background);
  }

  var axis = this.dom.axis;
  if (axis.parentNode) {
    axis.parentNode.removeChild(axis);
  }
};

/**
 * Add an item to the group
 * @param {Item} item
 */
Group.prototype.add = function (item) {
  this.items[item.id] = item;
  item.setParent(this);

  // add to
  if (item.data.subgroup !== undefined) {
    if (this.subgroups[item.data.subgroup] === undefined) {
      this.subgroups[item.data.subgroup] = { height: 0, visible: false, index: this.subgroupIndex, items: [] };
      this.subgroupIndex++;
    }
    this.subgroups[item.data.subgroup].items.push(item);
  }
  this.orderSubgroups();

  if (this.visibleItems.indexOf(item) == -1) {
    var range = this.itemSet.body.range; // TODO: not nice accessing the range like this
    this._checkIfVisible(item, this.visibleItems, range);
  }
};

Group.prototype.orderSubgroups = function () {
  if (this.subgroupOrderer !== undefined) {
    var sortArray = [];
    if (typeof this.subgroupOrderer == 'string') {
      for (var subgroup in this.subgroups) {
        sortArray.push({ subgroup: subgroup, sortField: this.subgroups[subgroup].items[0].data[this.subgroupOrderer] });
      }
      sortArray.sort(function (a, b) {
        return a.sortField - b.sortField;
      });
    } else if (typeof this.subgroupOrderer == 'function') {
      for (var subgroup in this.subgroups) {
        sortArray.push(this.subgroups[subgroup].items[0].data);
      }
      sortArray.sort(this.subgroupOrderer);
    }

    if (sortArray.length > 0) {
      for (var i = 0; i < sortArray.length; i++) {
        this.subgroups[sortArray[i].subgroup].index = i;
      }
    }
  }
};

Group.prototype.resetSubgroups = function () {
  for (var subgroup in this.subgroups) {
    if (this.subgroups.hasOwnProperty(subgroup)) {
      this.subgroups[subgroup].visible = false;
    }
  }
};

/**
 * Remove an item from the group
 * @param {Item} item
 */
Group.prototype.remove = function (item) {
  delete this.items[item.id];
  item.setParent(null);

  // remove from visible items
  var index = this.visibleItems.indexOf(item);
  if (index != -1) this.visibleItems.splice(index, 1);

  if (item.data.subgroup !== undefined) {
    var subgroup = this.subgroups[item.data.subgroup];
    if (subgroup) {
      var itemIndex = subgroup.items.indexOf(item);
      subgroup.items.splice(itemIndex, 1);
      if (!subgroup.items.length) {
        delete this.subgroups[item.data.subgroup];
        this.subgroupIndex--;
      }
      this.orderSubgroups();
    }
  }
};

/**
 * Remove an item from the corresponding DataSet
 * @param {Item} item
 */
Group.prototype.removeFromDataSet = function (item) {
  this.itemSet.removeItem(item.id);
};

/**
 * Reorder the items
 */
Group.prototype.order = function () {
  var array = util.toArray(this.items);
  var startArray = [];
  var endArray = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i].data.end !== undefined) {
      endArray.push(array[i]);
    }
    startArray.push(array[i]);
  }
  this.orderedItems = {
    byStart: startArray,
    byEnd: endArray
  };

  stack.orderByStart(this.orderedItems.byStart);
  stack.orderByEnd(this.orderedItems.byEnd);
};

/**
 * Update the visible items
 * @param {{byStart: Item[], byEnd: Item[]}} orderedItems   All items ordered by start date and by end date
 * @param {Item[]} visibleItems                             The previously visible items.
 * @param {{start: number, end: number}} range              Visible range
 * @return {Item[]} visibleItems                            The new visible items.
 * @private
 */
Group.prototype._updateVisibleItems = function (orderedItems, oldVisibleItems, range) {
  var visibleItems = [];
  var visibleItemsLookup = {}; // we keep this to quickly look up if an item already exists in the list without using indexOf on visibleItems
  var interval = (range.end - range.start) / 4;
  var lowerBound = range.start - interval;
  var upperBound = range.end + interval;
  var item, i;

  // this function is used to do the binary search.
  var searchFunction = function searchFunction(value) {
    if (value < lowerBound) {
      return -1;
    } else if (value <= upperBound) {
      return 0;
    } else {
      return 1;
    }
  };

  // first check if the items that were in view previously are still in view.
  // IMPORTANT: this handles the case for the items with startdate before the window and enddate after the window!
  // also cleans up invisible items.
  if (oldVisibleItems.length > 0) {
    for (i = 0; i < oldVisibleItems.length; i++) {
      this._checkIfVisibleWithReference(oldVisibleItems[i], visibleItems, visibleItemsLookup, range);
    }
  }

  // we do a binary search for the items that have only start values.
  var initialPosByStart = util.binarySearchCustom(orderedItems.byStart, searchFunction, 'data', 'start');

  // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the start values.
  this._traceVisible(initialPosByStart, orderedItems.byStart, visibleItems, visibleItemsLookup, function (item) {
    return item.data.start < lowerBound || item.data.start > upperBound;
  });

  // if the window has changed programmatically without overlapping the old window, the ranged items with start < lowerBound and end > upperbound are not shown.
  // We therefore have to brute force check all items in the byEnd list
  if (this.checkRangedItems == true) {
    this.checkRangedItems = false;
    for (i = 0; i < orderedItems.byEnd.length; i++) {
      this._checkIfVisibleWithReference(orderedItems.byEnd[i], visibleItems, visibleItemsLookup, range);
    }
  } else {
    // we do a binary search for the items that have defined end times.
    var initialPosByEnd = util.binarySearchCustom(orderedItems.byEnd, searchFunction, 'data', 'end');

    // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the end values.
    this._traceVisible(initialPosByEnd, orderedItems.byEnd, visibleItems, visibleItemsLookup, function (item) {
      return item.data.end < lowerBound || item.data.end > upperBound;
    });
  }

  // finally, we reposition all the visible items.
  for (i = 0; i < visibleItems.length; i++) {
    item = visibleItems[i];
    if (!item.displayed) item.show();
    // reposition item horizontally
    item.repositionX();
  }

  // debug
  //console.log("new line")
  //if (this.groupId == null) {
  //  for (i = 0; i < orderedItems.byStart.length; i++) {
  //    item = orderedItems.byStart[i].data;
  //    console.log('start',i,initialPosByStart, item.start.valueOf(), item.content, item.start >= lowerBound && item.start <= upperBound,i == initialPosByStart ? "<------------------- HEREEEE" : "")
  //  }
  //  for (i = 0; i < orderedItems.byEnd.length; i++) {
  //    item = orderedItems.byEnd[i].data;
  //    console.log('rangeEnd',i,initialPosByEnd, item.end.valueOf(), item.content, item.end >= range.start && item.end <= range.end,i == initialPosByEnd ? "<------------------- HEREEEE" : "")
  //  }
  //}

  return visibleItems;
};

Group.prototype._traceVisible = function (initialPos, items, visibleItems, visibleItemsLookup, breakCondition) {
  var item;
  var i;

  if (initialPos != -1) {
    for (i = initialPos; i >= 0; i--) {
      item = items[i];
      if (breakCondition(item)) {
        break;
      } else {
        if (visibleItemsLookup[item.id] === undefined) {
          visibleItemsLookup[item.id] = true;
          visibleItems.push(item);
        }
      }
    }

    for (i = initialPos + 1; i < items.length; i++) {
      item = items[i];
      if (breakCondition(item)) {
        break;
      } else {
        if (visibleItemsLookup[item.id] === undefined) {
          visibleItemsLookup[item.id] = true;
          visibleItems.push(item);
        }
      }
    }
  }
};

/**
 * this function is very similar to the _checkIfInvisible() but it does not
 * return booleans, hides the item if it should not be seen and always adds to
 * the visibleItems.
 * this one is for brute forcing and hiding.
 *
 * @param {Item} item
 * @param {Array} visibleItems
 * @param {{start:number, end:number}} range
 * @private
 */
Group.prototype._checkIfVisible = function (item, visibleItems, range) {
  if (item.isVisible(range)) {
    if (!item.displayed) item.show();
    // reposition item horizontally
    item.repositionX();
    visibleItems.push(item);
  } else {
    if (item.displayed) item.hide();
  }
};

/**
 * this function is very similar to the _checkIfInvisible() but it does not
 * return booleans, hides the item if it should not be seen and always adds to
 * the visibleItems.
 * this one is for brute forcing and hiding.
 *
 * @param {Item} item
 * @param {Array} visibleItems
 * @param {{start:number, end:number}} range
 * @private
 */
Group.prototype._checkIfVisibleWithReference = function (item, visibleItems, visibleItemsLookup, range) {
  if (item.isVisible(range)) {
    if (visibleItemsLookup[item.id] === undefined) {
      visibleItemsLookup[item.id] = true;
      visibleItems.push(item);
    }
  } else {
    if (item.displayed) item.hide();
  }
};

module.exports = Group;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9Hcm91cC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNqQyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDaEMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7Ozs7Ozs7O0FBUTVDLFNBQVMsS0FBSyxDQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ3RDLE1BQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBQ3ZCLE1BQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLE1BQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCLE1BQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUM7QUFDbEQsTUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7O0FBRXZCLE1BQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2QsTUFBSSxDQUFDLEtBQUssR0FBRztBQUNYLFNBQUssRUFBRTtBQUNMLFdBQUssRUFBRSxDQUFDO0FBQ1IsWUFBTSxFQUFFLENBQUM7S0FDVjtHQUNGLENBQUM7QUFDRixNQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQzs7QUFFdEIsTUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDaEIsTUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7QUFDdkIsTUFBSSxDQUFDLFlBQVksR0FBRztBQUNsQixXQUFPLEVBQUUsRUFBRTtBQUNYLFNBQUssRUFBRSxFQUFFO0dBQ1YsQ0FBQztBQUNGLE1BQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7QUFDOUIs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QUFHLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNyRCxVQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUMxRCxVQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUMxRCxVQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUNyRDtBQUNELFFBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDN0MsUUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUNsRCxRQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ2xELFFBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDNUMsUUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7R0FDNUI7OztBQUdELE1BQUksSUFBSSxDQUFDLEtBQUssRUFBRTtBQUNkLFFBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQy9DLFFBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0dBQ25CO0FBQ0QsTUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtBQUN0QixRQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM1QyxR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QUM7R0FDakM7Q0FDRixDQUFDOztBQUlGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9Hcm91cC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIHN0YWNrID0gcmVxdWlyZSgnLi4vU3RhY2snKTtcbnZhciBSYW5nZUl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0vUmFuZ2VJdGVtJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEdyb3VwXG4gKiBAcGFyYW0ge051bWJlciB8IFN0cmluZ30gZ3JvdXBJZFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7SXRlbVNldH0gaXRlbVNldFxuICovXG5mdW5jdGlvbiBHcm91cCAoZ3JvdXBJZCwgZGF0YSwgaXRlbVNldCkge1xuICB0aGlzLmdyb3VwSWQgPSBncm91cElkO1xuICB0aGlzLnN1Ymdyb3VwcyA9IHt9O1xuICB0aGlzLnN1Ymdyb3VwSW5kZXggPSAwO1xuICB0aGlzLnN1Ymdyb3VwT3JkZXJlciA9IGRhdGEgJiYgZGF0YS5zdWJncm91cE9yZGVyO1xuICB0aGlzLml0ZW1TZXQgPSBpdGVtU2V0O1xuXG4gIHRoaXMuZG9tID0ge307XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgbGFiZWw6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfVxuICB9O1xuICB0aGlzLmNsYXNzTmFtZSA9IG51bGw7XG5cbiAgdGhpcy5pdGVtcyA9IHt9OyAgICAgICAgLy8gaXRlbXMgZmlsdGVyZWQgYnkgZ3JvdXBJZCBvZiB0aGlzIGdyb3VwXG4gIHRoaXMudmlzaWJsZUl0ZW1zID0gW107IC8vIGl0ZW1zIGN1cnJlbnRseSB2aXNpYmxlIGluIHdpbmRvd1xuICB0aGlzLm9yZGVyZWRJdGVtcyA9IHtcbiAgICBieVN0YXJ0OiBbXSxcbiAgICBieUVuZDogW11cbiAgfTtcbiAgdGhpcy5jaGVja1JhbmdlZEl0ZW1zID0gZmFsc2U7IC8vIG5lZWRlZCB0byByZWZyZXNoIHRoZSByYW5nZWQgaXRlbXMgaWYgdGhlIHdpbmRvdyBpcyBwcm9ncmFtYXRpY2FsbHkgY2hhbmdlZCB3aXRoIE5PIG92ZXJsYXAuXG4gIHZhciBtZSA9IHRoaXM7XG4gIHRoaXMuaXRlbVNldC5ib2R5LmVtaXR0ZXIub24oXCJjaGVja1JhbmdlZEl0ZW1zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBtZS5jaGVja1JhbmdlZEl0ZW1zID0gdHJ1ZTtcbiAgfSlcblxuICB0aGlzLl9jcmVhdGUoKTtcblxuICB0aGlzLnNldERhdGEoZGF0YSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIERPTSBlbGVtZW50cyBmb3IgdGhlIGdyb3VwXG4gKiBAcHJpdmF0ZVxuICovXG5Hcm91cC5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaWYgKHRoaXMuaXRlbVNldC5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIpIHtcblx0ICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLWxhYmVsIGRyYWdnYWJsZSc7XG4gIH0gZWxzZSB7XG5cdCAgbGFiZWwuY2xhc3NOYW1lID0gJ3Zpcy1sYWJlbCc7XG4gIH1cbiAgdGhpcy5kb20ubGFiZWwgPSBsYWJlbDtcblxuICB2YXIgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaW5uZXIuY2xhc3NOYW1lID0gJ3Zpcy1pbm5lcic7XG4gIGxhYmVsLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgdGhpcy5kb20uaW5uZXIgPSBpbm5lcjtcblxuICB2YXIgZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBmb3JlZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtZ3JvdXAnO1xuICBmb3JlZ3JvdW5kWyd0aW1lbGluZS1ncm91cCddID0gdGhpcztcbiAgdGhpcy5kb20uZm9yZWdyb3VuZCA9IGZvcmVncm91bmQ7XG5cbiAgdGhpcy5kb20uYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtZ3JvdXAnO1xuXG4gIHRoaXMuZG9tLmF4aXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uYXhpcy5jbGFzc05hbWUgPSAndmlzLWdyb3VwJztcblxuICAvLyBjcmVhdGUgYSBoaWRkZW4gbWFya2VyIHRvIGRldGVjdCB3aGVuIHRoZSBUaW1lbGluZXMgY29udGFpbmVyIGlzIGF0dGFjaGVkXG4gIC8vIHRvIHRoZSBET00sIG9yIHRoZSBzdHlsZSBvZiBhIHBhcmVudCBvZiB0aGUgVGltZWxpbmUgaXMgY2hhbmdlZCBmcm9tXG4gIC8vIGRpc3BsYXk6bm9uZSBpcyBjaGFuZ2VkIHRvIHZpc2libGUuXG4gIHRoaXMuZG9tLm1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5tYXJrZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICB0aGlzLmRvbS5tYXJrZXIuaW5uZXJIVE1MID0gJz8nO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLm1hcmtlcik7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZ3JvdXAgZGF0YSBmb3IgdGhpcyBncm91cFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICBHcm91cCBkYXRhLCBjYW4gY29udGFpbiBwcm9wZXJ0aWVzIGNvbnRlbnQgYW5kIGNsYXNzTmFtZVxuICovXG5Hcm91cC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gdXBkYXRlIGNvbnRlbnRzXG4gIHZhciBjb250ZW50O1xuICBpZiAodGhpcy5pdGVtU2V0Lm9wdGlvbnMgJiYgdGhpcy5pdGVtU2V0Lm9wdGlvbnMuZ3JvdXBUZW1wbGF0ZSkge1xuICAgIGNvbnRlbnQgPSB0aGlzLml0ZW1TZXQub3B0aW9ucy5ncm91cFRlbXBsYXRlKGRhdGEpO1xuICB9XG4gIGVsc2Uge1xuICAgIGNvbnRlbnQgPSBkYXRhICYmIGRhdGEuY29udGVudDtcbiAgfVxuXG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIHRoaXMuZG9tLmlubmVyLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHdoaWxlICh0aGlzLmRvbS5pbm5lci5maXJzdENoaWxkKSB7XG4gICAgICB0aGlzLmRvbS5pbm5lci5yZW1vdmVDaGlsZCh0aGlzLmRvbS5pbm5lci5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgdGhpcy5kb20uaW5uZXIuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gIH1cbiAgZWxzZSBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkICYmIGNvbnRlbnQgIT09IG51bGwpIHtcbiAgICB0aGlzLmRvbS5pbm5lci5pbm5lckhUTUwgPSBjb250ZW50O1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuZG9tLmlubmVyLmlubmVySFRNTCA9IHRoaXMuZ3JvdXBJZCB8fCAnJzsgLy8gZ3JvdXBJZCBjYW4gYmUgbnVsbFxuICB9XG5cbiAgLy8gdXBkYXRlIHRpdGxlXG4gIHRoaXMuZG9tLmxhYmVsLnRpdGxlID0gZGF0YSAmJiBkYXRhLnRpdGxlIHx8ICcnO1xuXG4gIGlmICghdGhpcy5kb20uaW5uZXIuZmlyc3RDaGlsZCkge1xuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmlubmVyLCAndmlzLWhpZGRlbicpO1xuICB9XG4gIGVsc2Uge1xuICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmlubmVyLCAndmlzLWhpZGRlbicpO1xuICB9XG5cbiAgLy8gdXBkYXRlIGNsYXNzTmFtZVxuICB2YXIgY2xhc3NOYW1lID0gZGF0YSAmJiBkYXRhLmNsYXNzTmFtZSB8fCBudWxsO1xuICBpZiAoY2xhc3NOYW1lICE9IHRoaXMuY2xhc3NOYW1lKSB7XG4gICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5sYWJlbCwgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uZm9yZWdyb3VuZCwgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uYmFja2dyb3VuZCwgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uYXhpcywgdGhpcy5jbGFzc05hbWUpO1xuICAgIH1cbiAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5sYWJlbCwgY2xhc3NOYW1lKTtcbiAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5mb3JlZ3JvdW5kLCBjbGFzc05hbWUpO1xuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmJhY2tncm91bmQsIGNsYXNzTmFtZSk7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uYXhpcywgY2xhc3NOYW1lKTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBzdHlsZVxuICBpZiAodGhpcy5zdHlsZSkge1xuICAgIHV0aWwucmVtb3ZlQ3NzVGV4dCh0aGlzLmRvbS5sYWJlbCwgdGhpcy5zdHlsZSk7XG4gICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5zdHlsZSkge1xuICAgIHV0aWwuYWRkQ3NzVGV4dCh0aGlzLmRvbS5sYWJlbCwgZGF0YS5zdHlsZSk7XG4gICAgdGhpcy5zdHlsZSA9IGRhdGEuc3R5bGU7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSB3aWR0aCBvZiB0aGUgZ3JvdXAgbGFiZWxcbiAqIEByZXR1cm4ge251bWJlcn0gd2lkdGhcbiAqL1xuR3JvdXAucHJvdG90eXBlLmdldExhYmVsV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMubGFiZWwud2lkdGg7XG59O1xuXG5cbi8qKlxuICogUmVwYWludCB0aGlzIGdyb3VwXG4gKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlXG4gKiBAcGFyYW0ge3tpdGVtOiB7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfSwgYXhpczogbnVtYmVyfX0gbWFyZ2luXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXN0YWNrPWZhbHNlXSAgRm9yY2UgcmVzdGFja2luZyBvZiBhbGwgaXRlbXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ3JvdXAgaXMgcmVzaXplZFxuICovXG5Hcm91cC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24ocmFuZ2UsIG1hcmdpbiwgcmVzdGFjaykge1xuICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuXG4gIC8vIGZvcmNlIHJlY2FsY3VsYXRpb24gb2YgdGhlIGhlaWdodCBvZiB0aGUgaXRlbXMgd2hlbiB0aGUgbWFya2VyIGhlaWdodCBjaGFuZ2VkXG4gIC8vIChkdWUgdG8gdGhlIFRpbWVsaW5lIGJlaW5nIGF0dGFjaGVkIHRvIHRoZSBET00gb3IgY2hhbmdlZCBmcm9tIGRpc3BsYXk6bm9uZSB0byB2aXNpYmxlKVxuICB2YXIgbWFya2VySGVpZ2h0ID0gdGhpcy5kb20ubWFya2VyLmNsaWVudEhlaWdodDtcbiAgaWYgKG1hcmtlckhlaWdodCAhPSB0aGlzLmxhc3RNYXJrZXJIZWlnaHQpIHtcbiAgICB0aGlzLmxhc3RNYXJrZXJIZWlnaHQgPSBtYXJrZXJIZWlnaHQ7XG5cbiAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGl0ZW0uZGlydHkgPSB0cnVlO1xuICAgICAgaWYgKGl0ZW0uZGlzcGxheWVkKSBpdGVtLnJlZHJhdygpO1xuICAgIH0pO1xuXG4gICAgcmVzdGFjayA9IHRydWU7XG4gIH1cblxuICAvLyByZXBvc2l0aW9uIHZpc2libGUgaXRlbXMgdmVydGljYWxseVxuICBpZiAodHlwZW9mIHRoaXMuaXRlbVNldC5vcHRpb25zLm9yZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gYSBjdXN0b20gb3JkZXIgZnVuY3Rpb25cblxuICAgIGlmIChyZXN0YWNrKSB7XG4gICAgICAvLyBicnV0ZSBmb3JjZSByZXN0YWNrIG9mIGFsbCBpdGVtc1xuXG4gICAgICAvLyBzaG93IGFsbCBpdGVtc1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBsaW1pdFNpemUgPSBmYWxzZTtcbiAgICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0uZGlzcGxheWVkKSB7XG4gICAgICAgICAgaXRlbS5yZWRyYXcoKTtcbiAgICAgICAgICBtZS52aXNpYmxlSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLnJlcG9zaXRpb25YKGxpbWl0U2l6ZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gb3JkZXIgYWxsIGl0ZW1zIGFuZCBmb3JjZSBhIHJlc3RhY2tpbmdcbiAgICAgIHZhciBjdXN0b21PcmRlcmVkSXRlbXMgPSB0aGlzLm9yZGVyZWRJdGVtcy5ieVN0YXJ0LnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gbWUuaXRlbVNldC5vcHRpb25zLm9yZGVyKGEuZGF0YSwgYi5kYXRhKTtcbiAgICAgIH0pO1xuICAgICAgc3RhY2suc3RhY2soY3VzdG9tT3JkZXJlZEl0ZW1zLCBtYXJnaW4sIHRydWUgLyogcmVzdGFjaz10cnVlICovKTtcbiAgICB9XG5cbiAgICB0aGlzLnZpc2libGVJdGVtcyA9IHRoaXMuX3VwZGF0ZVZpc2libGVJdGVtcyh0aGlzLm9yZGVyZWRJdGVtcywgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBubyBjdXN0b20gb3JkZXIgZnVuY3Rpb24sIGxhenkgc3RhY2tpbmdcbiAgICB0aGlzLnZpc2libGVJdGVtcyA9IHRoaXMuX3VwZGF0ZVZpc2libGVJdGVtcyh0aGlzLm9yZGVyZWRJdGVtcywgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcblxuICAgIGlmICh0aGlzLml0ZW1TZXQub3B0aW9ucy5zdGFjaykgeyAvLyBUT0RPOiB1Z2x5IHdheSB0byBhY2Nlc3Mgb3B0aW9ucy4uLlxuICAgICAgc3RhY2suc3RhY2sodGhpcy52aXNpYmxlSXRlbXMsIG1hcmdpbiwgcmVzdGFjayk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBubyBzdGFja2luZ1xuICAgICAgc3RhY2subm9zdGFjayh0aGlzLnZpc2libGVJdGVtcywgbWFyZ2luLCB0aGlzLnN1Ymdyb3Vwcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXBcbiAgdmFyIGhlaWdodCA9IHRoaXMuX2NhbGN1bGF0ZUhlaWdodChtYXJnaW4pO1xuXG4gIC8vIGNhbGN1bGF0ZSBhY3R1YWwgc2l6ZSBhbmQgcG9zaXRpb25cbiAgdmFyIGZvcmVncm91bmQgPSB0aGlzLmRvbS5mb3JlZ3JvdW5kO1xuICB0aGlzLnRvcCA9IGZvcmVncm91bmQub2Zmc2V0VG9wO1xuICB0aGlzLmxlZnQgPSBmb3JlZ3JvdW5kLm9mZnNldExlZnQ7XG4gIHRoaXMud2lkdGggPSBmb3JlZ3JvdW5kLm9mZnNldFdpZHRoO1xuICByZXNpemVkID0gdXRpbC51cGRhdGVQcm9wZXJ0eSh0aGlzLCAnaGVpZ2h0JywgaGVpZ2h0KSB8fCByZXNpemVkO1xuXG4gIC8vIHJlY2FsY3VsYXRlIHNpemUgb2YgbGFiZWxcbiAgcmVzaXplZCA9IHV0aWwudXBkYXRlUHJvcGVydHkodGhpcy5wcm9wcy5sYWJlbCwgJ3dpZHRoJywgdGhpcy5kb20uaW5uZXIuY2xpZW50V2lkdGgpIHx8IHJlc2l6ZWQ7XG4gIHJlc2l6ZWQgPSB1dGlsLnVwZGF0ZVByb3BlcnR5KHRoaXMucHJvcHMubGFiZWwsICdoZWlnaHQnLCB0aGlzLmRvbS5pbm5lci5jbGllbnRIZWlnaHQpIHx8IHJlc2l6ZWQ7XG5cbiAgLy8gYXBwbHkgbmV3IGhlaWdodFxuICB0aGlzLmRvbS5iYWNrZ3JvdW5kLnN0eWxlLmhlaWdodCAgPSBoZWlnaHQgKyAncHgnO1xuICB0aGlzLmRvbS5mb3JlZ3JvdW5kLnN0eWxlLmhlaWdodCAgPSBoZWlnaHQgKyAncHgnO1xuICB0aGlzLmRvbS5sYWJlbC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gIC8vIHVwZGF0ZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBpdGVtcyBhZnRlciB0aGV5IGFyZSByZS1zdGFja2VkIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cCBpcyBjYWxjdWxhdGVkXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMudmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMudmlzaWJsZUl0ZW1zW2ldO1xuICAgIGl0ZW0ucmVwb3NpdGlvblkobWFyZ2luKTtcbiAgfVxuXG4gIHJldHVybiByZXNpemVkO1xufTtcblxuLyoqXG4gKiByZWNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cFxuICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaGVpZ2h0XG4gKiBAcHJpdmF0ZVxuICovXG5Hcm91cC5wcm90b3R5cGUuX2NhbGN1bGF0ZUhlaWdodCA9IGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgLy8gcmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXBcbiAgdmFyIGhlaWdodDtcbiAgdmFyIHZpc2libGVJdGVtcyA9IHRoaXMudmlzaWJsZUl0ZW1zO1xuICAvL3ZhciB2aXNpYmxlU3ViZ3JvdXBzID0gW107XG4gIC8vdGhpcy52aXNpYmxlU3ViZ3JvdXBzID0gMDtcbiAgdGhpcy5yZXNldFN1Ymdyb3VwcygpO1xuICB2YXIgbWUgPSB0aGlzO1xuICBpZiAodmlzaWJsZUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbWluID0gdmlzaWJsZUl0ZW1zWzBdLnRvcDtcbiAgICB2YXIgbWF4ID0gdmlzaWJsZUl0ZW1zWzBdLnRvcCArIHZpc2libGVJdGVtc1swXS5oZWlnaHQ7XG4gICAgdXRpbC5mb3JFYWNoKHZpc2libGVJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgaXRlbS50b3ApO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCAoaXRlbS50b3AgKyBpdGVtLmhlaWdodCkpO1xuICAgICAgaWYgKGl0ZW0uZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdLmhlaWdodCA9IE1hdGgubWF4KG1lLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdLmhlaWdodCxpdGVtLmhlaWdodCk7XG4gICAgICAgIG1lLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdLnZpc2libGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChtaW4gPiBtYXJnaW4uYXhpcykge1xuICAgICAgLy8gdGhlcmUgaXMgYW4gZW1wdHkgZ2FwIGJldHdlZW4gdGhlIGxvd2VzdCBpdGVtIGFuZCB0aGUgYXhpc1xuICAgICAgdmFyIG9mZnNldCA9IG1pbiAtIG1hcmdpbi5heGlzO1xuICAgICAgbWF4IC09IG9mZnNldDtcbiAgICAgIHV0aWwuZm9yRWFjaCh2aXNpYmxlSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGl0ZW0udG9wIC09IG9mZnNldDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBoZWlnaHQgPSBtYXggKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbCAvIDI7XG4gIH1cbiAgZWxzZSB7XG4gICAgaGVpZ2h0ID0gMDtcbiAgfVxuICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHRoaXMucHJvcHMubGFiZWwuaGVpZ2h0KTtcblxuICByZXR1cm4gaGVpZ2h0O1xufTtcblxuLyoqXG4gKiBTaG93IHRoaXMgZ3JvdXA6IGF0dGFjaCB0byB0aGUgRE9NXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kb20ubGFiZWwucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuaXRlbVNldC5kb20ubGFiZWxTZXQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubGFiZWwpO1xuICB9XG5cbiAgaWYgKCF0aGlzLmRvbS5mb3JlZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLml0ZW1TZXQuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20uZm9yZWdyb3VuZCk7XG4gIH1cblxuICBpZiAoIXRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuaXRlbVNldC5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kKTtcbiAgfVxuXG4gIGlmICghdGhpcy5kb20uYXhpcy5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5pdGVtU2V0LmRvbS5heGlzLmFwcGVuZENoaWxkKHRoaXMuZG9tLmF4aXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEhpZGUgdGhpcyBncm91cDogcmVtb3ZlIGZyb20gdGhlIERPTVxuICovXG5Hcm91cC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGFiZWwgPSB0aGlzLmRvbS5sYWJlbDtcbiAgaWYgKGxhYmVsLnBhcmVudE5vZGUpIHtcbiAgICBsYWJlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxhYmVsKTtcbiAgfVxuXG4gIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5kb20uZm9yZWdyb3VuZDtcbiAgaWYgKGZvcmVncm91bmQucGFyZW50Tm9kZSkge1xuICAgIGZvcmVncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmb3JlZ3JvdW5kKTtcbiAgfVxuXG4gIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5kb20uYmFja2dyb3VuZDtcbiAgaWYgKGJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgIGJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiYWNrZ3JvdW5kKTtcbiAgfVxuXG4gIHZhciBheGlzID0gdGhpcy5kb20uYXhpcztcbiAgaWYgKGF4aXMucGFyZW50Tm9kZSkge1xuICAgIGF4aXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChheGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgYW4gaXRlbSB0byB0aGUgZ3JvdXBcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICovXG5Hcm91cC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaXRlbSkge1xuICB0aGlzLml0ZW1zW2l0ZW0uaWRdID0gaXRlbTtcbiAgaXRlbS5zZXRQYXJlbnQodGhpcyk7XG5cbiAgLy8gYWRkIHRvXG4gIGlmIChpdGVtLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0gPSB7aGVpZ2h0OjAsIHZpc2libGU6IGZhbHNlLCBpbmRleDp0aGlzLnN1Ymdyb3VwSW5kZXgsIGl0ZW1zOiBbXX07XG4gICAgICB0aGlzLnN1Ymdyb3VwSW5kZXgrKztcbiAgICB9XG4gICAgdGhpcy5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXS5pdGVtcy5wdXNoKGl0ZW0pO1xuICB9XG4gIHRoaXMub3JkZXJTdWJncm91cHMoKTtcblxuICBpZiAodGhpcy52aXNpYmxlSXRlbXMuaW5kZXhPZihpdGVtKSA9PSAtMSkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuaXRlbVNldC5ib2R5LnJhbmdlOyAvLyBUT0RPOiBub3QgbmljZSBhY2Nlc3NpbmcgdGhlIHJhbmdlIGxpa2UgdGhpc1xuICAgIHRoaXMuX2NoZWNrSWZWaXNpYmxlKGl0ZW0sIHRoaXMudmlzaWJsZUl0ZW1zLCByYW5nZSk7XG4gIH1cbn07XG5cbkdyb3VwLnByb3RvdHlwZS5vcmRlclN1Ymdyb3VwcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdWJncm91cE9yZGVyZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzb3J0QXJyYXkgPSBbXTtcbiAgICBpZiAodHlwZW9mIHRoaXMuc3ViZ3JvdXBPcmRlcmVyID09ICdzdHJpbmcnKSB7XG4gICAgICBmb3IgKHZhciBzdWJncm91cCBpbiB0aGlzLnN1Ymdyb3Vwcykge1xuICAgICAgICBzb3J0QXJyYXkucHVzaCh7c3ViZ3JvdXA6IHN1Ymdyb3VwLCBzb3J0RmllbGQ6IHRoaXMuc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pdGVtc1swXS5kYXRhW3RoaXMuc3ViZ3JvdXBPcmRlcmVyXX0pXG4gICAgICB9XG4gICAgICBzb3J0QXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5zb3J0RmllbGQgLSBiLnNvcnRGaWVsZDtcbiAgICAgIH0pXG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnN1Ymdyb3VwT3JkZXJlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmb3IgKHZhciBzdWJncm91cCBpbiB0aGlzLnN1Ymdyb3Vwcykge1xuICAgICAgICBzb3J0QXJyYXkucHVzaCh0aGlzLnN1Ymdyb3Vwc1tzdWJncm91cF0uaXRlbXNbMF0uZGF0YSk7XG4gICAgICB9XG4gICAgICBzb3J0QXJyYXkuc29ydCh0aGlzLnN1Ymdyb3VwT3JkZXJlcik7XG4gICAgfVxuXG4gICAgaWYgKHNvcnRBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnN1Ymdyb3Vwc1tzb3J0QXJyYXlbaV0uc3ViZ3JvdXBdLmluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkdyb3VwLnByb3RvdHlwZS5yZXNldFN1Ymdyb3VwcyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBzdWJncm91cCBpbiB0aGlzLnN1Ymdyb3Vwcykge1xuICAgIGlmICh0aGlzLnN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgIHRoaXMuc3ViZ3JvdXBzW3N1Ymdyb3VwXS52aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGdyb3VwXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqL1xuR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgZGVsZXRlIHRoaXMuaXRlbXNbaXRlbS5pZF07XG4gIGl0ZW0uc2V0UGFyZW50KG51bGwpO1xuXG4gIC8vIHJlbW92ZSBmcm9tIHZpc2libGUgaXRlbXNcbiAgdmFyIGluZGV4ID0gdGhpcy52aXNpYmxlSXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGluZGV4ICE9IC0xKSB0aGlzLnZpc2libGVJdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIGlmKGl0ZW0uZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKXtcbiAgICB2YXIgc3ViZ3JvdXAgPSB0aGlzLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdO1xuICAgIGlmIChzdWJncm91cCl7XG4gICAgICB2YXIgaXRlbUluZGV4ID0gc3ViZ3JvdXAuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgIHN1Ymdyb3VwLml0ZW1zLnNwbGljZShpdGVtSW5kZXgsMSk7XG4gICAgICBpZiAoIXN1Ymdyb3VwLml0ZW1zLmxlbmd0aCl7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdO1xuICAgICAgICB0aGlzLnN1Ymdyb3VwSW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3JkZXJTdWJncm91cHMoKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIERhdGFTZXRcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICovXG5Hcm91cC5wcm90b3R5cGUucmVtb3ZlRnJvbURhdGFTZXQgPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuaXRlbVNldC5yZW1vdmVJdGVtKGl0ZW0uaWQpO1xufTtcblxuXG4vKipcbiAqIFJlb3JkZXIgdGhlIGl0ZW1zXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5vcmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5pdGVtcyk7XG4gIHZhciBzdGFydEFycmF5ID0gW107XG4gIHZhciBlbmRBcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0uZGF0YS5lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kQXJyYXkucHVzaChhcnJheVtpXSk7XG4gICAgfVxuICAgIHN0YXJ0QXJyYXkucHVzaChhcnJheVtpXSk7XG4gIH1cbiAgdGhpcy5vcmRlcmVkSXRlbXMgPSB7XG4gICAgYnlTdGFydDogc3RhcnRBcnJheSxcbiAgICBieUVuZDogZW5kQXJyYXlcbiAgfTtcblxuICBzdGFjay5vcmRlckJ5U3RhcnQodGhpcy5vcmRlcmVkSXRlbXMuYnlTdGFydCk7XG4gIHN0YWNrLm9yZGVyQnlFbmQodGhpcy5vcmRlcmVkSXRlbXMuYnlFbmQpO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdmlzaWJsZSBpdGVtc1xuICogQHBhcmFtIHt7YnlTdGFydDogSXRlbVtdLCBieUVuZDogSXRlbVtdfX0gb3JkZXJlZEl0ZW1zICAgQWxsIGl0ZW1zIG9yZGVyZWQgYnkgc3RhcnQgZGF0ZSBhbmQgYnkgZW5kIGRhdGVcbiAqIEBwYXJhbSB7SXRlbVtdfSB2aXNpYmxlSXRlbXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBwcmV2aW91c2x5IHZpc2libGUgaXRlbXMuXG4gKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlICAgICAgICAgICAgICBWaXNpYmxlIHJhbmdlXG4gKiBAcmV0dXJuIHtJdGVtW119IHZpc2libGVJdGVtcyAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbmV3IHZpc2libGUgaXRlbXMuXG4gKiBAcHJpdmF0ZVxuICovXG5Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVZpc2libGVJdGVtcyA9IGZ1bmN0aW9uKG9yZGVyZWRJdGVtcywgb2xkVmlzaWJsZUl0ZW1zLCByYW5nZSkge1xuICB2YXIgdmlzaWJsZUl0ZW1zID0gW107XG4gIHZhciB2aXNpYmxlSXRlbXNMb29rdXAgPSB7fTsgLy8gd2Uga2VlcCB0aGlzIHRvIHF1aWNrbHkgbG9vayB1cCBpZiBhbiBpdGVtIGFscmVhZHkgZXhpc3RzIGluIHRoZSBsaXN0IHdpdGhvdXQgdXNpbmcgaW5kZXhPZiBvbiB2aXNpYmxlSXRlbXNcbiAgdmFyIGludGVydmFsID0gKHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0KSAvIDQ7XG4gIHZhciBsb3dlckJvdW5kID0gcmFuZ2Uuc3RhcnQgLSBpbnRlcnZhbDtcbiAgdmFyIHVwcGVyQm91bmQgPSByYW5nZS5lbmQgKyBpbnRlcnZhbDtcbiAgdmFyIGl0ZW0sIGk7XG5cbiAgLy8gdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGRvIHRoZSBiaW5hcnkgc2VhcmNoLlxuICB2YXIgc2VhcmNoRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAgICAgICh2YWx1ZSA8IGxvd2VyQm91bmQpICB7cmV0dXJuIC0xO31cbiAgICBlbHNlIGlmICh2YWx1ZSA8PSB1cHBlckJvdW5kKSB7cmV0dXJuICAwO31cbiAgICBlbHNlICAgICAgICAgICAgICAgICAgICAgICAgICB7cmV0dXJuICAxO31cbiAgfVxuXG4gIC8vIGZpcnN0IGNoZWNrIGlmIHRoZSBpdGVtcyB0aGF0IHdlcmUgaW4gdmlldyBwcmV2aW91c2x5IGFyZSBzdGlsbCBpbiB2aWV3LlxuICAvLyBJTVBPUlRBTlQ6IHRoaXMgaGFuZGxlcyB0aGUgY2FzZSBmb3IgdGhlIGl0ZW1zIHdpdGggc3RhcnRkYXRlIGJlZm9yZSB0aGUgd2luZG93IGFuZCBlbmRkYXRlIGFmdGVyIHRoZSB3aW5kb3chXG4gIC8vIGFsc28gY2xlYW5zIHVwIGludmlzaWJsZSBpdGVtcy5cbiAgaWYgKG9sZFZpc2libGVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG9sZFZpc2libGVJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY2hlY2tJZlZpc2libGVXaXRoUmVmZXJlbmNlKG9sZFZpc2libGVJdGVtc1tpXSwgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICAvLyB3ZSBkbyBhIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpdGVtcyB0aGF0IGhhdmUgb25seSBzdGFydCB2YWx1ZXMuXG4gIHZhciBpbml0aWFsUG9zQnlTdGFydCA9IHV0aWwuYmluYXJ5U2VhcmNoQ3VzdG9tKG9yZGVyZWRJdGVtcy5ieVN0YXJ0LCBzZWFyY2hGdW5jdGlvbiwgJ2RhdGEnLCdzdGFydCcpO1xuXG4gIC8vIHRyYWNlIHRoZSB2aXNpYmxlIGl0ZW1zIGZyb20gdGhlIGluaXRhbCBzdGFydCBwb3MgYm90aCB3YXlzIHVudGlsIGFuIGludmlzaWJsZSBpdGVtIGlzIGZvdW5kLCB3ZSBvbmx5IGxvb2sgYXQgdGhlIHN0YXJ0IHZhbHVlcy5cbiAgdGhpcy5fdHJhY2VWaXNpYmxlKGluaXRpYWxQb3NCeVN0YXJ0LCBvcmRlcmVkSXRlbXMuYnlTdGFydCwgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIChpdGVtLmRhdGEuc3RhcnQgPCBsb3dlckJvdW5kIHx8IGl0ZW0uZGF0YS5zdGFydCA+IHVwcGVyQm91bmQpO1xuICB9KTtcblxuICAvLyBpZiB0aGUgd2luZG93IGhhcyBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHkgd2l0aG91dCBvdmVybGFwcGluZyB0aGUgb2xkIHdpbmRvdywgdGhlIHJhbmdlZCBpdGVtcyB3aXRoIHN0YXJ0IDwgbG93ZXJCb3VuZCBhbmQgZW5kID4gdXBwZXJib3VuZCBhcmUgbm90IHNob3duLlxuICAvLyBXZSB0aGVyZWZvcmUgaGF2ZSB0byBicnV0ZSBmb3JjZSBjaGVjayBhbGwgaXRlbXMgaW4gdGhlIGJ5RW5kIGxpc3RcbiAgaWYgKHRoaXMuY2hlY2tSYW5nZWRJdGVtcyA9PSB0cnVlKSB7XG4gICAgdGhpcy5jaGVja1JhbmdlZEl0ZW1zID0gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IG9yZGVyZWRJdGVtcy5ieUVuZC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY2hlY2tJZlZpc2libGVXaXRoUmVmZXJlbmNlKG9yZGVyZWRJdGVtcy5ieUVuZFtpXSwgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIHJhbmdlKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gd2UgZG8gYSBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaXRlbXMgdGhhdCBoYXZlIGRlZmluZWQgZW5kIHRpbWVzLlxuICAgIHZhciBpbml0aWFsUG9zQnlFbmQgPSB1dGlsLmJpbmFyeVNlYXJjaEN1c3RvbShvcmRlcmVkSXRlbXMuYnlFbmQsIHNlYXJjaEZ1bmN0aW9uLCAnZGF0YScsJ2VuZCcpO1xuXG4gICAgLy8gdHJhY2UgdGhlIHZpc2libGUgaXRlbXMgZnJvbSB0aGUgaW5pdGFsIHN0YXJ0IHBvcyBib3RoIHdheXMgdW50aWwgYW4gaW52aXNpYmxlIGl0ZW0gaXMgZm91bmQsIHdlIG9ubHkgbG9vayBhdCB0aGUgZW5kIHZhbHVlcy5cbiAgICB0aGlzLl90cmFjZVZpc2libGUoaW5pdGlhbFBvc0J5RW5kLCBvcmRlcmVkSXRlbXMuYnlFbmQsIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIChpdGVtLmRhdGEuZW5kIDwgbG93ZXJCb3VuZCB8fCBpdGVtLmRhdGEuZW5kID4gdXBwZXJCb3VuZCk7XG4gICAgfSk7XG4gIH1cblxuXG4gIC8vIGZpbmFsbHksIHdlIHJlcG9zaXRpb24gYWxsIHRoZSB2aXNpYmxlIGl0ZW1zLlxuICBmb3IgKGkgPSAwOyBpIDwgdmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaXRlbSA9IHZpc2libGVJdGVtc1tpXTtcbiAgICBpZiAoIWl0ZW0uZGlzcGxheWVkKSBpdGVtLnNob3coKTtcbiAgICAvLyByZXBvc2l0aW9uIGl0ZW0gaG9yaXpvbnRhbGx5XG4gICAgaXRlbS5yZXBvc2l0aW9uWCgpO1xuICB9XG5cbiAgLy8gZGVidWdcbiAgLy9jb25zb2xlLmxvZyhcIm5ldyBsaW5lXCIpXG4gIC8vaWYgKHRoaXMuZ3JvdXBJZCA9PSBudWxsKSB7XG4gIC8vICBmb3IgKGkgPSAwOyBpIDwgb3JkZXJlZEl0ZW1zLmJ5U3RhcnQubGVuZ3RoOyBpKyspIHtcbiAgLy8gICAgaXRlbSA9IG9yZGVyZWRJdGVtcy5ieVN0YXJ0W2ldLmRhdGE7XG4gIC8vICAgIGNvbnNvbGUubG9nKCdzdGFydCcsaSxpbml0aWFsUG9zQnlTdGFydCwgaXRlbS5zdGFydC52YWx1ZU9mKCksIGl0ZW0uY29udGVudCwgaXRlbS5zdGFydCA+PSBsb3dlckJvdW5kICYmIGl0ZW0uc3RhcnQgPD0gdXBwZXJCb3VuZCxpID09IGluaXRpYWxQb3NCeVN0YXJ0ID8gXCI8LS0tLS0tLS0tLS0tLS0tLS0tLSBIRVJFRUVFXCIgOiBcIlwiKVxuICAvLyAgfVxuICAvLyAgZm9yIChpID0gMDsgaSA8IG9yZGVyZWRJdGVtcy5ieUVuZC5sZW5ndGg7IGkrKykge1xuICAvLyAgICBpdGVtID0gb3JkZXJlZEl0ZW1zLmJ5RW5kW2ldLmRhdGE7XG4gIC8vICAgIGNvbnNvbGUubG9nKCdyYW5nZUVuZCcsaSxpbml0aWFsUG9zQnlFbmQsIGl0ZW0uZW5kLnZhbHVlT2YoKSwgaXRlbS5jb250ZW50LCBpdGVtLmVuZCA+PSByYW5nZS5zdGFydCAmJiBpdGVtLmVuZCA8PSByYW5nZS5lbmQsaSA9PSBpbml0aWFsUG9zQnlFbmQgPyBcIjwtLS0tLS0tLS0tLS0tLS0tLS0tIEhFUkVFRUVcIiA6IFwiXCIpXG4gIC8vICB9XG4gIC8vfVxuXG4gIHJldHVybiB2aXNpYmxlSXRlbXM7XG59O1xuXG5Hcm91cC5wcm90b3R5cGUuX3RyYWNlVmlzaWJsZSA9IGZ1bmN0aW9uIChpbml0aWFsUG9zLCBpdGVtcywgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIGJyZWFrQ29uZGl0aW9uKSB7XG4gIHZhciBpdGVtO1xuICB2YXIgaTtcblxuICBpZiAoaW5pdGlhbFBvcyAhPSAtMSkge1xuICAgIGZvciAoaSA9IGluaXRpYWxQb3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBpZiAoYnJlYWtDb25kaXRpb24oaXRlbSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHZpc2libGVJdGVtc0xvb2t1cFtpdGVtLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICB2aXNpYmxlSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IGluaXRpYWxQb3MgKyAxOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGlmIChicmVha0NvbmRpdGlvbihpdGVtKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiB0aGlzIGZ1bmN0aW9uIGlzIHZlcnkgc2ltaWxhciB0byB0aGUgX2NoZWNrSWZJbnZpc2libGUoKSBidXQgaXQgZG9lcyBub3RcbiAqIHJldHVybiBib29sZWFucywgaGlkZXMgdGhlIGl0ZW0gaWYgaXQgc2hvdWxkIG5vdCBiZSBzZWVuIGFuZCBhbHdheXMgYWRkcyB0b1xuICogdGhlIHZpc2libGVJdGVtcy5cbiAqIHRoaXMgb25lIGlzIGZvciBicnV0ZSBmb3JjaW5nIGFuZCBoaWRpbmcuXG4gKlxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge0FycmF5fSB2aXNpYmxlSXRlbXNcbiAqIEBwYXJhbSB7e3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn19IHJhbmdlXG4gKiBAcHJpdmF0ZVxuICovXG5Hcm91cC5wcm90b3R5cGUuX2NoZWNrSWZWaXNpYmxlID0gZnVuY3Rpb24oaXRlbSwgdmlzaWJsZUl0ZW1zLCByYW5nZSkge1xuICAgIGlmIChpdGVtLmlzVmlzaWJsZShyYW5nZSkpIHtcbiAgICAgIGlmICghaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uc2hvdygpO1xuICAgICAgLy8gcmVwb3NpdGlvbiBpdGVtIGhvcml6b250YWxseVxuICAgICAgaXRlbS5yZXBvc2l0aW9uWCgpO1xuICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGl0ZW0uZGlzcGxheWVkKSBpdGVtLmhpZGUoKTtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIF9jaGVja0lmSW52aXNpYmxlKCkgYnV0IGl0IGRvZXMgbm90XG4gKiByZXR1cm4gYm9vbGVhbnMsIGhpZGVzIHRoZSBpdGVtIGlmIGl0IHNob3VsZCBub3QgYmUgc2VlbiBhbmQgYWx3YXlzIGFkZHMgdG9cbiAqIHRoZSB2aXNpYmxlSXRlbXMuXG4gKiB0aGlzIG9uZSBpcyBmb3IgYnJ1dGUgZm9yY2luZyBhbmQgaGlkaW5nLlxuICpcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtBcnJheX0gdmlzaWJsZUl0ZW1zXG4gKiBAcGFyYW0ge3tzdGFydDpudW1iZXIsIGVuZDpudW1iZXJ9fSByYW5nZVxuICogQHByaXZhdGVcbiAqL1xuR3JvdXAucHJvdG90eXBlLl9jaGVja0lmVmlzaWJsZVdpdGhSZWZlcmVuY2UgPSBmdW5jdGlvbihpdGVtLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgcmFuZ2UpIHtcbiAgaWYgKGl0ZW0uaXNWaXNpYmxlKHJhbmdlKSkge1xuICAgIGlmICh2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID0gdHJ1ZTtcbiAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uaGlkZSgpO1xuICB9XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cDtcbiJdfQ==
},{"../../util":46,"../Stack":29,"./item/RangeItem":43}],37:[function(require,module,exports){
'use strict';

var Hammer = require('../../module/hammer');
var util = require('../../util');
var DataSet = require('../../DataSet');
var DataView = require('../../DataView');
var TimeStep = require('../TimeStep');
var Component = require('./Component');
var Group = require('./Group');
var BackgroundGroup = require('./BackgroundGroup');
var BoxItem = require('./item/BoxItem');
var PointItem = require('./item/PointItem');
var RangeItem = require('./item/RangeItem');
var BackgroundItem = require('./item/BackgroundItem');

var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items
var BACKGROUND = '__background__'; // reserved group id for background items without group

/**
 * An ItemSet holds a set of items and ranges which can be displayed in a
 * range. The width is determined by the parent of the ItemSet, and the height
 * is determined by the size of the items.
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
 * @param {Object} [options]      See ItemSet.setOptions for the available options.
 * @constructor ItemSet
 * @extends Component
 */
function ItemSet(body, options) {
  this.body = body;

  this.defaultOptions = {
    type: null, // 'box', 'point', 'range', 'background'
    orientation: {
      item: 'bottom' // item orientation: 'top' or 'bottom'
    },
    align: 'auto', // alignment of box items
    stack: true,
    groupOrderSwap: function groupOrderSwap(fromGroup, toGroup, groups) {
      var targetOrder = toGroup.order;
      toGroup.order = fromGroup.order;
      fromGroup.order = targetOrder;
    },
    groupOrder: 'order',

    selectable: true,
    multiselect: false,

    editable: {
      updateTime: false,
      updateGroup: false,
      add: false,
      remove: false
    },

    groupEditable: {
      order: false,
      add: false,
      remove: false
    },

    snap: TimeStep.snap,

    onAdd: function onAdd(item, callback) {
      callback(item);
    },
    onUpdate: function onUpdate(item, callback) {
      callback(item);
    },
    onMove: function onMove(item, callback) {
      callback(item);
    },
    onRemove: function onRemove(item, callback) {
      callback(item);
    },
    onMoving: function onMoving(item, callback) {
      callback(item);
    },
    onAddGroup: function onAddGroup(item, callback) {
      callback(item);
    },
    onMoveGroup: function onMoveGroup(item, callback) {
      callback(item);
    },
    onRemoveGroup: function onRemoveGroup(item, callback) {
      callback(item);
    },

    margin: {
      item: {
        horizontal: 10,
        vertical: 10
      },
      axis: 20
    }
  };

  // options is shared by this ItemSet and all its items
  this.options = util.extend({}, this.defaultOptions);

  // options for getting items from the DataSet with the correct type
  this.itemOptions = {
    type: { start: 'Date', end: 'Date' }
  };

  this.conversion = {
    toScreen: body.util.toScreen,
    toTime: body.util.toTime
  };
  this.dom = {};
  this.props = {};
  this.hammer = null;

  var me = this;
  this.itemsData = null; // DataSet
  this.groupsData = null; // DataSet

  // listeners for the DataSet of the items
  this.itemListeners = {
    'add': function add(event, params, senderId) {
      me._onAdd(params.items);
    },
    'update': function update(event, params, senderId) {
      me._onUpdate(params.items);
    },
    'remove': function remove(event, params, senderId) {
      me._onRemove(params.items);
    }
  };

  // listeners for the DataSet of the groups
  this.groupListeners = {
    'add': function add(event, params, senderId) {
      me._onAddGroups(params.items);
    },
    'update': function update(event, params, senderId) {
      me._onUpdateGroups(params.items);
    },
    'remove': function remove(event, params, senderId) {
      me._onRemoveGroups(params.items);
    }
  };

  this.items = {}; // object with an Item for every data item
  this.groups = {}; // Group object for every group
  this.groupIds = [];

  this.selection = []; // list with the ids of all selected nodes
  this.stackDirty = true; // if true, all items will be restacked on next redraw

  this.touchParams = {}; // stores properties while dragging
  this.groupTouchParams = {};
  // create the HTML DOM

  this._create();

  this.setOptions(options);
}

ItemSet.prototype = new Component();

// available item types will be registered here
ItemSet.types = {
  background: BackgroundItem,
  box: BoxItem,
  range: RangeItem,
  point: PointItem
};

/**
 * Create the HTML DOM for the ItemSet
 */
ItemSet.prototype._create = function () {
  var frame = document.createElement('div');
  frame.className = 'vis-itemset';
  frame['timeline-itemset'] = this;
  this.dom.frame = frame;

  // create background panel
  var background = document.createElement('div');
  background.className = 'vis-background';
  frame.appendChild(background);
  this.dom.background = background;

  // create foreground panel
  var foreground = document.createElement('div');
  foreground.className = 'vis-foreground';
  frame.appendChild(foreground);
  this.dom.foreground = foreground;

  // create axis panel
  var axis = document.createElement('div');
  axis.className = 'vis-axis';
  this.dom.axis = axis;

  // create labelset
  var labelSet = document.createElement('div');
  labelSet.className = 'vis-labelset';
  this.dom.labelSet = labelSet;

  // create ungrouped Group
  this._updateUngrouped();

  // create background Group
  var backgroundGroup = new BackgroundGroup(BACKGROUND, null, this);
  backgroundGroup.show();
  this.groups[BACKGROUND] = backgroundGroup;

  // attach event listeners
  // Note: we bind to the centerContainer for the case where the height
  //       of the center container is larger than of the ItemSet, so we
  //       can click in the empty area to create a new item or deselect an item.
  this.hammer = new Hammer(this.body.dom.centerContainer);

  // drag items when selected
  this.hammer.on('hammer.input', (function (event) {
    if (event.isFirst) {
      this._onTouch(event);
    }
  }).bind(this));
  this.hammer.on('panstart', this._onDragStart.bind(this));
  this.hammer.on('panmove', this._onDrag.bind(this));
  this.hammer.on('panend', this._onDragEnd.bind(this));
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.

  // single select (or unselect) when tapping an item
  this.hammer.on('tap', this._onSelectItem.bind(this));

  // multi select when holding mouse/touch, or on ctrl+click
  this.hammer.on('press', this._onMultiSelectItem.bind(this));

  // add item on doubletap
  this.hammer.on('doubletap', this._onAddItem.bind(this));

  this.groupHammer = new Hammer(this.body.dom.leftContainer);
  this.groupHammer.on('panstart', this._onGroupDragStart.bind(this));
  this.groupHammer.on('panmove', this._onGroupDrag.bind(this));
  this.groupHammer.on('panend', this._onGroupDragEnd.bind(this));
  this.groupHammer.get('pan').set({ threshold: 5, direction: 30 });

  // attach to the DOM
  this.show();
};

/**
 * Set options for the ItemSet. Existing options will be extended/overwritten.
 * @param {Object} [options] The following options are available:
 *                           {String} type
 *                              Default type for the items. Choose from 'box'
 *                              (default), 'point', 'range', or 'background'.
 *                              The default style can be overwritten by
 *                              individual items.
 *                           {String} align
 *                              Alignment for the items, only applicable for
 *                              BoxItem. Choose 'center' (default), 'left', or
 *                              'right'.
 *                           {String} orientation.item
 *                              Orientation of the item set. Choose 'top' or
 *                              'bottom' (default).
 *                           {Function} groupOrder
 *                              A sorting function for ordering groups
 *                           {Boolean} stack
 *                              If true (default), items will be stacked on
 *                              top of each other.
 *                           {Number} margin.axis
 *                              Margin between the axis and the items in pixels.
 *                              Default is 20.
 *                           {Number} margin.item.horizontal
 *                              Horizontal margin between items in pixels.
 *                              Default is 10.
 *                           {Number} margin.item.vertical
 *                              Vertical Margin between items in pixels.
 *                              Default is 10.
 *                           {Number} margin.item
 *                              Margin between items in pixels in both horizontal
 *                              and vertical direction. Default is 10.
 *                           {Number} margin
 *                              Set margin for both axis and items in pixels.
 *                           {Boolean} selectable
 *                              If true (default), items can be selected.
 *                           {Boolean} multiselect
 *                              If true, multiple items can be selected.
 *                              False by default.
 *                           {Boolean} editable
 *                              Set all editable options to true or false
 *                           {Boolean} editable.updateTime
 *                              Allow dragging an item to an other moment in time
 *                           {Boolean} editable.updateGroup
 *                              Allow dragging an item to an other group
 *                           {Boolean} editable.add
 *                              Allow creating new items on double tap
 *                           {Boolean} editable.remove
 *                              Allow removing items by clicking the delete button
 *                              top right of a selected item.
 *                           {Function(item: Item, callback: Function)} onAdd
 *                              Callback function triggered when an item is about to be added:
 *                              when the user double taps an empty space in the Timeline.
 *                           {Function(item: Item, callback: Function)} onUpdate
 *                              Callback function fired when an item is about to be updated.
 *                              This function typically has to show a dialog where the user
 *                              change the item. If not implemented, nothing happens.
 *                           {Function(item: Item, callback: Function)} onMove
 *                              Fired when an item has been moved. If not implemented,
 *                              the move action will be accepted.
 *                           {Function(item: Item, callback: Function)} onRemove
 *                              Fired when an item is about to be deleted.
 *                              If not implemented, the item will be always removed.
 */
ItemSet.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    var fields = ['type', 'align', 'order', 'stack', 'selectable', 'multiselect', 'groupOrder', 'dataAttributes', 'template', 'groupTemplate', 'hide', 'snap', 'groupOrderSwap'];
    util.selectiveExtend(fields, this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation.item = options.orientation === 'top' ? 'top' : 'bottom';
      } else if (typeof options.orientation === 'object' && 'item' in options.orientation) {
        this.options.orientation.item = options.orientation.item;
      }
    }

    if ('margin' in options) {
      if (typeof options.margin === 'number') {
        this.options.margin.axis = options.margin;
        this.options.margin.item.horizontal = options.margin;
        this.options.margin.item.vertical = options.margin;
      } else if (typeof options.margin === 'object') {
        util.selectiveExtend(['axis'], this.options.margin, options.margin);
        if ('item' in options.margin) {
          if (typeof options.margin.item === 'number') {
            this.options.margin.item.horizontal = options.margin.item;
            this.options.margin.item.vertical = options.margin.item;
          } else if (typeof options.margin.item === 'object') {
            util.selectiveExtend(['horizontal', 'vertical'], this.options.margin.item, options.margin.item);
          }
        }
      }
    }

    if ('editable' in options) {
      if (typeof options.editable === 'boolean') {
        this.options.editable.updateTime = options.editable;
        this.options.editable.updateGroup = options.editable;
        this.options.editable.add = options.editable;
        this.options.editable.remove = options.editable;
      } else if (typeof options.editable === 'object') {
        util.selectiveExtend(['updateTime', 'updateGroup', 'add', 'remove'], this.options.editable, options.editable);
      }
    }

    if ('groupEditable' in options) {
      if (typeof options.groupEditable === 'boolean') {
        this.options.groupEditable.order = options.groupEditable;
        this.options.groupEditable.add = options.groupEditable;
        this.options.groupEditable.remove = options.groupEditable;
      } else if (typeof options.groupEditable === 'object') {
        util.selectiveExtend(['order', 'add', 'remove'], this.options.groupEditable, options.groupEditable);
      }
    }

    // callback functions
    var addCallback = (function (name) {
      var fn = options[name];
      if (fn) {
        if (!(fn instanceof Function)) {
          throw new Error('option ' + name + ' must be a function ' + name + '(item, callback)');
        }
        this.options[name] = fn;
      }
    }).bind(this);
    ['onAdd', 'onUpdate', 'onRemove', 'onMove', 'onMoving', 'onAddGroup', 'onMoveGroup', 'onRemoveGroup'].forEach(addCallback);

    // force the itemSet to refresh: options like orientation and margins may be changed
    this.markDirty();
  }
};

/**
 * Mark the ItemSet dirty so it will refresh everything with next redraw.
 * Optionally, all items can be marked as dirty and be refreshed.
 * @param {{refreshItems: boolean}} [options]
 */
ItemSet.prototype.markDirty = function (options) {
  this.groupIds = [];
  this.stackDirty = true;

  if (options && options.refreshItems) {
    util.forEach(this.items, function (item) {
      item.dirty = true;
      if (item.displayed) item.redraw();
    });
  }
};

/**
 * Destroy the ItemSet
 */
ItemSet.prototype.destroy = function () {
  this.hide();
  this.setItems(null);
  this.setGroups(null);

  this.hammer = null;

  this.body = null;
  this.conversion = null;
};

/**
 * Hide the component from the DOM
 */
ItemSet.prototype.hide = function () {
  // remove the frame containing the items
  if (this.dom.frame.parentNode) {
    this.dom.frame.parentNode.removeChild(this.dom.frame);
  }

  // remove the axis with dots
  if (this.dom.axis.parentNode) {
    this.dom.axis.parentNode.removeChild(this.dom.axis);
  }

  // remove the labelset containing all group labels
  if (this.dom.labelSet.parentNode) {
    this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);
  }
};

/**
 * Show the component in the DOM (when not already visible).
 * @return {Boolean} changed
 */
ItemSet.prototype.show = function () {
  // show frame containing the items
  if (!this.dom.frame.parentNode) {
    this.body.dom.center.appendChild(this.dom.frame);
  }

  // show axis with dots
  if (!this.dom.axis.parentNode) {
    this.body.dom.backgroundVertical.appendChild(this.dom.axis);
  }

  // show labelset containing labels
  if (!this.dom.labelSet.parentNode) {
    this.body.dom.left.appendChild(this.dom.labelSet);
  }
};

/**
 * Set selected items by their id. Replaces the current selection
 * Unknown id's are silently ignored.
 * @param {string[] | string} [ids] An array with zero or more id's of the items to be
 *                                  selected, or a single item id. If ids is undefined
 *                                  or an empty array, all items will be unselected.
 */
ItemSet.prototype.setSelection = function (ids) {
  var i, ii, id, item;

  if (ids == undefined) ids = [];
  if (!Array.isArray(ids)) ids = [ids];

  // unselect currently selected items
  for (i = 0, ii = this.selection.length; i < ii; i++) {
    id = this.selection[i];
    item = this.items[id];
    if (item) item.unselect();
  }

  // select items
  this.selection = [];
  for (i = 0, ii = ids.length; i < ii; i++) {
    id = ids[i];
    item = this.items[id];
    if (item) {
      this.selection.push(id);
      item.select();
    }
  }
};

/**
 * Get the selected items by their id
 * @return {Array} ids  The ids of the selected items
 */
ItemSet.prototype.getSelection = function () {
  return this.selection.concat([]);
};

/**
 * Get the id's of the currently visible items.
 * @returns {Array} The ids of the visible items
 */
ItemSet.prototype.getVisibleItems = function () {
  var range = this.body.range.getRange();
  var left = this.body.util.toScreen(range.start);
  var right = this.body.util.toScreen(range.end);

  var ids = [];
  for (var groupId in this.groups) {
    if (this.groups.hasOwnProperty(groupId)) {
      var group = this.groups[groupId];
      var rawVisibleItems = group.visibleItems;

      // filter the "raw" set with visibleItems into a set which is really
      // visible by pixels
      for (var i = 0; i < rawVisibleItems.length; i++) {
        var item = rawVisibleItems[i];
        // TODO: also check whether visible vertically
        if (item.left < right && item.left + item.width > left) {
          ids.push(item.id);
        }
      }
    }
  }

  return ids;
};

/**
 * Deselect a selected item
 * @param {String | Number} id
 * @private
 */
ItemSet.prototype._deselect = function (id) {
  var selection = this.selection;
  for (var i = 0, ii = selection.length; i < ii; i++) {
    if (selection[i] == id) {
      // non-strict comparison!
      selection.splice(i, 1);
      break;
    }
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
ItemSet.prototype.redraw = function () {
  var margin = this.options.margin,
      range = this.body.range,
      asSize = util.option.asSize,
      options = this.options,
      orientation = options.orientation.item,
      resized = false,
      frame = this.dom.frame;

  // recalculate absolute position (before redrawing groups)
  this.props.top = this.body.domProps.top.height + this.body.domProps.border.top;
  this.props.left = this.body.domProps.left.width + this.body.domProps.border.left;

  // update class name
  frame.className = 'vis-itemset';

  // reorder the groups (if needed)
  resized = this._orderGroups() || resized;

  // check whether zoomed (in that case we need to re-stack everything)
  // TODO: would be nicer to get this as a trigger from Range
  var visibleInterval = range.end - range.start;
  var zoomed = visibleInterval != this.lastVisibleInterval || this.props.width != this.props.lastWidth;
  if (zoomed) this.stackDirty = true;
  this.lastVisibleInterval = visibleInterval;
  this.props.lastWidth = this.props.width;

  var restack = this.stackDirty;
  var firstGroup = this._firstGroup();
  var firstMargin = {
    item: margin.item,
    axis: margin.axis
  };
  var nonFirstMargin = {
    item: margin.item,
    axis: margin.item.vertical / 2
  };
  var height = 0;
  var minHeight = margin.axis + margin.item.vertical;

  // redraw the background group
  this.groups[BACKGROUND].redraw(range, nonFirstMargin, restack);

  // redraw all regular groups
  util.forEach(this.groups, function (group) {
    var groupMargin = group == firstGroup ? firstMargin : nonFirstMargin;
    var groupResized = group.redraw(range, groupMargin, restack);
    resized = groupResized || resized;
    height += group.height;
  });
  height = Math.max(height, minHeight);
  this.stackDirty = false;

  // update frame height
  frame.style.height = asSize(height);

  // calculate actual size
  this.props.width = frame.offsetWidth;
  this.props.height = height;

  // reposition axis
  this.dom.axis.style.top = asSize(orientation == 'top' ? this.body.domProps.top.height + this.body.domProps.border.top : this.body.domProps.top.height + this.body.domProps.centerContainer.height);
  this.dom.axis.style.left = '0';

  // check if this component is resized
  resized = this._isResized() || resized;

  return resized;
};

/**
 * Get the first group, aligned with the axis
 * @return {Group | null} firstGroup
 * @private
 */
ItemSet.prototype._firstGroup = function () {
  var firstGroupIndex = this.options.orientation.item == 'top' ? 0 : this.groupIds.length - 1;
  var firstGroupId = this.groupIds[firstGroupIndex];
  var firstGroup = this.groups[firstGroupId] || this.groups[UNGROUPED];

  return firstGroup || null;
};

/**
 * Create or delete the group holding all ungrouped items. This group is used when
 * there are no groups specified.
 * @protected
 */
ItemSet.prototype._updateUngrouped = function () {
  var ungrouped = this.groups[UNGROUPED];
  var background = this.groups[BACKGROUND];
  var item, itemId;

  if (this.groupsData) {
    // remove the group holding all ungrouped items
    if (ungrouped) {
      ungrouped.hide();
      delete this.groups[UNGROUPED];

      for (itemId in this.items) {
        if (this.items.hasOwnProperty(itemId)) {
          item = this.items[itemId];
          item.parent && item.parent.remove(item);
          var groupId = this._getGroupId(item.data);
          var group = this.groups[groupId];
          group && group.add(item) || item.hide();
        }
      }
    }
  } else {
    // create a group holding all (unfiltered) items
    if (!ungrouped) {
      var id = null;
      var data = null;
      ungrouped = new Group(id, data, this);
      this.groups[UNGROUPED] = ungrouped;

      for (itemId in this.items) {
        if (this.items.hasOwnProperty(itemId)) {
          item = this.items[itemId];
          ungrouped.add(item);
        }
      }

      ungrouped.show();
    }
  }
};

/**
 * Get the element for the labelset
 * @return {HTMLElement} labelSet
 */
ItemSet.prototype.getLabelSet = function () {
  return this.dom.labelSet;
};

/**
 * Set items
 * @param {vis.DataSet | null} items
 */
ItemSet.prototype.setItems = function (items) {
  var me = this,
      ids,
      oldItemsData = this.itemsData;

  // replace the dataset
  if (!items) {
    this.itemsData = null;
  } else if (items instanceof DataSet || items instanceof DataView) {
    this.itemsData = items;
  } else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (oldItemsData) {
    // unsubscribe from old dataset
    util.forEach(this.itemListeners, function (callback, event) {
      oldItemsData.off(event, callback);
    });

    // remove all drawn items
    ids = oldItemsData.getIds();
    this._onRemove(ids);
  }

  if (this.itemsData) {
    // subscribe to new dataset
    var id = this.id;
    util.forEach(this.itemListeners, function (callback, event) {
      me.itemsData.on(event, callback, id);
    });

    // add all new items
    ids = this.itemsData.getIds();
    this._onAdd(ids);

    // update the group holding all ungrouped items
    this._updateUngrouped();
  }
};

/**
 * Get the current items
 * @returns {vis.DataSet | null}
 */
ItemSet.prototype.getItems = function () {
  return this.itemsData;
};

/**
 * Set groups
 * @param {vis.DataSet} groups
 */
ItemSet.prototype.setGroups = function (groups) {
  var me = this,
      ids;

  // unsubscribe from current dataset
  if (this.groupsData) {
    util.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.off(event, callback);
    });

    // remove all drawn groups
    ids = this.groupsData.getIds();
    this.groupsData = null;
    this._onRemoveGroups(ids); // note: this will cause a redraw
  }

  // replace the dataset
  if (!groups) {
    this.groupsData = null;
  } else if (groups instanceof DataSet || groups instanceof DataView) {
    this.groupsData = groups;
  } else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (this.groupsData) {
    // subscribe to new dataset
    var id = this.id;
    util.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.on(event, callback, id);
    });

    // draw all ms
    ids = this.groupsData.getIds();
    this._onAddGroups(ids);
  }

  // update the group holding all ungrouped items
  this._updateUngrouped();

  // update the order of all items in each group
  this._order();

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Get the current groups
 * @returns {vis.DataSet | null} groups
 */
ItemSet.prototype.getGroups = function () {
  return this.groupsData;
};

/**
 * Remove an item by its id
 * @param {String | Number} id
 */
ItemSet.prototype.removeItem = function (id) {
  var item = this.itemsData.get(id),
      dataset = this.itemsData.getDataSet();

  if (item) {
    // confirm deletion
    this.options.onRemove(item, function (item) {
      if (item) {
        // remove by id here, it is possible that an item has no id defined
        // itself, so better not delete by the item itself
        dataset.remove(id);
      }
    });
  }
};

/**
 * Get the time of an item based on it's data and options.type
 * @param {Object} itemData
 * @returns {string} Returns the type
 * @private
 */
ItemSet.prototype._getType = function (itemData) {
  return itemData.type || this.options.type || (itemData.end ? 'range' : 'box');
};

/**
 * Get the group id for an item
 * @param {Object} itemData
 * @returns {string} Returns the groupId
 * @private
 */
ItemSet.prototype._getGroupId = function (itemData) {
  var type = this._getType(itemData);
  if (type == 'background' && itemData.group == undefined) {
    return BACKGROUND;
  } else {
    return this.groupsData ? itemData.group : UNGROUPED;
  }
};

/**
 * Handle updated items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onUpdate = function (ids) {
  var me = this;

  ids.forEach((function (id) {
    var itemData = me.itemsData.get(id, me.itemOptions);
    var item = me.items[id];
    var type = me._getType(itemData);

    var constructor = ItemSet.types[type];
    var selected;

    if (item) {
      // update item
      if (!constructor || !(item instanceof constructor)) {
        // item type has changed, delete the item and recreate it
        selected = item.selected; // preserve selection of this item
        me._removeItem(item);
        item = null;
      } else {
        me._updateItem(item, itemData);
      }
    }

    if (!item) {
      // create item
      if (constructor) {
        item = new constructor(itemData, me.conversion, me.options);
        item.id = id; // TODO: not so nice setting id afterwards
        me._addItem(item);
        if (selected) {
          this.selection.push(id);
          item.select();
        }
      } else if (type == 'rangeoverflow') {
        // TODO: deprecated since version 2.1.0 (or 3.0.0?). cleanup some day
        throw new TypeError('Item type "rangeoverflow" is deprecated. Use css styling instead: ' + '.vis-item.vis-range .vis-item-content {overflow: visible;}');
      } else {
        throw new TypeError('Unknown item type "' + type + '"');
      }
    }
  }).bind(this));

  this._order();
  this.stackDirty = true; // force re-stacking of all items next redraw
  this.body.emitter.emit('change', { queue: true });
};

/**
 * Handle added items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onAdd = ItemSet.prototype._onUpdate;

/**
 * Handle removed items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onRemove = function (ids) {
  var count = 0;
  var me = this;
  ids.forEach(function (id) {
    var item = me.items[id];
    if (item) {
      count++;
      me._removeItem(item);
    }
  });

  if (count) {
    // update order
    this._order();
    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('change', { queue: true });
  }
};

/**
 * Update the order of item in all groups
 * @private
 */
ItemSet.prototype._order = function () {
  // reorder the items in all groups
  // TODO: optimization: only reorder groups affected by the changed items
  util.forEach(this.groups, function (group) {
    group.order();
  });
};

/**
 * Handle updated groups
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onUpdateGroups = function (ids) {
  this._onAddGroups(ids);
};

/**
 * Handle changed groups (added or updated)
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onAddGroups = function (ids) {
  var me = this;

  ids.forEach(function (id) {
    var groupData = me.groupsData.get(id);
    var group = me.groups[id];

    if (!group) {
      // check for reserved ids
      if (id == UNGROUPED || id == BACKGROUND) {
        throw new Error('Illegal group id. ' + id + ' is a reserved id.');
      }

      var groupOptions = Object.create(me.options);
      util.extend(groupOptions, {
        height: null
      });

      group = new Group(id, groupData, me);
      me.groups[id] = group;

      // add items with this groupId to the new group
      for (var itemId in me.items) {
        if (me.items.hasOwnProperty(itemId)) {
          var item = me.items[itemId];
          if (item.data.group == id) {
            group.add(item);
          }
        }
      }

      group.order();
      group.show();
    } else {
      // update group
      group.setData(groupData);
    }
  });

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Handle removed groups
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onRemoveGroups = function (ids) {
  var groups = this.groups;
  ids.forEach(function (id) {
    var group = groups[id];

    if (group) {
      group.hide();
      delete groups[id];
    }
  });

  this.markDirty();

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Reorder the groups if needed
 * @return {boolean} changed
 * @private
 */
ItemSet.prototype._orderGroups = function () {
  if (this.groupsData) {
    // reorder the groups
    var groupIds = this.groupsData.getIds({
      order: this.options.groupOrder
    });

    var changed = !util.equalArray(groupIds, this.groupIds);
    if (changed) {
      // hide all groups, removes them from the DOM
      var groups = this.groups;
      groupIds.forEach(function (groupId) {
        groups[groupId].hide();
      });

      // show the groups again, attach them to the DOM in correct order
      groupIds.forEach(function (groupId) {
        groups[groupId].show();
      });

      this.groupIds = groupIds;
    }

    return changed;
  } else {
    return false;
  }
};

/**
 * Add a new item
 * @param {Item} item
 * @private
 */
ItemSet.prototype._addItem = function (item) {
  this.items[item.id] = item;

  // add to group
  var groupId = this._getGroupId(item.data);
  var group = this.groups[groupId];
  if (group) group.add(item);
};

/**
 * Update an existing item
 * @param {Item} item
 * @param {Object} itemData
 * @private
 */
ItemSet.prototype._updateItem = function (item, itemData) {
  var oldGroupId = item.data.group;
  var oldSubGroupId = item.data.subgroup;

  // update the items data (will redraw the item when displayed)
  item.setData(itemData);

  // update group
  if (oldGroupId != item.data.group || oldSubGroupId != item.data.subgroup) {
    var oldGroup = this.groups[oldGroupId];
    if (oldGroup) oldGroup.remove(item);

    var groupId = this._getGroupId(item.data);
    var group = this.groups[groupId];
    if (group) group.add(item);
  }
};

/**
 * Delete an item from the ItemSet: remove it from the DOM, from the map
 * with items, and from the map with visible items, and from the selection
 * @param {Item} item
 * @private
 */
ItemSet.prototype._removeItem = function (item) {
  // remove from DOM
  item.hide();

  // remove from items
  delete this.items[item.id];

  // remove from selection
  var index = this.selection.indexOf(item.id);
  if (index != -1) this.selection.splice(index, 1);

  // remove from group
  item.parent && item.parent.remove(item);
};

/**
 * Create an array containing all items being a range (having an end date)
 * @param array
 * @returns {Array}
 * @private
 */
ItemSet.prototype._constructByEndArray = function (array) {
  var endArray = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i] instanceof RangeItem) {
      endArray.push(array[i]);
    }
  }
  return endArray;
};

/**
 * Register the clicked item on touch, before dragStart is initiated.
 *
 * dragStart is initiated from a mousemove event, AFTER the mouse/touch is
 * already moving. Therefore, the mouse/touch can sometimes be above an other
 * DOM element than the item itself.
 *
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onTouch = function (event) {
  // store the touched item, used in _onDragStart
  this.touchParams.item = this.itemFromTarget(event);
  this.touchParams.dragLeftItem = event.target.dragLeftItem || false;
  this.touchParams.dragRightItem = event.target.dragRightItem || false;
  this.touchParams.itemProps = null;
};

/**
 * Given an group id, returns the index it has.
 *
 * @param {Number} groupID
 * @private
 */
ItemSet.prototype._getGroupIndex = function (groupId) {
  for (var i = 0; i < this.groupIds.length; i++) {
    if (groupId == this.groupIds[i]) return i;
  }
};

/**
 * Start dragging the selected events
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragStart = function (event) {
  var item = this.touchParams.item || null;
  var me = this;
  var props;

  if (item && item.selected) {

    if (!this.options.editable.updateTime && !this.options.editable.updateGroup && !item.editable) {
      return;
    }

    // override options.editable
    if (item.editable === false) {
      return;
    }

    var dragLeftItem = this.touchParams.dragLeftItem;
    var dragRightItem = this.touchParams.dragRightItem;

    if (dragLeftItem) {
      props = {
        item: dragLeftItem,
        initialX: event.center.x,
        dragLeft: true,
        data: this._cloneItemData(item.data)
      };

      this.touchParams.itemProps = [props];
    } else if (dragRightItem) {
      props = {
        item: dragRightItem,
        initialX: event.center.x,
        dragRight: true,
        data: this._cloneItemData(item.data)
      };

      this.touchParams.itemProps = [props];
    } else {
      this.touchParams.selectedItem = item;

      var baseGroupIndex = this._getGroupIndex(item.data.group);

      this.touchParams.itemProps = this.getSelection().map((function (id) {
        var item = me.items[id];
        var groupIndex = me._getGroupIndex(item.data.group);
        return {
          item: item,
          initialX: event.center.x,
          groupOffset: baseGroupIndex - groupIndex,
          data: this._cloneItemData(item.data)
        };
      }).bind(this));
    }

    event.stopPropagation();
  } else if (this.options.editable.add && (event.srcEvent.ctrlKey || event.srcEvent.metaKey)) {
    // create a new range item when dragging with ctrl key down
    this._onDragStartAddItem(event);
  }
};

/**
 * Start creating a new range item by dragging.
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragStartAddItem = function (event) {
  var snap = this.options.snap || null;
  var xAbs = util.getAbsoluteLeft(this.dom.frame);
  var x = event.center.x - xAbs - 10; // minus 10 to compensate for the drag starting as soon as you've moved 10px
  var time = this.body.util.toTime(x);
  var scale = this.body.util.getScale();
  var step = this.body.util.getStep();
  var start = snap ? snap(time, scale, step) : start;
  var end = start;

  var itemData = {
    type: 'range',
    start: start,
    end: end,
    content: 'new item'
  };

  var id = util.randomUUID();
  itemData[this.itemsData._fieldId] = id;

  var group = this.groupFromTarget(event);
  if (group) {
    itemData.group = group.groupId;
  }

  var newItem = new RangeItem(itemData, this.conversion, this.options);
  newItem.id = id; // TODO: not so nice setting id afterwards
  newItem.data = this._cloneItemData(itemData);
  this._addItem(newItem);

  var props = {
    item: newItem,
    dragRight: true,
    initialX: event.center.x,
    data: newItem.data
  };
  this.touchParams.itemProps = [props];

  event.stopPropagation();
};

/**
 * Drag selected items
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDrag = function (event) {
  if (this.touchParams.itemProps) {
    event.stopPropagation();

    var me = this;
    var snap = this.options.snap || null;
    var xOffset = this.body.dom.root.offsetLeft + this.body.domProps.left.width;
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();

    //only calculate the new group for the item that's actually dragged
    var selectedItem = this.touchParams.selectedItem;
    var updateGroupAllowed = me.options.editable.updateGroup;
    var newGroupBase = null;
    if (updateGroupAllowed && selectedItem) {
      if (selectedItem.data.group != undefined) {
        // drag from one group to another
        var group = me.groupFromTarget(event);
        if (group) {
          //we know the offset for all items, so the new group for all items
          //will be relative to this one.
          newGroupBase = this._getGroupIndex(group.groupId);
        }
      }
    }

    // move
    this.touchParams.itemProps.forEach((function (props) {
      var current = me.body.util.toTime(event.center.x - xOffset);
      var initial = me.body.util.toTime(props.initialX - xOffset);
      var offset = current - initial; // ms

      var itemData = this._cloneItemData(props.item.data); // clone the data
      if (props.item.editable === false) {
        return;
      }

      var updateTimeAllowed = me.options.editable.updateTime || props.item.editable === true;

      if (updateTimeAllowed) {
        if (props.dragLeft) {
          // drag left side of a range item
          if (itemData.start != undefined) {
            var initialStart = util.convert(props.data.start, 'Date');
            var start = new Date(initialStart.valueOf() + offset);
            // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
            itemData.start = snap ? snap(start, scale, step) : start;
          }
        } else if (props.dragRight) {
          // drag right side of a range item
          if (itemData.end != undefined) {
            var initialEnd = util.convert(props.data.end, 'Date');
            var end = new Date(initialEnd.valueOf() + offset);
            // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
            itemData.end = snap ? snap(end, scale, step) : end;
          }
        } else {
          // drag both start and end
          if (itemData.start != undefined) {
            var initialStart = util.convert(props.data.start, 'Date').valueOf();
            var start = new Date(initialStart + offset);

            if (itemData.end != undefined) {
              var initialEnd = util.convert(props.data.end, 'Date');
              var duration = initialEnd.valueOf() - initialStart.valueOf();

              // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
              itemData.start = snap ? snap(start, scale, step) : start;
              itemData.end = new Date(itemData.start.valueOf() + duration);
            } else {
              // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
              itemData.start = snap ? snap(start, scale, step) : start;
            }
          }
        }
      }

      var updateGroupAllowed = me.options.editable.updateGroup || props.item.editable === true;

      if (updateGroupAllowed && !props.dragLeft && !props.dragRight && newGroupBase != null) {
        if (itemData.group != undefined) {
          var newOffset = newGroupBase - props.groupOffset;

          //make sure we stay in bounds
          newOffset = Math.max(0, newOffset);
          newOffset = Math.min(me.groupIds.length - 1, newOffset);

          itemData.group = me.groupIds[newOffset];
        }
      }

      // confirm moving the item
      itemData = this._cloneItemData(itemData); // convert start and end to the correct type
      me.options.onMoving(itemData, (function (itemData) {
        if (itemData) {
          props.item.setData(this._cloneItemData(itemData, 'Date'));
        }
      }).bind(this));
    }).bind(this));

    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('change');
  }
};

/**
 * Move an item to another group
 * @param {Item} item
 * @param {String | Number} groupId
 * @private
 */
ItemSet.prototype._moveToGroup = function (item, groupId) {
  var group = this.groups[groupId];
  if (group && group.groupId != item.data.group) {
    var oldGroup = item.parent;
    oldGroup.remove(item);
    oldGroup.order();
    group.add(item);
    group.order();

    item.data.group = group.groupId;
  }
};

/**
 * End of dragging selected items
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragEnd = function (event) {
  if (this.touchParams.itemProps) {
    event.stopPropagation();

    var me = this;
    var dataset = this.itemsData.getDataSet();
    var itemProps = this.touchParams.itemProps;
    this.touchParams.itemProps = null;

    itemProps.forEach((function (props) {
      var id = props.item.id;
      var exists = me.itemsData.get(id, me.itemOptions) != null;

      if (!exists) {
        // add a new item
        me.options.onAdd(props.item.data, function (itemData) {
          me._removeItem(props.item); // remove temporary item
          if (itemData) {
            me.itemsData.getDataSet().add(itemData);
          }

          // force re-stacking of all items next redraw
          me.stackDirty = true;
          me.body.emitter.emit('change');
        });
      } else {
        // update existing item
        var itemData = this._cloneItemData(props.item.data); // convert start and end to the correct type
        me.options.onMove(itemData, function (itemData) {
          if (itemData) {
            // apply changes
            itemData[dataset._fieldId] = id; // ensure the item contains its id (can be undefined)
            dataset.update(itemData);
          } else {
            // restore original values
            props.item.setData(props.data);

            me.stackDirty = true; // force re-stacking of all items next redraw
            me.body.emitter.emit('change');
          }
        });
      }
    }).bind(this));
  }
};

ItemSet.prototype._onGroupDragStart = function (event) {
  if (this.options.groupEditable.order) {
    this.groupTouchParams.group = this.groupFromTarget(event);

    if (this.groupTouchParams.group) {
      event.stopPropagation();

      this.groupTouchParams.originalOrder = this.groupsData.getIds({
        order: this.options.groupOrder
      });
    }
  }
};

ItemSet.prototype._onGroupDrag = function (event) {
  if (this.options.groupEditable.order && this.groupTouchParams.group) {
    event.stopPropagation();

    // drag from one group to another
    var group = this.groupFromTarget(event);

    // try to avoid toggling when groups differ in height
    if (group && group.height != this.groupTouchParams.group.height) {
      var movingUp = group.top < this.groupTouchParams.group.top;
      var clientY = event.center ? event.center.y : event.clientY;
      var targetGroupTop = util.getAbsoluteTop(group.dom.foreground);
      var draggedGroupHeight = this.groupTouchParams.group.height;
      if (movingUp) {
        // skip swapping the groups when the dragged group is not below clientY afterwards
        if (targetGroupTop + draggedGroupHeight < clientY) {
          return;
        }
      } else {
        var targetGroupHeight = group.height;
        // skip swapping the groups when the dragged group is not below clientY afterwards
        if (targetGroupTop + targetGroupHeight - draggedGroupHeight > clientY) {
          return;
        }
      }
    }

    if (group && group != this.groupTouchParams.group) {
      var groupsData = this.groupsData;
      var targetGroup = groupsData.get(group.groupId);
      var draggedGroup = groupsData.get(this.groupTouchParams.group.groupId);

      // switch groups
      if (draggedGroup && targetGroup) {
        this.options.groupOrderSwap(draggedGroup, targetGroup, this.groupsData);
        this.groupsData.update(draggedGroup);
        this.groupsData.update(targetGroup);
      }

      // fetch current order of groups
      var newOrder = this.groupsData.getIds({
        order: this.options.groupOrder
      });

      // in case of changes since _onGroupDragStart
      if (!util.equalArray(newOrder, this.groupTouchParams.originalOrder)) {
        var groupsData = this.groupsData;
        var origOrder = this.groupTouchParams.originalOrder;
        var draggedId = this.groupTouchParams.group.groupId;
        var numGroups = Math.min(origOrder.length, newOrder.length);
        var curPos = 0;
        var newOffset = 0;
        var orgOffset = 0;
        while (curPos < numGroups) {
          // as long as the groups are where they should be step down along the groups order
          while (curPos + newOffset < numGroups && curPos + orgOffset < numGroups && newOrder[curPos + newOffset] == origOrder[curPos + orgOffset]) {
            curPos++;
          }

          // all ok
          if (curPos + newOffset >= numGroups) {
            break;
          }

          // not all ok
          // if dragged group was move upwards everything below should have an offset
          if (newOrder[curPos + newOffset] == draggedId) {
            newOffset = 1;
            continue;
          }
          // if dragged group was move downwards everything above should have an offset
          else if (origOrder[curPos + orgOffset] == draggedId) {
              orgOffset = 1;
              continue;
            }
            // found a group (apart from dragged group) that has the wrong position -> switch with the
            // group at the position where other one should be, fix index arrays and continue
            else {
                var slippedPosition = newOrder.indexOf(origOrder[curPos + orgOffset]);
                var switchGroup = groupsData.get(newOrder[curPos + newOffset]);
                var shouldBeGroup = groupsData.get(origOrder[curPos + orgOffset]);
                this.options.groupOrderSwap(switchGroup, shouldBeGroup, groupsData);
                groupsData.update(switchGroup);
                groupsData.update(shouldBeGroup);

                var switchGroupId = newOrder[curPos + newOffset];
                newOrder[curPos + newOffset] = origOrder[curPos + orgOffset];
                newOrder[slippedPosition] = switchGroupId;

                curPos++;
              }
        }
      }
    }
  }
};

ItemSet.prototype._onGroupDragEnd = function (event) {
  if (this.options.groupEditable.order && this.groupTouchParams.group) {
    event.stopPropagation();

    // update existing group
    var me = this;
    var id = me.groupTouchParams.group.groupId;
    var dataset = me.groupsData.getDataSet();
    var groupData = util.extend({}, dataset.get(id)); // clone the data
    me.options.onMoveGroup(groupData, function (groupData) {
      if (groupData) {
        // apply changes
        groupData[dataset._fieldId] = id; // ensure the group contains its id (can be undefined)
        dataset.update(groupData);
      } else {

        // fetch current order of groups
        var newOrder = dataset.getIds({
          order: me.options.groupOrder
        });

        // restore original order
        if (!util.equalArray(newOrder, me.groupTouchParams.originalOrder)) {
          var origOrder = me.groupTouchParams.originalOrder;
          var numGroups = Math.min(origOrder.length, newOrder.length);
          var curPos = 0;
          while (curPos < numGroups) {
            // as long as the groups are where they should be step down along the groups order
            while (curPos < numGroups && newOrder[curPos] == origOrder[curPos]) {
              curPos++;
            }

            // all ok
            if (curPos >= numGroups) {
              break;
            }

            // found a group that has the wrong position -> switch with the
            // group at the position where other one should be, fix index arrays and continue
            var slippedPosition = newOrder.indexOf(origOrder[curPos]);
            var switchGroup = dataset.get(newOrder[curPos]);
            var shouldBeGroup = dataset.get(origOrder[curPos]);
            me.options.groupOrderSwap(switchGroup, shouldBeGroup, dataset);
            groupsData.update(switchGroup);
            groupsData.update(shouldBeGroup);

            var switchGroupId = newOrder[curPos];
            newOrder[curPos] = origOrder[curPos];
            newOrder[slippedPosition] = switchGroupId;

            curPos++;
          }
        }
      }
    });

    me.body.emitter.emit('groupDragged', { groupId: id });
  }
};

/**
 * Handle selecting/deselecting an item when tapping it
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onSelectItem = function (event) {
  if (!this.options.selectable) return;

  var ctrlKey = event.srcEvent && (event.srcEvent.ctrlKey || event.srcEvent.metaKey);
  var shiftKey = event.srcEvent && event.srcEvent.shiftKey;
  if (ctrlKey || shiftKey) {
    this._onMultiSelectItem(event);
    return;
  }

  var oldSelection = this.getSelection();

  var item = this.itemFromTarget(event);
  var selection = item ? [item.id] : [];
  this.setSelection(selection);

  var newSelection = this.getSelection();

  // emit a select event,
  // except when old selection is empty and new selection is still empty
  if (newSelection.length > 0 || oldSelection.length > 0) {
    this.body.emitter.emit('select', {
      items: newSelection,
      event: event
    });
  }
};

/**
 * Handle creation and updates of an item on double tap
 * @param event
 * @private
 */
ItemSet.prototype._onAddItem = function (event) {
  if (!this.options.selectable) return;
  if (!this.options.editable.add) return;

  var me = this;
  var snap = this.options.snap || null;
  var item = this.itemFromTarget(event);

  event.stopPropagation();

  if (item) {
    // update item

    // execute async handler to update the item (or cancel it)
    var itemData = me.itemsData.get(item.id); // get a clone of the data from the dataset
    this.options.onUpdate(itemData, function (itemData) {
      if (itemData) {
        me.itemsData.getDataSet().update(itemData);
      }
    });
  } else {
    // add item
    var xAbs = util.getAbsoluteLeft(this.dom.frame);
    var x = event.center.x - xAbs;
    var start = this.body.util.toTime(x);
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();

    var newItemData = {
      start: snap ? snap(start, scale, step) : start,
      content: 'new item'
    };

    // when default type is a range, add a default end date to the new item
    if (this.options.type === 'range') {
      var end = this.body.util.toTime(x + this.props.width / 5);
      newItemData.end = snap ? snap(end, scale, step) : end;
    }

    newItemData[this.itemsData._fieldId] = util.randomUUID();

    var group = this.groupFromTarget(event);
    if (group) {
      newItemData.group = group.groupId;
    }

    // execute async handler to customize (or cancel) adding an item
    newItemData = this._cloneItemData(newItemData); // convert start and end to the correct type
    this.options.onAdd(newItemData, function (item) {
      if (item) {
        me.itemsData.getDataSet().add(item);
        // TODO: need to trigger a redraw?
      }
    });
  }
};

/**
 * Handle selecting/deselecting multiple items when holding an item
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onMultiSelectItem = function (event) {
  if (!this.options.selectable) return;

  var item = this.itemFromTarget(event);

  if (item) {
    // multi select items (if allowed)

    var selection = this.options.multiselect ? this.getSelection() // take current selection
    : []; // deselect current selection

    var shiftKey = event.srcEvent && event.srcEvent.shiftKey || false;

    if (shiftKey && this.options.multiselect) {
      // select all items between the old selection and the tapped item

      // determine the selection range
      selection.push(item.id);
      var range = ItemSet._getItemRange(this.itemsData.get(selection, this.itemOptions));

      // select all items within the selection range
      selection = [];
      for (var id in this.items) {
        if (this.items.hasOwnProperty(id)) {
          var _item = this.items[id];
          var start = _item.data.start;
          var end = _item.data.end !== undefined ? _item.data.end : start;

          if (start >= range.min && end <= range.max && !(_item instanceof BackgroundItem)) {
            selection.push(_item.id); // do not use id but item.id, id itself is stringified
          }
        }
      }
    } else {
        // add/remove this item from the current selection
        var index = selection.indexOf(item.id);
        if (index == -1) {
          // item is not yet selected -> select it
          selection.push(item.id);
        } else {
          // item is already selected -> deselect it
          selection.splice(index, 1);
        }
      }

    this.setSelection(selection);

    this.body.emitter.emit('select', {
      items: this.getSelection(),
      event: event
    });
  }
};

/**
 * Calculate the time range of a list of items
 * @param {Array.<Object>} itemsData
 * @return {{min: Date, max: Date}} Returns the range of the provided items
 * @private
 */
ItemSet._getItemRange = function (itemsData) {
  var max = null;
  var min = null;

  itemsData.forEach(function (data) {
    if (min == null || data.start < min) {
      min = data.start;
    }

    if (data.end != undefined) {
      if (max == null || data.end > max) {
        max = data.end;
      }
    } else {
      if (max == null || data.start > max) {
        max = data.start;
      }
    }
  });

  return {
    min: min,
    max: max
  };
};

/**
 * Find an item from an event target:
 * searches for the attribute 'timeline-item' in the event target's element tree
 * @param {Event} event
 * @return {Item | null} item
 */
ItemSet.prototype.itemFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('timeline-item')) {
      return target['timeline-item'];
    }
    target = target.parentNode;
  }

  return null;
};

/**
 * Find the Group from an event target:
 * searches for the attribute 'timeline-group' in the event target's element tree
 * @param {Event} event
 * @return {Group | null} group
 */
ItemSet.prototype.groupFromTarget = function (event) {
  var clientY = event.center ? event.center.y : event.clientY;
  for (var i = 0; i < this.groupIds.length; i++) {
    var groupId = this.groupIds[i];
    var group = this.groups[groupId];
    var foreground = group.dom.foreground;
    var top = util.getAbsoluteTop(foreground);
    if (clientY > top && clientY < top + foreground.offsetHeight) {
      return group;
    }

    if (this.options.orientation.item === 'top') {
      if (i === this.groupIds.length - 1 && clientY > top) {
        return group;
      }
    } else {
      if (i === 0 && clientY < top + foreground.offset) {
        return group;
      }
    }
  }

  return null;
};

/**
 * Find the ItemSet from an event target:
 * searches for the attribute 'timeline-itemset' in the event target's element tree
 * @param {Event} event
 * @return {ItemSet | null} item
 */
ItemSet.itemSetFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('timeline-itemset')) {
      return target['timeline-itemset'];
    }
    target = target.parentNode;
  }

  return null;
};

/**
 * Clone the data of an item, and "normalize" it: convert the start and end date
 * to the type (Date, Moment, ...) configured in the DataSet. If not configured,
 * start and end are converted to Date.
 * @param {Object} itemData, typically `item.data`
 * @param {string} [type]  Optional Date type. If not provided, the type from the DataSet is taken
 * @return {Object} The cloned object
 * @private
 */
ItemSet.prototype._cloneItemData = function (itemData, type) {
  var clone = util.extend({}, itemData);

  if (!type) {
    // convert start and end date to the type (Date, Moment, ...) configured in the DataSet
    type = this.itemsData.getDataSet()._options.type;
  }

  if (clone.start != undefined) {
    clone.start = util.convert(clone.start, type && type.start || 'Date');
  }
  if (clone.end != undefined) {
    clone.end = util.convert(clone.end, type && type.end || 'Date');
  }

  return clone;
};

module.exports = ItemSet;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9JdGVtU2V0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7QUFDNUMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2pDLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUN2QyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUN6QyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdEMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3ZDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUMvQixJQUFJLGVBQWUsR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUNuRCxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUN4QyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUM1QyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUM1QyxJQUFJLGNBQWMsR0FBRyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQzs7QUFHdEQsSUFBSSxTQUFTLEdBQUcsZUFBZSxDQUFDO0FBQ2hDLElBQUksVUFBVSxHQUFHLGdCQUFnQixDQUFDOzs7Ozs7Ozs7OztBQVdsQyxTQUFTLE9BQU8sQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQzlCLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOztBQUVqQixNQUFJLENBQUMsY0FBYyxHQUFHO0FBQ3BCLFFBQUks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QUFPLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxZQUFXOztBQUVsQyxNQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFO0FBQzlCLFFBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUNsRDs7O0FBR0QsTUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRTtBQUM3QixRQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUM3RDs7O0FBR0QsTUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRTtBQUNqQyxRQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7R0FDbkQ7Q0FDRixDQUFDOzs7Ozs7Ozs7QUFTRixPQUFPLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRyxVQUFTLEdBQUcsRUFBRTtBQUM3QyxNQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQzs7QUFFcEIsTUFBSSxHQUFHLElBQUksU0FBUyxFQUFFLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDL0IsTUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7OztBQUdyQyxPQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDbkQsTUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxD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LEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7O0FBRXRDLE1BQUksQ0FBQyxJQUFJLEVBQUU7O0FBRVQsUUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztHQUNsRDs7QUFFRCxNQUFJLEtBQUssQ0FBQyxLQUFLLElBQUksU0FBUyxFQUFFO0FBQzVCLFNBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxDQUFDO0dBQ3ZFO0FBQ0QsTUFBSSxLQUFLLENBQUMsR0FBRyxJQUFJLFNBQVMsRUFBRTtBQUMxQixTQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRyxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxNQUFNLENBQUMsQ0FBQztHQUNsRTs7QUFFRCxTQUFPLEtBQUssQ0FBQztDQUNkLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMiLCJmaWxlIjoiL1VzZXJzL2VtaWx5YXNobGV5L1NUT1JZVE9PTFMvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0l0ZW1TZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgRGF0YVNldCA9IHJlcXVpcmUoJy4uLy4uL0RhdGFTZXQnKTtcbnZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4uLy4uL0RhdGFWaWV3Jyk7XG52YXIgVGltZVN0ZXAgPSByZXF1aXJlKCcuLi9UaW1lU3RlcCcpO1xudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG52YXIgR3JvdXAgPSByZXF1aXJlKCcuL0dyb3VwJyk7XG52YXIgQmFja2dyb3VuZEdyb3VwID0gcmVxdWlyZSgnLi9CYWNrZ3JvdW5kR3JvdXAnKTtcbnZhciBCb3hJdGVtID0gcmVxdWlyZSgnLi9pdGVtL0JveEl0ZW0nKTtcbnZhciBQb2ludEl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0vUG9pbnRJdGVtJyk7XG52YXIgUmFuZ2VJdGVtID0gcmVxdWlyZSgnLi9pdGVtL1JhbmdlSXRlbScpO1xudmFyIEJhY2tncm91bmRJdGVtID0gcmVxdWlyZSgnLi9pdGVtL0JhY2tncm91bmRJdGVtJyk7XG5cblxudmFyIFVOR1JPVVBFRCA9ICdfX3VuZ3JvdXBlZF9fJzsgICAvLyByZXNlcnZlZCBncm91cCBpZCBmb3IgdW5ncm91cGVkIGl0ZW1zXG52YXIgQkFDS0dST1VORCA9ICdfX2JhY2tncm91bmRfXyc7IC8vIHJlc2VydmVkIGdyb3VwIGlkIGZvciBiYWNrZ3JvdW5kIGl0ZW1zIHdpdGhvdXQgZ3JvdXBcblxuLyoqXG4gKiBBbiBJdGVtU2V0IGhvbGRzIGEgc2V0IG9mIGl0ZW1zIGFuZCByYW5nZXMgd2hpY2ggY2FuIGJlIGRpc3BsYXllZCBpbiBhXG4gKiByYW5nZS4gVGhlIHdpZHRoIGlzIGRldGVybWluZWQgYnkgdGhlIHBhcmVudCBvZiB0aGUgSXRlbVNldCwgYW5kIHRoZSBoZWlnaHRcbiAqIGlzIGRldGVybWluZWQgYnkgdGhlIHNpemUgb2YgdGhlIGl0ZW1zLlxuICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXIsIHJhbmdlOiBSYW5nZX19IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICBTZWUgSXRlbVNldC5zZXRPcHRpb25zIGZvciB0aGUgYXZhaWxhYmxlIG9wdGlvbnMuXG4gKiBAY29uc3RydWN0b3IgSXRlbVNldFxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIEl0ZW1TZXQoYm9keSwgb3B0aW9ucykge1xuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgdHlwZTogbnVsbCwgIC8vICdib3gnLCAncG9pbnQnLCAncmFuZ2UnLCAnYmFja2dyb3VuZCdcbiAgICBvcmllbnRhdGlvbjoge1xuICAgICAgaXRlbTogJ2JvdHRvbScgICAvLyBpdGVtIG9yaWVudGF0aW9uOiAndG9wJyBvciAnYm90dG9tJ1xuICAgIH0sXG4gICAgYWxpZ246ICdhdXRvJywgLy8gYWxpZ25tZW50IG9mIGJveCBpdGVtc1xuICAgIHN0YWNrOiB0cnVlLFxuICAgIGdyb3VwT3JkZXJTd2FwOiBmdW5jdGlvbihmcm9tR3JvdXAsIHRvR3JvdXAsIGdyb3Vwcykge1xuICAgIFx0dmFyIHRhcmdldE9yZGVyID0gdG9Hcm91cC5vcmRlcjtcbiAgICBcdHRvR3JvdXAub3JkZXIgPSBmcm9tR3JvdXAub3JkZXI7XG4gICAgXHRmcm9tR3JvdXAub3JkZXIgPSB0YXJnZXRPcmRlcjtcbiAgICB9LFxuICAgIGdyb3VwT3JkZXI6ICdvcmRlcicsXG5cbiAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgIG11bHRpc2VsZWN0OiBmYWxzZSxcblxuICAgIGVkaXRhYmxlOiB7XG4gICAgICB1cGRhdGVUaW1lOiBmYWxzZSxcbiAgICAgIHVwZGF0ZUdyb3VwOiBmYWxzZSxcbiAgICAgIGFkZDogZmFsc2UsXG4gICAgICByZW1vdmU6IGZhbHNlXG4gICAgfSxcblxuICAgIGdyb3VwRWRpdGFibGU6IHtcbiAgICAgIG9yZGVyOiBmYWxzZSxcbiAgICAgIGFkZDogZmFsc2UsXG4gICAgICByZW1vdmU6IGZhbHNlXG4gICAgfSwgICAgXG4gICAgXG4gICAgc25hcDogVGltZVN0ZXAuc25hcCxcblxuICAgIG9uQWRkOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG4gICAgb25VcGRhdGU6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcbiAgICBvbk1vdmU6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcbiAgICBvblJlbW92ZTogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuICAgIG9uTW92aW5nOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG4gICAgb25BZGRHcm91cDogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuICAgIG9uTW92ZUdyb3VwOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG4gICAgb25SZW1vdmVHcm91cDogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuXG4gICAgbWFyZ2luOiB7XG4gICAgICBpdGVtOiB7XG4gICAgICAgIGhvcml6b250YWw6IDEwLFxuICAgICAgICB2ZXJ0aWNhbDogMTBcbiAgICAgIH0sXG4gICAgICBheGlzOiAyMFxuICAgIH1cbiAgfTtcblxuICAvLyBvcHRpb25zIGlzIHNoYXJlZCBieSB0aGlzIEl0ZW1TZXQgYW5kIGFsbCBpdHMgaXRlbXNcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gIC8vIG9wdGlvbnMgZm9yIGdldHRpbmcgaXRlbXMgZnJvbSB0aGUgRGF0YVNldCB3aXRoIHRoZSBjb3JyZWN0IHR5cGVcbiAgdGhpcy5pdGVtT3B0aW9ucyA9IHtcbiAgICB0eXBlOiB7c3RhcnQ6ICdEYXRlJywgZW5kOiAnRGF0ZSd9XG4gIH07XG5cbiAgdGhpcy5jb252ZXJzaW9uID0ge1xuICAgIHRvU2NyZWVuOiBib2R5LnV0aWwudG9TY3JlZW4sXG4gICAgdG9UaW1lOiBib2R5LnV0aWwudG9UaW1lXG4gIH07XG4gIHRoaXMuZG9tID0ge307XG4gIHRoaXMucHJvcHMgPSB7fTtcbiAgdGhpcy5oYW1tZXIgPSBudWxsO1xuXG4gIHZhciBtZSA9IHRoaXM7XG4gIHRoaXMuaXRlbXNEYXRhID0gbnVsbDsgICAgLy8gRGF0YVNldFxuICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsOyAgIC8vIERhdGFTZXRcblxuICAvLyBsaXN0ZW5lcnMgZm9yIHRoZSBEYXRhU2V0IG9mIHRoZSBpdGVtc1xuICB0aGlzLml0ZW1MaXN0ZW5lcnMgPSB7XG4gICAgJ2FkZCc6IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgbWUuX29uQWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICBtZS5fb25VcGRhdGUocGFyYW1zLml0ZW1zKTtcbiAgICB9LFxuICAgICdyZW1vdmUnOiBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgIG1lLl9vblJlbW92ZShwYXJhbXMuaXRlbXMpO1xuICAgIH1cbiAgfTtcblxuICAvLyBsaXN0ZW5lcnMgZm9yIHRoZSBEYXRhU2V0IG9mIHRoZSBncm91cHNcbiAgdGhpcy5ncm91cExpc3RlbmVycyA9IHtcbiAgICAnYWRkJzogZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICBtZS5fb25BZGRHcm91cHMocGFyYW1zLml0ZW1zKTtcbiAgICB9LFxuICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgIG1lLl9vblVwZGF0ZUdyb3VwcyhwYXJhbXMuaXRlbXMpO1xuICAgIH0sXG4gICAgJ3JlbW92ZSc6IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgbWUuX29uUmVtb3ZlR3JvdXBzKHBhcmFtcy5pdGVtcyk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuaXRlbXMgPSB7fTsgICAgICAvLyBvYmplY3Qgd2l0aCBhbiBJdGVtIGZvciBldmVyeSBkYXRhIGl0ZW1cbiAgdGhpcy5ncm91cHMgPSB7fTsgICAgIC8vIEdyb3VwIG9iamVjdCBmb3IgZXZlcnkgZ3JvdXBcbiAgdGhpcy5ncm91cElkcyA9IFtdO1xuXG4gIHRoaXMuc2VsZWN0aW9uID0gW107ICAvLyBsaXN0IHdpdGggdGhlIGlkcyBvZiBhbGwgc2VsZWN0ZWQgbm9kZXNcbiAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gaWYgdHJ1ZSwgYWxsIGl0ZW1zIHdpbGwgYmUgcmVzdGFja2VkIG9uIG5leHQgcmVkcmF3XG5cbiAgdGhpcy50b3VjaFBhcmFtcyA9IHt9OyAvLyBzdG9yZXMgcHJvcGVydGllcyB3aGlsZSBkcmFnZ2luZ1xuICB0aGlzLmdyb3VwVG91Y2hQYXJhbXMgPSB7fTtcbiAgLy8gY3JlYXRlIHRoZSBIVE1MIERPTVxuXG4gIHRoaXMuX2NyZWF0ZSgpO1xuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbn1cblxuSXRlbVNldC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8vIGF2YWlsYWJsZSBpdGVtIHR5cGVzIHdpbGwgYmUgcmVnaXN0ZXJlZCBoZXJlXG5JdGVtU2V0LnR5cGVzID0ge1xuICBiYWNrZ3JvdW5kOiBCYWNrZ3JvdW5kSXRlbSxcbiAgYm94OiBCb3hJdGVtLFxuICByYW5nZTogUmFuZ2VJdGVtLFxuICBwb2ludDogUG9pbnRJdGVtXG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBJdGVtU2V0XG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtc2V0JztcbiAgZnJhbWVbJ3RpbWVsaW5lLWl0ZW1zZXQnXSA9IHRoaXM7XG4gIHRoaXMuZG9tLmZyYW1lID0gZnJhbWU7XG5cbiAgLy8gY3JlYXRlIGJhY2tncm91bmQgcGFuZWxcbiAgdmFyIGJhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYmFja2dyb3VuZC5jbGFzc05hbWUgPSAndmlzLWJhY2tncm91bmQnO1xuICBmcmFtZS5hcHBlbmRDaGlsZChiYWNrZ3JvdW5kKTtcbiAgdGhpcy5kb20uYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cbiAgLy8gY3JlYXRlIGZvcmVncm91bmQgcGFuZWxcbiAgdmFyIGZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZm9yZWdyb3VuZC5jbGFzc05hbWUgPSAndmlzLWZvcmVncm91bmQnO1xuICBmcmFtZS5hcHBlbmRDaGlsZChmb3JlZ3JvdW5kKTtcbiAgdGhpcy5kb20uZm9yZWdyb3VuZCA9IGZvcmVncm91bmQ7XG5cbiAgLy8gY3JlYXRlIGF4aXMgcGFuZWxcbiAgdmFyIGF4aXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYXhpcy5jbGFzc05hbWUgPSAndmlzLWF4aXMnO1xuICB0aGlzLmRvbS5heGlzID0gYXhpcztcblxuICAvLyBjcmVhdGUgbGFiZWxzZXRcbiAgdmFyIGxhYmVsU2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGxhYmVsU2V0LmNsYXNzTmFtZSA9ICd2aXMtbGFiZWxzZXQnO1xuICB0aGlzLmRvbS5sYWJlbFNldCA9IGxhYmVsU2V0O1xuXG4gIC8vIGNyZWF0ZSB1bmdyb3VwZWQgR3JvdXBcbiAgdGhpcy5fdXBkYXRlVW5ncm91cGVkKCk7XG5cbiAgLy8gY3JlYXRlIGJhY2tncm91bmQgR3JvdXBcbiAgdmFyIGJhY2tncm91bmRHcm91cCA9IG5ldyBCYWNrZ3JvdW5kR3JvdXAoQkFDS0dST1VORCwgbnVsbCwgdGhpcyk7XG4gIGJhY2tncm91bmRHcm91cC5zaG93KCk7XG4gIHRoaXMuZ3JvdXBzW0JBQ0tHUk9VTkRdID0gYmFja2dyb3VuZEdyb3VwO1xuXG4gIC8vIGF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgLy8gTm90ZTogd2UgYmluZCB0byB0aGUgY2VudGVyQ29udGFpbmVyIGZvciB0aGUgY2FzZSB3aGVyZSB0aGUgaGVpZ2h0XG4gIC8vICAgICAgIG9mIHRoZSBjZW50ZXIgY29udGFpbmVyIGlzIGxhcmdlciB0aGFuIG9mIHRoZSBJdGVtU2V0LCBzbyB3ZVxuICAvLyAgICAgICBjYW4gY2xpY2sgaW4gdGhlIGVtcHR5IGFyZWEgdG8gY3JlYXRlIGEgbmV3IGl0ZW0gb3IgZGVzZWxlY3QgYW4gaXRlbS5cbiAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuYm9keS5kb20uY2VudGVyQ29udGFpbmVyKTtcblxuICAvLyBkcmFnIGl0ZW1zIHdoZW4gc2VsZWN0ZWRcbiAgdGhpcy5oYW1tZXIub24oJ2hhbW1lci5pbnB1dCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICB0aGlzLl9vblRvdWNoKGV2ZW50KTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG4gIHRoaXMuaGFtbWVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5vbigncGFubW92ZScsICB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG4gIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCAgIHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5oYW1tZXIuZ2V0KCdwYW4nKS5zZXQoe3RocmVzaG9sZDo1LCBkaXJlY3Rpb246MzB9KTsgLy8gMzAgaXMgQUxMX0RJUkVDVElPTlMgaW4gaGFtbWVyLlxuXG4gIC8vIHNpbmdsZSBzZWxlY3QgKG9yIHVuc2VsZWN0KSB3aGVuIHRhcHBpbmcgYW4gaXRlbVxuICB0aGlzLmhhbW1lci5vbigndGFwJywgIHRoaXMuX29uU2VsZWN0SXRlbS5iaW5kKHRoaXMpKTtcblxuICAvLyBtdWx0aSBzZWxlY3Qgd2hlbiBob2xkaW5nIG1vdXNlL3RvdWNoLCBvciBvbiBjdHJsK2NsaWNrXG4gIHRoaXMuaGFtbWVyLm9uKCdwcmVzcycsIHRoaXMuX29uTXVsdGlTZWxlY3RJdGVtLmJpbmQodGhpcykpO1xuXG4gIC8vIGFkZCBpdGVtIG9uIGRvdWJsZXRhcFxuICB0aGlzLmhhbW1lci5vbignZG91YmxldGFwJywgdGhpcy5fb25BZGRJdGVtLmJpbmQodGhpcykpO1xuXG4gIHRoaXMuZ3JvdXBIYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuYm9keS5kb20ubGVmdENvbnRhaW5lcik7XG4gIHRoaXMuZ3JvdXBIYW1tZXIub24oJ3BhbnN0YXJ0JywgdGhpcy5fb25Hcm91cERyYWdTdGFydC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ncm91cEhhbW1lci5vbigncGFubW92ZScsICB0aGlzLl9vbkdyb3VwRHJhZy5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ncm91cEhhbW1lci5vbigncGFuZW5kJywgICB0aGlzLl9vbkdyb3VwRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ncm91cEhhbW1lci5nZXQoJ3BhbicpLnNldCh7dGhyZXNob2xkOjUsIGRpcmVjdGlvbjozMH0pO1xuICBcbiAgLy8gYXR0YWNoIHRvIHRoZSBET01cbiAgdGhpcy5zaG93KCk7XG59O1xuXG4vKipcbiAqIFNldCBvcHRpb25zIGZvciB0aGUgSXRlbVNldC4gRXhpc3Rpbmcgb3B0aW9ucyB3aWxsIGJlIGV4dGVuZGVkL292ZXJ3cml0dGVuLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGF2YWlsYWJsZTpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gdHlwZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHR5cGUgZm9yIHRoZSBpdGVtcy4gQ2hvb3NlIGZyb20gJ2JveCdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlZmF1bHQpLCAncG9pbnQnLCAncmFuZ2UnLCBvciAnYmFja2dyb3VuZCcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHN0eWxlIGNhbiBiZSBvdmVyd3JpdHRlbiBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpdmlkdWFsIGl0ZW1zLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBhbGlnblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGlnbm1lbnQgZm9yIHRoZSBpdGVtcywgb25seSBhcHBsaWNhYmxlIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCb3hJdGVtLiBDaG9vc2UgJ2NlbnRlcicgKGRlZmF1bHQpLCAnbGVmdCcsIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyaWdodCcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG9yaWVudGF0aW9uLml0ZW1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3JpZW50YXRpb24gb2YgdGhlIGl0ZW0gc2V0LiBDaG9vc2UgJ3RvcCcgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JvdHRvbScgKGRlZmF1bHQpLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb259IGdyb3VwT3JkZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBzb3J0aW5nIGZ1bmN0aW9uIGZvciBvcmRlcmluZyBncm91cHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IHN0YWNrXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCBpdGVtcyB3aWxsIGJlIHN0YWNrZWQgb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wIG9mIGVhY2ggb3RoZXIuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpbi5heGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hcmdpbiBiZXR3ZWVuIHRoZSBheGlzIGFuZCB0aGUgaXRlbXMgaW4gcGl4ZWxzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIDIwLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uaXRlbS5ob3Jpem9udGFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhvcml6b250YWwgbWFyZ2luIGJldHdlZW4gaXRlbXMgaW4gcGl4ZWxzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIDEwLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uaXRlbS52ZXJ0aWNhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZXJ0aWNhbCBNYXJnaW4gYmV0d2VlbiBpdGVtcyBpbiBwaXhlbHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgMTAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpbi5pdGVtXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hcmdpbiBiZXR3ZWVuIGl0ZW1zIGluIHBpeGVscyBpbiBib3RoIGhvcml6b250YWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHZlcnRpY2FsIGRpcmVjdGlvbi4gRGVmYXVsdCBpcyAxMC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldCBtYXJnaW4gZm9yIGJvdGggYXhpcyBhbmQgaXRlbXMgaW4gcGl4ZWxzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gc2VsZWN0YWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgaXRlbXMgY2FuIGJlIHNlbGVjdGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gbXVsdGlzZWxlY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSwgbXVsdGlwbGUgaXRlbXMgY2FuIGJlIHNlbGVjdGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGYWxzZSBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0IGFsbCBlZGl0YWJsZSBvcHRpb25zIHRvIHRydWUgb3IgZmFsc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlLnVwZGF0ZVRpbWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxsb3cgZHJhZ2dpbmcgYW4gaXRlbSB0byBhbiBvdGhlciBtb21lbnQgaW4gdGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUudXBkYXRlR3JvdXBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxsb3cgZHJhZ2dpbmcgYW4gaXRlbSB0byBhbiBvdGhlciBncm91cFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUuYWRkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IGNyZWF0aW5nIG5ldyBpdGVtcyBvbiBkb3VibGUgdGFwXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZS5yZW1vdmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxsb3cgcmVtb3ZpbmcgaXRlbXMgYnkgY2xpY2tpbmcgdGhlIGRlbGV0ZSBidXR0b25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wIHJpZ2h0IG9mIGEgc2VsZWN0ZWQgaXRlbS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9uKGl0ZW06IEl0ZW0sIGNhbGxiYWNrOiBGdW5jdGlvbil9IG9uQWRkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCB3aGVuIGFuIGl0ZW0gaXMgYWJvdXQgdG8gYmUgYWRkZWQ6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIHVzZXIgZG91YmxlIHRhcHMgYW4gZW1wdHkgc3BhY2UgaW4gdGhlIFRpbWVsaW5lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb24oaXRlbTogSXRlbSwgY2FsbGJhY2s6IEZ1bmN0aW9uKX0gb25VcGRhdGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgZnVuY3Rpb24gZmlyZWQgd2hlbiBhbiBpdGVtIGlzIGFib3V0IHRvIGJlIHVwZGF0ZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgZnVuY3Rpb24gdHlwaWNhbGx5IGhhcyB0byBzaG93IGEgZGlhbG9nIHdoZXJlIHRoZSB1c2VyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZSB0aGUgaXRlbS4gSWYgbm90IGltcGxlbWVudGVkLCBub3RoaW5nIGhhcHBlbnMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvbk1vdmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlyZWQgd2hlbiBhbiBpdGVtIGhhcyBiZWVuIG1vdmVkLiBJZiBub3QgaW1wbGVtZW50ZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBtb3ZlIGFjdGlvbiB3aWxsIGJlIGFjY2VwdGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb24oaXRlbTogSXRlbSwgY2FsbGJhY2s6IEZ1bmN0aW9uKX0gb25SZW1vdmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlyZWQgd2hlbiBhbiBpdGVtIGlzIGFib3V0IHRvIGJlIGRlbGV0ZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBpbXBsZW1lbnRlZCwgdGhlIGl0ZW0gd2lsbCBiZSBhbHdheXMgcmVtb3ZlZC5cbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBjb3B5IGFsbCBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgIHZhciBmaWVsZHMgPSBbJ3R5cGUnLCAnYWxpZ24nLCAnb3JkZXInLCAnc3RhY2snLCAnc2VsZWN0YWJsZScsICdtdWx0aXNlbGVjdCcsICdncm91cE9yZGVyJywgJ2RhdGFBdHRyaWJ1dGVzJywgJ3RlbXBsYXRlJywgJ2dyb3VwVGVtcGxhdGUnLCAnaGlkZScsICdzbmFwJywgJ2dyb3VwT3JkZXJTd2FwJ107XG4gICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdvcmllbnRhdGlvbicgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9IG9wdGlvbnMub3JpZW50YXRpb24gPT09ICd0b3AnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnb2JqZWN0JyAmJiAnaXRlbScgaW4gb3B0aW9ucy5vcmllbnRhdGlvbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9IG9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ21hcmdpbicgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1hcmdpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm1hcmdpbi5heGlzID0gb3B0aW9ucy5tYXJnaW47XG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbS5ob3Jpem9udGFsID0gb3B0aW9ucy5tYXJnaW47XG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbS52ZXJ0aWNhbCA9IG9wdGlvbnMubWFyZ2luO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMubWFyZ2luID09PSAnb2JqZWN0Jykge1xuICAgICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ2F4aXMnXSwgdGhpcy5vcHRpb25zLm1hcmdpbiwgb3B0aW9ucy5tYXJnaW4pO1xuICAgICAgICBpZiAoJ2l0ZW0nIGluIG9wdGlvbnMubWFyZ2luKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1hcmdpbi5pdGVtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1hcmdpbi5pdGVtLmhvcml6b250YWwgPSBvcHRpb25zLm1hcmdpbi5pdGVtO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1hcmdpbi5pdGVtLnZlcnRpY2FsID0gb3B0aW9ucy5tYXJnaW4uaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMubWFyZ2luLml0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ2hvcml6b250YWwnLCAndmVydGljYWwnXSwgdGhpcy5vcHRpb25zLm1hcmdpbi5pdGVtLCBvcHRpb25zLm1hcmdpbi5pdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ2VkaXRhYmxlJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWRpdGFibGUgPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSAgPSBvcHRpb25zLmVkaXRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgPSBvcHRpb25zLmVkaXRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdGFibGUuYWRkICAgICAgICAgPSBvcHRpb25zLmVkaXRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdGFibGUucmVtb3ZlICAgICAgPSBvcHRpb25zLmVkaXRhYmxlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZWRpdGFibGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsndXBkYXRlVGltZScsICd1cGRhdGVHcm91cCcsICdhZGQnLCAncmVtb3ZlJ10sIHRoaXMub3B0aW9ucy5lZGl0YWJsZSwgb3B0aW9ucy5lZGl0YWJsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICgnZ3JvdXBFZGl0YWJsZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmdyb3VwRWRpdGFibGUgPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5vcmRlciAgPSBvcHRpb25zLmdyb3VwRWRpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLmFkZCAgICA9IG9wdGlvbnMuZ3JvdXBFZGl0YWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUucmVtb3ZlID0gb3B0aW9ucy5ncm91cEVkaXRhYmxlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZ3JvdXBFZGl0YWJsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydvcmRlcicsICdhZGQnLCAncmVtb3ZlJ10sIHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLCBvcHRpb25zLmdyb3VwRWRpdGFibGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgIHZhciBhZGRDYWxsYmFjayA9IChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGZuID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBpZiAoIShmbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9uICcgKyBuYW1lICsgJyBtdXN0IGJlIGEgZnVuY3Rpb24gJyArIG5hbWUgKyAnKGl0ZW0sIGNhbGxiYWNrKScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1tuYW1lXSA9IGZuO1xuICAgICAgfVxuICAgIH0pLmJpbmQodGhpcyk7XG4gICAgWydvbkFkZCcsICdvblVwZGF0ZScsICdvblJlbW92ZScsICdvbk1vdmUnLCAnb25Nb3ZpbmcnLCAnb25BZGRHcm91cCcsICdvbk1vdmVHcm91cCcsICdvblJlbW92ZUdyb3VwJ10uZm9yRWFjaChhZGRDYWxsYmFjayk7XG5cbiAgICAvLyBmb3JjZSB0aGUgaXRlbVNldCB0byByZWZyZXNoOiBvcHRpb25zIGxpa2Ugb3JpZW50YXRpb24gYW5kIG1hcmdpbnMgbWF5IGJlIGNoYW5nZWRcbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICB9XG59O1xuXG4vKipcbiAqIE1hcmsgdGhlIEl0ZW1TZXQgZGlydHkgc28gaXQgd2lsbCByZWZyZXNoIGV2ZXJ5dGhpbmcgd2l0aCBuZXh0IHJlZHJhdy5cbiAqIE9wdGlvbmFsbHksIGFsbCBpdGVtcyBjYW4gYmUgbWFya2VkIGFzIGRpcnR5IGFuZCBiZSByZWZyZXNoZWQuXG4gKiBAcGFyYW0ge3tyZWZyZXNoSXRlbXM6IGJvb2xlYW59fSBbb3B0aW9uc11cbiAqL1xuSXRlbVNldC5wcm90b3R5cGUubWFya0RpcnR5ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLmdyb3VwSWRzID0gW107XG4gIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWZyZXNoSXRlbXMpIHtcbiAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGl0ZW0uZGlydHkgPSB0cnVlO1xuICAgICAgaWYgKGl0ZW0uZGlzcGxheWVkKSBpdGVtLnJlZHJhdygpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIEl0ZW1TZXRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmhpZGUoKTtcbiAgdGhpcy5zZXRJdGVtcyhudWxsKTtcbiAgdGhpcy5zZXRHcm91cHMobnVsbCk7XG5cbiAgdGhpcy5oYW1tZXIgPSBudWxsO1xuXG4gIHRoaXMuYm9keSA9IG51bGw7XG4gIHRoaXMuY29udmVyc2lvbiA9IG51bGw7XG59O1xuXG4vKipcbiAqIEhpZGUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBET01cbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAvLyByZW1vdmUgdGhlIGZyYW1lIGNvbnRhaW5pbmcgdGhlIGl0ZW1zXG4gIGlmICh0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5mcmFtZSk7XG4gIH1cblxuICAvLyByZW1vdmUgdGhlIGF4aXMgd2l0aCBkb3RzXG4gIGlmICh0aGlzLmRvbS5heGlzLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmRvbS5heGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uYXhpcyk7XG4gIH1cblxuICAvLyByZW1vdmUgdGhlIGxhYmVsc2V0IGNvbnRhaW5pbmcgYWxsIGdyb3VwIGxhYmVsc1xuICBpZiAodGhpcy5kb20ubGFiZWxTZXQucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLmxhYmVsU2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ubGFiZWxTZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIFNob3cgdGhlIGNvbXBvbmVudCBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLlxuICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNob3cgZnJhbWUgY29udGFpbmluZyB0aGUgaXRlbXNcbiAgaWYgKCF0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5ib2R5LmRvbS5jZW50ZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uZnJhbWUpO1xuICB9XG5cbiAgLy8gc2hvdyBheGlzIHdpdGggZG90c1xuICBpZiAoIXRoaXMuZG9tLmF4aXMucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmFwcGVuZENoaWxkKHRoaXMuZG9tLmF4aXMpO1xuICB9XG5cbiAgLy8gc2hvdyBsYWJlbHNldCBjb250YWluaW5nIGxhYmVsc1xuICBpZiAoIXRoaXMuZG9tLmxhYmVsU2V0LnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmJvZHkuZG9tLmxlZnQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubGFiZWxTZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBzZWxlY3RlZCBpdGVtcyBieSB0aGVpciBpZC4gUmVwbGFjZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gKiBVbmtub3duIGlkJ3MgYXJlIHNpbGVudGx5IGlnbm9yZWQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdIHwgc3RyaW5nfSBbaWRzXSBBbiBhcnJheSB3aXRoIHplcm8gb3IgbW9yZSBpZCdzIG9mIHRoZSBpdGVtcyB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQsIG9yIGEgc2luZ2xlIGl0ZW0gaWQuIElmIGlkcyBpcyB1bmRlZmluZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGFuIGVtcHR5IGFycmF5LCBhbGwgaXRlbXMgd2lsbCBiZSB1bnNlbGVjdGVkLlxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbihpZHMpIHtcbiAgdmFyIGksIGlpLCBpZCwgaXRlbTtcblxuICBpZiAoaWRzID09IHVuZGVmaW5lZCkgaWRzID0gW107XG4gIGlmICghQXJyYXkuaXNBcnJheShpZHMpKSBpZHMgPSBbaWRzXTtcblxuICAvLyB1bnNlbGVjdCBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXNcbiAgZm9yIChpID0gMCwgaWkgPSB0aGlzLnNlbGVjdGlvbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWQgPSB0aGlzLnNlbGVjdGlvbltpXTtcbiAgICBpdGVtID0gdGhpcy5pdGVtc1tpZF07XG4gICAgaWYgKGl0ZW0pIGl0ZW0udW5zZWxlY3QoKTtcbiAgfVxuXG4gIC8vIHNlbGVjdCBpdGVtc1xuICB0aGlzLnNlbGVjdGlvbiA9IFtdO1xuICBmb3IgKGkgPSAwLCBpaSA9IGlkcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWQgPSBpZHNbaV07XG4gICAgaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5wdXNoKGlkKTtcbiAgICAgIGl0ZW0uc2VsZWN0KCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWRcbiAqIEByZXR1cm4ge0FycmF5fSBpZHMgIFRoZSBpZHMgb2YgdGhlIHNlbGVjdGVkIGl0ZW1zXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uY29uY2F0KFtdKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpZCdzIG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBpdGVtcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGlkcyBvZiB0aGUgdmlzaWJsZSBpdGVtc1xuICovXG5JdGVtU2V0LnByb3RvdHlwZS5nZXRWaXNpYmxlSXRlbXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJhbmdlID0gdGhpcy5ib2R5LnJhbmdlLmdldFJhbmdlKCk7XG4gIHZhciBsZWZ0ICA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHJhbmdlLnN0YXJ0KTtcbiAgdmFyIHJpZ2h0ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4ocmFuZ2UuZW5kKTtcblxuICB2YXIgaWRzID0gW107XG4gIGZvciAodmFyIGdyb3VwSWQgaW4gdGhpcy5ncm91cHMpIHtcbiAgICBpZiAodGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoZ3JvdXBJZCkpIHtcbiAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgdmFyIHJhd1Zpc2libGVJdGVtcyA9IGdyb3VwLnZpc2libGVJdGVtcztcblxuICAgICAgLy8gZmlsdGVyIHRoZSBcInJhd1wiIHNldCB3aXRoIHZpc2libGVJdGVtcyBpbnRvIGEgc2V0IHdoaWNoIGlzIHJlYWxseVxuICAgICAgLy8gdmlzaWJsZSBieSBwaXhlbHNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3VmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gcmF3VmlzaWJsZUl0ZW1zW2ldO1xuICAgICAgICAvLyBUT0RPOiBhbHNvIGNoZWNrIHdoZXRoZXIgdmlzaWJsZSB2ZXJ0aWNhbGx5XG4gICAgICAgIGlmICgoaXRlbS5sZWZ0IDwgcmlnaHQpICYmIChpdGVtLmxlZnQgKyBpdGVtLndpZHRoID4gbGVmdCkpIHtcbiAgICAgICAgICBpZHMucHVzaChpdGVtLmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vKipcbiAqIERlc2VsZWN0IGEgc2VsZWN0ZWQgaXRlbVxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGlkXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fZGVzZWxlY3QgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHNlbGVjdGlvbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWYgKHNlbGVjdGlvbltpXSA9PSBpZCkgeyAvLyBub24tc3RyaWN0IGNvbXBhcmlzb24hXG4gICAgICBzZWxlY3Rpb24uc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5tYXJnaW4sXG4gICAgICByYW5nZSA9IHRoaXMuYm9keS5yYW5nZSxcbiAgICAgIGFzU2l6ZSA9IHV0aWwub3B0aW9uLmFzU2l6ZSxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBvcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb24uaXRlbSxcbiAgICAgIHJlc2l6ZWQgPSBmYWxzZSxcbiAgICAgIGZyYW1lID0gdGhpcy5kb20uZnJhbWU7XG5cbiAgLy8gcmVjYWxjdWxhdGUgYWJzb2x1dGUgcG9zaXRpb24gKGJlZm9yZSByZWRyYXdpbmcgZ3JvdXBzKVxuICB0aGlzLnByb3BzLnRvcCA9IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci50b3A7XG4gIHRoaXMucHJvcHMubGVmdCA9IHRoaXMuYm9keS5kb21Qcm9wcy5sZWZ0LndpZHRoICsgdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci5sZWZ0O1xuXG4gIC8vIHVwZGF0ZSBjbGFzcyBuYW1lXG4gIGZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtaXRlbXNldCc7XG5cbiAgLy8gcmVvcmRlciB0aGUgZ3JvdXBzIChpZiBuZWVkZWQpXG4gIHJlc2l6ZWQgPSB0aGlzLl9vcmRlckdyb3VwcygpIHx8IHJlc2l6ZWQ7XG5cbiAgLy8gY2hlY2sgd2hldGhlciB6b29tZWQgKGluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHJlLXN0YWNrIGV2ZXJ5dGhpbmcpXG4gIC8vIFRPRE86IHdvdWxkIGJlIG5pY2VyIHRvIGdldCB0aGlzIGFzIGEgdHJpZ2dlciBmcm9tIFJhbmdlXG4gIHZhciB2aXNpYmxlSW50ZXJ2YWwgPSByYW5nZS5lbmQgLSByYW5nZS5zdGFydDtcbiAgdmFyIHpvb21lZCA9ICh2aXNpYmxlSW50ZXJ2YWwgIT0gdGhpcy5sYXN0VmlzaWJsZUludGVydmFsKSB8fCAodGhpcy5wcm9wcy53aWR0aCAhPSB0aGlzLnByb3BzLmxhc3RXaWR0aCk7XG4gIGlmICh6b29tZWQpIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7XG4gIHRoaXMubGFzdFZpc2libGVJbnRlcnZhbCA9IHZpc2libGVJbnRlcnZhbDtcbiAgdGhpcy5wcm9wcy5sYXN0V2lkdGggPSB0aGlzLnByb3BzLndpZHRoO1xuXG4gIHZhciByZXN0YWNrID0gdGhpcy5zdGFja0RpcnR5O1xuICB2YXIgZmlyc3RHcm91cCA9IHRoaXMuX2ZpcnN0R3JvdXAoKTtcbiAgdmFyIGZpcnN0TWFyZ2luID0ge1xuICAgIGl0ZW06IG1hcmdpbi5pdGVtLFxuICAgIGF4aXM6IG1hcmdpbi5heGlzXG4gIH07XG4gIHZhciBub25GaXJzdE1hcmdpbiA9IHtcbiAgICBpdGVtOiBtYXJnaW4uaXRlbSxcbiAgICBheGlzOiBtYXJnaW4uaXRlbS52ZXJ0aWNhbCAvIDJcbiAgfTtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBtaW5IZWlnaHQgPSBtYXJnaW4uYXhpcyArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuXG4gIC8vIHJlZHJhdyB0aGUgYmFja2dyb3VuZCBncm91cFxuICB0aGlzLmdyb3Vwc1tCQUNLR1JPVU5EXS5yZWRyYXcocmFuZ2UsIG5vbkZpcnN0TWFyZ2luLCByZXN0YWNrKTtcblxuICAvLyByZWRyYXcgYWxsIHJlZ3VsYXIgZ3JvdXBzXG4gIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgdmFyIGdyb3VwTWFyZ2luID0gKGdyb3VwID09IGZpcnN0R3JvdXApID8gZmlyc3RNYXJnaW4gOiBub25GaXJzdE1hcmdpbjtcbiAgICB2YXIgZ3JvdXBSZXNpemVkID0gZ3JvdXAucmVkcmF3KHJhbmdlLCBncm91cE1hcmdpbiwgcmVzdGFjayk7XG4gICAgcmVzaXplZCA9IGdyb3VwUmVzaXplZCB8fCByZXNpemVkO1xuICAgIGhlaWdodCArPSBncm91cC5oZWlnaHQ7XG4gIH0pO1xuICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIG1pbkhlaWdodCk7XG4gIHRoaXMuc3RhY2tEaXJ0eSA9IGZhbHNlO1xuXG4gIC8vIHVwZGF0ZSBmcmFtZSBoZWlnaHRcbiAgZnJhbWUuc3R5bGUuaGVpZ2h0ICA9IGFzU2l6ZShoZWlnaHQpO1xuXG4gIC8vIGNhbGN1bGF0ZSBhY3R1YWwgc2l6ZVxuICB0aGlzLnByb3BzLndpZHRoID0gZnJhbWUub2Zmc2V0V2lkdGg7XG4gIHRoaXMucHJvcHMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIC8vIHJlcG9zaXRpb24gYXhpc1xuICB0aGlzLmRvbS5heGlzLnN0eWxlLnRvcCA9IGFzU2l6ZSgob3JpZW50YXRpb24gPT0gJ3RvcCcpID9cbiAgICAgICh0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArIHRoaXMuYm9keS5kb21Qcm9wcy5ib3JkZXIudG9wKSA6XG4gICAgICAodGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyB0aGlzLmJvZHkuZG9tUHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCkpO1xuICB0aGlzLmRvbS5heGlzLnN0eWxlLmxlZnQgPSAnMCc7XG5cbiAgLy8gY2hlY2sgaWYgdGhpcyBjb21wb25lbnQgaXMgcmVzaXplZFxuICByZXNpemVkID0gdGhpcy5faXNSZXNpemVkKCkgfHwgcmVzaXplZDtcblxuICByZXR1cm4gcmVzaXplZDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBncm91cCwgYWxpZ25lZCB3aXRoIHRoZSBheGlzXG4gKiBAcmV0dXJuIHtHcm91cCB8IG51bGx9IGZpcnN0R3JvdXBcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9maXJzdEdyb3VwID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmaXJzdEdyb3VwSW5kZXggPSAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPT0gJ3RvcCcpID8gMCA6ICh0aGlzLmdyb3VwSWRzLmxlbmd0aCAtIDEpO1xuICB2YXIgZmlyc3RHcm91cElkID0gdGhpcy5ncm91cElkc1tmaXJzdEdyb3VwSW5kZXhdO1xuICB2YXIgZmlyc3RHcm91cCA9IHRoaXMuZ3JvdXBzW2ZpcnN0R3JvdXBJZF0gfHwgdGhpcy5ncm91cHNbVU5HUk9VUEVEXTtcblxuICByZXR1cm4gZmlyc3RHcm91cCB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgb3IgZGVsZXRlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXMuIFRoaXMgZ3JvdXAgaXMgdXNlZCB3aGVuXG4gKiB0aGVyZSBhcmUgbm8gZ3JvdXBzIHNwZWNpZmllZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX3VwZGF0ZVVuZ3JvdXBlZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdW5ncm91cGVkID0gdGhpcy5ncm91cHNbVU5HUk9VUEVEXTtcbiAgdmFyIGJhY2tncm91bmQgPSB0aGlzLmdyb3Vwc1tCQUNLR1JPVU5EXTtcbiAgdmFyIGl0ZW0sIGl0ZW1JZDtcblxuICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXNcbiAgICBpZiAodW5ncm91cGVkKSB7XG4gICAgICB1bmdyb3VwZWQuaGlkZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF07XG5cbiAgICAgIGZvciAoaXRlbUlkIGluIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXMuaGFzT3duUHJvcGVydHkoaXRlbUlkKSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2l0ZW1JZF07XG4gICAgICAgICAgaXRlbS5wYXJlbnQgJiYgaXRlbS5wYXJlbnQucmVtb3ZlKGl0ZW0pO1xuICAgICAgICAgIHZhciBncm91cElkID0gdGhpcy5fZ2V0R3JvdXBJZChpdGVtLmRhdGEpO1xuICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgICAgIGdyb3VwICYmIGdyb3VwLmFkZChpdGVtKSB8fCBpdGVtLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBjcmVhdGUgYSBncm91cCBob2xkaW5nIGFsbCAodW5maWx0ZXJlZCkgaXRlbXNcbiAgICBpZiAoIXVuZ3JvdXBlZCkge1xuICAgICAgdmFyIGlkID0gbnVsbDtcbiAgICAgIHZhciBkYXRhID0gbnVsbDtcbiAgICAgIHVuZ3JvdXBlZCA9IG5ldyBHcm91cChpZCwgZGF0YSwgdGhpcyk7XG4gICAgICB0aGlzLmdyb3Vwc1tVTkdST1VQRURdID0gdW5ncm91cGVkO1xuXG4gICAgICBmb3IgKGl0ZW1JZCBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1tpdGVtSWRdO1xuICAgICAgICAgIHVuZ3JvdXBlZC5hZGQoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdW5ncm91cGVkLnNob3coKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBlbGVtZW50IGZvciB0aGUgbGFiZWxzZXRcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBsYWJlbFNldFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5nZXRMYWJlbFNldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kb20ubGFiZWxTZXQ7XG59O1xuXG4vKipcbiAqIFNldCBpdGVtc1xuICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IG51bGx9IGl0ZW1zXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLnNldEl0ZW1zID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgdmFyIG1lID0gdGhpcyxcbiAgICAgIGlkcyxcbiAgICAgIG9sZEl0ZW1zRGF0YSA9IHRoaXMuaXRlbXNEYXRhO1xuXG4gIC8vIHJlcGxhY2UgdGhlIGRhdGFzZXRcbiAgaWYgKCFpdGVtcykge1xuICAgIHRoaXMuaXRlbXNEYXRhID0gbnVsbDtcbiAgfVxuICBlbHNlIGlmIChpdGVtcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgaXRlbXMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHRoaXMuaXRlbXNEYXRhID0gaXRlbXM7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIERhdGFTZXQgb3IgRGF0YVZpZXcnKTtcbiAgfVxuXG4gIGlmIChvbGRJdGVtc0RhdGEpIHtcbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbUxpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgb2xkSXRlbXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGFsbCBkcmF3biBpdGVtc1xuICAgIGlkcyA9IG9sZEl0ZW1zRGF0YS5nZXRJZHMoKTtcbiAgICB0aGlzLl9vblJlbW92ZShpZHMpO1xuICB9XG5cbiAgaWYgKHRoaXMuaXRlbXNEYXRhKSB7XG4gICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICBtZS5pdGVtc0RhdGEub24oZXZlbnQsIGNhbGxiYWNrLCBpZCk7XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgYWxsIG5ldyBpdGVtc1xuICAgIGlkcyA9IHRoaXMuaXRlbXNEYXRhLmdldElkcygpO1xuICAgIHRoaXMuX29uQWRkKGlkcyk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIGdyb3VwIGhvbGRpbmcgYWxsIHVuZ3JvdXBlZCBpdGVtc1xuICAgIHRoaXMuX3VwZGF0ZVVuZ3JvdXBlZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBpdGVtc1xuICogQHJldHVybnMge3Zpcy5EYXRhU2V0IHwgbnVsbH1cbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ2V0SXRlbXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXRlbXNEYXRhO1xufTtcblxuLyoqXG4gKiBTZXQgZ3JvdXBzXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0fSBncm91cHNcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuc2V0R3JvdXBzID0gZnVuY3Rpb24oZ3JvdXBzKSB7XG4gIHZhciBtZSA9IHRoaXMsXG4gICAgICBpZHM7XG5cbiAgLy8gdW5zdWJzY3JpYmUgZnJvbSBjdXJyZW50IGRhdGFzZXRcbiAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICBtZS5ncm91cHNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGFsbCBkcmF3biBncm91cHNcbiAgICBpZHMgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKCk7XG4gICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDtcbiAgICB0aGlzLl9vblJlbW92ZUdyb3VwcyhpZHMpOyAvLyBub3RlOiB0aGlzIHdpbGwgY2F1c2UgYSByZWRyYXdcbiAgfVxuXG4gIC8vIHJlcGxhY2UgdGhlIGRhdGFzZXRcbiAgaWYgKCFncm91cHMpIHtcbiAgICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsO1xuICB9XG4gIGVsc2UgaWYgKGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICB0aGlzLmdyb3Vwc0RhdGEgPSBncm91cHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIERhdGFTZXQgb3IgRGF0YVZpZXcnKTtcbiAgfVxuXG4gIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICBtZS5ncm91cHNEYXRhLm9uKGV2ZW50LCBjYWxsYmFjaywgaWQpO1xuICAgIH0pO1xuXG4gICAgLy8gZHJhdyBhbGwgbXNcbiAgICBpZHMgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKCk7XG4gICAgdGhpcy5fb25BZGRHcm91cHMoaWRzKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSB0aGUgZ3JvdXAgaG9sZGluZyBhbGwgdW5ncm91cGVkIGl0ZW1zXG4gIHRoaXMuX3VwZGF0ZVVuZ3JvdXBlZCgpO1xuXG4gIC8vIHVwZGF0ZSB0aGUgb3JkZXIgb2YgYWxsIGl0ZW1zIGluIGVhY2ggZ3JvdXBcbiAgdGhpcy5fb3JkZXIoKTtcblxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7cXVldWU6IHRydWV9KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGdyb3Vwc1xuICogQHJldHVybnMge3Zpcy5EYXRhU2V0IHwgbnVsbH0gZ3JvdXBzXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmdldEdyb3VwcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ncm91cHNEYXRhO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBieSBpdHMgaWRcbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBpZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zRGF0YS5nZXQoaWQpLFxuICAgICAgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKTtcblxuICBpZiAoaXRlbSkge1xuICAgIC8vIGNvbmZpcm0gZGVsZXRpb25cbiAgICB0aGlzLm9wdGlvbnMub25SZW1vdmUoaXRlbSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIC8vIHJlbW92ZSBieSBpZCBoZXJlLCBpdCBpcyBwb3NzaWJsZSB0aGF0IGFuIGl0ZW0gaGFzIG5vIGlkIGRlZmluZWRcbiAgICAgICAgLy8gaXRzZWxmLCBzbyBiZXR0ZXIgbm90IGRlbGV0ZSBieSB0aGUgaXRlbSBpdHNlbGZcbiAgICAgICAgZGF0YXNldC5yZW1vdmUoaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGltZSBvZiBhbiBpdGVtIGJhc2VkIG9uIGl0J3MgZGF0YSBhbmQgb3B0aW9ucy50eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHR5cGVcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9nZXRUeXBlID0gZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gIHJldHVybiBpdGVtRGF0YS50eXBlIHx8IHRoaXMub3B0aW9ucy50eXBlIHx8IChpdGVtRGF0YS5lbmQgPyAncmFuZ2UnIDogJ2JveCcpO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgZ3JvdXAgaWQgZm9yIGFuIGl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRGF0YVxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZ3JvdXBJZFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2dldEdyb3VwSWQgPSBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLl9nZXRUeXBlKGl0ZW1EYXRhKTtcbiAgaWYgKHR5cGUgPT0gJ2JhY2tncm91bmQnICYmIGl0ZW1EYXRhLmdyb3VwID09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuIEJBQ0tHUk9VTkQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBzRGF0YSA/IGl0ZW1EYXRhLmdyb3VwIDogVU5HUk9VUEVEO1xuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZSB1cGRhdGVkIGl0ZW1zXG4gKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uVXBkYXRlID0gZnVuY3Rpb24oaWRzKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW1EYXRhID0gbWUuaXRlbXNEYXRhLmdldChpZCwgbWUuaXRlbU9wdGlvbnMpO1xuICAgIHZhciBpdGVtID0gbWUuaXRlbXNbaWRdO1xuICAgIHZhciB0eXBlID0gbWUuX2dldFR5cGUoaXRlbURhdGEpO1xuXG4gICAgdmFyIGNvbnN0cnVjdG9yID0gSXRlbVNldC50eXBlc1t0eXBlXTtcbiAgICB2YXIgc2VsZWN0ZWQ7XG5cbiAgICBpZiAoaXRlbSkge1xuICAgICAgLy8gdXBkYXRlIGl0ZW1cbiAgICAgIGlmICghY29uc3RydWN0b3IgfHwgIShpdGVtIGluc3RhbmNlb2YgY29uc3RydWN0b3IpKSB7XG4gICAgICAgIC8vIGl0ZW0gdHlwZSBoYXMgY2hhbmdlZCwgZGVsZXRlIHRoZSBpdGVtIGFuZCByZWNyZWF0ZSBpdFxuICAgICAgICBzZWxlY3RlZCA9IGl0ZW0uc2VsZWN0ZWQ7IC8vIHByZXNlcnZlIHNlbGVjdGlvbiBvZiB0aGlzIGl0ZW1cbiAgICAgICAgbWUuX3JlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgIGl0ZW0gPSBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1lLl91cGRhdGVJdGVtKGl0ZW0sIGl0ZW1EYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIC8vIGNyZWF0ZSBpdGVtXG4gICAgICBpZiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgaXRlbSA9IG5ldyBjb25zdHJ1Y3RvcihpdGVtRGF0YSwgbWUuY29udmVyc2lvbiwgbWUub3B0aW9ucyk7XG4gICAgICAgIGl0ZW0uaWQgPSBpZDsgLy8gVE9ETzogbm90IHNvIG5pY2Ugc2V0dGluZyBpZCBhZnRlcndhcmRzXG4gICAgICAgIG1lLl9hZGRJdGVtKGl0ZW0pO1xuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5wdXNoKGlkKTtcbiAgICAgICAgICBpdGVtLnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlID09ICdyYW5nZW92ZXJmbG93Jykge1xuICAgICAgICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjAgKG9yIDMuMC4wPykuIGNsZWFudXAgc29tZSBkYXlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXRlbSB0eXBlIFwicmFuZ2VvdmVyZmxvd1wiIGlzIGRlcHJlY2F0ZWQuIFVzZSBjc3Mgc3R5bGluZyBpbnN0ZWFkOiAnICtcbiAgICAgICAgICAgICcudmlzLWl0ZW0udmlzLXJhbmdlIC52aXMtaXRlbS1jb250ZW50IHtvdmVyZmxvdzogdmlzaWJsZTt9Jyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBpdGVtIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICAgICAgfVxuICAgIH1cbiAgfS5iaW5kKHRoaXMpKTtcblxuICB0aGlzLl9vcmRlcigpO1xuICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlOyAvLyBmb3JjZSByZS1zdGFja2luZyBvZiBhbGwgaXRlbXMgbmV4dCByZWRyYXdcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge3F1ZXVlOiB0cnVlfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBhZGRlZCBpdGVtc1xuICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vbkFkZCA9IEl0ZW1TZXQucHJvdG90eXBlLl9vblVwZGF0ZTtcblxuLyoqXG4gKiBIYW5kbGUgcmVtb3ZlZCBpdGVtc1xuICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vblJlbW92ZSA9IGZ1bmN0aW9uKGlkcykge1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgbWUgPSB0aGlzO1xuICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IG1lLml0ZW1zW2lkXTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY291bnQrKztcbiAgICAgIG1lLl9yZW1vdmVJdGVtKGl0ZW0pO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGNvdW50KSB7XG4gICAgLy8gdXBkYXRlIG9yZGVyXG4gICAgdGhpcy5fb3JkZXIoKTtcbiAgICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlOyAvLyBmb3JjZSByZS1zdGFja2luZyBvZiBhbGwgaXRlbXMgbmV4dCByZWRyYXdcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7cXVldWU6IHRydWV9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIG9yZGVyIG9mIGl0ZW0gaW4gYWxsIGdyb3Vwc1xuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29yZGVyID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJlb3JkZXIgdGhlIGl0ZW1zIGluIGFsbCBncm91cHNcbiAgLy8gVE9ETzogb3B0aW1pemF0aW9uOiBvbmx5IHJlb3JkZXIgZ3JvdXBzIGFmZmVjdGVkIGJ5IHRoZSBjaGFuZ2VkIGl0ZW1zXG4gIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgZ3JvdXAub3JkZXIoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSB1cGRhdGVkIGdyb3Vwc1xuICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25VcGRhdGVHcm91cHMgPSBmdW5jdGlvbihpZHMpIHtcbiAgdGhpcy5fb25BZGRHcm91cHMoaWRzKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGNoYW5nZWQgZ3JvdXBzIChhZGRlZCBvciB1cGRhdGVkKVxuICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25BZGRHcm91cHMgPSBmdW5jdGlvbihpZHMpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZ3JvdXBEYXRhID0gbWUuZ3JvdXBzRGF0YS5nZXQoaWQpO1xuICAgIHZhciBncm91cCA9IG1lLmdyb3Vwc1tpZF07XG5cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAvLyBjaGVjayBmb3IgcmVzZXJ2ZWQgaWRzXG4gICAgICBpZiAoaWQgPT0gVU5HUk9VUEVEIHx8IGlkID09IEJBQ0tHUk9VTkQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGdyb3VwIGlkLiAnICsgaWQgKyAnIGlzIGEgcmVzZXJ2ZWQgaWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBncm91cE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG1lLm9wdGlvbnMpO1xuICAgICAgdXRpbC5leHRlbmQoZ3JvdXBPcHRpb25zLCB7XG4gICAgICAgIGhlaWdodDogbnVsbFxuICAgICAgfSk7XG5cbiAgICAgIGdyb3VwID0gbmV3IEdyb3VwKGlkLCBncm91cERhdGEsIG1lKTtcbiAgICAgIG1lLmdyb3Vwc1tpZF0gPSBncm91cDtcblxuICAgICAgLy8gYWRkIGl0ZW1zIHdpdGggdGhpcyBncm91cElkIHRvIHRoZSBuZXcgZ3JvdXBcbiAgICAgIGZvciAodmFyIGl0ZW1JZCBpbiBtZS5pdGVtcykge1xuICAgICAgICBpZiAobWUuaXRlbXMuaGFzT3duUHJvcGVydHkoaXRlbUlkKSkge1xuICAgICAgICAgIHZhciBpdGVtID0gbWUuaXRlbXNbaXRlbUlkXTtcbiAgICAgICAgICBpZiAoaXRlbS5kYXRhLmdyb3VwID09IGlkKSB7XG4gICAgICAgICAgICBncm91cC5hZGQoaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdyb3VwLm9yZGVyKCk7XG4gICAgICBncm91cC5zaG93KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdXBkYXRlIGdyb3VwXG4gICAgICBncm91cC5zZXREYXRhKGdyb3VwRGF0YSk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7cXVldWU6IHRydWV9KTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHJlbW92ZWQgZ3JvdXBzXG4gKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vblJlbW92ZUdyb3VwcyA9IGZ1bmN0aW9uKGlkcykge1xuICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBncm91cCA9IGdyb3Vwc1tpZF07XG5cbiAgICBpZiAoZ3JvdXApIHtcbiAgICAgIGdyb3VwLmhpZGUoKTtcbiAgICAgIGRlbGV0ZSBncm91cHNbaWRdO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5tYXJrRGlydHkoKTtcblxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7cXVldWU6IHRydWV9KTtcbn07XG5cbi8qKlxuICogUmVvcmRlciB0aGUgZ3JvdXBzIGlmIG5lZWRlZFxuICogQHJldHVybiB7Ym9vbGVhbn0gY2hhbmdlZFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29yZGVyR3JvdXBzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgLy8gcmVvcmRlciB0aGUgZ3JvdXBzXG4gICAgdmFyIGdyb3VwSWRzID0gdGhpcy5ncm91cHNEYXRhLmdldElkcyh7XG4gICAgICBvcmRlcjogdGhpcy5vcHRpb25zLmdyb3VwT3JkZXJcbiAgICB9KTtcblxuICAgIHZhciBjaGFuZ2VkID0gIXV0aWwuZXF1YWxBcnJheShncm91cElkcywgdGhpcy5ncm91cElkcyk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIC8vIGhpZGUgYWxsIGdyb3VwcywgcmVtb3ZlcyB0aGVtIGZyb20gdGhlIERPTVxuICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICAgICAgZ3JvdXBJZHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICBncm91cHNbZ3JvdXBJZF0uaGlkZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHNob3cgdGhlIGdyb3VwcyBhZ2FpbiwgYXR0YWNoIHRoZW0gdG8gdGhlIERPTSBpbiBjb3JyZWN0IG9yZGVyXG4gICAgICBncm91cElkcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgICAgIGdyb3Vwc1tncm91cElkXS5zaG93KCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5ncm91cElkcyA9IGdyb3VwSWRzO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgYSBuZXcgaXRlbVxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fYWRkSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5pdGVtc1tpdGVtLmlkXSA9IGl0ZW07XG5cbiAgLy8gYWRkIHRvIGdyb3VwXG4gIHZhciBncm91cElkID0gdGhpcy5fZ2V0R3JvdXBJZChpdGVtLmRhdGEpO1xuICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgaWYgKGdyb3VwKSBncm91cC5hZGQoaXRlbSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBpdGVtXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRGF0YVxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX3VwZGF0ZUl0ZW0gPSBmdW5jdGlvbihpdGVtLCBpdGVtRGF0YSkge1xuICB2YXIgb2xkR3JvdXBJZCA9IGl0ZW0uZGF0YS5ncm91cDtcbiAgdmFyIG9sZFN1Ykdyb3VwSWQgPSBpdGVtLmRhdGEuc3ViZ3JvdXA7XG5cbiAgLy8gdXBkYXRlIHRoZSBpdGVtcyBkYXRhICh3aWxsIHJlZHJhdyB0aGUgaXRlbSB3aGVuIGRpc3BsYXllZClcbiAgaXRlbS5zZXREYXRhKGl0ZW1EYXRhKTtcblxuICAvLyB1cGRhdGUgZ3JvdXBcbiAgaWYgKG9sZEdyb3VwSWQgIT0gaXRlbS5kYXRhLmdyb3VwIHx8IG9sZFN1Ykdyb3VwSWQgIT0gaXRlbS5kYXRhLnN1Ymdyb3VwKSB7XG4gICAgdmFyIG9sZEdyb3VwID0gdGhpcy5ncm91cHNbb2xkR3JvdXBJZF07XG4gICAgaWYgKG9sZEdyb3VwKSBvbGRHcm91cC5yZW1vdmUoaXRlbSk7XG5cbiAgICB2YXIgZ3JvdXBJZCA9IHRoaXMuX2dldEdyb3VwSWQoaXRlbS5kYXRhKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICBpZiAoZ3JvdXApIGdyb3VwLmFkZChpdGVtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWxldGUgYW4gaXRlbSBmcm9tIHRoZSBJdGVtU2V0OiByZW1vdmUgaXQgZnJvbSB0aGUgRE9NLCBmcm9tIHRoZSBtYXBcbiAqIHdpdGggaXRlbXMsIGFuZCBmcm9tIHRoZSBtYXAgd2l0aCB2aXNpYmxlIGl0ZW1zLCBhbmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9yZW1vdmVJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICAvLyByZW1vdmUgZnJvbSBET01cbiAgaXRlbS5oaWRlKCk7XG5cbiAgLy8gcmVtb3ZlIGZyb20gaXRlbXNcbiAgZGVsZXRlIHRoaXMuaXRlbXNbaXRlbS5pZF07XG5cbiAgLy8gcmVtb3ZlIGZyb20gc2VsZWN0aW9uXG4gIHZhciBpbmRleCA9IHRoaXMuc2VsZWN0aW9uLmluZGV4T2YoaXRlbS5pZCk7XG4gIGlmIChpbmRleCAhPSAtMSkgdGhpcy5zZWxlY3Rpb24uc3BsaWNlKGluZGV4LCAxKTtcblxuICAvLyByZW1vdmUgZnJvbSBncm91cFxuICBpdGVtLnBhcmVudCAmJiBpdGVtLnBhcmVudC5yZW1vdmUoaXRlbSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBjb250YWluaW5nIGFsbCBpdGVtcyBiZWluZyBhIHJhbmdlIChoYXZpbmcgYW4gZW5kIGRhdGUpXG4gKiBAcGFyYW0gYXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9jb25zdHJ1Y3RCeUVuZEFycmF5ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgdmFyIGVuZEFycmF5ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJheVtpXSBpbnN0YW5jZW9mIFJhbmdlSXRlbSkge1xuICAgICAgZW5kQXJyYXkucHVzaChhcnJheVtpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmRBcnJheTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgdGhlIGNsaWNrZWQgaXRlbSBvbiB0b3VjaCwgYmVmb3JlIGRyYWdTdGFydCBpcyBpbml0aWF0ZWQuXG4gKlxuICogZHJhZ1N0YXJ0IGlzIGluaXRpYXRlZCBmcm9tIGEgbW91c2Vtb3ZlIGV2ZW50LCBBRlRFUiB0aGUgbW91c2UvdG91Y2ggaXNcbiAqIGFscmVhZHkgbW92aW5nLiBUaGVyZWZvcmUsIHRoZSBtb3VzZS90b3VjaCBjYW4gc29tZXRpbWVzIGJlIGFib3ZlIGFuIG90aGVyXG4gKiBET00gZWxlbWVudCB0aGFuIHRoZSBpdGVtIGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uVG91Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gc3RvcmUgdGhlIHRvdWNoZWQgaXRlbSwgdXNlZCBpbiBfb25EcmFnU3RhcnRcbiAgdGhpcy50b3VjaFBhcmFtcy5pdGVtID0gdGhpcy5pdGVtRnJvbVRhcmdldChldmVudCk7XG4gIHRoaXMudG91Y2hQYXJhbXMuZHJhZ0xlZnRJdGVtID0gZXZlbnQudGFyZ2V0LmRyYWdMZWZ0SXRlbSB8fCBmYWxzZTtcbiAgdGhpcy50b3VjaFBhcmFtcy5kcmFnUmlnaHRJdGVtID0gZXZlbnQudGFyZ2V0LmRyYWdSaWdodEl0ZW0gfHwgZmFsc2U7XG4gIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBHaXZlbiBhbiBncm91cCBpZCwgcmV0dXJucyB0aGUgaW5kZXggaXQgaGFzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBncm91cElEXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fZ2V0R3JvdXBJbmRleCA9IGZ1bmN0aW9uKGdyb3VwSWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGdyb3VwSWQgPT0gdGhpcy5ncm91cElkc1tpXSlcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU3RhcnQgZHJhZ2dpbmcgdGhlIHNlbGVjdGVkIGV2ZW50c1xuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgaXRlbSA9IHRoaXMudG91Y2hQYXJhbXMuaXRlbSB8fCBudWxsO1xuICB2YXIgbWUgPSB0aGlzO1xuICB2YXIgcHJvcHM7XG5cbiAgaWYgKGl0ZW0gJiYgaXRlbS5zZWxlY3RlZCkge1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSAmJlxuICAgICAgICAhdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwICYmXG4gICAgICAgICFpdGVtLmVkaXRhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgb3B0aW9ucy5lZGl0YWJsZVxuICAgIGlmIChpdGVtLmVkaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkcmFnTGVmdEl0ZW0gPSB0aGlzLnRvdWNoUGFyYW1zLmRyYWdMZWZ0SXRlbTtcbiAgICB2YXIgZHJhZ1JpZ2h0SXRlbSA9IHRoaXMudG91Y2hQYXJhbXMuZHJhZ1JpZ2h0SXRlbTtcblxuICAgIGlmIChkcmFnTGVmdEl0ZW0pIHtcbiAgICAgIHByb3BzID0ge1xuICAgICAgICBpdGVtOiBkcmFnTGVmdEl0ZW0sXG4gICAgICAgIGluaXRpYWxYOiBldmVudC5jZW50ZXIueCxcbiAgICAgICAgZHJhZ0xlZnQ6ICB0cnVlLFxuICAgICAgICBkYXRhOiB0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW0uZGF0YSlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gW3Byb3BzXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHJhZ1JpZ2h0SXRlbSkge1xuICAgICAgcHJvcHMgPSB7XG4gICAgICAgIGl0ZW06IGRyYWdSaWdodEl0ZW0sXG4gICAgICAgIGluaXRpYWxYOiBldmVudC5jZW50ZXIueCxcbiAgICAgICAgZHJhZ1JpZ2h0OiB0cnVlLFxuICAgICAgICBkYXRhOiB0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW0uZGF0YSlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gW3Byb3BzXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnRvdWNoUGFyYW1zLnNlbGVjdGVkSXRlbSA9IGl0ZW07XG5cbiAgICAgIHZhciBiYXNlR3JvdXBJbmRleCA9IHRoaXMuX2dldEdyb3VwSW5kZXgoaXRlbS5kYXRhLmdyb3VwKTtcblxuICAgICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSB0aGlzLmdldFNlbGVjdGlvbigpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBtZS5pdGVtc1tpZF07XG4gICAgICAgIHZhciBncm91cEluZGV4ID0gbWUuX2dldEdyb3VwSW5kZXgoaXRlbS5kYXRhLmdyb3VwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgIGluaXRpYWxYOiBldmVudC5jZW50ZXIueCxcbiAgICAgICAgICBncm91cE9mZnNldDogYmFzZUdyb3VwSW5kZXgtZ3JvdXBJbmRleCxcbiAgICAgICAgICBkYXRhOiB0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW0uZGF0YSlcbiAgICAgICAgfTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmVkaXRhYmxlLmFkZCAmJiAoZXZlbnQuc3JjRXZlbnQuY3RybEtleSB8fCBldmVudC5zcmNFdmVudC5tZXRhS2V5KSkge1xuICAgIC8vIGNyZWF0ZSBhIG5ldyByYW5nZSBpdGVtIHdoZW4gZHJhZ2dpbmcgd2l0aCBjdHJsIGtleSBkb3duXG4gICAgdGhpcy5fb25EcmFnU3RhcnRBZGRJdGVtKGV2ZW50KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydCBjcmVhdGluZyBhIG5ldyByYW5nZSBpdGVtIGJ5IGRyYWdnaW5nLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vbkRyYWdTdGFydEFkZEl0ZW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNuYXAgPSB0aGlzLm9wdGlvbnMuc25hcCB8fCBudWxsO1xuICB2YXIgeEFicyA9IHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuZG9tLmZyYW1lKTtcbiAgdmFyIHggPSBldmVudC5jZW50ZXIueCAtIHhBYnMgLSAxMDsgIC8vIG1pbnVzIDEwIHRvIGNvbXBlbnNhdGUgZm9yIHRoZSBkcmFnIHN0YXJ0aW5nIGFzIHNvb24gYXMgeW91J3ZlIG1vdmVkIDEwcHhcbiAgdmFyIHRpbWUgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoeCk7XG4gIHZhciBzY2FsZSA9IHRoaXMuYm9keS51dGlsLmdldFNjYWxlKCk7XG4gIHZhciBzdGVwID0gdGhpcy5ib2R5LnV0aWwuZ2V0U3RlcCgpO1xuICB2YXIgc3RhcnQgPSBzbmFwID8gc25hcCh0aW1lLCBzY2FsZSwgc3RlcCkgOiBzdGFydDtcbiAgdmFyIGVuZCA9IHN0YXJ0O1xuXG4gIHZhciBpdGVtRGF0YSA9IHtcbiAgICB0eXBlOiAncmFuZ2UnLFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZCxcbiAgICBjb250ZW50OiAnbmV3IGl0ZW0nXG4gIH07XG5cbiAgdmFyIGlkID0gdXRpbC5yYW5kb21VVUlEKCk7XG4gIGl0ZW1EYXRhW3RoaXMuaXRlbXNEYXRhLl9maWVsZElkXSA9IGlkO1xuXG4gIHZhciBncm91cCA9IHRoaXMuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcbiAgaWYgKGdyb3VwKSB7XG4gICAgaXRlbURhdGEuZ3JvdXAgPSBncm91cC5ncm91cElkO1xuICB9XG5cbiAgdmFyIG5ld0l0ZW0gPSBuZXcgUmFuZ2VJdGVtKGl0ZW1EYXRhLCB0aGlzLmNvbnZlcnNpb24sIHRoaXMub3B0aW9ucyk7XG4gIG5ld0l0ZW0uaWQgPSBpZDsgLy8gVE9ETzogbm90IHNvIG5pY2Ugc2V0dGluZyBpZCBhZnRlcndhcmRzXG4gIG5ld0l0ZW0uZGF0YSA9IHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbURhdGEpO1xuICB0aGlzLl9hZGRJdGVtKG5ld0l0ZW0pO1xuXG4gIHZhciBwcm9wcyA9IHtcbiAgICBpdGVtOiBuZXdJdGVtLFxuICAgIGRyYWdSaWdodDogdHJ1ZSxcbiAgICBpbml0aWFsWDogZXZlbnQuY2VudGVyLngsXG4gICAgZGF0YTogbmV3SXRlbS5kYXRhXG4gIH07XG4gIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gW3Byb3BzXTtcblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbi8qKlxuICogRHJhZyBzZWxlY3RlZCBpdGVtc1xuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzKSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAgfHwgbnVsbDtcbiAgICB2YXIgeE9mZnNldCA9IHRoaXMuYm9keS5kb20ucm9vdC5vZmZzZXRMZWZ0ICsgdGhpcy5ib2R5LmRvbVByb3BzLmxlZnQud2lkdGg7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnV0aWwuZ2V0U2NhbGUoKTtcbiAgICB2YXIgc3RlcCA9IHRoaXMuYm9keS51dGlsLmdldFN0ZXAoKTtcblxuICAgIC8vb25seSBjYWxjdWxhdGUgdGhlIG5ldyBncm91cCBmb3IgdGhlIGl0ZW0gdGhhdCdzIGFjdHVhbGx5IGRyYWdnZWRcbiAgICB2YXIgc2VsZWN0ZWRJdGVtID0gdGhpcy50b3VjaFBhcmFtcy5zZWxlY3RlZEl0ZW07XG4gICAgdmFyIHVwZGF0ZUdyb3VwQWxsb3dlZCA9IG1lLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXA7XG4gICAgdmFyIG5ld0dyb3VwQmFzZSA9IG51bGw7XG4gICAgaWYgKHVwZGF0ZUdyb3VwQWxsb3dlZCAmJiBzZWxlY3RlZEl0ZW0pIHtcbiAgICAgIGlmIChzZWxlY3RlZEl0ZW0uZGF0YS5ncm91cCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZHJhZyBmcm9tIG9uZSBncm91cCB0byBhbm90aGVyXG4gICAgICAgIHZhciBncm91cCA9IG1lLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgIC8vd2Uga25vdyB0aGUgb2Zmc2V0IGZvciBhbGwgaXRlbXMsIHNvIHRoZSBuZXcgZ3JvdXAgZm9yIGFsbCBpdGVtc1xuICAgICAgICAgIC8vd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzIG9uZS5cbiAgICAgICAgICBuZXdHcm91cEJhc2UgPSB0aGlzLl9nZXRHcm91cEluZGV4KGdyb3VwLmdyb3VwSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbW92ZVxuICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICB2YXIgY3VycmVudCA9IG1lLmJvZHkudXRpbC50b1RpbWUoZXZlbnQuY2VudGVyLnggLSB4T2Zmc2V0KTtcbiAgICAgIHZhciBpbml0aWFsID0gbWUuYm9keS51dGlsLnRvVGltZShwcm9wcy5pbml0aWFsWCAtIHhPZmZzZXQpO1xuICAgICAgdmFyIG9mZnNldCA9IGN1cnJlbnQgLSBpbml0aWFsOyAvLyBtc1xuXG4gICAgICB2YXIgaXRlbURhdGEgPSB0aGlzLl9jbG9uZUl0ZW1EYXRhKHByb3BzLml0ZW0uZGF0YSk7IC8vIGNsb25lIHRoZSBkYXRhXG4gICAgICBpZiAocHJvcHMuaXRlbS5lZGl0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlVGltZUFsbG93ZWQgPSBtZS5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgfHxcbiAgICAgICAgICBwcm9wcy5pdGVtLmVkaXRhYmxlID09PSB0cnVlO1xuXG4gICAgICBpZiAodXBkYXRlVGltZUFsbG93ZWQpIHtcbiAgICAgICAgaWYgKHByb3BzLmRyYWdMZWZ0KSB7XG4gICAgICAgICAgLy8gZHJhZyBsZWZ0IHNpZGUgb2YgYSByYW5nZSBpdGVtXG4gICAgICAgICAgaWYgKGl0ZW1EYXRhLnN0YXJ0ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxTdGFydCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLnN0YXJ0LCAnRGF0ZScpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoaW5pdGlhbFN0YXJ0LnZhbHVlT2YoKSArIG9mZnNldCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgIGl0ZW1EYXRhLnN0YXJ0ID0gc25hcCA/IHNuYXAoc3RhcnQsIHNjYWxlLCBzdGVwKSA6IHN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9wcy5kcmFnUmlnaHQpIHtcbiAgICAgICAgICAvLyBkcmFnIHJpZ2h0IHNpZGUgb2YgYSByYW5nZSBpdGVtXG4gICAgICAgICAgaWYgKGl0ZW1EYXRhLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsRW5kID0gdXRpbC5jb252ZXJ0KHByb3BzLmRhdGEuZW5kLCAnRGF0ZScpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IG5ldyBEYXRlKGluaXRpYWxFbmQudmFsdWVPZigpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBNb21lbnQgaW5zdGVhZCBvZiBhIERhdGUgdG8gc25hcCgpLiAoQnJlYWtpbmcgY2hhbmdlKVxuICAgICAgICAgICAgaXRlbURhdGEuZW5kID0gc25hcCA/IHNuYXAoZW5kLCBzY2FsZSwgc3RlcCkgOiBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGRyYWcgYm90aCBzdGFydCBhbmQgZW5kXG4gICAgICAgICAgaWYgKGl0ZW1EYXRhLnN0YXJ0ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxTdGFydCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLnN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGluaXRpYWxTdGFydCArIG9mZnNldCk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtRGF0YS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBpbml0aWFsRW5kID0gdXRpbC5jb252ZXJ0KHByb3BzLmRhdGEuZW5kLCAnRGF0ZScpO1xuICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gID0gaW5pdGlhbEVuZC52YWx1ZU9mKCkgLSBpbml0aWFsU3RhcnQudmFsdWVPZigpO1xuXG4gICAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBNb21lbnQgaW5zdGVhZCBvZiBhIERhdGUgdG8gc25hcCgpLiAoQnJlYWtpbmcgY2hhbmdlKVxuICAgICAgICAgICAgICBpdGVtRGF0YS5zdGFydCA9IHNuYXAgPyBzbmFwKHN0YXJ0LCBzY2FsZSwgc3RlcCkgOiBzdGFydDtcbiAgICAgICAgICAgICAgaXRlbURhdGEuZW5kICAgPSBuZXcgRGF0ZShpdGVtRGF0YS5zdGFydC52YWx1ZU9mKCkgKyBkdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIE1vbWVudCBpbnN0ZWFkIG9mIGEgRGF0ZSB0byBzbmFwKCkuIChCcmVha2luZyBjaGFuZ2UpXG4gICAgICAgICAgICAgIGl0ZW1EYXRhLnN0YXJ0ID0gc25hcCA/IHNuYXAoc3RhcnQsIHNjYWxlLCBzdGVwKSA6IHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlR3JvdXBBbGxvd2VkID0gbWUub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCB8fFxuICAgICAgICAgIHByb3BzLml0ZW0uZWRpdGFibGUgPT09IHRydWU7XG5cbiAgICAgIGlmICh1cGRhdGVHcm91cEFsbG93ZWQgJiYgKCFwcm9wcy5kcmFnTGVmdCAmJiAhcHJvcHMuZHJhZ1JpZ2h0KSAmJiBuZXdHcm91cEJhc2UhPW51bGwpIHtcbiAgICAgICAgaWYgKGl0ZW1EYXRhLmdyb3VwICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBuZXdPZmZzZXQgPSBuZXdHcm91cEJhc2UgLSBwcm9wcy5ncm91cE9mZnNldDtcblxuICAgICAgICAgIC8vbWFrZSBzdXJlIHdlIHN0YXkgaW4gYm91bmRzXG4gICAgICAgICAgbmV3T2Zmc2V0ID0gTWF0aC5tYXgoMCwgbmV3T2Zmc2V0KTtcbiAgICAgICAgICBuZXdPZmZzZXQgPSBNYXRoLm1pbihtZS5ncm91cElkcy5sZW5ndGgtMSwgbmV3T2Zmc2V0KTtcblxuICAgICAgICAgIGl0ZW1EYXRhLmdyb3VwID0gbWUuZ3JvdXBJZHNbbmV3T2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjb25maXJtIG1vdmluZyB0aGUgaXRlbVxuICAgICAgaXRlbURhdGEgPSB0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW1EYXRhKTsgIC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCB0byB0aGUgY29ycmVjdCB0eXBlXG4gICAgICBtZS5vcHRpb25zLm9uTW92aW5nKGl0ZW1EYXRhLCBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICAgICAgaWYgKGl0ZW1EYXRhKSB7XG4gICAgICAgICAgcHJvcHMuaXRlbS5zZXREYXRhKHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbURhdGEsICdEYXRlJykpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlOyAvLyBmb3JjZSByZS1zdGFja2luZyBvZiBhbGwgaXRlbXMgbmV4dCByZWRyYXdcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdjaGFuZ2UnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNb3ZlIGFuIGl0ZW0gdG8gYW5vdGhlciBncm91cFxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gZ3JvdXBJZFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX21vdmVUb0dyb3VwID0gZnVuY3Rpb24oaXRlbSwgZ3JvdXBJZCkge1xuICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgaWYgKGdyb3VwICYmIGdyb3VwLmdyb3VwSWQgIT0gaXRlbS5kYXRhLmdyb3VwKSB7XG4gICAgdmFyIG9sZEdyb3VwID0gaXRlbS5wYXJlbnQ7XG4gICAgb2xkR3JvdXAucmVtb3ZlKGl0ZW0pO1xuICAgIG9sZEdyb3VwLm9yZGVyKCk7XG4gICAgZ3JvdXAuYWRkKGl0ZW0pO1xuICAgIGdyb3VwLm9yZGVyKCk7XG5cbiAgICBpdGVtLmRhdGEuZ3JvdXAgPSBncm91cC5ncm91cElkO1xuICB9XG59O1xuXG4vKipcbiAqIEVuZCBvZiBkcmFnZ2luZyBzZWxlY3RlZCBpdGVtc1xuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzKSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBkYXRhc2V0ID0gdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpO1xuICAgIHZhciBpdGVtUHJvcHMgPSB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA7XG4gICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBudWxsO1xuXG4gICAgaXRlbVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICB2YXIgaWQgPSBwcm9wcy5pdGVtLmlkO1xuICAgICAgdmFyIGV4aXN0cyA9IG1lLml0ZW1zRGF0YS5nZXQoaWQsIG1lLml0ZW1PcHRpb25zKSAhPSBudWxsO1xuXG4gICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAvLyBhZGQgYSBuZXcgaXRlbVxuICAgICAgICBtZS5vcHRpb25zLm9uQWRkKHByb3BzLml0ZW0uZGF0YSwgZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgICAgICAgbWUuX3JlbW92ZUl0ZW0ocHJvcHMuaXRlbSk7IC8vIHJlbW92ZSB0ZW1wb3JhcnkgaXRlbVxuICAgICAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICAgICAgbWUuaXRlbXNEYXRhLmdldERhdGFTZXQoKS5hZGQoaXRlbURhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICAgICAgICAgIG1lLnN0YWNrRGlydHkgPSB0cnVlO1xuICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdjaGFuZ2UnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIGl0ZW1cbiAgICAgICAgdmFyIGl0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShwcm9wcy5pdGVtLmRhdGEpOyAvLyBjb252ZXJ0IHN0YXJ0IGFuZCBlbmQgdG8gdGhlIGNvcnJlY3QgdHlwZVxuICAgICAgICBtZS5vcHRpb25zLm9uTW92ZShpdGVtRGF0YSwgZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhKSB7XG4gICAgICAgICAgICAvLyBhcHBseSBjaGFuZ2VzXG4gICAgICAgICAgICBpdGVtRGF0YVtkYXRhc2V0Ll9maWVsZElkXSA9IGlkOyAvLyBlbnN1cmUgdGhlIGl0ZW0gY29udGFpbnMgaXRzIGlkIChjYW4gYmUgdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGF0YXNldC51cGRhdGUoaXRlbURhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgICBwcm9wcy5pdGVtLnNldERhdGEocHJvcHMuZGF0YSk7XG5cbiAgICAgICAgICAgIG1lLnN0YWNrRGlydHkgPSB0cnVlOyAvLyBmb3JjZSByZS1zdGFja2luZyBvZiBhbGwgaXRlbXMgbmV4dCByZWRyYXdcbiAgICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdjaGFuZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cbn07XG5cbkl0ZW1TZXQucHJvdG90eXBlLl9vbkdyb3VwRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdGlmICh0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5vcmRlcikge1xuXHRcdHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCA9IHRoaXMuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcblx0XHRcblx0XHRpZiAodGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwKSB7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXIgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKHtcblx0XHRcdCAgICBvcmRlcjogdGhpcy5vcHRpb25zLmdyb3VwT3JkZXJcblx0XHQgICAgfSk7XG5cdFx0fVxuXHR9XG59XG5cbkl0ZW1TZXQucHJvdG90eXBlLl9vbkdyb3VwRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRpZiAodGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIgJiYgdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwKSB7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XG5cdFx0Ly8gZHJhZyBmcm9tIG9uZSBncm91cCB0byBhbm90aGVyXG5cdFx0dmFyIGdyb3VwID0gdGhpcy5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuXHRcdFxuXHRcdC8vIHRyeSB0byBhdm9pZCB0b2dnbGluZyB3aGVuIGdyb3VwcyBkaWZmZXIgaW4gaGVpZ2h0XG5cdFx0aWYgKGdyb3VwICYmIGdyb3VwLmhlaWdodCAhPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuaGVpZ2h0KSB7XG5cdFx0XHR2YXIgbW92aW5nVXAgPSAoZ3JvdXAudG9wIDwgdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLnRvcCk7XG5cdFx0XHR2YXIgY2xpZW50WSA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci55IDogZXZlbnQuY2xpZW50WTtcblx0XHRcdHZhciB0YXJnZXRHcm91cFRvcCA9IHV0aWwuZ2V0QWJzb2x1dGVUb3AoZ3JvdXAuZG9tLmZvcmVncm91bmQpO1xuXHRcdFx0dmFyIGRyYWdnZWRHcm91cEhlaWdodCA9IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC5oZWlnaHQ7XG5cdFx0XHRpZiAobW92aW5nVXApIHtcblx0XHRcdFx0Ly8gc2tpcCBzd2FwcGluZyB0aGUgZ3JvdXBzIHdoZW4gdGhlIGRyYWdnZWQgZ3JvdXAgaXMgbm90IGJlbG93IGNsaWVudFkgYWZ0ZXJ3YXJkc1xuXHRcdFx0XHRpZiAodGFyZ2V0R3JvdXBUb3AgKyBkcmFnZ2VkR3JvdXBIZWlnaHQgPCBjbGllbnRZKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgdGFyZ2V0R3JvdXBIZWlnaHQgPSBncm91cC5oZWlnaHQ7XG5cdFx0XHRcdC8vIHNraXAgc3dhcHBpbmcgdGhlIGdyb3VwcyB3aGVuIHRoZSBkcmFnZ2VkIGdyb3VwIGlzIG5vdCBiZWxvdyBjbGllbnRZIGFmdGVyd2FyZHNcblx0XHRcdFx0aWYgKHRhcmdldEdyb3VwVG9wICsgdGFyZ2V0R3JvdXBIZWlnaHQgLSBkcmFnZ2VkR3JvdXBIZWlnaHQgPiBjbGllbnRZKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChncm91cCAmJiBncm91cCAhPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXApIHtcblx0XHRcdHZhciBncm91cHNEYXRhID0gdGhpcy5ncm91cHNEYXRhO1xuXHRcdFx0dmFyIHRhcmdldEdyb3VwID0gZ3JvdXBzRGF0YS5nZXQoZ3JvdXAuZ3JvdXBJZCk7XG5cdFx0XHR2YXIgZHJhZ2dlZEdyb3VwID0gZ3JvdXBzRGF0YS5nZXQodGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmdyb3VwSWQpO1xuXHRcdFx0XG5cdFx0XHQvLyBzd2l0Y2ggZ3JvdXBzXG5cdFx0XHRpZiAoZHJhZ2dlZEdyb3VwICYmIHRhcmdldEdyb3VwKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5ncm91cE9yZGVyU3dhcChkcmFnZ2VkR3JvdXAsIHRhcmdldEdyb3VwLCB0aGlzLmdyb3Vwc0RhdGEpO1xuXHRcdFx0XHR0aGlzLmdyb3Vwc0RhdGEudXBkYXRlKGRyYWdnZWRHcm91cCk7XG5cdFx0XHRcdHRoaXMuZ3JvdXBzRGF0YS51cGRhdGUodGFyZ2V0R3JvdXApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBmZXRjaCBjdXJyZW50IG9yZGVyIG9mIGdyb3Vwc1xuXHRcdFx0dmFyIG5ld09yZGVyID0gdGhpcy5ncm91cHNEYXRhLmdldElkcyh7XG5cdFx0XHQgICAgb3JkZXI6IHRoaXMub3B0aW9ucy5ncm91cE9yZGVyXG5cdFx0ICAgIH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBpbiBjYXNlIG9mIGNoYW5nZXMgc2luY2UgX29uR3JvdXBEcmFnU3RhcnRcblx0XHRcdGlmICghdXRpbC5lcXVhbEFycmF5KG5ld09yZGVyLCB0aGlzLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlcikpIHtcblx0XHRcdFx0dmFyIGdyb3Vwc0RhdGEgPSB0aGlzLmdyb3Vwc0RhdGE7XG5cdFx0XHRcdHZhciBvcmlnT3JkZXIgPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlcjtcblx0XHRcdFx0dmFyIGRyYWdnZWRJZCA9IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC5ncm91cElkO1xuXHRcdFx0XHR2YXIgbnVtR3JvdXBzID0gTWF0aC5taW4ob3JpZ09yZGVyLmxlbmd0aCwgbmV3T3JkZXIubGVuZ3RoKTtcblx0XHRcdFx0dmFyIGN1clBvcyA9IDA7XG5cdFx0XHRcdHZhciBuZXdPZmZzZXQgPSAwO1xuXHRcdFx0XHR2YXIgb3JnT2Zmc2V0ID0gMDtcblx0XHRcdFx0d2hpbGUgKGN1clBvcyA8IG51bUdyb3Vwcykge1xuXHRcdFx0XHRcdC8vIGFzIGxvbmcgYXMgdGhlIGdyb3VwcyBhcmUgd2hlcmUgdGhleSBzaG91bGQgYmUgc3RlcCBkb3duIGFsb25nIHRoZSBncm91cHMgb3JkZXJcblx0XHRcdFx0XHR3aGlsZSAoKGN1clBvcytuZXdPZmZzZXQpIDwgbnVtR3JvdXBzIFxuXHRcdFx0XHRcdFx0JiYgKGN1clBvcytvcmdPZmZzZXQpIDwgbnVtR3JvdXBzIFxuXHRcdFx0XHRcdFx0JiYgbmV3T3JkZXJbY3VyUG9zK25ld09mZnNldF0gPT0gb3JpZ09yZGVyW2N1clBvcytvcmdPZmZzZXRdKSB7XG5cdFx0XHRcdFx0XHRjdXJQb3MrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gYWxsIG9rXG5cdFx0XHRcdFx0aWYgKGN1clBvcytuZXdPZmZzZXQgPj0gbnVtR3JvdXBzKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gbm90IGFsbCBva1xuXHRcdFx0XHRcdC8vIGlmIGRyYWdnZWQgZ3JvdXAgd2FzIG1vdmUgdXB3YXJkcyBldmVyeXRoaW5nIGJlbG93IHNob3VsZCBoYXZlIGFuIG9mZnNldFxuXHRcdFx0XHRcdGlmIChuZXdPcmRlcltjdXJQb3MrbmV3T2Zmc2V0XSA9PSBkcmFnZ2VkSWQpIHtcblx0XHRcdFx0XHRcdG5ld09mZnNldCA9IDE7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gaWYgZHJhZ2dlZCBncm91cCB3YXMgbW92ZSBkb3dud2FyZHMgZXZlcnl0aGluZyBhYm92ZSBzaG91bGQgaGF2ZSBhbiBvZmZzZXRcblx0XHRcdFx0XHRlbHNlIGlmIChvcmlnT3JkZXJbY3VyUG9zK29yZ09mZnNldF0gPT0gZHJhZ2dlZElkKSB7XG5cdFx0XHRcdFx0XHRvcmdPZmZzZXQgPSAxO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fSBcblx0XHRcdFx0XHQvLyBmb3VuZCBhIGdyb3VwIChhcGFydCBmcm9tIGRyYWdnZWQgZ3JvdXApIHRoYXQgaGFzIHRoZSB3cm9uZyBwb3NpdGlvbiAtPiBzd2l0Y2ggd2l0aCB0aGUgXG5cdFx0XHRcdFx0Ly8gZ3JvdXAgYXQgdGhlIHBvc2l0aW9uIHdoZXJlIG90aGVyIG9uZSBzaG91bGQgYmUsIGZpeCBpbmRleCBhcnJheXMgYW5kIGNvbnRpbnVlXG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgc2xpcHBlZFBvc2l0aW9uID0gbmV3T3JkZXIuaW5kZXhPZihvcmlnT3JkZXJbY3VyUG9zK29yZ09mZnNldF0pXG5cdFx0XHRcdFx0XHR2YXIgc3dpdGNoR3JvdXAgPSBncm91cHNEYXRhLmdldChuZXdPcmRlcltjdXJQb3MrbmV3T2Zmc2V0XSk7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkQmVHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KG9yaWdPcmRlcltjdXJQb3Mrb3JnT2Zmc2V0XSk7XG5cdFx0XHRcdFx0XHR0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclN3YXAoc3dpdGNoR3JvdXAsIHNob3VsZEJlR3JvdXAsIGdyb3Vwc0RhdGEpO1xuXHRcdFx0XHRcdFx0Z3JvdXBzRGF0YS51cGRhdGUoc3dpdGNoR3JvdXApO1xuXHRcdFx0XHRcdFx0Z3JvdXBzRGF0YS51cGRhdGUoc2hvdWxkQmVHcm91cCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHZhciBzd2l0Y2hHcm91cElkID0gbmV3T3JkZXJbY3VyUG9zK25ld09mZnNldF07XG5cdFx0XHRcdFx0XHRuZXdPcmRlcltjdXJQb3MrbmV3T2Zmc2V0XSA9IG9yaWdPcmRlcltjdXJQb3Mrb3JnT2Zmc2V0XTtcblx0XHRcdFx0XHRcdG5ld09yZGVyW3NsaXBwZWRQb3NpdGlvbl0gPSBzd2l0Y2hHcm91cElkO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjdXJQb3MrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdH1cblx0fVxufVxuXG5JdGVtU2V0LnByb3RvdHlwZS5fb25Hcm91cERyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0aWYgKHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyICYmIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFxuXHRcdC8vIHVwZGF0ZSBleGlzdGluZyBncm91cFxuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGlkID0gbWUuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC5ncm91cElkO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ3JvdXBzRGF0YS5nZXREYXRhU2V0KCk7XG4gICAgICAgIHZhciBncm91cERhdGEgPSB1dGlsLmV4dGVuZCh7fSwgZGF0YXNldC5nZXQoaWQpKTsgLy8gY2xvbmUgdGhlIGRhdGFcbiAgICAgICAgbWUub3B0aW9ucy5vbk1vdmVHcm91cChncm91cERhdGEsIGZ1bmN0aW9uIChncm91cERhdGEpIHtcbiAgICAgICAgICBpZiAoZ3JvdXBEYXRhKSB7XG4gICAgICAgICAgICAvLyBhcHBseSBjaGFuZ2VzXG4gICAgICAgIFx0Z3JvdXBEYXRhW2RhdGFzZXQuX2ZpZWxkSWRdID0gaWQ7IC8vIGVuc3VyZSB0aGUgZ3JvdXAgY29udGFpbnMgaXRzIGlkIChjYW4gYmUgdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGF0YXNldC51cGRhdGUoZ3JvdXBEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgIFx0ICBcbiAgICAgICAgXHQvLyBmZXRjaCBjdXJyZW50IG9yZGVyIG9mIGdyb3Vwc1xuICBcdFx0XHR2YXIgbmV3T3JkZXIgPSBkYXRhc2V0LmdldElkcyh7XG4gIFx0XHRcdCAgICBvcmRlcjogbWUub3B0aW9ucy5ncm91cE9yZGVyXG4gIFx0XHQgICAgfSk7XG4gICAgICAgIFx0ICBcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgb3JkZXJcbiAgICAgICAgXHRpZiAoIXV0aWwuZXF1YWxBcnJheShuZXdPcmRlciwgbWUuZ3JvdXBUb3VjaFBhcmFtcy5vcmlnaW5hbE9yZGVyKSkge1xuICAgICAgICBcdFx0dmFyIG9yaWdPcmRlciA9IG1lLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlcjtcbiAgXHRcdFx0XHR2YXIgbnVtR3JvdXBzID0gTWF0aC5taW4ob3JpZ09yZGVyLmxlbmd0aCwgbmV3T3JkZXIubGVuZ3RoKTtcbiAgXHRcdFx0XHR2YXIgY3VyUG9zID0gMDtcbiAgXHRcdFx0XHR3aGlsZSAoY3VyUG9zIDwgbnVtR3JvdXBzKSB7XG4gIFx0XHRcdFx0XHQvLyBhcyBsb25nIGFzIHRoZSBncm91cHMgYXJlIHdoZXJlIHRoZXkgc2hvdWxkIGJlIHN0ZXAgZG93biBhbG9uZyB0aGUgZ3JvdXBzIG9yZGVyXG4gIFx0XHRcdFx0XHR3aGlsZSAoY3VyUG9zIDwgbnVtR3JvdXBzICYmIG5ld09yZGVyW2N1clBvc10gPT0gb3JpZ09yZGVyW2N1clBvc10pIHtcbiAgXHRcdFx0XHRcdCAgICBjdXJQb3MrKztcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFxuICBcdFx0XHRcdFx0Ly8gYWxsIG9rXG4gIFx0XHRcdFx0XHRpZiAoY3VyUG9zID49IG51bUdyb3Vwcykge1xuICBcdFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFxuICBcdFx0XHRcdFx0Ly8gZm91bmQgYSBncm91cCB0aGF0IGhhcyB0aGUgd3JvbmcgcG9zaXRpb24gLT4gc3dpdGNoIHdpdGggdGhlIFxuICBcdFx0XHRcdFx0Ly8gZ3JvdXAgYXQgdGhlIHBvc2l0aW9uIHdoZXJlIG90aGVyIG9uZSBzaG91bGQgYmUsIGZpeCBpbmRleCBhcnJheXMgYW5kIGNvbnRpbnVlXG4gIFx0XHRcdFx0XHR2YXIgc2xpcHBlZFBvc2l0aW9uID0gbmV3T3JkZXIuaW5kZXhPZihvcmlnT3JkZXJbY3VyUG9zXSlcbiAgXHRcdFx0XHRcdHZhciBzd2l0Y2hHcm91cCA9IGRhdGFzZXQuZ2V0KG5ld09yZGVyW2N1clBvc10pO1xuICBcdFx0XHRcdFx0dmFyIHNob3VsZEJlR3JvdXAgPSBkYXRhc2V0LmdldChvcmlnT3JkZXJbY3VyUG9zXSk7XG4gIFx0XHRcdFx0XHRtZS5vcHRpb25zLmdyb3VwT3JkZXJTd2FwKHN3aXRjaEdyb3VwLCBzaG91bGRCZUdyb3VwLCBkYXRhc2V0KTtcbiAgXHRcdFx0XHRcdGdyb3Vwc0RhdGEudXBkYXRlKHN3aXRjaEdyb3VwKTtcblx0XHRcdFx0XHRncm91cHNEYXRhLnVwZGF0ZShzaG91bGRCZUdyb3VwKTtcbiAgXHRcdFx0XHRcdFx0XG4gIFx0XHRcdFx0XHR2YXIgc3dpdGNoR3JvdXBJZCA9IG5ld09yZGVyW2N1clBvc107XG4gIFx0XHRcdFx0XHRuZXdPcmRlcltjdXJQb3NdID0gb3JpZ09yZGVyW2N1clBvc107XG4gIFx0XHRcdFx0XHRuZXdPcmRlcltzbGlwcGVkUG9zaXRpb25dID0gc3dpdGNoR3JvdXBJZDtcbiAgXHRcdFx0XHRcdFx0XG4gIFx0XHRcdFx0XHRjdXJQb3MrKztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgnZ3JvdXBEcmFnZ2VkJywgeyBncm91cElkOiBpZCB9KTtcblx0fVxufVxuXG4vKipcbiAqIEhhbmRsZSBzZWxlY3RpbmcvZGVzZWxlY3RpbmcgYW4gaXRlbSB3aGVuIHRhcHBpbmcgaXRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25TZWxlY3RJdGVtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLnNlbGVjdGFibGUpIHJldHVybjtcblxuICB2YXIgY3RybEtleSAgPSBldmVudC5zcmNFdmVudCAmJiAoZXZlbnQuc3JjRXZlbnQuY3RybEtleSB8fCBldmVudC5zcmNFdmVudC5tZXRhS2V5KTtcbiAgdmFyIHNoaWZ0S2V5ID0gZXZlbnQuc3JjRXZlbnQgJiYgZXZlbnQuc3JjRXZlbnQuc2hpZnRLZXk7XG4gIGlmIChjdHJsS2V5IHx8IHNoaWZ0S2V5KSB7XG4gICAgdGhpcy5fb25NdWx0aVNlbGVjdEl0ZW0oZXZlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvbGRTZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gIHZhciBpdGVtID0gdGhpcy5pdGVtRnJvbVRhcmdldChldmVudCk7XG4gIHZhciBzZWxlY3Rpb24gPSBpdGVtID8gW2l0ZW0uaWRdIDogW107XG4gIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG5cbiAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgLy8gZW1pdCBhIHNlbGVjdCBldmVudCxcbiAgLy8gZXhjZXB0IHdoZW4gb2xkIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgbmV3IHNlbGVjdGlvbiBpcyBzdGlsbCBlbXB0eVxuICBpZiAobmV3U2VsZWN0aW9uLmxlbmd0aCA+IDAgfHwgb2xkU2VsZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzZWxlY3QnLCB7XG4gICAgICBpdGVtczogbmV3U2VsZWN0aW9uLFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIGNyZWF0aW9uIGFuZCB1cGRhdGVzIG9mIGFuIGl0ZW0gb24gZG91YmxlIHRhcFxuICogQHBhcmFtIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25BZGRJdGVtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLnNlbGVjdGFibGUpIHJldHVybjtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuZWRpdGFibGUuYWRkKSByZXR1cm47XG5cbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIHNuYXAgPSB0aGlzLm9wdGlvbnMuc25hcCB8fCBudWxsO1xuICB2YXIgaXRlbSA9IHRoaXMuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gIGlmIChpdGVtKSB7XG4gICAgLy8gdXBkYXRlIGl0ZW1cblxuICAgIC8vIGV4ZWN1dGUgYXN5bmMgaGFuZGxlciB0byB1cGRhdGUgdGhlIGl0ZW0gKG9yIGNhbmNlbCBpdClcbiAgICB2YXIgaXRlbURhdGEgPSBtZS5pdGVtc0RhdGEuZ2V0KGl0ZW0uaWQpOyAvLyBnZXQgYSBjbG9uZSBvZiB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhc2V0XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGl0ZW1EYXRhLCBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICBtZS5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpLnVwZGF0ZShpdGVtRGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gYWRkIGl0ZW1cbiAgICB2YXIgeEFicyA9IHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuZG9tLmZyYW1lKTtcbiAgICB2YXIgeCA9IGV2ZW50LmNlbnRlci54IC0geEFicztcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoeCk7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnV0aWwuZ2V0U2NhbGUoKTtcbiAgICB2YXIgc3RlcCA9IHRoaXMuYm9keS51dGlsLmdldFN0ZXAoKTtcblxuICAgIHZhciBuZXdJdGVtRGF0YSA9IHtcbiAgICAgIHN0YXJ0OiBzbmFwID8gc25hcChzdGFydCwgc2NhbGUsIHN0ZXApIDogc3RhcnQsXG4gICAgICBjb250ZW50OiAnbmV3IGl0ZW0nXG4gICAgfTtcblxuICAgIC8vIHdoZW4gZGVmYXVsdCB0eXBlIGlzIGEgcmFuZ2UsIGFkZCBhIGRlZmF1bHQgZW5kIGRhdGUgdG8gdGhlIG5ldyBpdGVtXG4gICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICB2YXIgZW5kID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHggKyB0aGlzLnByb3BzLndpZHRoIC8gNSk7XG4gICAgICBuZXdJdGVtRGF0YS5lbmQgPSBzbmFwID8gc25hcChlbmQsIHNjYWxlLCBzdGVwKSA6IGVuZDtcbiAgICB9XG5cbiAgICBuZXdJdGVtRGF0YVt0aGlzLml0ZW1zRGF0YS5fZmllbGRJZF0gPSB1dGlsLnJhbmRvbVVVSUQoKTtcblxuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAoZ3JvdXApIHtcbiAgICAgIG5ld0l0ZW1EYXRhLmdyb3VwID0gZ3JvdXAuZ3JvdXBJZDtcbiAgICB9XG5cbiAgICAvLyBleGVjdXRlIGFzeW5jIGhhbmRsZXIgdG8gY3VzdG9taXplIChvciBjYW5jZWwpIGFkZGluZyBhbiBpdGVtXG4gICAgbmV3SXRlbURhdGEgPSB0aGlzLl9jbG9uZUl0ZW1EYXRhKG5ld0l0ZW1EYXRhKTsgICAgIC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCB0byB0aGUgY29ycmVjdCB0eXBlXG4gICAgdGhpcy5vcHRpb25zLm9uQWRkKG5ld0l0ZW1EYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgbWUuaXRlbXNEYXRhLmdldERhdGFTZXQoKS5hZGQoaXRlbSk7XG4gICAgICAgIC8vIFRPRE86IG5lZWQgdG8gdHJpZ2dlciBhIHJlZHJhdz9cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgc2VsZWN0aW5nL2Rlc2VsZWN0aW5nIG11bHRpcGxlIGl0ZW1zIHdoZW4gaG9sZGluZyBhbiBpdGVtXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uTXVsdGlTZWxlY3RJdGVtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLnNlbGVjdGFibGUpIHJldHVybjtcblxuICB2YXIgaXRlbSA9IHRoaXMuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuXG4gIGlmIChpdGVtKSB7XG4gICAgLy8gbXVsdGkgc2VsZWN0IGl0ZW1zIChpZiBhbGxvd2VkKVxuXG4gICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMub3B0aW9ucy5tdWx0aXNlbGVjdFxuICAgICAgPyB0aGlzLmdldFNlbGVjdGlvbigpIC8vIHRha2UgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgIDogW107ICAgICAgICAgICAgICAgICAvLyBkZXNlbGVjdCBjdXJyZW50IHNlbGVjdGlvblxuXG4gICAgdmFyIHNoaWZ0S2V5ID0gZXZlbnQuc3JjRXZlbnQgJiYgZXZlbnQuc3JjRXZlbnQuc2hpZnRLZXkgfHwgZmFsc2U7XG5cbiAgICBpZiAoc2hpZnRLZXkgJiYgdGhpcy5vcHRpb25zLm11bHRpc2VsZWN0KSB7XG4gICAgICAvLyBzZWxlY3QgYWxsIGl0ZW1zIGJldHdlZW4gdGhlIG9sZCBzZWxlY3Rpb24gYW5kIHRoZSB0YXBwZWQgaXRlbVxuXG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIHNlbGVjdGlvbiByYW5nZVxuICAgICAgc2VsZWN0aW9uLnB1c2goaXRlbS5pZCk7XG4gICAgICB2YXIgcmFuZ2UgPSBJdGVtU2V0Ll9nZXRJdGVtUmFuZ2UodGhpcy5pdGVtc0RhdGEuZ2V0KHNlbGVjdGlvbiwgdGhpcy5pdGVtT3B0aW9ucykpO1xuXG4gICAgICAvLyBzZWxlY3QgYWxsIGl0ZW1zIHdpdGhpbiB0aGUgc2VsZWN0aW9uIHJhbmdlXG4gICAgICBzZWxlY3Rpb24gPSBbXTtcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgdmFyIF9pdGVtID0gdGhpcy5pdGVtc1tpZF07XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gX2l0ZW0uZGF0YS5zdGFydDtcbiAgICAgICAgICB2YXIgZW5kID0gKF9pdGVtLmRhdGEuZW5kICE9PSB1bmRlZmluZWQpID8gX2l0ZW0uZGF0YS5lbmQgOiBzdGFydDtcblxuICAgICAgICAgIGlmIChzdGFydCA+PSByYW5nZS5taW4gJiZcbiAgICAgICAgICAgICAgZW5kIDw9IHJhbmdlLm1heCAmJlxuICAgICAgICAgICAgICAhKF9pdGVtIGluc3RhbmNlb2YgQmFja2dyb3VuZEl0ZW0pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24ucHVzaChfaXRlbS5pZCk7IC8vIGRvIG5vdCB1c2UgaWQgYnV0IGl0ZW0uaWQsIGlkIGl0c2VsZiBpcyBzdHJpbmdpZmllZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGFkZC9yZW1vdmUgdGhpcyBpdGVtIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICB2YXIgaW5kZXggPSBzZWxlY3Rpb24uaW5kZXhPZihpdGVtLmlkKTtcbiAgICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgICAvLyBpdGVtIGlzIG5vdCB5ZXQgc2VsZWN0ZWQgLT4gc2VsZWN0IGl0XG4gICAgICAgIHNlbGVjdGlvbi5wdXNoKGl0ZW0uaWQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGl0ZW0gaXMgYWxyZWFkeSBzZWxlY3RlZCAtPiBkZXNlbGVjdCBpdFxuICAgICAgICBzZWxlY3Rpb24uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc2VsZWN0Jywge1xuICAgICAgaXRlbXM6IHRoaXMuZ2V0U2VsZWN0aW9uKCksXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHRpbWUgcmFuZ2Ugb2YgYSBsaXN0IG9mIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBpdGVtc0RhdGFcbiAqIEByZXR1cm4ge3ttaW46IERhdGUsIG1heDogRGF0ZX19IFJldHVybnMgdGhlIHJhbmdlIG9mIHRoZSBwcm92aWRlZCBpdGVtc1xuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5fZ2V0SXRlbVJhbmdlID0gZnVuY3Rpb24oaXRlbXNEYXRhKSB7XG4gIHZhciBtYXggPSBudWxsO1xuICB2YXIgbWluID0gbnVsbDtcblxuICBpdGVtc0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmIChtaW4gPT0gbnVsbCB8fCBkYXRhLnN0YXJ0IDwgbWluKSB7XG4gICAgICBtaW4gPSBkYXRhLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChkYXRhLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChtYXggPT0gbnVsbCB8fCBkYXRhLmVuZCA+IG1heCkge1xuICAgICAgICBtYXggPSBkYXRhLmVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAobWF4ID09IG51bGwgfHwgZGF0YS5zdGFydCA+IG1heCkge1xuICAgICAgICBtYXggPSBkYXRhLnN0YXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heFxuICB9XG59O1xuXG4vKipcbiAqIEZpbmQgYW4gaXRlbSBmcm9tIGFuIGV2ZW50IHRhcmdldDpcbiAqIHNlYXJjaGVzIGZvciB0aGUgYXR0cmlidXRlICd0aW1lbGluZS1pdGVtJyBpbiB0aGUgZXZlbnQgdGFyZ2V0J3MgZWxlbWVudCB0cmVlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7SXRlbSB8IG51bGx9IGl0ZW1cbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuaXRlbUZyb21UYXJnZXQgPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICB3aGlsZSAodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgndGltZWxpbmUtaXRlbScpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Wyd0aW1lbGluZS1pdGVtJ107XG4gICAgfVxuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIEdyb3VwIGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICogc2VhcmNoZXMgZm9yIHRoZSBhdHRyaWJ1dGUgJ3RpbWVsaW5lLWdyb3VwJyBpbiB0aGUgZXZlbnQgdGFyZ2V0J3MgZWxlbWVudCB0cmVlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7R3JvdXAgfCBudWxsfSBncm91cFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5ncm91cEZyb21UYXJnZXQgPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgY2xpZW50WSA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci55IDogZXZlbnQuY2xpZW50WTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyb3VwSWQgPSB0aGlzLmdyb3VwSWRzW2ldO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgIHZhciBmb3JlZ3JvdW5kID0gZ3JvdXAuZG9tLmZvcmVncm91bmQ7XG4gICAgdmFyIHRvcCA9IHV0aWwuZ2V0QWJzb2x1dGVUb3AoZm9yZWdyb3VuZCk7XG4gICAgaWYgKGNsaWVudFkgPiB0b3AgJiYgY2xpZW50WSA8IHRvcCArIGZvcmVncm91bmQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID09PSAndG9wJykge1xuICAgICAgaWYgKGkgPT09IHRoaXMuZ3JvdXBJZHMubGVuZ3RoIC0gMSAmJiBjbGllbnRZID4gdG9wKSB7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaSA9PT0gMCAmJiBjbGllbnRZIDwgdG9wICsgZm9yZWdyb3VuZC5vZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBJdGVtU2V0IGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICogc2VhcmNoZXMgZm9yIHRoZSBhdHRyaWJ1dGUgJ3RpbWVsaW5lLWl0ZW1zZXQnIGluIHRoZSBldmVudCB0YXJnZXQncyBlbGVtZW50IHRyZWVcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtJdGVtU2V0IHwgbnVsbH0gaXRlbVxuICovXG5JdGVtU2V0Lml0ZW1TZXRGcm9tVGFyZ2V0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgd2hpbGUgKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ3RpbWVsaW5lLWl0ZW1zZXQnKSkge1xuICAgICAgcmV0dXJuIHRhcmdldFsndGltZWxpbmUtaXRlbXNldCddO1xuICAgIH1cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbG9uZSB0aGUgZGF0YSBvZiBhbiBpdGVtLCBhbmQgXCJub3JtYWxpemVcIiBpdDogY29udmVydCB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlXG4gKiB0byB0aGUgdHlwZSAoRGF0ZSwgTW9tZW50LCAuLi4pIGNvbmZpZ3VyZWQgaW4gdGhlIERhdGFTZXQuIElmIG5vdCBjb25maWd1cmVkLFxuICogc3RhcnQgYW5kIGVuZCBhcmUgY29udmVydGVkIHRvIERhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGEsIHR5cGljYWxseSBgaXRlbS5kYXRhYFxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAgT3B0aW9uYWwgRGF0ZSB0eXBlLiBJZiBub3QgcHJvdmlkZWQsIHRoZSB0eXBlIGZyb20gdGhlIERhdGFTZXQgaXMgdGFrZW5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lZCBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9jbG9uZUl0ZW1EYXRhID0gZnVuY3Rpb24gKGl0ZW1EYXRhLCB0eXBlKSB7XG4gIHZhciBjbG9uZSA9IHV0aWwuZXh0ZW5kKHt9LCBpdGVtRGF0YSk7XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgLy8gY29udmVydCBzdGFydCBhbmQgZW5kIGRhdGUgdG8gdGhlIHR5cGUgKERhdGUsIE1vbWVudCwgLi4uKSBjb25maWd1cmVkIGluIHRoZSBEYXRhU2V0XG4gICAgdHlwZSA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKS5fb3B0aW9ucy50eXBlO1xuICB9XG5cbiAgaWYgKGNsb25lLnN0YXJ0ICE9IHVuZGVmaW5lZCkge1xuICAgIGNsb25lLnN0YXJ0ID0gdXRpbC5jb252ZXJ0KGNsb25lLnN0YXJ0LCB0eXBlICYmIHR5cGUuc3RhcnQgfHwgJ0RhdGUnKTtcbiAgfVxuICBpZiAoY2xvbmUuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgIGNsb25lLmVuZCA9IHV0aWwuY29udmVydChjbG9uZS5lbmQgLCB0eXBlICYmIHR5cGUuZW5kIHx8ICdEYXRlJyk7XG4gIH1cblxuICByZXR1cm4gY2xvbmU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZW1TZXQ7XG4iXX0=
},{"../../DataSet":15,"../../DataView":16,"../../module/hammer":19,"../../util":46,"../TimeStep":30,"./BackgroundGroup":32,"./Component":33,"./Group":36,"./item/BackgroundItem":39,"./item/BoxItem":40,"./item/PointItem":42,"./item/RangeItem":43}],38:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Component = require('./Component');
var TimeStep = require('../TimeStep');
var DateUtil = require('../DateUtil');
var moment = require('../../module/moment');

/**
 * A horizontal time axis
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
 * @param {Object} [options]        See TimeAxis.setOptions for the available
 *                                  options.
 * @constructor TimeAxis
 * @extends Component
 */
function TimeAxis(body, options) {
  this.dom = {
    foreground: null,
    lines: [],
    majorTexts: [],
    minorTexts: [],
    redundant: {
      lines: [],
      majorTexts: [],
      minorTexts: []
    }
  };
  this.props = {
    range: {
      start: 0,
      end: 0,
      minimumStep: 0
    },
    lineTop: 0
  };

  this.defaultOptions = {
    orientation: {
      axis: 'bottom'
    }, // axis orientation: 'top' or 'bottom'
    showMinorLabels: true,
    showMajorLabels: true,
    format: TimeStep.FORMAT,
    moment: moment,
    timeAxis: null
  };
  this.options = util.extend({}, this.defaultOptions);

  this.body = body;

  // create the HTML DOM
  this._create();

  this.setOptions(options);
}

TimeAxis.prototype = new Component();

/**
 * Set options for the TimeAxis.
 * Parameters will be merged in current options.
 * @param {Object} options  Available options:
 *                          {string} [orientation.axis]
 *                          {boolean} [showMinorLabels]
 *                          {boolean} [showMajorLabels]
 */
TimeAxis.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['showMinorLabels', 'showMajorLabels', 'hiddenDates', 'timeAxis', 'moment'], this.options, options);

    // deep copy the format options
    util.selectiveDeepExtend(['format'], this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation.axis = options.orientation;
      } else if (typeof options.orientation === 'object' && 'axis' in options.orientation) {
        this.options.orientation.axis = options.orientation.axis;
      }
    }

    // apply locale to moment.js
    // TODO: not so nice, this is applied globally to moment.js
    if ('locale' in options) {
      if (typeof moment.locale === 'function') {
        // moment.js 2.8.1+
        moment.locale(options.locale);
      } else {
        moment.lang(options.locale);
      }
    }
  }
};

/**
 * Create the HTML DOM for the TimeAxis
 */
TimeAxis.prototype._create = function () {
  this.dom.foreground = document.createElement('div');
  this.dom.background = document.createElement('div');

  this.dom.foreground.className = 'vis-time-axis vis-foreground';
  this.dom.background.className = 'vis-time-axis vis-background';
};

/**
 * Destroy the TimeAxis
 */
TimeAxis.prototype.destroy = function () {
  // remove from DOM
  if (this.dom.foreground.parentNode) {
    this.dom.foreground.parentNode.removeChild(this.dom.foreground);
  }
  if (this.dom.background.parentNode) {
    this.dom.background.parentNode.removeChild(this.dom.background);
  }

  this.body = null;
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
TimeAxis.prototype.redraw = function () {
  var props = this.props;
  var foreground = this.dom.foreground;
  var background = this.dom.background;

  // determine the correct parent DOM element (depending on option orientation)
  var parent = this.options.orientation.axis == 'top' ? this.body.dom.top : this.body.dom.bottom;
  var parentChanged = foreground.parentNode !== parent;

  // calculate character width and height
  this._calculateCharSize();

  // TODO: recalculate sizes only needed when parent is resized or options is changed
  var showMinorLabels = this.options.showMinorLabels && this.options.orientation.axis !== 'none';
  var showMajorLabels = this.options.showMajorLabels && this.options.orientation.axis !== 'none';

  // determine the width and height of the elemens for the axis
  props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
  props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
  props.height = props.minorLabelHeight + props.majorLabelHeight;
  props.width = foreground.offsetWidth;

  props.minorLineHeight = this.body.domProps.root.height - props.majorLabelHeight - (this.options.orientation.axis == 'top' ? this.body.domProps.bottom.height : this.body.domProps.top.height);
  props.minorLineWidth = 1; // TODO: really calculate width
  props.majorLineHeight = props.minorLineHeight + props.majorLabelHeight;
  props.majorLineWidth = 1; // TODO: really calculate width

  //  take foreground and background offline while updating (is almost twice as fast)
  var foregroundNextSibling = foreground.nextSibling;
  var backgroundNextSibling = background.nextSibling;
  foreground.parentNode && foreground.parentNode.removeChild(foreground);
  background.parentNode && background.parentNode.removeChild(background);

  foreground.style.height = this.props.height + 'px';

  this._repaintLabels();

  // put DOM online again (at the same place)
  if (foregroundNextSibling) {
    parent.insertBefore(foreground, foregroundNextSibling);
  } else {
    parent.appendChild(foreground);
  }
  if (backgroundNextSibling) {
    this.body.dom.backgroundVertical.insertBefore(background, backgroundNextSibling);
  } else {
    this.body.dom.backgroundVertical.appendChild(background);
  }

  return this._isResized() || parentChanged;
};

/**
 * Repaint major and minor text labels and vertical grid lines
 * @private
 */
TimeAxis.prototype._repaintLabels = function () {
  var orientation = this.options.orientation.axis;

  // calculate range and step (step such that we have space for 7 characters per label)
  var start = util.convert(this.body.range.start, 'Number');
  var end = util.convert(this.body.range.end, 'Number');
  var timeLabelsize = this.body.util.toTime((this.props.minorCharWidth || 10) * 7).valueOf();
  var minimumStep = timeLabelsize - DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this.body.range, timeLabelsize);
  minimumStep -= this.body.util.toTime(0).valueOf();

  var step = new TimeStep(new Date(start), new Date(end), minimumStep, this.body.hiddenDates);
  step.setMoment(this.options.moment);
  if (this.options.format) {
    step.setFormat(this.options.format);
  }
  if (this.options.timeAxis) {
    step.setScale(this.options.timeAxis);
  }
  this.step = step;

  // Move all DOM elements to a "redundant" list, where they
  // can be picked for re-use, and clear the lists with lines and texts.
  // At the end of the function _repaintLabels, left over elements will be cleaned up
  var dom = this.dom;
  dom.redundant.lines = dom.lines;
  dom.redundant.majorTexts = dom.majorTexts;
  dom.redundant.minorTexts = dom.minorTexts;
  dom.lines = [];
  dom.majorTexts = [];
  dom.minorTexts = [];

  var current;
  var next;
  var x;
  var xNext;
  var isMajor;
  var width;
  var line;
  var labelMinor;
  var xFirstMajorLabel = undefined;
  var max = 0;
  var className;

  step.start();
  next = step.getCurrent();
  xNext = this.body.util.toScreen(next);
  while (step.hasNext() && max < 1000) {
    max++;

    isMajor = step.isMajor();
    className = step.getClassName();
    labelMinor = step.getLabelMinor();

    current = next;
    x = xNext;

    step.next();
    next = step.getCurrent();
    xNext = this.body.util.toScreen(next);

    width = xNext - x;
    var labelFits = (labelMinor.length + 1) * this.props.minorCharWidth < width;

    if (this.options.showMinorLabels && labelFits) {
      this._repaintMinorText(x, labelMinor, orientation, className);
    }

    if (isMajor && this.options.showMajorLabels) {
      if (x > 0) {
        if (xFirstMajorLabel == undefined) {
          xFirstMajorLabel = x;
        }
        this._repaintMajorText(x, step.getLabelMajor(), orientation, className);
      }
      line = this._repaintMajorLine(x, width, orientation, className);
    } else {
      if (labelFits) {
        line = this._repaintMinorLine(x, width, orientation, className);
      } else {
        if (line) {
          line.style.width = parseInt(line.style.width) + width + 'px';
        }
      }
    }
  }

  // create a major label on the left when needed
  if (this.options.showMajorLabels) {
    var leftTime = this.body.util.toTime(0),
        leftText = step.getLabelMajor(leftTime),
        widthText = leftText.length * (this.props.majorCharWidth || 10) + 10; // upper bound estimation

    if (xFirstMajorLabel == undefined || widthText < xFirstMajorLabel) {
      this._repaintMajorText(0, leftText, orientation, className);
    }
  }

  // Cleanup leftover DOM elements from the redundant list
  util.forEach(this.dom.redundant, function (arr) {
    while (arr.length) {
      var elem = arr.pop();
      if (elem && elem.parentNode) {
        elem.parentNode.removeChild(elem);
      }
    }
  });
};

/**
 * Create a minor label for the axis at position x
 * @param {Number} x
 * @param {String} text
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the HTML element of the created label
 * @private
 */
TimeAxis.prototype._repaintMinorText = function (x, text, orientation, className) {
  // reuse redundant label
  var label = this.dom.redundant.minorTexts.shift();

  if (!label) {
    // create new label
    var content = document.createTextNode('');
    label = document.createElement('div');
    label.appendChild(content);
    this.dom.foreground.appendChild(label);
  }
  this.dom.minorTexts.push(label);

  label.childNodes[0].nodeValue = text;

  label.style.top = orientation == 'top' ? this.props.majorLabelHeight + 'px' : '0';
  label.style.left = x + 'px';
  label.className = 'vis-text vis-minor ' + className;
  //label.title = title;  // TODO: this is a heavy operation

  return label;
};

/**
 * Create a Major label for the axis at position x
 * @param {Number} x
 * @param {String} text
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the HTML element of the created label
 * @private
 */
TimeAxis.prototype._repaintMajorText = function (x, text, orientation, className) {
  // reuse redundant label
  var label = this.dom.redundant.majorTexts.shift();

  if (!label) {
    // create label
    var content = document.createTextNode(text);
    label = document.createElement('div');
    label.appendChild(content);
    this.dom.foreground.appendChild(label);
  }
  this.dom.majorTexts.push(label);

  label.childNodes[0].nodeValue = text;
  label.className = 'vis-text vis-major ' + className;
  //label.title = title; // TODO: this is a heavy operation

  label.style.top = orientation == 'top' ? '0' : this.props.minorLabelHeight + 'px';
  label.style.left = x + 'px';

  return label;
};

/**
 * Create a minor line for the axis at position x
 * @param {Number} x
 * @param {Number} width
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the created line
 * @private
 */
TimeAxis.prototype._repaintMinorLine = function (x, width, orientation, className) {
  // reuse redundant line
  var line = this.dom.redundant.lines.shift();
  if (!line) {
    // create vertical line
    line = document.createElement('div');
    this.dom.background.appendChild(line);
  }
  this.dom.lines.push(line);

  var props = this.props;
  if (orientation == 'top') {
    line.style.top = props.majorLabelHeight + 'px';
  } else {
    line.style.top = this.body.domProps.top.height + 'px';
  }
  line.style.height = props.minorLineHeight + 'px';
  line.style.left = x - props.minorLineWidth / 2 + 'px';
  line.style.width = width + 'px';

  line.className = 'vis-grid vis-vertical vis-minor ' + className;

  return line;
};

/**
 * Create a Major line for the axis at position x
 * @param {Number} x
 * @param {Number} width
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the created line
 * @private
 */
TimeAxis.prototype._repaintMajorLine = function (x, width, orientation, className) {
  // reuse redundant line
  var line = this.dom.redundant.lines.shift();
  if (!line) {
    // create vertical line
    line = document.createElement('div');
    this.dom.background.appendChild(line);
  }
  this.dom.lines.push(line);

  var props = this.props;
  if (orientation == 'top') {
    line.style.top = '0';
  } else {
    line.style.top = this.body.domProps.top.height + 'px';
  }
  line.style.left = x - props.majorLineWidth / 2 + 'px';
  line.style.height = props.majorLineHeight + 'px';
  line.style.width = width + 'px';

  line.className = 'vis-grid vis-vertical vis-major ' + className;

  return line;
};

/**
 * Determine the size of text on the axis (both major and minor axis).
 * The size is calculated only once and then cached in this.props.
 * @private
 */
TimeAxis.prototype._calculateCharSize = function () {
  // Note: We calculate char size with every redraw. Size may change, for
  // example when any of the timelines parents had display:none for example.

  // determine the char width and height on the minor axis
  if (!this.dom.measureCharMinor) {
    this.dom.measureCharMinor = document.createElement('DIV');
    this.dom.measureCharMinor.className = 'vis-text vis-minor vis-measure';
    this.dom.measureCharMinor.style.position = 'absolute';

    this.dom.measureCharMinor.appendChild(document.createTextNode('0'));
    this.dom.foreground.appendChild(this.dom.measureCharMinor);
  }
  this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight;
  this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth;

  // determine the char width and height on the major axis
  if (!this.dom.measureCharMajor) {
    this.dom.measureCharMajor = document.createElement('DIV');
    this.dom.measureCharMajor.className = 'vis-text vis-major vis-measure';
    this.dom.measureCharMajor.style.position = 'absolute';

    this.dom.measureCharMajor.appendChild(document.createTextNode('0'));
    this.dom.foreground.appendChild(this.dom.measureCharMajor);
  }
  this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight;
  this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth;
};

module.exports = TimeAxis;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9UaW1lQXhpcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNqQyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdkMsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3RDLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN0QyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQzs7Ozs7Ozs7OztBQVU1QyxTQUFTLFFBQVEsQ0FBRSxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ2hDLE1BQUksQ0FBQyxHQUFHLEdBQUc7QUFDVCxjQUFVLEVBQUUsSUFBSTtBQUNoQixTQUFLLEVBQUUsRUFBRTtBQUNULGNBQVUsRUFBRSxFQUFFO0FBQ2QsY0FBVSxFQUFFLEVBQUU7QUFDZCxhQUFTLEVBQUU7QUFDVCxXQUFLLEVBQUUsRUFBRTtBQUNULGdCQUFVLEVBQUUsRUFBRTtBQUNkLGdCQUFVLEVBQUUsRUFBRTtLQUNmO0dBQ0YsQ0FBQztBQUNGLE1BQUksQ0FBQyxLQUFLLEdBQUc7QUFDWCxTQUFLLEVBQUU7QUFDTCxXQUFLLEVBQUUsQ0FBQztBQUNSLFNBQUcsRUFBRSxDQUFDO0FBQ04saUJBQVcsRUFBRSxDQUFDO0tBQ2Y7QUFDRCxXQUFPLEVBQUUsQ0FBQztHQUNYLENBQUM7O0FBRUYsTUFBSSxDQUFDLGNBQWMsR0FBRztBQUNwQixlQUFXLEVBQUU7QUFDWCxVQUFJLEVBQUUsUUFBUTtLQUNmO0FBQ0QsbUJBQWUsRUFBRSxJQUFJO0FBQ3JCLG1CQUFlLEVBQUUsSUFBSTtBQUNyQixVQUFNLEVBQUUsUUFBUSxDQUFDLE1BQU07QUFDdkIsVUFBTSxFQUFFLE1BQU07QUFDZCxZQUFRLEVBQUUsSUFBSTtHQUNmLENBQUM7QUFDRixNQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQzs7QUFFcEQsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7OztBQUdqQixNQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7O0FBRWYsTUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUMxQjs7QUFFRCxRQUFRLENBQUMsU0FBUyxHQUFHLElBQUksU0FBUyxFQUFFLENBQUM7Ozs7Ozs7Ozs7QUFVckMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsVUFBUyxPQUFPLEVBQUU7QUFDaEQsTUFBSSxPQUFPLEVBQUU7O0FBRVgsUUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUNuQixpQkFBaUIsRUFDakIsaUJBQWlCLEVBQ2pCLGFBQWEsRUFDYixVQUFVLEVBQ1YsUUFBUSxDQUNULEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQzs7O0FBRzFCLFFBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRTVELFFBQUksYUFBYSxJQUFJLE9BQU8sRUFBRTtBQUM1QixVQUFJLE9BQU8sT0FBTyxDQUFDLFdBQVcsS0FBSyxRQUFRLEVBQUU7QUFDM0MsWUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUM7T0FDckQsTUFDSSxJQUFJLE9BQU8sT0FBTyxDQUFDLFdBQVcsS0FBSyxRQUFRLElBQUksTUFBTSxJQUFJLE9BQU8sQ0FBQyxXQUFXLEVBQUU7QUFDakYsWUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO09BQzFEO0tBQ0Y7Ozs7QUFJRCxRQUFJLFFBQVEsSUFBSSxPQUFPLEVBQUU7QUFDdkIsVUFBSSxPQUFPLE1BQU0sQ0FBQyxNQUFNLEtBQUssVUFBVSxFQUFFOztBQUV2QyxjQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztPQUMvQixNQUNJO0FBQ0gsY0FBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7T0FDN0I7S0FDRjtHQUNGO0NBQ0YsQ0FBQzs7Ozs7QUFLRixRQUFRLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxZQUFXO0FBQ3RDLE1BQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDcEQsTUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFcEQsTUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLDhCQUE4QixDQUFDO0FBQy9ELE1BQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFNBQVMsR0FBRyw4QkFBOEIsQ0FBQztDQUNoRSxDQUFDOzs7OztBQUtGLFFBQVEsQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFlBQVc7O0FBRXRDLE1BQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFO0FBQ2xDLFFBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztHQUNqRTtBQUNELE1BQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFO0FBQ2xDLFFBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztHQUNqRTs7QUFFRCxNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztDQUNsQixDQUFDOzs7Ozs7QUFNRixRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxZQUFZO0FBQ3RDLE1BQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7QUFDdkIsTUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7QUFDckMsTUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7OztBQUdyQyxNQUFJLE1BQU0sR0FBRyxBQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksSUFBSSxLQUFLLEdBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQztBQUNqRyxNQUFJLGFBQWEsR0FBSSxVQUFVLENBQUMsVUFBVSxLQUFLLE1BQU0sQUFBQyxDQUFDOzs7QUFHdkQsTUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7OztBQUcxQixNQUFJLGVBQWUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDO0FBQy9GLE1BQUksZUFBZSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksS0FBSyxNQUFNLENBQUM7OztBQUcvRixPQUFLLENBQUMsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLEtBQUssQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO0FBQ3JFLE9BQUssQ0FBQyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsS0FBSyxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7QUFDckUsT0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDO0FBQy9ELE9BQUssQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLFdBQVcsQ0FBQzs7QUFFckMsT0FBSyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsSUFDMUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUEsQUFBQyxDQUFDO0FBQ2hILE9BQUssQ0FBQyxjQUFjLEdBQUcsQ0FBQyxDQUFDO0FBQ3pCLE9BQUssQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUMsZ0JBQWdCLENBQUM7QUFDdkUsT0FBSyxDQUFDLGNBQWMsR0FBRyxDQUFDLENBQUM7OztBQUd6QixNQUFJLHFCQUFxQixHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUM7QUFDbkQsTUFBSSxxQkFBcUIsR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDO0FBQ25ELFlBQVUsQ0FBQyxVQUFVLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDdkUsWUFBVSxDQUFDLFVBQVUsSUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQzs7QUFFdkUsWUFBVSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDOztBQUVuRCxNQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7OztBQUd0QixNQUFJLHFCQUFxQixFQUFFO0FBQ3pCLFVBQU0sQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFFLHFCQUFxQixDQUFDLENBQUM7R0FDeEQsTUFDSTtBQUNILFVBQU0sQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUE7R0FDL0I7QUFDRCxNQUFJLHFCQUFxQixFQUFFO0FBQ3pCLFFBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUUscUJBQXFCLENBQUMsQ0FBQztHQUNsRixNQUNJO0FBQ0gsUUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFBO0dBQ3pEOztBQUVELFNBQU8sSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLGFBQWEsQ0FBQztDQUMzQyxDQUFDOzs7Ozs7QUFNRixRQUFRLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxZQUFZO0FBQzlDLE1BQUksV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQzs7O0FBR2hELE1BQUksS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQzFELE1BQUksR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQ3RELE1BQUksYUFBYSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxJQUFJLEVBQUUsQ0FBQSxHQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQzNGLE1BQUksV0FBVyxHQUFHLGFBQWEsR0FBRyxRQUFRLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDL0ksYUFBVyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQzs7QUFFbEQsTUFBSSxJQUFJLEdBQUcsSUFBSSxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDNUYsTUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3BDLE1BQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUU7QUFDdkIsUUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0dBQ3JDO0FBQ0QsTUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRTtBQUN6QixRQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7R0FDdEM7QUFDRCxNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzs7Ozs7QUFLakIsTUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUNuQixLQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDO0FBQ2hDLEtBQUcsQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUM7QUFDMUMsS0FBRyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQztBQUMxQyxLQUFHLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNmLEtBQUcsQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLEtBQUcsQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDOztBQUVwQixNQUFJLE9BQU8sQ0FBQztBQUNaLE1BQUksSUFBSSxDQUFDO0FBQ1QsTUFBSSxDQUFDLENBQUM7QUFDTixNQUFJLEtBQUssQ0FBQztBQUNWLE1BQUksT0FBTyxDQUFDO0FBQ1osTUFBSSxLQUFLLENBQUM7QUFDVixNQUFJLElBQUksQ0FBQztBQUNULE1BQUksVUFBVSxDQUFDO0FBQ2YsTUFBSSxnQkFBZ0IsR0FBRyxTQUFTLENBQUM7QUFDakMsTUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ1osTUFBSSxTQUFTLENBQUM7O0FBRWQsTUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ2IsTUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztBQUN6QixPQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3RDLFNBQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLEdBQUcsR0FBRyxJQUFJLEVBQUU7QUFDbkMsT0FBRyxFQUFFLENBQUM7O0FBRU4sV0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUN6QixhQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQ2hDLGNBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7O0FBRWxDLFdBQU8sR0FBRyxJQUFJLENBQUM7QUFDZixLQUFDLEdBQUcsS0FBSyxDQUFDOztBQUVWLFFBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUNaLFFBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDekIsU0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFdEMsU0FBSyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDbEIsUUFBSSxTQUFTLEdBQUcsQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQSxHQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQzs7QUFFNUUsUUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsSUFBSSxTQUFTLEVBQUU7QUFDN0MsVUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0tBQy9EOztBQUVELFFBQUksT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFO0FBQzNDLFVBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUNULFlBQUksZ0JBQWdCLElBQUksU0FBUyxFQUFFO0FBQ2pDLDBCQUFnQixHQUFHLENBQUMsQ0FBQztTQUN0QjtBQUNELFlBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQztPQUN6RTtBQUNELFVBQUksR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDakUsTUFDSTtBQUNILFVBQUksU0FBUyxFQUFFO0FBQ2IsWUFBSSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQztPQUNqRSxNQUNJO0FBQ0gsWUFBSSxJQUFJLEVBQUU7QUFDUixjQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxBQUFDLFFBQVEsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssR0FBSSxJQUFJLENBQUE7U0FDaEU7T0FDRjtLQUNGO0dBQ0Y7OztBQUdELE1BQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUU7QUFDaEMsUUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNuQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7UUFDdkMsU0FBUyxHQUFHLFFBQVEsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLElBQUksRUFBRSxDQUFBLEFBQUMsR0FBRyxFQUFFLENBQUM7O0FBRXpFLFFBQUksZ0JBQWdCLElBQUksU0FBUyxJQUFJLFNBQVMsR0FBRyxnQkFBZ0IsRUFBRTtBQUNqRSxVQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDN0Q7R0FDRjs7O0FBR0QsTUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxVQUFVLEdBQUcsRUFBRTtBQUM5QyxXQUFPLEdBQUcsQ0FBQyxNQUFNLEVBQUU7QUFDakIsVUFBSSxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ3JCLFVBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7QUFDM0IsWUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7T0FDbkM7S0FDRjtHQUNGLENBQUMsQ0FBQztDQUNKLENBQUM7Ozs7Ozs7Ozs7O0FBV0YsUUFBUSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsR0FBRyxVQUFVLENBQUMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRTs7QUFFaEYsTUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDOztBQUVsRCxNQUFJLENBQUMsS0FBSyxFQUFFOztBQUVWLFFBQUksT0FBTyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDMUMsU0FBSyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdEMsU0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMzQixRQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7R0FDeEM7QUFDRCxNQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRWhDLE9BQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQzs7QUFFckMsT0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQUFBQyxXQUFXLElBQUksS0FBSyxHQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxHQUFJLEdBQUcsQ0FBQztBQUN0RixPQUFLLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQzVCLE9BQUssQ0FBQyxTQUFTLEdBQUcscUJBQXFCLEdBQUcsU0FBUyxDQUFDOzs7QUFHcEQsU0FBTyxLQUFLLENBQUM7Q0FDZCxDQUFDOzs7Ozs7Ozs7OztBQVdGLFFBQVEsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEdBQUcsVUFBVSxDQUFDLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUU7O0FBRWhGLE1BQUksS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQzs7QUFFbEQsTUFBSSxDQUFDLEtBQUssRUFBRTs7QUFFVixRQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzVDLFNBQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3RDLFNBQUssQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDM0IsUUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0dBQ3hDO0FBQ0QsTUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUVoQyxPQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7QUFDckMsT0FBSyxDQUFDLFNBQVMsR0FBRyxxQkFBcUIsR0FBRyxTQUFTLENBQUM7OztBQUdwRCxPQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxBQUFDLFdBQVcsSUFBSSxLQUFLLEdBQUksR0FBRyxHQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEdBQUksSUFBSSxBQUFDLENBQUM7QUFDdkYsT0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQzs7QUFFNUIsU0FBTyxLQUFLLENBQUM7Q0FDZCxDQUFDOzs7Ozs7Ozs7OztBQVdGLFFBQVEsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEdBQUcsVUFBVSxDQUFDLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUU7O0FBRWpGLE1BQUksSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUM1QyxNQUFJLENBQUMsSUFBSSxFQUFFOztBQUVULFFBQUksR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3JDLFFBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUN2QztBQUNELE1BQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFMUIsTUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztBQUN2QixNQUFJLFdBQVcsSUFBSSxLQUFLLEVBQUU7QUFDeEIsUUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQztHQUNoRCxNQUNJO0FBQ0gsUUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7R0FDdkQ7QUFDRCxNQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztBQUNqRCxNQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxBQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsY0FBYyxHQUFHLENBQUMsR0FBSSxJQUFJLENBQUM7QUFDeEQsTUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQzs7QUFFaEMsTUFBSSxDQUFDLFNBQVMsR0FBRyxrQ0FBa0MsR0FBRyxTQUFTLENBQUM7O0FBRWhFLFNBQU8sSUFBSSxDQUFDO0NBQ2IsQ0FBQzs7Ozs7Ozs7Ozs7QUFXRixRQUFRLENBQUMsU0FBUyxDQUFDLGlCQUFpQixHQUFHLFVBQVUsQ0FBQyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFOztBQUVqRixNQUFJLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDNUMsTUFBSSxDQUFDLElBQUksRUFBRTs7QUFFVCxRQUFJLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNyQyxRQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDdkM7QUFDRCxNQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRTFCLE1BQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7QUFDdkIsTUFBSSxXQUFXLElBQUksS0FBSyxFQUFFO0FBQ3hCLFFBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztHQUN0QixNQUNJO0FBQ0gsUUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7R0FDdkQ7QUFDRCxNQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxBQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsY0FBYyxHQUFHLENBQUMsR0FBSSxJQUFJLENBQUM7QUFDeEQsTUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7QUFDakQsTUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFJLElBQUksQ0FBQzs7QUFFakMsTUFBSSxDQUFDLFNBQVMsR0FBRyxrQ0FBa0MsR0FBRyxTQUFTLENBQUM7O0FBRWhFLFNBQU8sSUFBSSxDQUFDO0NBQ2IsQ0FBQzs7Ozs7OztBQU9GLFFBQVEsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEdBQUcsWUFBWTs7Ozs7QUFLbEQsTUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEVBQUU7QUFDOUIsUUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzFELFFBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxHQUFHLGdDQUFnQyxDQUFDO0FBQ3ZFLFFBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7O0FBRXRELFFBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNwRSxRQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0dBQzVEO0FBQ0QsTUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUM7QUFDcEUsTUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUM7OztBQUdsRSxNQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsRUFBRTtBQUM5QixRQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUQsUUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEdBQUcsZ0NBQWdDLENBQUM7QUFDdkUsUUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQzs7QUFFdEQsUUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3BFLFFBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7R0FDNUQ7QUFDRCxNQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQztBQUNwRSxNQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQztDQUNuRSxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9UaW1lQXhpcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG52YXIgVGltZVN0ZXAgPSByZXF1aXJlKCcuLi9UaW1lU3RlcCcpO1xudmFyIERhdGVVdGlsID0gcmVxdWlyZSgnLi4vRGF0ZVV0aWwnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGUvbW9tZW50Jyk7XG5cbi8qKlxuICogQSBob3Jpem9udGFsIHRpbWUgYXhpc1xuICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXIsIHJhbmdlOiBSYW5nZX19IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIFNlZSBUaW1lQXhpcy5zZXRPcHRpb25zIGZvciB0aGUgYXZhaWxhYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yIFRpbWVBeGlzXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gVGltZUF4aXMgKGJvZHksIG9wdGlvbnMpIHtcbiAgdGhpcy5kb20gPSB7XG4gICAgZm9yZWdyb3VuZDogbnVsbCxcbiAgICBsaW5lczogW10sXG4gICAgbWFqb3JUZXh0czogW10sXG4gICAgbWlub3JUZXh0czogW10sXG4gICAgcmVkdW5kYW50OiB7XG4gICAgICBsaW5lczogW10sXG4gICAgICBtYWpvclRleHRzOiBbXSxcbiAgICAgIG1pbm9yVGV4dHM6IFtdXG4gICAgfVxuICB9O1xuICB0aGlzLnByb3BzID0ge1xuICAgIHJhbmdlOiB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogMCxcbiAgICAgIG1pbmltdW1TdGVwOiAwXG4gICAgfSxcbiAgICBsaW5lVG9wOiAwXG4gIH07XG5cbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBvcmllbnRhdGlvbjoge1xuICAgICAgYXhpczogJ2JvdHRvbSdcbiAgICB9LCAgLy8gYXhpcyBvcmllbnRhdGlvbjogJ3RvcCcgb3IgJ2JvdHRvbSdcbiAgICBzaG93TWlub3JMYWJlbHM6IHRydWUsXG4gICAgc2hvd01ham9yTGFiZWxzOiB0cnVlLFxuICAgIGZvcm1hdDogVGltZVN0ZXAuRk9STUFULFxuICAgIG1vbWVudDogbW9tZW50LFxuICAgIHRpbWVBeGlzOiBudWxsXG4gIH07XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIC8vIGNyZWF0ZSB0aGUgSFRNTCBET01cbiAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xufVxuXG5UaW1lQXhpcy5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8qKlxuICogU2V0IG9wdGlvbnMgZm9yIHRoZSBUaW1lQXhpcy5cbiAqIFBhcmFtZXRlcnMgd2lsbCBiZSBtZXJnZWQgaW4gY3VycmVudCBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IFtvcmllbnRhdGlvbi5heGlzXVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHtib29sZWFufSBbc2hvd01pbm9yTGFiZWxzXVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHtib29sZWFufSBbc2hvd01ham9yTGFiZWxzXVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBjb3B5IGFsbCBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFtcbiAgICAgICdzaG93TWlub3JMYWJlbHMnLFxuICAgICAgJ3Nob3dNYWpvckxhYmVscycsXG4gICAgICAnaGlkZGVuRGF0ZXMnLFxuICAgICAgJ3RpbWVBeGlzJyxcbiAgICAgICdtb21lbnQnXG4gICAgXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIC8vIGRlZXAgY29weSB0aGUgZm9ybWF0IG9wdGlvbnNcbiAgICB1dGlsLnNlbGVjdGl2ZURlZXBFeHRlbmQoWydmb3JtYXQnXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICgnb3JpZW50YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPSBvcHRpb25zLm9yaWVudGF0aW9uO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdvYmplY3QnICYmICdheGlzJyBpbiBvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID0gb3B0aW9ucy5vcmllbnRhdGlvbi5heGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFwcGx5IGxvY2FsZSB0byBtb21lbnQuanNcbiAgICAvLyBUT0RPOiBub3Qgc28gbmljZSwgdGhpcyBpcyBhcHBsaWVkIGdsb2JhbGx5IHRvIG1vbWVudC5qc1xuICAgIGlmICgnbG9jYWxlJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG1vbWVudC5sb2NhbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbW9tZW50LmpzIDIuOC4xK1xuICAgICAgICBtb21lbnQubG9jYWxlKG9wdGlvbnMubG9jYWxlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtb21lbnQubGFuZyhvcHRpb25zLmxvY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBUaW1lQXhpc1xuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRvbS5mb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtdGltZS1heGlzIHZpcy1mb3JlZ3JvdW5kJztcbiAgdGhpcy5kb20uYmFja2dyb3VuZC5jbGFzc05hbWUgPSAndmlzLXRpbWUtYXhpcyB2aXMtYmFja2dyb3VuZCc7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIFRpbWVBeGlzXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJlbW92ZSBmcm9tIERPTVxuICBpZiAodGhpcy5kb20uZm9yZWdyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmZvcmVncm91bmQpO1xuICB9XG4gIGlmICh0aGlzLmRvbS5iYWNrZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZCk7XG4gIH1cblxuICB0aGlzLmJvZHkgPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgdmFyIGZvcmVncm91bmQgPSB0aGlzLmRvbS5mb3JlZ3JvdW5kO1xuICB2YXIgYmFja2dyb3VuZCA9IHRoaXMuZG9tLmJhY2tncm91bmQ7XG5cbiAgLy8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHBhcmVudCBET00gZWxlbWVudCAoZGVwZW5kaW5nIG9uIG9wdGlvbiBvcmllbnRhdGlvbilcbiAgdmFyIHBhcmVudCA9ICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyA9PSAndG9wJykgPyB0aGlzLmJvZHkuZG9tLnRvcCA6IHRoaXMuYm9keS5kb20uYm90dG9tO1xuICB2YXIgcGFyZW50Q2hhbmdlZCA9IChmb3JlZ3JvdW5kLnBhcmVudE5vZGUgIT09IHBhcmVudCk7XG5cbiAgLy8gY2FsY3VsYXRlIGNoYXJhY3RlciB3aWR0aCBhbmQgaGVpZ2h0XG4gIHRoaXMuX2NhbGN1bGF0ZUNoYXJTaXplKCk7XG5cbiAgLy8gVE9ETzogcmVjYWxjdWxhdGUgc2l6ZXMgb25seSBuZWVkZWQgd2hlbiBwYXJlbnQgaXMgcmVzaXplZCBvciBvcHRpb25zIGlzIGNoYW5nZWRcbiAgdmFyIHNob3dNaW5vckxhYmVscyA9IHRoaXMub3B0aW9ucy5zaG93TWlub3JMYWJlbHMgJiYgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgIT09ICdub25lJztcbiAgdmFyIHNob3dNYWpvckxhYmVscyA9IHRoaXMub3B0aW9ucy5zaG93TWFqb3JMYWJlbHMgJiYgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgIT09ICdub25lJztcblxuICAvLyBkZXRlcm1pbmUgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGVsZW1lbnMgZm9yIHRoZSBheGlzXG4gIHByb3BzLm1pbm9yTGFiZWxIZWlnaHQgPSBzaG93TWlub3JMYWJlbHMgPyBwcm9wcy5taW5vckNoYXJIZWlnaHQgOiAwO1xuICBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0ID0gc2hvd01ham9yTGFiZWxzID8gcHJvcHMubWFqb3JDaGFySGVpZ2h0IDogMDtcbiAgcHJvcHMuaGVpZ2h0ID0gcHJvcHMubWlub3JMYWJlbEhlaWdodCArIHByb3BzLm1ham9yTGFiZWxIZWlnaHQ7XG4gIHByb3BzLndpZHRoID0gZm9yZWdyb3VuZC5vZmZzZXRXaWR0aDtcblxuICBwcm9wcy5taW5vckxpbmVIZWlnaHQgPSB0aGlzLmJvZHkuZG9tUHJvcHMucm9vdC5oZWlnaHQgLSBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0IC1cbiAgICAgICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyA9PSAndG9wJyA/IHRoaXMuYm9keS5kb21Qcm9wcy5ib3R0b20uaGVpZ2h0IDogdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQpO1xuICBwcm9wcy5taW5vckxpbmVXaWR0aCA9IDE7IC8vIFRPRE86IHJlYWxseSBjYWxjdWxhdGUgd2lkdGhcbiAgcHJvcHMubWFqb3JMaW5lSGVpZ2h0ID0gcHJvcHMubWlub3JMaW5lSGVpZ2h0ICsgcHJvcHMubWFqb3JMYWJlbEhlaWdodDtcbiAgcHJvcHMubWFqb3JMaW5lV2lkdGggPSAxOyAvLyBUT0RPOiByZWFsbHkgY2FsY3VsYXRlIHdpZHRoXG5cbiAgLy8gIHRha2UgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBvZmZsaW5lIHdoaWxlIHVwZGF0aW5nIChpcyBhbG1vc3QgdHdpY2UgYXMgZmFzdClcbiAgdmFyIGZvcmVncm91bmROZXh0U2libGluZyA9IGZvcmVncm91bmQubmV4dFNpYmxpbmc7XG4gIHZhciBiYWNrZ3JvdW5kTmV4dFNpYmxpbmcgPSBiYWNrZ3JvdW5kLm5leHRTaWJsaW5nO1xuICBmb3JlZ3JvdW5kLnBhcmVudE5vZGUgJiYgZm9yZWdyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZvcmVncm91bmQpO1xuICBiYWNrZ3JvdW5kLnBhcmVudE5vZGUgJiYgYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJhY2tncm91bmQpO1xuXG4gIGZvcmVncm91bmQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5wcm9wcy5oZWlnaHQgKyAncHgnO1xuXG4gIHRoaXMuX3JlcGFpbnRMYWJlbHMoKTtcblxuICAvLyBwdXQgRE9NIG9ubGluZSBhZ2FpbiAoYXQgdGhlIHNhbWUgcGxhY2UpXG4gIGlmIChmb3JlZ3JvdW5kTmV4dFNpYmxpbmcpIHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGZvcmVncm91bmQsIGZvcmVncm91bmROZXh0U2libGluZyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGZvcmVncm91bmQpXG4gIH1cbiAgaWYgKGJhY2tncm91bmROZXh0U2libGluZykge1xuICAgIHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmluc2VydEJlZm9yZShiYWNrZ3JvdW5kLCBiYWNrZ3JvdW5kTmV4dFNpYmxpbmcpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmFwcGVuZENoaWxkKGJhY2tncm91bmQpXG4gIH1cblxuICByZXR1cm4gdGhpcy5faXNSZXNpemVkKCkgfHwgcGFyZW50Q2hhbmdlZDtcbn07XG5cbi8qKlxuICogUmVwYWludCBtYWpvciBhbmQgbWlub3IgdGV4dCBsYWJlbHMgYW5kIHZlcnRpY2FsIGdyaWQgbGluZXNcbiAqIEBwcml2YXRlXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludExhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXM7XG5cbiAgLy8gY2FsY3VsYXRlIHJhbmdlIGFuZCBzdGVwIChzdGVwIHN1Y2ggdGhhdCB3ZSBoYXZlIHNwYWNlIGZvciA3IGNoYXJhY3RlcnMgcGVyIGxhYmVsKVxuICB2YXIgc3RhcnQgPSB1dGlsLmNvbnZlcnQodGhpcy5ib2R5LnJhbmdlLnN0YXJ0LCAnTnVtYmVyJyk7XG4gIHZhciBlbmQgPSB1dGlsLmNvbnZlcnQodGhpcy5ib2R5LnJhbmdlLmVuZCwgJ051bWJlcicpO1xuICB2YXIgdGltZUxhYmVsc2l6ZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSgodGhpcy5wcm9wcy5taW5vckNoYXJXaWR0aCB8fCAxMCkgKiA3KS52YWx1ZU9mKCk7XG4gIHZhciBtaW5pbXVtU3RlcCA9IHRpbWVMYWJlbHNpemUgLSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJlZm9yZSh0aGlzLm9wdGlvbnMubW9tZW50LCB0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIHRoaXMuYm9keS5yYW5nZSwgdGltZUxhYmVsc2l6ZSk7XG4gIG1pbmltdW1TdGVwIC09IHRoaXMuYm9keS51dGlsLnRvVGltZSgwKS52YWx1ZU9mKCk7XG5cbiAgdmFyIHN0ZXAgPSBuZXcgVGltZVN0ZXAobmV3IERhdGUoc3RhcnQpLCBuZXcgRGF0ZShlbmQpLCBtaW5pbXVtU3RlcCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzKTtcbiAgc3RlcC5zZXRNb21lbnQodGhpcy5vcHRpb25zLm1vbWVudCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZm9ybWF0KSB7XG4gICAgc3RlcC5zZXRGb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCk7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy50aW1lQXhpcykge1xuICAgIHN0ZXAuc2V0U2NhbGUodGhpcy5vcHRpb25zLnRpbWVBeGlzKTtcbiAgfVxuICB0aGlzLnN0ZXAgPSBzdGVwO1xuXG4gIC8vIE1vdmUgYWxsIERPTSBlbGVtZW50cyB0byBhIFwicmVkdW5kYW50XCIgbGlzdCwgd2hlcmUgdGhleVxuICAvLyBjYW4gYmUgcGlja2VkIGZvciByZS11c2UsIGFuZCBjbGVhciB0aGUgbGlzdHMgd2l0aCBsaW5lcyBhbmQgdGV4dHMuXG4gIC8vIEF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uIF9yZXBhaW50TGFiZWxzLCBsZWZ0IG92ZXIgZWxlbWVudHMgd2lsbCBiZSBjbGVhbmVkIHVwXG4gIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgZG9tLnJlZHVuZGFudC5saW5lcyA9IGRvbS5saW5lcztcbiAgZG9tLnJlZHVuZGFudC5tYWpvclRleHRzID0gZG9tLm1ham9yVGV4dHM7XG4gIGRvbS5yZWR1bmRhbnQubWlub3JUZXh0cyA9IGRvbS5taW5vclRleHRzO1xuICBkb20ubGluZXMgPSBbXTtcbiAgZG9tLm1ham9yVGV4dHMgPSBbXTtcbiAgZG9tLm1pbm9yVGV4dHMgPSBbXTtcblxuICB2YXIgY3VycmVudDtcbiAgdmFyIG5leHQ7XG4gIHZhciB4O1xuICB2YXIgeE5leHQ7XG4gIHZhciBpc01ham9yO1xuICB2YXIgd2lkdGg7XG4gIHZhciBsaW5lO1xuICB2YXIgbGFiZWxNaW5vcjtcbiAgdmFyIHhGaXJzdE1ham9yTGFiZWwgPSB1bmRlZmluZWQ7XG4gIHZhciBtYXggPSAwO1xuICB2YXIgY2xhc3NOYW1lO1xuXG4gIHN0ZXAuc3RhcnQoKTtcbiAgbmV4dCA9IHN0ZXAuZ2V0Q3VycmVudCgpO1xuICB4TmV4dCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKG5leHQpO1xuICB3aGlsZSAoc3RlcC5oYXNOZXh0KCkgJiYgbWF4IDwgMTAwMCkge1xuICAgIG1heCsrO1xuXG4gICAgaXNNYWpvciA9IHN0ZXAuaXNNYWpvcigpO1xuICAgIGNsYXNzTmFtZSA9IHN0ZXAuZ2V0Q2xhc3NOYW1lKCk7XG4gICAgbGFiZWxNaW5vciA9IHN0ZXAuZ2V0TGFiZWxNaW5vcigpO1xuXG4gICAgY3VycmVudCA9IG5leHQ7XG4gICAgeCA9IHhOZXh0O1xuXG4gICAgc3RlcC5uZXh0KCk7XG4gICAgbmV4dCA9IHN0ZXAuZ2V0Q3VycmVudCgpO1xuICAgIHhOZXh0ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4obmV4dCk7XG5cbiAgICB3aWR0aCA9IHhOZXh0IC0geDtcbiAgICB2YXIgbGFiZWxGaXRzID0gKGxhYmVsTWlub3IubGVuZ3RoICsgMSkgKiB0aGlzLnByb3BzLm1pbm9yQ2hhcldpZHRoIDwgd2lkdGg7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dNaW5vckxhYmVscyAmJiBsYWJlbEZpdHMpIHtcbiAgICAgIHRoaXMuX3JlcGFpbnRNaW5vclRleHQoeCwgbGFiZWxNaW5vciwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTWFqb3IgJiYgdGhpcy5vcHRpb25zLnNob3dNYWpvckxhYmVscykge1xuICAgICAgaWYgKHggPiAwKSB7XG4gICAgICAgIGlmICh4Rmlyc3RNYWpvckxhYmVsID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHhGaXJzdE1ham9yTGFiZWwgPSB4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcGFpbnRNYWpvclRleHQoeCwgc3RlcC5nZXRMYWJlbE1ham9yKCksIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpO1xuICAgICAgfVxuICAgICAgbGluZSA9IHRoaXMuX3JlcGFpbnRNYWpvckxpbmUoeCwgd2lkdGgsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChsYWJlbEZpdHMpIHtcbiAgICAgICAgbGluZSA9IHRoaXMuX3JlcGFpbnRNaW5vckxpbmUoeCwgd2lkdGgsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgbGluZS5zdHlsZS53aWR0aCA9IChwYXJzZUludCAobGluZS5zdHlsZS53aWR0aCkgKyB3aWR0aCkgKyAncHgnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBjcmVhdGUgYSBtYWpvciBsYWJlbCBvbiB0aGUgbGVmdCB3aGVuIG5lZWRlZFxuICBpZiAodGhpcy5vcHRpb25zLnNob3dNYWpvckxhYmVscykge1xuICAgIHZhciBsZWZ0VGltZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSgwKSxcbiAgICAgICAgbGVmdFRleHQgPSBzdGVwLmdldExhYmVsTWFqb3IobGVmdFRpbWUpLFxuICAgICAgICB3aWR0aFRleHQgPSBsZWZ0VGV4dC5sZW5ndGggKiAodGhpcy5wcm9wcy5tYWpvckNoYXJXaWR0aCB8fCAxMCkgKyAxMDsgLy8gdXBwZXIgYm91bmQgZXN0aW1hdGlvblxuXG4gICAgaWYgKHhGaXJzdE1ham9yTGFiZWwgPT0gdW5kZWZpbmVkIHx8IHdpZHRoVGV4dCA8IHhGaXJzdE1ham9yTGFiZWwpIHtcbiAgICAgIHRoaXMuX3JlcGFpbnRNYWpvclRleHQoMCwgbGVmdFRleHQsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFudXAgbGVmdG92ZXIgRE9NIGVsZW1lbnRzIGZyb20gdGhlIHJlZHVuZGFudCBsaXN0XG4gIHV0aWwuZm9yRWFjaCh0aGlzLmRvbS5yZWR1bmRhbnQsIGZ1bmN0aW9uIChhcnIpIHtcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCkge1xuICAgICAgdmFyIGVsZW0gPSBhcnIucG9wKCk7XG4gICAgICBpZiAoZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG1pbm9yIGxhYmVsIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAgIFwidG9wXCIgb3IgXCJib3R0b21cIiAoZGVmYXVsdClcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCBvZiB0aGUgY3JlYXRlZCBsYWJlbFxuICogQHByaXZhdGVcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TWlub3JUZXh0ID0gZnVuY3Rpb24gKHgsIHRleHQsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpIHtcbiAgLy8gcmV1c2UgcmVkdW5kYW50IGxhYmVsXG4gIHZhciBsYWJlbCA9IHRoaXMuZG9tLnJlZHVuZGFudC5taW5vclRleHRzLnNoaWZ0KCk7XG5cbiAgaWYgKCFsYWJlbCkge1xuICAgIC8vIGNyZWF0ZSBuZXcgbGFiZWxcbiAgICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxhYmVsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICB9XG4gIHRoaXMuZG9tLm1pbm9yVGV4dHMucHVzaChsYWJlbCk7XG5cbiAgbGFiZWwuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgPSB0ZXh0O1xuXG4gIGxhYmVsLnN0eWxlLnRvcCA9IChvcmllbnRhdGlvbiA9PSAndG9wJykgPyAodGhpcy5wcm9wcy5tYWpvckxhYmVsSGVpZ2h0ICsgJ3B4JykgOiAnMCc7XG4gIGxhYmVsLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgbGFiZWwuY2xhc3NOYW1lID0gJ3Zpcy10ZXh0IHZpcy1taW5vciAnICsgY2xhc3NOYW1lO1xuICAvL2xhYmVsLnRpdGxlID0gdGl0bGU7ICAvLyBUT0RPOiB0aGlzIGlzIGEgaGVhdnkgb3BlcmF0aW9uXG5cbiAgcmV0dXJuIGxhYmVsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBNYWpvciBsYWJlbCBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge1N0cmluZ30gb3JpZW50YXRpb24gICBcInRvcFwiIG9yIFwiYm90dG9tXCIgKGRlZmF1bHQpXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgb2YgdGhlIGNyZWF0ZWQgbGFiZWxcbiAqIEBwcml2YXRlXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludE1ham9yVGV4dCA9IGZ1bmN0aW9uICh4LCB0ZXh0LCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKSB7XG4gIC8vIHJldXNlIHJlZHVuZGFudCBsYWJlbFxuICB2YXIgbGFiZWwgPSB0aGlzLmRvbS5yZWR1bmRhbnQubWFqb3JUZXh0cy5zaGlmdCgpO1xuXG4gIGlmICghbGFiZWwpIHtcbiAgICAvLyBjcmVhdGUgbGFiZWxcbiAgICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGFiZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gIH1cbiAgdGhpcy5kb20ubWFqb3JUZXh0cy5wdXNoKGxhYmVsKTtcblxuICBsYWJlbC5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA9IHRleHQ7XG4gIGxhYmVsLmNsYXNzTmFtZSA9ICd2aXMtdGV4dCB2aXMtbWFqb3IgJyArIGNsYXNzTmFtZTtcbiAgLy9sYWJlbC50aXRsZSA9IHRpdGxlOyAvLyBUT0RPOiB0aGlzIGlzIGEgaGVhdnkgb3BlcmF0aW9uXG5cbiAgbGFiZWwuc3R5bGUudG9wID0gKG9yaWVudGF0aW9uID09ICd0b3AnKSA/ICcwJyA6ICh0aGlzLnByb3BzLm1pbm9yTGFiZWxIZWlnaHQgICsgJ3B4Jyk7XG4gIGxhYmVsLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcblxuICByZXR1cm4gbGFiZWw7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG1pbm9yIGxpbmUgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAgIFwidG9wXCIgb3IgXCJib3R0b21cIiAoZGVmYXVsdClcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIGNyZWF0ZWQgbGluZVxuICogQHByaXZhdGVcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TWlub3JMaW5lID0gZnVuY3Rpb24gKHgsIHdpZHRoLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKSB7XG4gIC8vIHJldXNlIHJlZHVuZGFudCBsaW5lXG4gIHZhciBsaW5lID0gdGhpcy5kb20ucmVkdW5kYW50LmxpbmVzLnNoaWZ0KCk7XG4gIGlmICghbGluZSkge1xuICAgIC8vIGNyZWF0ZSB2ZXJ0aWNhbCBsaW5lXG4gICAgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQobGluZSk7XG4gIH1cbiAgdGhpcy5kb20ubGluZXMucHVzaChsaW5lKTtcblxuICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICBsaW5lLnN0eWxlLnRvcCA9IHByb3BzLm1ham9yTGFiZWxIZWlnaHQgKyAncHgnO1xuICB9XG4gIGVsc2Uge1xuICAgIGxpbmUuc3R5bGUudG9wID0gdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICB9XG4gIGxpbmUuc3R5bGUuaGVpZ2h0ID0gcHJvcHMubWlub3JMaW5lSGVpZ2h0ICsgJ3B4JztcbiAgbGluZS5zdHlsZS5sZWZ0ID0gKHggLSBwcm9wcy5taW5vckxpbmVXaWR0aCAvIDIpICsgJ3B4JztcbiAgbGluZS5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcblxuICBsaW5lLmNsYXNzTmFtZSA9ICd2aXMtZ3JpZCB2aXMtdmVydGljYWwgdmlzLW1pbm9yICcgKyBjbGFzc05hbWU7XG5cbiAgcmV0dXJuIGxpbmU7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIE1ham9yIGxpbmUgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAgIFwidG9wXCIgb3IgXCJib3R0b21cIiAoZGVmYXVsdClcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIGNyZWF0ZWQgbGluZVxuICogQHByaXZhdGVcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TWFqb3JMaW5lID0gZnVuY3Rpb24gKHgsIHdpZHRoLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKSB7XG4gIC8vIHJldXNlIHJlZHVuZGFudCBsaW5lXG4gIHZhciBsaW5lID0gdGhpcy5kb20ucmVkdW5kYW50LmxpbmVzLnNoaWZ0KCk7XG4gIGlmICghbGluZSkge1xuICAgIC8vIGNyZWF0ZSB2ZXJ0aWNhbCBsaW5lXG4gICAgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQobGluZSk7XG4gIH1cbiAgdGhpcy5kb20ubGluZXMucHVzaChsaW5lKTtcblxuICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICBsaW5lLnN0eWxlLnRvcCA9ICcwJztcbiAgfVxuICBlbHNlIHtcbiAgICBsaW5lLnN0eWxlLnRvcCA9IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgfVxuICBsaW5lLnN0eWxlLmxlZnQgPSAoeCAtIHByb3BzLm1ham9yTGluZVdpZHRoIC8gMikgKyAncHgnO1xuICBsaW5lLnN0eWxlLmhlaWdodCA9IHByb3BzLm1ham9yTGluZUhlaWdodCArICdweCc7XG4gIGxpbmUuc3R5bGUud2lkdGggPSB3aWR0aCAgKyAncHgnO1xuXG4gIGxpbmUuY2xhc3NOYW1lID0gJ3Zpcy1ncmlkIHZpcy12ZXJ0aWNhbCB2aXMtbWFqb3IgJyArIGNsYXNzTmFtZTtcblxuICByZXR1cm4gbGluZTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRleHQgb24gdGhlIGF4aXMgKGJvdGggbWFqb3IgYW5kIG1pbm9yIGF4aXMpLlxuICogVGhlIHNpemUgaXMgY2FsY3VsYXRlZCBvbmx5IG9uY2UgYW5kIHRoZW4gY2FjaGVkIGluIHRoaXMucHJvcHMuXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX2NhbGN1bGF0ZUNoYXJTaXplID0gZnVuY3Rpb24gKCkge1xuICAvLyBOb3RlOiBXZSBjYWxjdWxhdGUgY2hhciBzaXplIHdpdGggZXZlcnkgcmVkcmF3LiBTaXplIG1heSBjaGFuZ2UsIGZvclxuICAvLyBleGFtcGxlIHdoZW4gYW55IG9mIHRoZSB0aW1lbGluZXMgcGFyZW50cyBoYWQgZGlzcGxheTpub25lIGZvciBleGFtcGxlLlxuXG4gIC8vIGRldGVybWluZSB0aGUgY2hhciB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBtaW5vciBheGlzXG4gIGlmICghdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vcikge1xuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLmNsYXNzTmFtZSA9ICd2aXMtdGV4dCB2aXMtbWlub3IgdmlzLW1lYXN1cmUnO1xuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3Iuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnMCcpKTtcbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IpO1xuICB9XG4gIHRoaXMucHJvcHMubWlub3JDaGFySGVpZ2h0ID0gdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5jbGllbnRIZWlnaHQ7XG4gIHRoaXMucHJvcHMubWlub3JDaGFyV2lkdGggPSB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLmNsaWVudFdpZHRoO1xuXG4gIC8vIGRldGVybWluZSB0aGUgY2hhciB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBtYWpvciBheGlzXG4gIGlmICghdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvcikge1xuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmNsYXNzTmFtZSA9ICd2aXMtdGV4dCB2aXMtbWFqb3IgdmlzLW1lYXN1cmUnO1xuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3Iuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnMCcpKTtcbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IpO1xuICB9XG4gIHRoaXMucHJvcHMubWFqb3JDaGFySGVpZ2h0ID0gdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5jbGllbnRIZWlnaHQ7XG4gIHRoaXMucHJvcHMubWFqb3JDaGFyV2lkdGggPSB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmNsaWVudFdpZHRoO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lQXhpcztcbiJdfQ==
},{"../../module/moment":20,"../../util":46,"../DateUtil":27,"../TimeStep":30,"./Component":33}],39:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var Item = require('./Item');
var BackgroundGroup = require('../BackgroundGroup');
var RangeItem = require('./RangeItem');

/**
 * @constructor BackgroundItem
 * @extends Item
 * @param {Object} data             Object containing parameters start, end
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe options
 */
// TODO: implement support for the BackgroundItem just having a start, then being displayed as a sort of an annotation
function BackgroundItem(data, conversion, options) {
  this.props = {
    content: {
      width: 0
    }
  };
  this.overflow = false; // if contents can overflow (css styling), this flag is set to true

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data.id);
    }
    if (data.end == undefined) {
      throw new Error('Property "end" missing in item ' + data.id);
    }
  }

  Item.call(this, data, conversion, options);
}

BackgroundItem.prototype = new Item(null, null, null);

BackgroundItem.prototype.baseClassName = 'vis-item vis-background';
BackgroundItem.prototype.stack = false;

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
BackgroundItem.prototype.isVisible = function (range) {
  // determine visibility
  return this.data.start < range.end && this.data.end > range.start;
};

/**
 * Repaint the item
 */
BackgroundItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.box = document.createElement('div');
    // className is updated in redraw()

    // frame box (to prevent the item contents from overflowing
    dom.frame = document.createElement('div');
    dom.frame.className = 'vis-item-overflow';
    dom.box.appendChild(dom.frame);

    // contents box
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.frame.appendChild(dom.content);

    // Note: we do NOT attach this item as attribute to the DOM,
    //       such that background items cannot be selected
    //dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var background = this.parent.dom.background;
    if (!background) {
      throw new Error('Cannot redraw item: parent has no background container element');
    }
    background.appendChild(dom.box);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.content);
    this._updateDataAttributes(this.dom.content);
    this._updateStyle(this.dom.box);

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '');
    dom.box.className = this.baseClassName + className;

    // determine from css whether this box has overflow
    this.overflow = window.getComputedStyle(dom.content).overflow !== 'hidden';

    // recalculate size
    this.props.content.width = this.dom.content.offsetWidth;
    this.height = 0; // set height zero, so this item will be ignored when stacking items

    this.dirty = false;
  }
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
BackgroundItem.prototype.show = RangeItem.prototype.show;

/**
 * Hide the item from the DOM (when visible)
 * @return {Boolean} changed
 */
BackgroundItem.prototype.hide = RangeItem.prototype.hide;

/**
 * Reposition the item horizontally
 * @Override
 */
BackgroundItem.prototype.repositionX = RangeItem.prototype.repositionX;

/**
 * Reposition the item vertically
 * @Override
 */
BackgroundItem.prototype.repositionY = function (margin) {
  var onTop = this.options.orientation.item === 'top';
  this.dom.content.style.top = onTop ? '' : '0';
  this.dom.content.style.bottom = onTop ? '0' : '';
  var height;

  // special positioning for subgroups
  if (this.data.subgroup !== undefined) {
    // TODO: instead of calculating the top position of the subgroups here for every BackgroundItem, calculate the top of the subgroup once in Itemset

    var itemSubgroup = this.data.subgroup;
    var subgroups = this.parent.subgroups;
    var subgroupIndex = subgroups[itemSubgroup].index;
    // if the orientation is top, we need to take the difference in height into account.
    if (onTop == true) {
      // the first subgroup will have to account for the distance from the top to the first item.
      height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
      height += subgroupIndex == 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
      var newTop = this.parent.top;
      for (var subgroup in subgroups) {
        if (subgroups.hasOwnProperty(subgroup)) {
          if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroupIndex) {
            newTop += subgroups[subgroup].height + margin.item.vertical;
          }
        }
      }

      // the others will have to be offset downwards with this same distance.
      newTop += subgroupIndex != 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
      this.dom.box.style.top = newTop + 'px';
      this.dom.box.style.bottom = '';
    }
    // and when the orientation is bottom:
    else {
        var newTop = this.parent.top;
        var totalHeight = 0;
        for (var subgroup in subgroups) {
          if (subgroups.hasOwnProperty(subgroup)) {
            if (subgroups[subgroup].visible == true) {
              var newHeight = subgroups[subgroup].height + margin.item.vertical;
              totalHeight += newHeight;
              if (subgroups[subgroup].index > subgroupIndex) {
                newTop += newHeight;
              }
            }
          }
        }
        height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
        this.dom.box.style.top = this.parent.height - totalHeight + newTop + 'px';
        this.dom.box.style.bottom = '';
      }
  }
  // and in the case of no subgroups:
  else {
      // we want backgrounds with groups to only show in groups.
      if (this.parent instanceof BackgroundGroup) {
        // if the item is not in a group:
        height = Math.max(this.parent.height, this.parent.itemSet.body.domProps.center.height, this.parent.itemSet.body.domProps.centerContainer.height);
        this.dom.box.style.top = onTop ? '0' : '';
        this.dom.box.style.bottom = onTop ? '' : '0';
      } else {
        height = this.parent.height;
        // same alignment for items when orientation is top or bottom
        this.dom.box.style.top = this.parent.top + 'px';
        this.dom.box.style.bottom = '';
      }
    }
  this.dom.box.style.height = height + 'px';
};

module.exports = BackgroundItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL0JhY2tncm91bmRJdGVtLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUM7QUFDL0MsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzdCLElBQUksZUFBZSxHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQ3BELElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7OztBQWF2QyxTQUFTLGNBQWMsQ0FBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRTtBQUNsRCxNQUFJLENBQUMsS0FBSyxHQUFHO0FBQ1gsV0FBTyxFQUFFO0FBQ1AsV0FBSyxFQUFFLENBQUM7S0FDVDtHQUNGLENBQUM7QUFDRixNQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQzs7O0FBR3RCLE1BQUksSUFBSSxFQUFFO0FBQ1IsUUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLFNBQVMsRUFBRTtBQUMzQixZQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUNoRTtBQUNELFFBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxTQUFTLEVBQUU7QUFDekIsWUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDOUQ7R0FDRjs7QUFFRCxNQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQzVDOztBQUVELGNBQWMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxJQUFJLENBQUUsSUFBSSxFQUFFLElBQUksRUFB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LEVBQ2hDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFDL0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDOUQsWUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUMxQyxZQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEtBQUssR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDO09BQzlDLE1BQ0k7QUFDSCxjQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7O0FBRTVCLFlBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQ2hELFlBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO09BQ2hDO0tBQ0Y7QUFDRCxNQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUM7Q0FDM0MsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLGNBQWMsQ0FBQyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9CYWNrZ3JvdW5kSXRlbS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgSXRlbSA9IHJlcXVpcmUoJy4vSXRlbScpO1xudmFyIEJhY2tncm91bmRHcm91cCA9IHJlcXVpcmUoJy4uL0JhY2tncm91bmRHcm91cCcpO1xudmFyIFJhbmdlSXRlbSA9IHJlcXVpcmUoJy4vUmFuZ2VJdGVtJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEJhY2tncm91bmRJdGVtXG4gKiBAZXh0ZW5kcyBJdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHN0YXJ0LCBlbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsIGNsYXNzTmFtZS5cbiAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgb3B0aW9uc1xuICovXG4vLyBUT0RPOiBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgdGhlIEJhY2tncm91bmRJdGVtIGp1c3QgaGF2aW5nIGEgc3RhcnQsIHRoZW4gYmVpbmcgZGlzcGxheWVkIGFzIGEgc29ydCBvZiBhbiBhbm5vdGF0aW9uXG5mdW5jdGlvbiBCYWNrZ3JvdW5kSXRlbSAoZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICB0aGlzLnByb3BzID0ge1xuICAgIGNvbnRlbnQ6IHtcbiAgICAgIHdpZHRoOiAwXG4gICAgfVxuICB9O1xuICB0aGlzLm92ZXJmbG93ID0gZmFsc2U7IC8vIGlmIGNvbnRlbnRzIGNhbiBvdmVyZmxvdyAoY3NzIHN0eWxpbmcpLCB0aGlzIGZsYWcgaXMgc2V0IHRvIHRydWVcblxuICAvLyB2YWxpZGF0ZSBkYXRhXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKGRhdGEuc3RhcnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwic3RhcnRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEuaWQpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5lbmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwiZW5kXCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhLmlkKTtcbiAgICB9XG4gIH1cblxuICBJdGVtLmNhbGwodGhpcywgZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucyk7XG59XG5cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZSA9IG5ldyBJdGVtIChudWxsLCBudWxsLCBudWxsKTtcblxuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLmJhc2VDbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLWJhY2tncm91bmQnO1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLnN0YWNrID0gZmFsc2U7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gKi9cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbihyYW5nZSkge1xuICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICByZXR1cm4gKHRoaXMuZGF0YS5zdGFydCA8IHJhbmdlLmVuZCkgJiYgKHRoaXMuZGF0YS5lbmQgPiByYW5nZS5zdGFydCk7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAqL1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZG9tID0gdGhpcy5kb207XG4gIGlmICghZG9tKSB7XG4gICAgLy8gY3JlYXRlIERPTVxuICAgIHRoaXMuZG9tID0ge307XG4gICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAvLyBiYWNrZ3JvdW5kIGJveFxuICAgIGRvbS5ib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAvLyBjbGFzc05hbWUgaXMgdXBkYXRlZCBpbiByZWRyYXcoKVxuXG4gICAgLy8gZnJhbWUgYm94ICh0byBwcmV2ZW50IHRoZSBpdGVtIGNvbnRlbnRzIGZyb20gb3ZlcmZsb3dpbmdcbiAgICBkb20uZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLW92ZXJmbG93JztcbiAgICBkb20uYm94LmFwcGVuZENoaWxkKGRvbS5mcmFtZSk7XG5cbiAgICAvLyBjb250ZW50cyBib3hcbiAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5jb250ZW50LmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1jb250ZW50JztcbiAgICBkb20uZnJhbWUuYXBwZW5kQ2hpbGQoZG9tLmNvbnRlbnQpO1xuXG4gICAgLy8gTm90ZTogd2UgZG8gTk9UIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlIHRvIHRoZSBET00sXG4gICAgLy8gICAgICAgc3VjaCB0aGF0IGJhY2tncm91bmQgaXRlbXMgY2Fubm90IGJlIHNlbGVjdGVkXG4gICAgLy9kb20uYm94Wyd0aW1lbGluZS1pdGVtJ10gPSB0aGlzO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cblxuICAvLyBhcHBlbmQgRE9NIHRvIHBhcmVudCBET01cbiAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBubyBwYXJlbnQgYXR0YWNoZWQnKTtcbiAgfVxuICBpZiAoIWRvbS5ib3gucGFyZW50Tm9kZSkge1xuICAgIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmJhY2tncm91bmQ7XG4gICAgaWYgKCFiYWNrZ3JvdW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBiYWNrZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgfVxuICAgIGJhY2tncm91bmQuYXBwZW5kQ2hpbGQoZG9tLmJveCk7XG4gIH1cbiAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gIC8vIFVwZGF0ZSBET00gd2hlbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eS4gQW4gaXRlbSBpcyBtYXJrZWQgZGlydHkgd2hlbjpcbiAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgLy8gLSB0aGUgaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgdGhpcy5fdXBkYXRlVGl0bGUodGhpcy5kb20uY29udGVudCk7XG4gICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20uY29udGVudCk7XG4gICAgdGhpcy5fdXBkYXRlU3R5bGUodGhpcy5kb20uYm94KTtcblxuICAgIC8vIHVwZGF0ZSBjbGFzc1xuICAgIHZhciBjbGFzc05hbWUgPSAodGhpcy5kYXRhLmNsYXNzTmFtZSA/ICgnICcgKyB0aGlzLmRhdGEuY2xhc3NOYW1lKSA6ICcnKSArXG4gICAgICAgICh0aGlzLnNlbGVjdGVkID8gJyB2aXMtc2VsZWN0ZWQnIDogJycpO1xuICAgIGRvbS5ib3guY2xhc3NOYW1lID0gdGhpcy5iYXNlQ2xhc3NOYW1lICsgY2xhc3NOYW1lO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGZyb20gY3NzIHdoZXRoZXIgdGhpcyBib3ggaGFzIG92ZXJmbG93XG4gICAgdGhpcy5vdmVyZmxvdyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbS5jb250ZW50KS5vdmVyZmxvdyAhPT0gJ2hpZGRlbic7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBzaXplXG4gICAgdGhpcy5wcm9wcy5jb250ZW50LndpZHRoID0gdGhpcy5kb20uY29udGVudC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IDA7IC8vIHNldCBoZWlnaHQgemVybywgc28gdGhpcyBpdGVtIHdpbGwgYmUgaWdub3JlZCB3aGVuIHN0YWNraW5nIGl0ZW1zXG5cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gKi9cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5zaG93ID0gUmFuZ2VJdGVtLnByb3RvdHlwZS5zaG93O1xuXG4vKipcbiAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5oaWRlID0gUmFuZ2VJdGVtLnByb3RvdHlwZS5oaWRlO1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gaG9yaXpvbnRhbGx5XG4gKiBAT3ZlcnJpZGVcbiAqL1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gUmFuZ2VJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWDtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAqIEBPdmVycmlkZVxuICovXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbihtYXJnaW4pIHtcbiAgdmFyIG9uVG9wID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPT09ICd0b3AnO1xuICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLnRvcCA9IG9uVG9wID8gJycgOiAnMCc7XG4gIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUuYm90dG9tID0gb25Ub3AgPyAnMCcgOiAnJztcbiAgdmFyIGhlaWdodDtcblxuICAvLyBzcGVjaWFsIHBvc2l0aW9uaW5nIGZvciBzdWJncm91cHNcbiAgaWYgKHRoaXMuZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVE9ETzogaW5zdGVhZCBvZiBjYWxjdWxhdGluZyB0aGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBzdWJncm91cHMgaGVyZSBmb3IgZXZlcnkgQmFja2dyb3VuZEl0ZW0sIGNhbGN1bGF0ZSB0aGUgdG9wIG9mIHRoZSBzdWJncm91cCBvbmNlIGluIEl0ZW1zZXRcblxuICAgIHZhciBpdGVtU3ViZ3JvdXAgPSB0aGlzLmRhdGEuc3ViZ3JvdXA7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IHRoaXMucGFyZW50LnN1Ymdyb3VwcztcbiAgICB2YXIgc3ViZ3JvdXBJbmRleCA9IHN1Ymdyb3Vwc1tpdGVtU3ViZ3JvdXBdLmluZGV4O1xuICAgIC8vIGlmIHRoZSBvcmllbnRhdGlvbiBpcyB0b3AsIHdlIG5lZWQgdG8gdGFrZSB0aGUgZGlmZmVyZW5jZSBpbiBoZWlnaHQgaW50byBhY2NvdW50LlxuICAgIGlmIChvblRvcCA9PSB0cnVlKSB7XG4gICAgICAvLyB0aGUgZmlyc3Qgc3ViZ3JvdXAgd2lsbCBoYXZlIHRvIGFjY291bnQgZm9yIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgdG8gdGhlIGZpcnN0IGl0ZW0uXG4gICAgICBoZWlnaHQgPSB0aGlzLnBhcmVudC5zdWJncm91cHNbaXRlbVN1Ymdyb3VwXS5oZWlnaHQgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgICAgIGhlaWdodCArPSBzdWJncm91cEluZGV4ID09IDAgPyBtYXJnaW4uYXhpcyAtIDAuNSptYXJnaW4uaXRlbS52ZXJ0aWNhbCA6IDA7XG4gICAgICB2YXIgbmV3VG9wID0gdGhpcy5wYXJlbnQudG9wO1xuICAgICAgZm9yICh2YXIgc3ViZ3JvdXAgaW4gc3ViZ3JvdXBzKSB7XG4gICAgICAgIGlmIChzdWJncm91cHMuaGFzT3duUHJvcGVydHkoc3ViZ3JvdXApKSB7XG4gICAgICAgICAgaWYgKHN1Ymdyb3Vwc1tzdWJncm91cF0udmlzaWJsZSA9PSB0cnVlICYmIHN1Ymdyb3Vwc1tzdWJncm91cF0uaW5kZXggPCBzdWJncm91cEluZGV4KSB7XG4gICAgICAgICAgICBuZXdUb3AgKz0gc3ViZ3JvdXBzW3N1Ymdyb3VwXS5oZWlnaHQgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdGhlIG90aGVycyB3aWxsIGhhdmUgdG8gYmUgb2Zmc2V0IGRvd253YXJkcyB3aXRoIHRoaXMgc2FtZSBkaXN0YW5jZS5cbiAgICAgIG5ld1RvcCArPSBzdWJncm91cEluZGV4ICE9IDAgPyBtYXJnaW4uYXhpcyAtIDAuNSAqIG1hcmdpbi5pdGVtLnZlcnRpY2FsIDogMDtcbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS50b3AgPSBuZXdUb3AgKyAncHgnO1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIH1cbiAgICAvLyBhbmQgd2hlbiB0aGUgb3JpZW50YXRpb24gaXMgYm90dG9tOlxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1RvcCA9IHRoaXMucGFyZW50LnRvcDtcbiAgICAgIHZhciB0b3RhbEhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBzdWJncm91cCBpbiBzdWJncm91cHMpIHtcbiAgICAgICAgaWYgKHN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgICBpZiAoc3ViZ3JvdXBzW3N1Ymdyb3VwXS52aXNpYmxlID09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSBzdWJncm91cHNbc3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHN1Ymdyb3Vwc1tzdWJncm91cF0uaW5kZXggPiBzdWJncm91cEluZGV4KSB7XG4gICAgICAgICAgICAgIG5ld1RvcCArPSBuZXdIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoZWlnaHQgPSB0aGlzLnBhcmVudC5zdWJncm91cHNbaXRlbVN1Ymdyb3VwXS5oZWlnaHQgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS50b3AgPSAodGhpcy5wYXJlbnQuaGVpZ2h0IC0gdG90YWxIZWlnaHQgKyBuZXdUb3ApICsgJ3B4JztcbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB9XG4gIH1cbiAgLy8gYW5kIGluIHRoZSBjYXNlIG9mIG5vIHN1Ymdyb3VwczpcbiAgZWxzZSB7XG4gICAgLy8gd2Ugd2FudCBiYWNrZ3JvdW5kcyB3aXRoIGdyb3VwcyB0byBvbmx5IHNob3cgaW4gZ3JvdXBzLlxuICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIEJhY2tncm91bmRHcm91cCkge1xuICAgICAgLy8gaWYgdGhlIGl0ZW0gaXMgbm90IGluIGEgZ3JvdXA6XG4gICAgICBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLnBhcmVudC5oZWlnaHQsXG4gICAgICAgICAgdGhpcy5wYXJlbnQuaXRlbVNldC5ib2R5LmRvbVByb3BzLmNlbnRlci5oZWlnaHQsXG4gICAgICAgICAgdGhpcy5wYXJlbnQuaXRlbVNldC5ib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQpO1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnRvcCA9IG9uVG9wID8gJzAnIDogJyc7XG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUuYm90dG9tID0gb25Ub3AgPyAnJyA6ICcwJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZWlnaHQgPSB0aGlzLnBhcmVudC5oZWlnaHQ7XG4gICAgICAvLyBzYW1lIGFsaWdubWVudCBmb3IgaXRlbXMgd2hlbiBvcmllbnRhdGlvbiBpcyB0b3Agb3IgYm90dG9tXG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUudG9wID0gdGhpcy5wYXJlbnQudG9wICsgJ3B4JztcbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB9XG4gIH1cbiAgdGhpcy5kb20uYm94LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tncm91bmRJdGVtO1xuIl19
},{"../../../module/hammer":19,"../BackgroundGroup":32,"./Item":41,"./RangeItem":43}],40:[function(require,module,exports){
'use strict';

var Item = require('./Item');
var util = require('../../../util');

/**
 * @constructor BoxItem
 * @extends Item
 * @param {Object} data             Object containing parameters start
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe available options
 */
function BoxItem(data, conversion, options) {
  this.props = {
    dot: {
      width: 0,
      height: 0
    },
    line: {
      width: 0,
      height: 0
    }
  };

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data);
    }
  }

  Item.call(this, data, conversion, options);
}

BoxItem.prototype = new Item(null, null, null);

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
BoxItem.prototype.isVisible = function (range) {
  // determine visibility
  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
  var interval = (range.end - range.start) / 4;
  return this.data.start > range.start - interval && this.data.start < range.end + interval;
};

/**
 * Repaint the item
 */
BoxItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // create main box
    dom.box = document.createElement('DIV');

    // contents box (inside the background box). used for making margins
    dom.content = document.createElement('DIV');
    dom.content.className = 'vis-item-content';
    dom.box.appendChild(dom.content);

    // line to axis
    dom.line = document.createElement('DIV');
    dom.line.className = 'vis-line';

    // dot on axis
    dom.dot = document.createElement('DIV');
    dom.dot.className = 'vis-dot';

    // attach this item as attribute
    dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) throw new Error('Cannot redraw item: parent has no foreground container element');
    foreground.appendChild(dom.box);
  }
  if (!dom.line.parentNode) {
    var background = this.parent.dom.background;
    if (!background) throw new Error('Cannot redraw item: parent has no background container element');
    background.appendChild(dom.line);
  }
  if (!dom.dot.parentNode) {
    var axis = this.parent.dom.axis;
    if (!background) throw new Error('Cannot redraw item: parent has no axis container element');
    axis.appendChild(dom.dot);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.box);
    this._updateDataAttributes(this.dom.box);
    this._updateStyle(this.dom.box);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.box.className = 'vis-item vis-box' + className;
    dom.line.className = 'vis-item vis-line' + className;
    dom.dot.className = 'vis-item vis-dot' + className;

    // recalculate size
    this.props.dot.height = dom.dot.offsetHeight;
    this.props.dot.width = dom.dot.offsetWidth;
    this.props.line.width = dom.line.offsetWidth;
    this.width = dom.box.offsetWidth;
    this.height = dom.box.offsetHeight;

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.box);
};

/**
 * Show the item in the DOM (when not already displayed). The items DOM will
 * be created when needed.
 */
BoxItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 */
BoxItem.prototype.hide = function () {
  if (this.displayed) {
    var dom = this.dom;

    if (dom.box.parentNode) dom.box.parentNode.removeChild(dom.box);
    if (dom.line.parentNode) dom.line.parentNode.removeChild(dom.line);
    if (dom.dot.parentNode) dom.dot.parentNode.removeChild(dom.dot);

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @Override
 */
BoxItem.prototype.repositionX = function () {
  var start = this.conversion.toScreen(this.data.start);
  var align = this.options.align;
  var left;

  // calculate left position of the box
  if (align == 'right') {
    this.left = start - this.width;
  } else if (align == 'left') {
    this.left = start;
  } else {
    // default or 'center'
    this.left = start - this.width / 2;
  }

  // reposition box
  this.dom.box.style.left = this.left + 'px';

  // reposition line
  this.dom.line.style.left = start - this.props.line.width / 2 + 'px';

  // reposition dot
  this.dom.dot.style.left = start - this.props.dot.width / 2 + 'px';
};

/**
 * Reposition the item vertically
 * @Override
 */
BoxItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var box = this.dom.box;
  var line = this.dom.line;
  var dot = this.dom.dot;

  if (orientation == 'top') {
    box.style.top = (this.top || 0) + 'px';

    line.style.top = '0';
    line.style.height = this.parent.top + this.top + 1 + 'px';
    line.style.bottom = '';
  } else {
    // orientation 'bottom'
    var itemSetHeight = this.parent.itemSet.props.height; // TODO: this is nasty
    var lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;

    box.style.top = (this.parent.height - this.top - this.height || 0) + 'px';
    line.style.top = itemSetHeight - lineHeight + 'px';
    line.style.bottom = '0';
  }

  dot.style.top = -this.props.dot.height / 2 + 'px';
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
BoxItem.prototype.getWidthLeft = function () {
  return this.width / 2;
};

/**
 * Return the width of the item right from its start date
 * @return {number}
 */
BoxItem.prototype.getWidthRight = function () {
  return this.width / 2;
};

module.exports = BoxItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL0JveEl0ZW0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDN0IsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7QUFZcEMsU0FBUyxPQUFPLENBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUU7QUFDM0MsTUFBSSxDQUFDLEtBQUssR0FBRztBQUNYLE9BQUcsRUFBRTtBQUNILFdBQUssRUFBRSxDQUFDO0FBQ1IsWUFBTSxFQUFFLENBQUM7S0FDVjtBQUNELFFBQUksRUFBRTtBQUNKLFdBQUssRUFBRSxDQUFDO0FBQ1IsWUFBTSxFQUFFLENBQUM7S0FDVjtHQUNGLENBQUM7OztBQUdGLE1BQUksSUFBSSxFQUFFO0FBQ1IsUUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLFNBQVMsRUFBRTtBQUMzQixZQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxHQUFHLElBQUksQ0FBQyxDQUFDO0tBQzdEO0dBQ0Y7O0FBRUQsTUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztDQUM1Qzs7QUFFRCxPQUFPLENBQUMsU0FBUyxHQUFHLElBQUksSUFBSSxDQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7Ozs7Ozs7QUFPaEQsT0FBTyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsVUFBUyxLQUFLLEVBQUU7OztBQUc1QyxNQUFJLFFBQVEsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQSxHQUFJLENBQUMsQ0FBQztBQUM3QyxTQUFPLEFBQUMsSUFBSSxD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Qjs7QUFFRCxLQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxBQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBSSxJQUFJLENBQUM7Q0FDckQsQ0FBQzs7Ozs7O0FBTUYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsWUFBWTtBQUMzQyxTQUFPLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0NBQ3ZCLENBQUM7Ozs7OztBQU1GLE9BQU8sQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFlBQVk7QUFDNUMsU0FBTyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztDQUN2QixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL0JveEl0ZW0uanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSXRlbSA9IHJlcXVpcmUoJy4vSXRlbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEJveEl0ZW1cbiAqIEBleHRlbmRzIEl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsIGNsYXNzTmFtZS5cbiAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgYXZhaWxhYmxlIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gQm94SXRlbSAoZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICB0aGlzLnByb3BzID0ge1xuICAgIGRvdDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9LFxuICAgIGxpbmU6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfVxuICB9O1xuXG4gIC8vIHZhbGlkYXRlIGRhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgSXRlbS5jYWxsKHRoaXMsIGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpO1xufVxuXG5Cb3hJdGVtLnByb3RvdHlwZSA9IG5ldyBJdGVtIChudWxsLCBudWxsLCBudWxsKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAqL1xuQm94SXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgLy8gZGV0ZXJtaW5lIHZpc2liaWxpdHlcbiAgLy8gVE9ETzogYWNjb3VudCBmb3IgdGhlIHJlYWwgd2lkdGggb2YgdGhlIGl0ZW0uIFJpZ2h0IG5vdyB3ZSBqdXN0IGFkZCAxLzQgdG8gdGhlIHdpbmRvd1xuICB2YXIgaW50ZXJ2YWwgPSAocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQpIC8gNDtcbiAgcmV0dXJuICh0aGlzLmRhdGEuc3RhcnQgPiByYW5nZS5zdGFydCAtIGludGVydmFsKSAmJiAodGhpcy5kYXRhLnN0YXJ0IDwgcmFuZ2UuZW5kICsgaW50ZXJ2YWwpO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBpdGVtXG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZG9tID0gdGhpcy5kb207XG4gIGlmICghZG9tKSB7XG4gICAgLy8gY3JlYXRlIERPTVxuICAgIHRoaXMuZG9tID0ge307XG4gICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAvLyBjcmVhdGUgbWFpbiBib3hcbiAgICBkb20uYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG5cbiAgICAvLyBjb250ZW50cyBib3ggKGluc2lkZSB0aGUgYmFja2dyb3VuZCBib3gpLiB1c2VkIGZvciBtYWtpbmcgbWFyZ2luc1xuICAgIGRvbS5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgIGRvbS5ib3guYXBwZW5kQ2hpbGQoZG9tLmNvbnRlbnQpO1xuXG4gICAgLy8gbGluZSB0byBheGlzXG4gICAgZG9tLmxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICBkb20ubGluZS5jbGFzc05hbWUgPSAndmlzLWxpbmUnO1xuXG4gICAgLy8gZG90IG9uIGF4aXNcbiAgICBkb20uZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgZG9tLmRvdC5jbGFzc05hbWUgPSAndmlzLWRvdCc7XG5cbiAgICAvLyBhdHRhY2ggdGhpcyBpdGVtIGFzIGF0dHJpYnV0ZVxuICAgIGRvbS5ib3hbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IG5vIHBhcmVudCBhdHRhY2hlZCcpO1xuICB9XG4gIGlmICghZG9tLmJveC5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLnBhcmVudC5kb20uZm9yZWdyb3VuZDtcbiAgICBpZiAoIWZvcmVncm91bmQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGZvcmVncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICBmb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5ib3gpO1xuICB9XG4gIGlmICghZG9tLmxpbmUucGFyZW50Tm9kZSkge1xuICAgIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmJhY2tncm91bmQ7XG4gICAgaWYgKCFiYWNrZ3JvdW5kKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBiYWNrZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgYmFja2dyb3VuZC5hcHBlbmRDaGlsZChkb20ubGluZSk7XG4gIH1cbiAgaWYgKCFkb20uZG90LnBhcmVudE5vZGUpIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMucGFyZW50LmRvbS5heGlzO1xuICAgIGlmICghYmFja2dyb3VuZCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gYXhpcyBjb250YWluZXIgZWxlbWVudCcpO1xuICAgIGF4aXMuYXBwZW5kQ2hpbGQoZG9tLmRvdCk7XG4gIH1cbiAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gIC8vIFVwZGF0ZSBET00gd2hlbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eS4gQW4gaXRlbSBpcyBtYXJrZWQgZGlydHkgd2hlbjpcbiAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgLy8gLSB0aGUgaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgdGhpcy5fdXBkYXRlVGl0bGUodGhpcy5kb20uYm94KTtcbiAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5ib3gpO1xuICAgIHRoaXMuX3VwZGF0ZVN0eWxlKHRoaXMuZG9tLmJveCk7XG5cbiAgICB2YXIgZWRpdGFibGUgPSAodGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgfHwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRhYmxlID09PSB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdGFibGUgIT09IGZhbHNlO1xuXG4gICAgLy8gdXBkYXRlIGNsYXNzXG4gICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lPyAnICcgKyB0aGlzLmRhdGEuY2xhc3NOYW1lIDogJycpICtcbiAgICAgICAgKHRoaXMuc2VsZWN0ZWQgPyAnIHZpcy1zZWxlY3RlZCcgOiAnJykgKyBcbiAgICAgICAgKGVkaXRhYmxlID8gJyB2aXMtZWRpdGFibGUnIDogJyB2aXMtcmVhZG9ubHknKTtcbiAgICBkb20uYm94LmNsYXNzTmFtZSA9ICd2aXMtaXRlbSB2aXMtYm94JyArIGNsYXNzTmFtZTtcbiAgICBkb20ubGluZS5jbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLWxpbmUnICsgY2xhc3NOYW1lO1xuICAgIGRvbS5kb3QuY2xhc3NOYW1lICA9ICd2aXMtaXRlbSB2aXMtZG90JyArIGNsYXNzTmFtZTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICB0aGlzLnByb3BzLmRvdC5oZWlnaHQgPSBkb20uZG90Lm9mZnNldEhlaWdodDtcbiAgICB0aGlzLnByb3BzLmRvdC53aWR0aCA9IGRvbS5kb3Qub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5wcm9wcy5saW5lLndpZHRoID0gZG9tLmxpbmUub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy53aWR0aCA9IGRvbS5ib3gub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBkb20uYm94Lm9mZnNldEhlaWdodDtcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuX3JlcGFpbnREZWxldGVCdXR0b24oZG9tLmJveCk7XG59O1xuXG4vKipcbiAqIFNob3cgdGhlIGl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSBkaXNwbGF5ZWQpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRpc3BsYXllZCkge1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH1cbn07XG5cbi8qKlxuICogSGlkZSB0aGUgaXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAqL1xuQm94SXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG5cbiAgICBpZiAoZG9tLmJveC5wYXJlbnROb2RlKSAgIGRvbS5ib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20uYm94KTtcbiAgICBpZiAoZG9tLmxpbmUucGFyZW50Tm9kZSkgIGRvbS5saW5lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tLmxpbmUpO1xuICAgIGlmIChkb20uZG90LnBhcmVudE5vZGUpICAgZG9tLmRvdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbS5kb3QpO1xuXG4gICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIGhvcml6b250YWxseVxuICogQE92ZXJyaWRlXG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuY29udmVyc2lvbi50b1NjcmVlbih0aGlzLmRhdGEuc3RhcnQpO1xuICB2YXIgYWxpZ24gPSB0aGlzLm9wdGlvbnMuYWxpZ247XG4gIHZhciBsZWZ0O1xuXG4gIC8vIGNhbGN1bGF0ZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBib3hcbiAgaWYgKGFsaWduID09ICdyaWdodCcpIHtcbiAgICB0aGlzLmxlZnQgPSBzdGFydCAtIHRoaXMud2lkdGg7XG4gIH1cbiAgZWxzZSBpZiAoYWxpZ24gPT0gJ2xlZnQnKSB7XG4gICAgdGhpcy5sZWZ0ID0gc3RhcnQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZGVmYXVsdCBvciAnY2VudGVyJ1xuICAgIHRoaXMubGVmdCA9IHN0YXJ0IC0gdGhpcy53aWR0aCAvIDI7XG4gIH1cblxuICAvLyByZXBvc2l0aW9uIGJveFxuICB0aGlzLmRvbS5ib3guc3R5bGUubGVmdCA9IHRoaXMubGVmdCArICdweCc7XG5cbiAgLy8gcmVwb3NpdGlvbiBsaW5lXG4gIHRoaXMuZG9tLmxpbmUuc3R5bGUubGVmdCA9IChzdGFydCAtIHRoaXMucHJvcHMubGluZS53aWR0aCAvIDIpICsgJ3B4JztcblxuICAvLyByZXBvc2l0aW9uIGRvdFxuICB0aGlzLmRvbS5kb3Quc3R5bGUubGVmdCA9IChzdGFydCAtIHRoaXMucHJvcHMuZG90LndpZHRoIC8gMikgKyAncHgnO1xufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAqIEBPdmVycmlkZVxuICovXG5Cb3hJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgdmFyIGJveCA9IHRoaXMuZG9tLmJveDtcbiAgdmFyIGxpbmUgPSB0aGlzLmRvbS5saW5lO1xuICB2YXIgZG90ID0gdGhpcy5kb20uZG90O1xuXG4gIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgIGJveC5zdHlsZS50b3AgICAgID0gKHRoaXMudG9wIHx8IDApICsgJ3B4JztcblxuICAgIGxpbmUuc3R5bGUudG9wICAgID0gJzAnO1xuICAgIGxpbmUuc3R5bGUuaGVpZ2h0ID0gKHRoaXMucGFyZW50LnRvcCArIHRoaXMudG9wICsgMSkgKyAncHgnO1xuICAgIGxpbmUuc3R5bGUuYm90dG9tID0gJyc7XG4gIH1cbiAgZWxzZSB7IC8vIG9yaWVudGF0aW9uICdib3R0b20nXG4gICAgdmFyIGl0ZW1TZXRIZWlnaHQgPSB0aGlzLnBhcmVudC5pdGVtU2V0LnByb3BzLmhlaWdodDsgLy8gVE9ETzogdGhpcyBpcyBuYXN0eVxuICAgIHZhciBsaW5lSGVpZ2h0ID0gaXRlbVNldEhlaWdodCAtIHRoaXMucGFyZW50LnRvcCAtIHRoaXMucGFyZW50LmhlaWdodCArIHRoaXMudG9wO1xuXG4gICAgYm94LnN0eWxlLnRvcCAgICAgPSAodGhpcy5wYXJlbnQuaGVpZ2h0IC0gdGhpcy50b3AgLSB0aGlzLmhlaWdodCB8fCAwKSArICdweCc7XG4gICAgbGluZS5zdHlsZS50b3AgICAgPSAoaXRlbVNldEhlaWdodCAtIGxpbmVIZWlnaHQpICsgJ3B4JztcbiAgICBsaW5lLnN0eWxlLmJvdHRvbSA9ICcwJztcbiAgfVxuXG4gIGRvdC5zdHlsZS50b3AgPSAoLXRoaXMucHJvcHMuZG90LmhlaWdodCAvIDIpICsgJ3B4Jztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSBsZWZ0IGZyb20gaXRzIHN0YXJ0IGRhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuQm94SXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aCAvIDI7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gcmlnaHQgZnJvbSBpdHMgc3RhcnQgZGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5Cb3hJdGVtLnByb3RvdHlwZS5nZXRXaWR0aFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aCAvIDI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJveEl0ZW07XG4iXX0=
},{"../../../util":46,"./Item":41}],41:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var util = require('../../../util');

/**
 * @constructor Item
 * @param {Object} data             Object containing (optional) parameters type,
 *                                  start, end, content, group, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} options          Configuration options
 *                                  // TODO: describe available options
 */
function Item(data, conversion, options) {
  this.id = null;
  this.parent = null;
  this.data = data;
  this.dom = null;
  this.conversion = conversion || {};
  this.options = options || {};

  this.selected = false;
  this.displayed = false;
  this.dirty = true;

  this.top = null;
  this.left = null;
  this.width = null;
  this.height = null;

  this.editable = null;
  if (this.data && this.data.hasOwnProperty('editable') && typeof this.data.editable === 'boolean') {
    this.editable = data.editable;
  }
}

Item.prototype.stack = true;

/**
 * Select current item
 */
Item.prototype.select = function () {
  this.selected = true;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Unselect current item
 */
Item.prototype.unselect = function () {
  this.selected = false;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Set data for the item. Existing data will be updated. The id should not
 * be changed. When the item is displayed, it will be redrawn immediately.
 * @param {Object} data
 */
Item.prototype.setData = function (data) {
  var groupChanged = data.group != undefined && this.data.group != data.group;
  if (groupChanged) {
    this.parent.itemSet._moveToGroup(this, data.group);
  }

  if (data.hasOwnProperty('editable') && typeof data.editable === 'boolean') {
    this.editable = data.editable;
  }

  this.data = data;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Set a parent for the item
 * @param {ItemSet | Group} parent
 */
Item.prototype.setParent = function (parent) {
  if (this.displayed) {
    this.hide();
    this.parent = parent;
    if (this.parent) {
      this.show();
    }
  } else {
    this.parent = parent;
  }
};

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
Item.prototype.isVisible = function (range) {
  // Should be implemented by Item implementations
  return false;
};

/**
 * Show the Item in the DOM (when not already visible)
 * @return {Boolean} changed
 */
Item.prototype.show = function () {
  return false;
};

/**
 * Hide the Item from the DOM (when visible)
 * @return {Boolean} changed
 */
Item.prototype.hide = function () {
  return false;
};

/**
 * Repaint the item
 */
Item.prototype.redraw = function () {
  // should be implemented by the item
};

/**
 * Reposition the Item horizontally
 */
Item.prototype.repositionX = function () {
  // should be implemented by the item
};

/**
 * Reposition the Item vertically
 */
Item.prototype.repositionY = function () {
  // should be implemented by the item
};

/**
 * Repaint a delete button on the top right of the item when the item is selected
 * @param {HTMLElement} anchor
 * @protected
 */
Item.prototype._repaintDeleteButton = function (anchor) {
  var editable = (this.options.editable.remove || this.data.editable === true) && this.data.editable !== false;

  if (this.selected && editable && !this.dom.deleteButton) {
    // create and show button
    var me = this;

    var deleteButton = document.createElement('div');
    deleteButton.className = 'vis-delete';
    deleteButton.title = 'Delete this item';

    // TODO: be able to destroy the delete button
    new Hammer(deleteButton).on('tap', function (event) {
      event.stopPropagation();
      me.parent.removeFromDataSet(me);
    });

    anchor.appendChild(deleteButton);
    this.dom.deleteButton = deleteButton;
  } else if (!this.selected && this.dom.deleteButton) {
    // remove button
    if (this.dom.deleteButton.parentNode) {
      this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);
    }
    this.dom.deleteButton = null;
  }
};

/**
 * Set HTML contents for the item
 * @param {Element} element   HTML element to fill with the contents
 * @private
 */
Item.prototype._updateContents = function (element) {
  var content;
  if (this.options.template) {
    var itemData = this.parent.itemSet.itemsData.get(this.id); // get a clone of the data from the dataset
    content = this.options.template(itemData);
  } else {
    content = this.data.content;
  }

  var changed = this._contentToString(this.content) !== this._contentToString(content);
  if (changed) {
    // only replace the content when changed
    if (content instanceof Element) {
      element.innerHTML = '';
      element.appendChild(content);
    } else if (content != undefined) {
      element.innerHTML = content;
    } else {
      if (!(this.data.type == 'background' && this.data.content === undefined)) {
        throw new Error('Property "content" missing in item ' + this.id);
      }
    }

    this.content = content;
  }
};

/**
 * Set HTML contents for the item
 * @param {Element} element   HTML element to fill with the contents
 * @private
 */
Item.prototype._updateTitle = function (element) {
  if (this.data.title != null) {
    element.title = this.data.title || '';
  } else {
    element.removeAttribute('vis-title');
  }
};

/**
 * Process dataAttributes timeline option and set as data- attributes on dom.content
 * @param {Element} element   HTML element to which the attributes will be attached
 * @private
 */
Item.prototype._updateDataAttributes = function (element) {
  if (this.options.dataAttributes && this.options.dataAttributes.length > 0) {
    var attributes = [];

    if (Array.isArray(this.options.dataAttributes)) {
      attributes = this.options.dataAttributes;
    } else if (this.options.dataAttributes == 'all') {
      attributes = Object.keys(this.data);
    } else {
      return;
    }

    for (var i = 0; i < attributes.length; i++) {
      var name = attributes[i];
      var value = this.data[name];

      if (value != null) {
        element.setAttribute('data-' + name, value);
      } else {
        element.removeAttribute('data-' + name);
      }
    }
  }
};

/**
 * Update custom styles of the element
 * @param element
 * @private
 */
Item.prototype._updateStyle = function (element) {
  // remove old styles
  if (this.style) {
    util.removeCssText(element, this.style);
    this.style = null;
  }

  // append new styles
  if (this.data.style) {
    util.addCssText(element, this.data.style);
    this.style = this.data.style;
  }
};

/**
 * Stringify the items contents
 * @param {string | Element | undefined} content
 * @returns {string | undefined}
 * @private
 */
Item.prototype._contentToString = function (content) {
  if (typeof content === 'string') return content;
  if (content && 'outerHTML' in content) return content.outerHTML;
  return content;
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
Item.prototype.getWidthLeft = function () {
  return 0;
};

/**
 * Return the width of the item right from the max of its start and end date
 * @return {number}
 */
Item.prototype.getWidthRight = function () {
  return 0;
};

module.exports = Item;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL0l0ZW0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQUMvQyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7Ozs7Ozs7Ozs7O0FBV3BDLFNBQVMsSUFBSSxDQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFO0FBQ3hDLE1BQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDO0FBQ2YsTUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7QUFDbkIsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDakIsTUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7QUFDaEIsTUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLElBQUksRUFBRSxDQUFDO0FBQ25DLE1BQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxJQUFJLEVBQUUsQ0FBQzs7QUFFN0IsTUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7QUFDdEIsTUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFDdkIsTUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7O0FBRWxCLE1BQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQ2hCLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLE1BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0FBQ2xCLE1BQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDOztBQUVuQixNQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztBQUNyQixNQUFJLElBQUksQ0FBQyxJQUFJLElBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLElB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RixNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9JdGVtLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBJdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyAob3B0aW9uYWwpIHBhcmFtZXRlcnMgdHlwZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LCBlbmQsIGNvbnRlbnQsIGdyb3VwLCBjbGFzc05hbWUuXG4gKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIGF2YWlsYWJsZSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEl0ZW0gKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdGhpcy5pZCA9IG51bGw7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5kb20gPSBudWxsO1xuICB0aGlzLmNvbnZlcnNpb24gPSBjb252ZXJzaW9uIHx8IHt9O1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgdGhpcy50b3AgPSBudWxsO1xuICB0aGlzLmxlZnQgPSBudWxsO1xuICB0aGlzLndpZHRoID0gbnVsbDtcbiAgdGhpcy5oZWlnaHQgPSBudWxsO1xuXG4gIHRoaXMuZWRpdGFibGUgPSBudWxsO1xuICBpZiAodGhpcy5kYXRhICYmIFxuICAgICAgdGhpcy5kYXRhLmhhc093blByb3BlcnR5KCdlZGl0YWJsZScpICYmIFxuICAgICAgdHlwZW9mIHRoaXMuZGF0YS5lZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhpcy5lZGl0YWJsZSA9IGRhdGEuZWRpdGFibGU7XG4gIH1cbn1cblxuSXRlbS5wcm90b3R5cGUuc3RhY2sgPSB0cnVlO1xuXG4vKipcbiAqIFNlbGVjdCBjdXJyZW50IGl0ZW1cbiAqL1xuSXRlbS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgaWYgKHRoaXMuZGlzcGxheWVkKSB0aGlzLnJlZHJhdygpO1xufTtcblxuLyoqXG4gKiBVbnNlbGVjdCBjdXJyZW50IGl0ZW1cbiAqL1xuSXRlbS5wcm90b3R5cGUudW5zZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgaWYgKHRoaXMuZGlzcGxheWVkKSB0aGlzLnJlZHJhdygpO1xufTtcblxuLyoqXG4gKiBTZXQgZGF0YSBmb3IgdGhlIGl0ZW0uIEV4aXN0aW5nIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBUaGUgaWQgc2hvdWxkIG5vdFxuICogYmUgY2hhbmdlZC4gV2hlbiB0aGUgaXRlbSBpcyBkaXNwbGF5ZWQsIGl0IHdpbGwgYmUgcmVkcmF3biBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBncm91cENoYW5nZWQgPSBkYXRhLmdyb3VwICE9IHVuZGVmaW5lZCAmJiB0aGlzLmRhdGEuZ3JvdXAgIT0gZGF0YS5ncm91cDtcbiAgaWYgKGdyb3VwQ2hhbmdlZCkge1xuICAgIHRoaXMucGFyZW50Lml0ZW1TZXQuX21vdmVUb0dyb3VwKHRoaXMsIGRhdGEuZ3JvdXApO1xuICB9XG5cbiAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ2VkaXRhYmxlJykgJiYgdHlwZW9mIGRhdGEuZWRpdGFibGUgPT09ICdib29sZWFuJykge1xuICAgIHRoaXMuZWRpdGFibGUgPSBkYXRhLmVkaXRhYmxlO1xuICB9XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIGlmICh0aGlzLmRpc3BsYXllZCkgdGhpcy5yZWRyYXcoKTtcbn07XG5cbi8qKlxuICogU2V0IGEgcGFyZW50IGZvciB0aGUgaXRlbVxuICogQHBhcmFtIHtJdGVtU2V0IHwgR3JvdXB9IHBhcmVudFxuICovXG5JdGVtLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgaWYgKHRoaXMuZGlzcGxheWVkKSB7XG4gICAgdGhpcy5oaWRlKCk7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIC8vIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBJdGVtIGltcGxlbWVudGF0aW9uc1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFNob3cgdGhlIEl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKVxuICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICovXG5JdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSGlkZSB0aGUgSXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAqL1xuSXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAqL1xuSXRlbS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgaXRlbVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBJdGVtIGhvcml6b250YWxseVxuICovXG5JdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWCA9IGZ1bmN0aW9uKCkge1xuICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGl0ZW1cbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgSXRlbSB2ZXJ0aWNhbGx5XG4gKi9cbkl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgaXRlbVxufTtcblxuLyoqXG4gKiBSZXBhaW50IGEgZGVsZXRlIGJ1dHRvbiBvbiB0aGUgdG9wIHJpZ2h0IG9mIHRoZSBpdGVtIHdoZW4gdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGFuY2hvclxuICogQHByb3RlY3RlZFxuICovXG5JdGVtLnByb3RvdHlwZS5fcmVwYWludERlbGV0ZUJ1dHRvbiA9IGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgdmFyIGVkaXRhYmxlID0gKHRoaXMub3B0aW9ucy5lZGl0YWJsZS5yZW1vdmUgfHwgXG4gICAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZWRpdGFibGUgPT09IHRydWUpICYmXG4gICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5lZGl0YWJsZSAhPT0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuc2VsZWN0ZWQgJiYgZWRpdGFibGUgJiYgIXRoaXMuZG9tLmRlbGV0ZUJ1dHRvbikge1xuICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyBidXR0b25cbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgdmFyIGRlbGV0ZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlbGV0ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWRlbGV0ZSc7XG4gICAgZGVsZXRlQnV0dG9uLnRpdGxlID0gJ0RlbGV0ZSB0aGlzIGl0ZW0nO1xuXG4gICAgLy8gVE9ETzogYmUgYWJsZSB0byBkZXN0cm95IHRoZSBkZWxldGUgYnV0dG9uXG4gICAgbmV3IEhhbW1lcihkZWxldGVCdXR0b24pLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgbWUucGFyZW50LnJlbW92ZUZyb21EYXRhU2V0KG1lKTtcbiAgICB9KTtcblxuICAgIGFuY2hvci5hcHBlbmRDaGlsZChkZWxldGVCdXR0b24pO1xuICAgIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbiA9IGRlbGV0ZUJ1dHRvbjtcbiAgfVxuICBlbHNlIGlmICghdGhpcy5zZWxlY3RlZCAmJiB0aGlzLmRvbS5kZWxldGVCdXR0b24pIHtcbiAgICAvLyByZW1vdmUgYnV0dG9uXG4gICAgaWYgKHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbi5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5kZWxldGVCdXR0b24ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5kZWxldGVCdXR0b24pO1xuICAgIH1cbiAgICB0aGlzLmRvbS5kZWxldGVCdXR0b24gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBIVE1MIGNvbnRlbnRzIGZvciB0aGUgaXRlbVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgSFRNTCBlbGVtZW50IHRvIGZpbGwgd2l0aCB0aGUgY29udGVudHNcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW0ucHJvdG90eXBlLl91cGRhdGVDb250ZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBjb250ZW50O1xuICBpZiAodGhpcy5vcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgdmFyIGl0ZW1EYXRhID0gdGhpcy5wYXJlbnQuaXRlbVNldC5pdGVtc0RhdGEuZ2V0KHRoaXMuaWQpOyAvLyBnZXQgYSBjbG9uZSBvZiB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhc2V0XG4gICAgY29udGVudCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZShpdGVtRGF0YSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgY29udGVudCA9IHRoaXMuZGF0YS5jb250ZW50O1xuICB9XG5cbiAgdmFyIGNoYW5nZWQgPSB0aGlzLl9jb250ZW50VG9TdHJpbmcodGhpcy5jb250ZW50KSAhPT0gdGhpcy5fY29udGVudFRvU3RyaW5nKGNvbnRlbnQpO1xuICBpZiAoY2hhbmdlZCkge1xuICAgIC8vIG9ubHkgcmVwbGFjZSB0aGUgY29udGVudCB3aGVuIGNoYW5nZWRcbiAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZW50ICE9IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICghKHRoaXMuZGF0YS50eXBlID09ICdiYWNrZ3JvdW5kJyAmJiB0aGlzLmRhdGEuY29udGVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwiY29udGVudFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgdGhpcy5pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgSFRNTCBjb250ZW50cyBmb3IgdGhlIGl0ZW1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAgIEhUTUwgZWxlbWVudCB0byBmaWxsIHdpdGggdGhlIGNvbnRlbnRzXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtLnByb3RvdHlwZS5fdXBkYXRlVGl0bGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBpZiAodGhpcy5kYXRhLnRpdGxlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnRpdGxlID0gdGhpcy5kYXRhLnRpdGxlIHx8ICcnO1xuICB9XG4gIGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd2aXMtdGl0bGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9jZXNzIGRhdGFBdHRyaWJ1dGVzIHRpbWVsaW5lIG9wdGlvbiBhbmQgc2V0IGFzIGRhdGEtIGF0dHJpYnV0ZXMgb24gZG9tLmNvbnRlbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAgIEhUTUwgZWxlbWVudCB0byB3aGljaCB0aGUgYXR0cmlidXRlcyB3aWxsIGJlIGF0dGFjaGVkXG4gKiBAcHJpdmF0ZVxuICovXG4gSXRlbS5wcm90b3R5cGUuX3VwZGF0ZURhdGFBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBpZiAodGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzICYmIHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcykpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSB0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcyA9PSAnYWxsJykge1xuICAgICAgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5kYXRhW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS0nICsgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLScgKyBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGN1c3RvbSBzdHlsZXMgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSBlbGVtZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtLnByb3RvdHlwZS5fdXBkYXRlU3R5bGUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIC8vIHJlbW92ZSBvbGQgc3R5bGVzXG4gIGlmICh0aGlzLnN0eWxlKSB7XG4gICAgdXRpbC5yZW1vdmVDc3NUZXh0KGVsZW1lbnQsIHRoaXMuc3R5bGUpO1xuICAgIHRoaXMuc3R5bGUgPSBudWxsO1xuICB9XG5cbiAgLy8gYXBwZW5kIG5ldyBzdHlsZXNcbiAgaWYgKHRoaXMuZGF0YS5zdHlsZSkge1xuICAgIHV0aWwuYWRkQ3NzVGV4dChlbGVtZW50LCB0aGlzLmRhdGEuc3R5bGUpO1xuICAgIHRoaXMuc3R5bGUgPSB0aGlzLmRhdGEuc3R5bGU7XG4gIH1cbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBpdGVtcyBjb250ZW50c1xuICogQHBhcmFtIHtzdHJpbmcgfCBFbGVtZW50IHwgdW5kZWZpbmVkfSBjb250ZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuSXRlbS5wcm90b3R5cGUuX2NvbnRlbnRUb1N0cmluZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHJldHVybiBjb250ZW50O1xuICBpZiAoY29udGVudCAmJiAnb3V0ZXJIVE1MJyBpbiBjb250ZW50KSByZXR1cm4gY29udGVudC5vdXRlckhUTUw7XG4gIHJldHVybiBjb250ZW50O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIGxlZnQgZnJvbSBpdHMgc3RhcnQgZGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRXaWR0aExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIHJpZ2h0IGZyb20gdGhlIG1heCBvZiBpdHMgc3RhcnQgYW5kIGVuZCBkYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldFdpZHRoUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAwO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJdGVtO1xuIl19
},{"../../../module/hammer":19,"../../../util":46}],42:[function(require,module,exports){
'use strict';

var Item = require('./Item');

/**
 * @constructor PointItem
 * @extends Item
 * @param {Object} data             Object containing parameters start
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe available options
 */
function PointItem(data, conversion, options) {
  this.props = {
    dot: {
      top: 0,
      width: 0,
      height: 0
    },
    content: {
      height: 0,
      marginLeft: 0
    }
  };

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data);
    }
  }

  Item.call(this, data, conversion, options);
}

PointItem.prototype = new Item(null, null, null);

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
PointItem.prototype.isVisible = function (range) {
  // determine visibility
  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
  var interval = (range.end - range.start) / 4;
  return this.data.start > range.start - interval && this.data.start < range.end + interval;
};

/**
 * Repaint the item
 */
PointItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.point = document.createElement('div');
    // className is updated in redraw()

    // contents box, right from the dot
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.point.appendChild(dom.content);

    // dot at start
    dom.dot = document.createElement('div');
    dom.point.appendChild(dom.dot);

    // attach this item as attribute
    dom.point['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.point.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) {
      throw new Error('Cannot redraw item: parent has no foreground container element');
    }
    foreground.appendChild(dom.point);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.point);
    this._updateDataAttributes(this.dom.point);
    this._updateStyle(this.dom.point);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.point.className = 'vis-item vis-point' + className;
    dom.dot.className = 'vis-item vis-dot' + className;

    // recalculate size of dot and contents
    this.props.dot.width = dom.dot.offsetWidth;
    this.props.dot.height = dom.dot.offsetHeight;
    this.props.content.height = dom.content.offsetHeight;

    // resize contents
    dom.content.style.marginLeft = 2 * this.props.dot.width + 'px';
    //dom.content.style.marginRight = ... + 'px'; // TODO: margin right

    // recalculate size
    this.width = dom.point.offsetWidth;
    this.height = dom.point.offsetHeight;

    // reposition the dot
    dom.dot.style.top = (this.height - this.props.dot.height) / 2 + 'px';
    dom.dot.style.left = this.props.dot.width / 2 + 'px';

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.point);
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
PointItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 */
PointItem.prototype.hide = function () {
  if (this.displayed) {
    if (this.dom.point.parentNode) {
      this.dom.point.parentNode.removeChild(this.dom.point);
    }

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @Override
 */
PointItem.prototype.repositionX = function () {
  var start = this.conversion.toScreen(this.data.start);

  this.left = start - this.props.dot.width;

  // reposition point
  this.dom.point.style.left = this.left + 'px';
};

/**
 * Reposition the item vertically
 * @Override
 */
PointItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var point = this.dom.point;

  if (orientation == 'top') {
    point.style.top = this.top + 'px';
  } else {
    point.style.top = this.parent.height - this.top - this.height + 'px';
  }
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
PointItem.prototype.getWidthLeft = function () {
  return this.props.dot.width;
};

/**
 * Return the width of the item right from  its start date
 * @return {number}
 */
PointItem.prototype.getWidthRight = function () {
  return this.width - this.props.dot.width;
};

module.exports = PointItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL1BvaW50SXRlbS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7O0FBWTdCLFNBQVMsU0FBUyxDQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFO0FBQzdDLE1BQUksQ0FBQyxLQUFLLEdBQUc7QUFDWCxPQUFHLEVBQUU7QUFDSCxTQUFHLEVBQUUsQ0FBQztBQUNOLFdBQUssRUFBRSxDQUFDO0FBQ1IsWUFBTSxFQUFFLENBQUM7S0FDVjtBQUNELFdBQU8sRUFBRTtBQUNQLFlBQU0sRUFBRSxDQUFDO0FBQ1QsZ0JBQVUsRUFBRSxDQUFDO0tBQ2Q7R0FDRixDQUFDOzs7QUFHRixNQUFJLElBQUksRUFBRTtBQUNSLFFBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxTQUFTLEVBQUU7QUFDM0IsWUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsR0FBRyxJQUFJLENBQUMsQ0FBQztLQUM3RDtHQUNGOztBQUVELE1BQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7Q0FDNUM7O0FBRUQsU0FBUyxDQUFDLFNBQVMsR0FBRyxJQUFJLElBQUksQ0FBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDOzs7Ozs7O0FBT2xELFNBQVMsQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFVBQVMsS0FBSyxFQUFFOzs7QUFHOUMsTUFBSSxRQUFRLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUEsR0FBSSxDQUFDLENBQUM7QUFDN0MsU0FBTyxBQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFH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LENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztHQUNuQyxNQUNJO0FBQ0gsU0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUksSUFBSSxDQUFDO0dBQ3hFO0NBQ0YsQ0FBQzs7Ozs7O0FBTUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsWUFBWTtBQUM3QyxTQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztDQUM3QixDQUFDOzs7Ozs7QUFNRixTQUFTLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxZQUFZO0FBQzlDLFNBQU8sSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7Q0FDMUMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9Qb2ludEl0ZW0uanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSXRlbSA9IHJlcXVpcmUoJy4vSXRlbScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBQb2ludEl0ZW1cbiAqIEBleHRlbmRzIEl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsIGNsYXNzTmFtZS5cbiAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgYXZhaWxhYmxlIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUG9pbnRJdGVtIChkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgZG90OiB7XG4gICAgICB0b3A6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH0sXG4gICAgY29udGVudDoge1xuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgbWFyZ2luTGVmdDogMFxuICAgIH1cbiAgfTtcblxuICAvLyB2YWxpZGF0ZSBkYXRhXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKGRhdGEuc3RhcnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwic3RhcnRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbn1cblxuUG9pbnRJdGVtLnByb3RvdHlwZSA9IG5ldyBJdGVtIChudWxsLCBudWxsLCBudWxsKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAqL1xuUG9pbnRJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbihyYW5nZSkge1xuICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICAvLyBUT0RPOiBhY2NvdW50IGZvciB0aGUgcmVhbCB3aWR0aCBvZiB0aGUgaXRlbS4gUmlnaHQgbm93IHdlIGp1c3QgYWRkIDEvNCB0byB0aGUgd2luZG93XG4gIHZhciBpbnRlcnZhbCA9IChyYW5nZS5lbmQgLSByYW5nZS5zdGFydCkgLyA0O1xuICByZXR1cm4gKHRoaXMuZGF0YS5zdGFydCA+IHJhbmdlLnN0YXJ0IC0gaW50ZXJ2YWwpICYmICh0aGlzLmRhdGEuc3RhcnQgPCByYW5nZS5lbmQgKyBpbnRlcnZhbCk7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAqL1xuUG9pbnRJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICBpZiAoIWRvbSkge1xuICAgIC8vIGNyZWF0ZSBET01cbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIGRvbSA9IHRoaXMuZG9tO1xuXG4gICAgLy8gYmFja2dyb3VuZCBib3hcbiAgICBkb20ucG9pbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAvLyBjbGFzc05hbWUgaXMgdXBkYXRlZCBpbiByZWRyYXcoKVxuXG4gICAgLy8gY29udGVudHMgYm94LCByaWdodCBmcm9tIHRoZSBkb3RcbiAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5jb250ZW50LmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1jb250ZW50JztcbiAgICBkb20ucG9pbnQuYXBwZW5kQ2hpbGQoZG9tLmNvbnRlbnQpO1xuXG4gICAgLy8gZG90IGF0IHN0YXJ0XG4gICAgZG9tLmRvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5wb2ludC5hcHBlbmRDaGlsZChkb20uZG90KTtcblxuICAgIC8vIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlXG4gICAgZG9tLnBvaW50Wyd0aW1lbGluZS1pdGVtJ10gPSB0aGlzO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cblxuICAvLyBhcHBlbmQgRE9NIHRvIHBhcmVudCBET01cbiAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBubyBwYXJlbnQgYXR0YWNoZWQnKTtcbiAgfVxuICBpZiAoIWRvbS5wb2ludC5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLnBhcmVudC5kb20uZm9yZWdyb3VuZDtcbiAgICBpZiAoIWZvcmVncm91bmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGZvcmVncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICB9XG4gICAgZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChkb20ucG9pbnQpO1xuICB9XG4gIHRoaXMuZGlzcGxheWVkID0gdHJ1ZTtcblxuICAvLyBVcGRhdGUgRE9NIHdoZW4gaXRlbSBpcyBtYXJrZWQgZGlydHkuIEFuIGl0ZW0gaXMgbWFya2VkIGRpcnR5IHdoZW46XG4gIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAvLyAtIHRoZSBpdGVtJ3MgZGF0YSBpcyBjaGFuZ2VkXG4gIC8vIC0gdGhlIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICBpZiAodGhpcy5kaXJ0eSkge1xuICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnRzKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHRoaXMuZG9tLnBvaW50KTtcbiAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5wb2ludCk7XG4gICAgdGhpcy5fdXBkYXRlU3R5bGUodGhpcy5kb20ucG9pbnQpO1xuXG4gICAgdmFyIGVkaXRhYmxlID0gKHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lIHx8IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRhYmxlICE9PSBmYWxzZTtcblxuICAgIC8vIHVwZGF0ZSBjbGFzc1xuICAgIHZhciBjbGFzc05hbWUgPSAodGhpcy5kYXRhLmNsYXNzTmFtZSA/ICcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUgOiAnJykgK1xuICAgICAgICAodGhpcy5zZWxlY3RlZCA/ICcgdmlzLXNlbGVjdGVkJyA6ICcnKSArXG4gICAgICAgIChlZGl0YWJsZSA/ICcgdmlzLWVkaXRhYmxlJyA6ICcgdmlzLXJlYWRvbmx5Jyk7XG4gICAgZG9tLnBvaW50LmNsYXNzTmFtZSAgPSAndmlzLWl0ZW0gdmlzLXBvaW50JyArIGNsYXNzTmFtZTtcbiAgICBkb20uZG90LmNsYXNzTmFtZSAgPSAndmlzLWl0ZW0gdmlzLWRvdCcgKyBjbGFzc05hbWU7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBzaXplIG9mIGRvdCBhbmQgY29udGVudHNcbiAgICB0aGlzLnByb3BzLmRvdC53aWR0aCA9IGRvbS5kb3Qub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5wcm9wcy5kb3QuaGVpZ2h0ID0gZG9tLmRvdC5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5wcm9wcy5jb250ZW50LmhlaWdodCA9IGRvbS5jb250ZW50Lm9mZnNldEhlaWdodDtcblxuICAgIC8vIHJlc2l6ZSBjb250ZW50c1xuICAgIGRvbS5jb250ZW50LnN0eWxlLm1hcmdpbkxlZnQgPSAyICogdGhpcy5wcm9wcy5kb3Qud2lkdGggKyAncHgnO1xuICAgIC8vZG9tLmNvbnRlbnQuc3R5bGUubWFyZ2luUmlnaHQgPSAuLi4gKyAncHgnOyAvLyBUT0RPOiBtYXJnaW4gcmlnaHRcblxuICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICB0aGlzLndpZHRoID0gZG9tLnBvaW50Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gZG9tLnBvaW50Lm9mZnNldEhlaWdodDtcblxuICAgIC8vIHJlcG9zaXRpb24gdGhlIGRvdFxuICAgIGRvbS5kb3Quc3R5bGUudG9wID0gKCh0aGlzLmhlaWdodCAtIHRoaXMucHJvcHMuZG90LmhlaWdodCkgLyAyKSArICdweCc7XG4gICAgZG9tLmRvdC5zdHlsZS5sZWZ0ID0gKHRoaXMucHJvcHMuZG90LndpZHRoIC8gMikgKyAncHgnO1xuXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5fcmVwYWludERlbGV0ZUJ1dHRvbihkb20ucG9pbnQpO1xufTtcblxuLyoqXG4gKiBTaG93IHRoZSBpdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuIFRoZSBpdGVtcyBET00gd2lsbFxuICogYmUgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqL1xuUG9pbnRJdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9XG59O1xuXG4vKipcbiAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICBpZiAodGhpcy5kb20ucG9pbnQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20ucG9pbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5wb2ludCk7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIGhvcml6b250YWxseVxuICogQE92ZXJyaWRlXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5zdGFydCk7XG5cbiAgdGhpcy5sZWZ0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmRvdC53aWR0aDtcblxuICAvLyByZXBvc2l0aW9uIHBvaW50XG4gIHRoaXMuZG9tLnBvaW50LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAqIEBPdmVycmlkZVxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtO1xuICB2YXIgcG9pbnQgPSB0aGlzLmRvbS5wb2ludDtcblxuICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICBwb2ludC5zdHlsZS50b3AgPSB0aGlzLnRvcCArICdweCc7XG4gIH1cbiAgZWxzZSB7XG4gICAgcG9pbnQuc3R5bGUudG9wID0gKHRoaXMucGFyZW50LmhlaWdodCAtIHRoaXMudG9wIC0gdGhpcy5oZWlnaHQpICsgJ3B4JztcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIGxlZnQgZnJvbSBpdHMgc3RhcnQgZGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLmdldFdpZHRoTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuZG90LndpZHRoO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIHJpZ2h0IGZyb20gIGl0cyBzdGFydCBkYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGggLSB0aGlzLnByb3BzLmRvdC53aWR0aDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRJdGVtO1xuIl19
},{"./Item":41}],43:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var Item = require('./Item');

/**
 * @constructor RangeItem
 * @extends Item
 * @param {Object} data             Object containing parameters start, end
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe options
 */
function RangeItem(data, conversion, options) {
  this.props = {
    content: {
      width: 0
    }
  };
  this.overflow = false; // if contents can overflow (css styling), this flag is set to true

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data.id);
    }
    if (data.end == undefined) {
      throw new Error('Property "end" missing in item ' + data.id);
    }
  }

  Item.call(this, data, conversion, options);
}

RangeItem.prototype = new Item(null, null, null);

RangeItem.prototype.baseClassName = 'vis-item vis-range';

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
RangeItem.prototype.isVisible = function (range) {
  // determine visibility
  return this.data.start < range.end && this.data.end > range.start;
};

/**
 * Repaint the item
 */
RangeItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.box = document.createElement('div');
    // className is updated in redraw()

    // frame box (to prevent the item contents from overflowing
    dom.frame = document.createElement('div');
    dom.frame.className = 'vis-item-overflow';
    dom.box.appendChild(dom.frame);

    // contents box
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.frame.appendChild(dom.content);

    // attach this item as attribute
    dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) {
      throw new Error('Cannot redraw item: parent has no foreground container element');
    }
    foreground.appendChild(dom.box);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.box);
    this._updateDataAttributes(this.dom.box);
    this._updateStyle(this.dom.box);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.box.className = this.baseClassName + className;

    // determine from css whether this box has overflow
    this.overflow = window.getComputedStyle(dom.frame).overflow !== 'hidden';

    // recalculate size
    // turn off max-width to be able to calculate the real width
    // this causes an extra browser repaint/reflow, but so be it
    this.dom.content.style.maxWidth = 'none';
    this.props.content.width = this.dom.content.offsetWidth;
    this.height = this.dom.box.offsetHeight;
    this.dom.content.style.maxWidth = '';

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.box);
  this._repaintDragLeft();
  this._repaintDragRight();
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
RangeItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 * @return {Boolean} changed
 */
RangeItem.prototype.hide = function () {
  if (this.displayed) {
    var box = this.dom.box;

    if (box.parentNode) {
      box.parentNode.removeChild(box);
    }

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @param {boolean} [limitSize=true] If true (default), the width of the range
 *                                   item will be limited, as the browser cannot
 *                                   display very wide divs. This means though
 *                                   that the applied left and width may
 *                                   not correspond to the ranges start and end
 * @Override
 */
RangeItem.prototype.repositionX = function (limitSize) {
  var parentWidth = this.parent.width;
  var start = this.conversion.toScreen(this.data.start);
  var end = this.conversion.toScreen(this.data.end);
  var contentLeft;
  var contentWidth;

  // limit the width of the range, as browsers cannot draw very wide divs
  if (limitSize === undefined || limitSize === true) {
    if (start < -parentWidth) {
      start = -parentWidth;
    }
    if (end > 2 * parentWidth) {
      end = 2 * parentWidth;
    }
  }
  var boxWidth = Math.max(end - start, 1);

  if (this.overflow) {
    this.left = start;
    this.width = boxWidth + this.props.content.width;
    contentWidth = this.props.content.width;

    // Note: The calculation of width is an optimistic calculation, giving
    //       a width which will not change when moving the Timeline
    //       So no re-stacking needed, which is nicer for the eye;
  } else {
      this.left = start;
      this.width = boxWidth;
      contentWidth = Math.min(end - start, this.props.content.width);
    }

  this.dom.box.style.left = this.left + 'px';
  this.dom.box.style.width = boxWidth + 'px';

  switch (this.options.align) {
    case 'left':
      this.dom.content.style.left = '0';
      break;

    case 'right':
      this.dom.content.style.left = Math.max(boxWidth - contentWidth, 0) + 'px';
      break;

    case 'center':
      this.dom.content.style.left = Math.max((boxWidth - contentWidth) / 2, 0) + 'px';
      break;

    default:
      // 'auto'
      // when range exceeds left of the window, position the contents at the left of the visible area
      if (this.overflow) {
        if (end > 0) {
          contentLeft = Math.max(-start, 0);
        } else {
          contentLeft = -contentWidth; // ensure it's not visible anymore
        }
      } else {
          if (start < 0) {
            contentLeft = -start;
          } else {
            contentLeft = 0;
          }
        }
      this.dom.content.style.left = contentLeft + 'px';
  }
};

/**
 * Reposition the item vertically
 * @Override
 */
RangeItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var box = this.dom.box;

  if (orientation == 'top') {
    box.style.top = this.top + 'px';
  } else {
    box.style.top = this.parent.height - this.top - this.height + 'px';
  }
};

/**
 * Repaint a drag area on the left side of the range when the range is selected
 * @protected
 */
RangeItem.prototype._repaintDragLeft = function () {
  if (this.selected && this.options.editable.updateTime && !this.dom.dragLeft) {
    // create and show drag area
    var dragLeft = document.createElement('div');
    dragLeft.className = 'vis-drag-left';
    dragLeft.dragLeftItem = this;

    this.dom.box.appendChild(dragLeft);
    this.dom.dragLeft = dragLeft;
  } else if (!this.selected && this.dom.dragLeft) {
    // delete drag area
    if (this.dom.dragLeft.parentNode) {
      this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);
    }
    this.dom.dragLeft = null;
  }
};

/**
 * Repaint a drag area on the right side of the range when the range is selected
 * @protected
 */
RangeItem.prototype._repaintDragRight = function () {
  if (this.selected && this.options.editable.updateTime && !this.dom.dragRight) {
    // create and show drag area
    var dragRight = document.createElement('div');
    dragRight.className = 'vis-drag-right';
    dragRight.dragRightItem = this;

    this.dom.box.appendChild(dragRight);
    this.dom.dragRight = dragRight;
  } else if (!this.selected && this.dom.dragRight) {
    // delete drag area
    if (this.dom.dragRight.parentNode) {
      this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);
    }
    this.dom.dragRight = null;
  }
};

module.exports = RangeItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL1JhbmdlSXRlbS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQy9DLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7O0FBWTdCLFNBQVMsU0FBUyxDQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFO0FBQzdDLE1BQUksQ0FBQyxLQUFLLEdBQUc7QUFDWCxXQUFPLEVBQUU7QUFDUCxXQUFLLEVBQUUsQ0FBQztLQUNUO0dBQ0YsQ0FBQztBQUNGLE1BQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDOzs7QUFHdEIsTUFBSSxJQUFJLEVBQUU7QUFDUixRQUFJLElBQUksQ0FBQyxLQUFLLElBQUksU0FBUyxFQUFFO0FBQzNCLFlBQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ2hFO0FBQ0QsUUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLFNBQVMsRUFBRTtBQUN6QixZQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUM5RDtHQUNGOztBQUVELE1BQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7Q0FDNUM7O0FBRUQsU0FBUyxDQUFDLFNBQVMsR0FBRyxJQUFJLElBQUksQ0FBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDOztBQUVsRCxTQUFTLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxvQkFBb0IsQ0FBQzs7Ozs7OztBQU96RCxTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFTLEtBQUssRUFBRTs7QUFFOUMsU0FBTyxBQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLElBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssQUFBQyxDQUFDO0NBQ3ZFLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsWUFBVztBQUN0QyxNQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO0FBQ25CLE1BQUksQ0FBQyxHQUFHLEVBQUU7O0FBRVIsUUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDZCxPQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQzs7O0FBR2YsT0FBRyxDQUFDLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDOzs7O0FBSXhDLE9BQUcsQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxQyxPQUFHLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQztBQUMxQyxPQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7OztBQUcvQixPQUFHLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDNUMsT0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsa0JBQWtCLENBQUM7QUFDM0MsT0FBRyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDOzs7QUFHbkMsT0FBRyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsR0FBRyxJQUFJLENBQUM7O0FBRWhDLFFBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0dBQ25COzs7QUFHRCxNQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNoQixVQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7R0FDM0Q7QUFDRCxNQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUU7QUFDdkIsUUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDO0FBQzVDLFFBQUksQ0FBQyxVQUFVLEVBQUU7QUFDZixZQUFNLElBQUksS0FBSyxDQUFDLGdFQUFnRSxDQUFDLENBQUM7S0FDbkY7QUFDRCxjQUFVLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztHQUNqQztBQUNELE1BQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDOzs7Ozs7QUFNdEIsTUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ2QsUUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3ZDLFFBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNoQyxRQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN6QyxRQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7O0FBRWhDLFFBQUksUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsVUFBVSxJQUNoQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxXQUFXLElBQ2pDLElBQUksQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFBLElBQ3ZCLElBQUksQ0FBQyxRQUFRLEtBQUssS0FBSyxDQUFDOzs7QUFHdkMsUUFBSSxTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUksRUFBRSxDQUFBLElBQ2xFLElBQUksQ0FBQyxRQUFRLEdBQUcsZUFBZSxHQUFHLEVBQUUsQ0FBQSxBQUFDLElBQ3JDLFFBQVEsR0FBRyxlQUFlLEdBQUcsZUFBZSxDQUFBLEFBQUMsQ0FBQztBQUNuRCxPQUFHLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxHQUFHLFNBQVMsQ0FBQzs7O0FBR25ELFFBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDOzs7OztBQUt6RSxRQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQztBQUN6QyxRQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDO0FBQ3hELFFBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDO0FBQ3hDLFFBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDOztBQUVyQyxRQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztHQUNwQjs7QUFFRCxNQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ25DLE1BQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0FBQ3hCLE1BQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0NBQzFCLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFlBQVc7QUFDcEMsTUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7QUFDbkIsUUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0dBQ2Y7Q0FDRixDQUFDOzs7Ozs7QUFNRixTQUFTLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxZQUFXO0FBQ3BDLE1BQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtBQUNsQixRQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQzs7QUFFdkIsUUFBSSxHQUFHLENBQUMsVUFBVSxFQUFFO0FBQ2xCLFNBQUcsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ2pDOztBQUVELFFBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0dBQ3hCO0NBQ0YsQ0FBQzs7Ozs7Ozs7Ozs7QUFXRixTQUFTLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxVQUFTLFNBQVMsRUFBRTtBQUNwRCxNQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztBQUNwQyxNQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3RELE1BQUksR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbEQsTUFBSSxXQUFXLENBQUM7QUFDaEIsTUFBSSxZQUFZLENBQUM7OztBQUdqQixNQUFJLFNBQVMsS0FBSyxTQUFTLElBQUksU0FBUyxLQUFLLElBQUksRUFBRTtBQUNqRCxRQUFJLEtBQUssR0FBRyxDQUFDLFdBQVcsRUFBRTtBQUN4QixXQUFLLEdBQUcsQ0FBQyxXQUFXLENBQUM7S0FDdEI7QUFDRCxRQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsV0FBVyxFQUFFO0FBQ3pCLFNBQUcsR0FBRyxDQUFDLEdBQUcsV0FBVyxDQUFDO0tBQ3ZCO0dBQ0Y7QUFDRCxNQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7O0FBRXhDLE1BQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNqQixRQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztBQUNsQixRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7QUFDakQsZ0JBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7Ozs7O0dBS3pDLE1BQ0k7QUFDSCxVQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztBQUNsQixVQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQztBQUN0QixrQkFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUNoRTs7QUFFRCxNQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQzNDLE1BQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsUUFBUSxHQUFHLElBQUksQ0FBQzs7QUFFM0MsVUFBUSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUs7QUFDeEIsU0FBSyxNQUFNO0FBQ1QsVUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7QUFDbEMsWUFBTTs7QUFBQSxBQUVSLFNBQUssT0FBTztBQUNWLFVBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBRSxRQUFRLEdBQUcsWUFBWSxFQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztBQUM1RSxZQUFNOztBQUFBLEFBRVIsU0FBSyxRQUFRO0FBQ1gsVUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxHQUFHLFlBQVksQ0FBQSxHQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDaEYsWUFBTTs7QUFBQSxBQUVSOzs7QUFFRSxVQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7QUFDakIsWUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFO0FBQ1gscUJBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ25DLE1BQ0k7QUFDSCxxQkFBVyxHQUFHLENBQUMsWUFBWSxDQUFDO1NBQzdCO09BQ0YsTUFDSTtBQUNILGNBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtBQUNiLHVCQUFXLEdBQUcsQ0FBQyxLQUFLLENBQUM7V0FDdEIsTUFDSTtBQUNILHVCQUFXLEdBQUcsQ0FBQyxDQUFDO1dBQ2pCO1NBQ0Y7QUFDRCxVQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFBQSxHQUNwRDtDQUNGLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLFlBQVc7QUFDM0MsTUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO0FBQ2hELE1BQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDOztBQUV2QixNQUFJLFdBQVcsSUFBSSxLQUFLLEVBQUU7QUFDeEIsT0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7R0FDakMsTUFDSTtBQUNILE9BQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEFBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFJLElBQUksQ0FBQztHQUN0RTtDQUNGLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsWUFBWTtBQUNqRCxNQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUU7O0FBRTNFLFFBQUksUUFBUSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDN0MsWUFBUSxDQUFDLFNBQVMsR0FBRyxlQUFlLENBQUM7QUFDckMsWUFBUSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7O0FBRTdCLFFBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNuQyxRQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7R0FDOUIsTUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRTs7QUFFNUMsUUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUU7QUFDaEMsVUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQzdEO0FBQ0QsUUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO0dBQzFCO0NBQ0YsQ0FBQzs7Ozs7O0FBTUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsR0FBRyxZQUFZO0FBQ2xELE1BQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxVQUFVLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRTs7QUFFNUUsUUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM5QyxhQUFTLENBQUMsU0FBUyxHQUFHLGdCQUFnQixDQUFDO0FBQ3ZDLGFBQVMsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDOztBQUUvQixRQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDcEMsUUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0dBQ2hDLE1BQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUU7O0FBRTdDLFFBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFO0FBQ2pDLFVBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUMvRDtBQUNELFFBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztHQUMzQjtDQUNGLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMiLCJmaWxlIjoiL1VzZXJzL2VtaWx5YXNobGV5L1NUT1JZVE9PTFMvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vUmFuZ2VJdGVtLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciBJdGVtID0gcmVxdWlyZSgnLi9JdGVtJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIFJhbmdlSXRlbVxuICogQGV4dGVuZHMgSXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBzdGFydCwgZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmFuZ2VJdGVtIChkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgY29udGVudDoge1xuICAgICAgd2lkdGg6IDBcbiAgICB9XG4gIH07XG4gIHRoaXMub3ZlcmZsb3cgPSBmYWxzZTsgLy8gaWYgY29udGVudHMgY2FuIG92ZXJmbG93IChjc3Mgc3R5bGluZyksIHRoaXMgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuXG4gIC8vIHZhbGlkYXRlIGRhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgfVxuICAgIGlmIChkYXRhLmVuZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJlbmRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEuaWQpO1xuICAgIH1cbiAgfVxuXG4gIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbn1cblxuUmFuZ2VJdGVtLnByb3RvdHlwZSA9IG5ldyBJdGVtIChudWxsLCBudWxsLCBudWxsKTtcblxuUmFuZ2VJdGVtLnByb3RvdHlwZS5iYXNlQ2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1yYW5nZSc7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgLy8gZGV0ZXJtaW5lIHZpc2liaWxpdHlcbiAgcmV0dXJuICh0aGlzLmRhdGEuc3RhcnQgPCByYW5nZS5lbmQpICYmICh0aGlzLmRhdGEuZW5kID4gcmFuZ2Uuc3RhcnQpO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBpdGVtXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgaWYgKCFkb20pIHtcbiAgICAvLyBjcmVhdGUgRE9NXG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICBkb20gPSB0aGlzLmRvbTtcblxuICAgICAgLy8gYmFja2dyb3VuZCBib3hcbiAgICBkb20uYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gY2xhc3NOYW1lIGlzIHVwZGF0ZWQgaW4gcmVkcmF3KClcblxuICAgIC8vIGZyYW1lIGJveCAodG8gcHJldmVudCB0aGUgaXRlbSBjb250ZW50cyBmcm9tIG92ZXJmbG93aW5nXG4gICAgZG9tLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1vdmVyZmxvdyc7XG4gICAgZG9tLmJveC5hcHBlbmRDaGlsZChkb20uZnJhbWUpO1xuXG4gICAgLy8gY29udGVudHMgYm94XG4gICAgZG9tLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uY29udGVudC5jbGFzc05hbWUgPSAndmlzLWl0ZW0tY29udGVudCc7XG4gICAgZG9tLmZyYW1lLmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgIC8vIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlXG4gICAgZG9tLmJveFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogbm8gcGFyZW50IGF0dGFjaGVkJyk7XG4gIH1cbiAgaWYgKCFkb20uYm94LnBhcmVudE5vZGUpIHtcbiAgICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMucGFyZW50LmRvbS5mb3JlZ3JvdW5kO1xuICAgIGlmICghZm9yZWdyb3VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gZm9yZWdyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgIH1cbiAgICBmb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5ib3gpO1xuICB9XG4gIHRoaXMuZGlzcGxheWVkID0gdHJ1ZTtcblxuICAvLyBVcGRhdGUgRE9NIHdoZW4gaXRlbSBpcyBtYXJrZWQgZGlydHkuIEFuIGl0ZW0gaXMgbWFya2VkIGRpcnR5IHdoZW46XG4gIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAvLyAtIHRoZSBpdGVtJ3MgZGF0YSBpcyBjaGFuZ2VkXG4gIC8vIC0gdGhlIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICBpZiAodGhpcy5kaXJ0eSkge1xuICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnRzKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHRoaXMuZG9tLmJveCk7XG4gICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20uYm94KTtcbiAgICB0aGlzLl91cGRhdGVTdHlsZSh0aGlzLmRvbS5ib3gpO1xuXG4gICAgdmFyIGVkaXRhYmxlID0gKHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lIHx8IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRhYmxlICE9PSBmYWxzZTtcblxuICAgIC8vIHVwZGF0ZSBjbGFzc1xuICAgIHZhciBjbGFzc05hbWUgPSAodGhpcy5kYXRhLmNsYXNzTmFtZSA/ICgnICcgKyB0aGlzLmRhdGEuY2xhc3NOYW1lKSA6ICcnKSArXG4gICAgICAgICh0aGlzLnNlbGVjdGVkID8gJyB2aXMtc2VsZWN0ZWQnIDogJycpICsgXG4gICAgICAgIChlZGl0YWJsZSA/ICcgdmlzLWVkaXRhYmxlJyA6ICcgdmlzLXJlYWRvbmx5Jyk7XG4gICAgZG9tLmJveC5jbGFzc05hbWUgPSB0aGlzLmJhc2VDbGFzc05hbWUgKyBjbGFzc05hbWU7XG5cbiAgICAvLyBkZXRlcm1pbmUgZnJvbSBjc3Mgd2hldGhlciB0aGlzIGJveCBoYXMgb3ZlcmZsb3dcbiAgICB0aGlzLm92ZXJmbG93ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tLmZyYW1lKS5vdmVyZmxvdyAhPT0gJ2hpZGRlbic7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBzaXplXG4gICAgLy8gdHVybiBvZmYgbWF4LXdpZHRoIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHRoZSByZWFsIHdpZHRoXG4gICAgLy8gdGhpcyBjYXVzZXMgYW4gZXh0cmEgYnJvd3NlciByZXBhaW50L3JlZmxvdywgYnV0IHNvIGJlIGl0XG4gICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5tYXhXaWR0aCA9ICdub25lJztcbiAgICB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGggPSB0aGlzLmRvbS5jb250ZW50Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5kb20uYm94Lm9mZnNldEhlaWdodDtcbiAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLm1heFdpZHRoID0gJyc7XG5cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cblxuICB0aGlzLl9yZXBhaW50RGVsZXRlQnV0dG9uKGRvbS5ib3gpO1xuICB0aGlzLl9yZXBhaW50RHJhZ0xlZnQoKTtcbiAgdGhpcy5fcmVwYWludERyYWdSaWdodCgpO1xufTtcblxuLyoqXG4gKiBTaG93IHRoZSBpdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuIFRoZSBpdGVtcyBET00gd2lsbFxuICogYmUgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9XG59O1xuXG4vKipcbiAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB2YXIgYm94ID0gdGhpcy5kb20uYm94O1xuXG4gICAgaWYgKGJveC5wYXJlbnROb2RlKSB7XG4gICAgICBib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib3gpO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGxheWVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xpbWl0U2l6ZT10cnVlXSBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHdpZHRoIG9mIHRoZSByYW5nZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gd2lsbCBiZSBsaW1pdGVkLCBhcyB0aGUgYnJvd3NlciBjYW5ub3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5IHZlcnkgd2lkZSBkaXZzLiBUaGlzIG1lYW5zIHRob3VnaFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgdGhlIGFwcGxpZWQgbGVmdCBhbmQgd2lkdGggbWF5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvcnJlc3BvbmQgdG8gdGhlIHJhbmdlcyBzdGFydCBhbmQgZW5kXG4gKiBAT3ZlcnJpZGVcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWCA9IGZ1bmN0aW9uKGxpbWl0U2l6ZSkge1xuICB2YXIgcGFyZW50V2lkdGggPSB0aGlzLnBhcmVudC53aWR0aDtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5zdGFydCk7XG4gIHZhciBlbmQgPSB0aGlzLmNvbnZlcnNpb24udG9TY3JlZW4odGhpcy5kYXRhLmVuZCk7XG4gIHZhciBjb250ZW50TGVmdDtcbiAgdmFyIGNvbnRlbnRXaWR0aDtcblxuICAvLyBsaW1pdCB0aGUgd2lkdGggb2YgdGhlIHJhbmdlLCBhcyBicm93c2VycyBjYW5ub3QgZHJhdyB2ZXJ5IHdpZGUgZGl2c1xuICBpZiAobGltaXRTaXplID09PSB1bmRlZmluZWQgfHwgbGltaXRTaXplID09PSB0cnVlKSB7XG4gICAgaWYgKHN0YXJ0IDwgLXBhcmVudFdpZHRoKSB7XG4gICAgICBzdGFydCA9IC1wYXJlbnRXaWR0aDtcbiAgICB9XG4gICAgaWYgKGVuZCA+IDIgKiBwYXJlbnRXaWR0aCkge1xuICAgICAgZW5kID0gMiAqIHBhcmVudFdpZHRoO1xuICAgIH1cbiAgfVxuICB2YXIgYm94V2lkdGggPSBNYXRoLm1heChlbmQgLSBzdGFydCwgMSk7XG5cbiAgaWYgKHRoaXMub3ZlcmZsb3cpIHtcbiAgICB0aGlzLmxlZnQgPSBzdGFydDtcbiAgICB0aGlzLndpZHRoID0gYm94V2lkdGggKyB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGg7XG4gICAgY29udGVudFdpZHRoID0gdGhpcy5wcm9wcy5jb250ZW50LndpZHRoO1xuXG4gICAgLy8gTm90ZTogVGhlIGNhbGN1bGF0aW9uIG9mIHdpZHRoIGlzIGFuIG9wdGltaXN0aWMgY2FsY3VsYXRpb24sIGdpdmluZ1xuICAgIC8vICAgICAgIGEgd2lkdGggd2hpY2ggd2lsbCBub3QgY2hhbmdlIHdoZW4gbW92aW5nIHRoZSBUaW1lbGluZVxuICAgIC8vICAgICAgIFNvIG5vIHJlLXN0YWNraW5nIG5lZWRlZCwgd2hpY2ggaXMgbmljZXIgZm9yIHRoZSBleWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5sZWZ0ID0gc3RhcnQ7XG4gICAgdGhpcy53aWR0aCA9IGJveFdpZHRoO1xuICAgIGNvbnRlbnRXaWR0aCA9IE1hdGgubWluKGVuZCAtIHN0YXJ0LCB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGgpO1xuICB9XG5cbiAgdGhpcy5kb20uYm94LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xuICB0aGlzLmRvbS5ib3guc3R5bGUud2lkdGggPSBib3hXaWR0aCArICdweCc7XG5cbiAgc3dpdGNoICh0aGlzLm9wdGlvbnMuYWxpZ24pIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gTWF0aC5tYXgoKGJveFdpZHRoIC0gY29udGVudFdpZHRoKSwgMCkgKyAncHgnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gTWF0aC5tYXgoKGJveFdpZHRoIC0gY29udGVudFdpZHRoKSAvIDIsIDApICsgJ3B4JztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDogLy8gJ2F1dG8nXG4gICAgICAvLyB3aGVuIHJhbmdlIGV4Y2VlZHMgbGVmdCBvZiB0aGUgd2luZG93LCBwb3NpdGlvbiB0aGUgY29udGVudHMgYXQgdGhlIGxlZnQgb2YgdGhlIHZpc2libGUgYXJlYVxuICAgICAgaWYgKHRoaXMub3ZlcmZsb3cpIHtcbiAgICAgICAgaWYgKGVuZCA+IDApIHtcbiAgICAgICAgICBjb250ZW50TGVmdCA9IE1hdGgubWF4KC1zdGFydCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGVudExlZnQgPSAtY29udGVudFdpZHRoOyAvLyBlbnN1cmUgaXQncyBub3QgdmlzaWJsZSBhbnltb3JlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgY29udGVudExlZnQgPSAtc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGVudExlZnQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmxlZnQgPSBjb250ZW50TGVmdCArICdweCc7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSB2ZXJ0aWNhbGx5XG4gKiBAT3ZlcnJpZGVcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgdmFyIGJveCA9IHRoaXMuZG9tLmJveDtcblxuICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICBib3guc3R5bGUudG9wID0gdGhpcy50b3AgKyAncHgnO1xuICB9XG4gIGVsc2Uge1xuICAgIGJveC5zdHlsZS50b3AgPSAodGhpcy5wYXJlbnQuaGVpZ2h0IC0gdGhpcy50b3AgLSB0aGlzLmhlaWdodCkgKyAncHgnO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgYSBkcmFnIGFyZWEgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgcmFuZ2Ugd2hlbiB0aGUgcmFuZ2UgaXMgc2VsZWN0ZWRcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5fcmVwYWludERyYWdMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zZWxlY3RlZCAmJiB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSAmJiAhdGhpcy5kb20uZHJhZ0xlZnQpIHtcbiAgICAvLyBjcmVhdGUgYW5kIHNob3cgZHJhZyBhcmVhXG4gICAgdmFyIGRyYWdMZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZHJhZ0xlZnQuY2xhc3NOYW1lID0gJ3Zpcy1kcmFnLWxlZnQnO1xuICAgIGRyYWdMZWZ0LmRyYWdMZWZ0SXRlbSA9IHRoaXM7XG5cbiAgICB0aGlzLmRvbS5ib3guYXBwZW5kQ2hpbGQoZHJhZ0xlZnQpO1xuICAgIHRoaXMuZG9tLmRyYWdMZWZ0ID0gZHJhZ0xlZnQ7XG4gIH1cbiAgZWxzZSBpZiAoIXRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5kb20uZHJhZ0xlZnQpIHtcbiAgICAvLyBkZWxldGUgZHJhZyBhcmVhXG4gICAgaWYgKHRoaXMuZG9tLmRyYWdMZWZ0LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmRyYWdMZWZ0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZHJhZ0xlZnQpO1xuICAgIH1cbiAgICB0aGlzLmRvbS5kcmFnTGVmdCA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwYWludCBhIGRyYWcgYXJlYSBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgcmFuZ2Ugd2hlbiB0aGUgcmFuZ2UgaXMgc2VsZWN0ZWRcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5fcmVwYWludERyYWdSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgJiYgIXRoaXMuZG9tLmRyYWdSaWdodCkge1xuICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyBkcmFnIGFyZWFcbiAgICB2YXIgZHJhZ1JpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZHJhZ1JpZ2h0LmNsYXNzTmFtZSA9ICd2aXMtZHJhZy1yaWdodCc7XG4gICAgZHJhZ1JpZ2h0LmRyYWdSaWdodEl0ZW0gPSB0aGlzO1xuXG4gICAgdGhpcy5kb20uYm94LmFwcGVuZENoaWxkKGRyYWdSaWdodCk7XG4gICAgdGhpcy5kb20uZHJhZ1JpZ2h0ID0gZHJhZ1JpZ2h0O1xuICB9XG4gIGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLmRyYWdSaWdodCkge1xuICAgIC8vIGRlbGV0ZSBkcmFnIGFyZWFcbiAgICBpZiAodGhpcy5kb20uZHJhZ1JpZ2h0LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmRyYWdSaWdodC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmRyYWdSaWdodCk7XG4gICAgfVxuICAgIHRoaXMuZG9tLmRyYWdSaWdodCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VJdGVtO1xuIl19
},{"../../../module/hammer":19,"./Item":41}],44:[function(require,module,exports){
// English
'use strict';

exports['en'] = {
  current: 'current',
  time: 'time'
};
exports['en_EN'] = exports['en'];
exports['en_US'] = exports['en'];

// Dutch
exports['nl'] = {
  current: 'huidige',
  time: 'tijd'
};
exports['nl_NL'] = exports['nl'];
exports['nl_BE'] = exports['nl'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2xvY2FsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHO0FBQ2QsU0FBTyxFQUFFLFNBQVM7QUFDbEIsTUFBSSxFQUFFLE1BQU07Q0FDYixDQUFDO0FBQ0YsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDOzs7QUFHakMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHO0FBQ2QsU0FBTyxFQUFFLFNBQVM7QUFDbEIsTUFBSSxFQUFFLE1BQU07Q0FDYixDQUFDO0FBQ0YsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2xvY2FsZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbmdsaXNoXG5leHBvcnRzWydlbiddID0ge1xuICBjdXJyZW50OiAnY3VycmVudCcsXG4gIHRpbWU6ICd0aW1lJ1xufTtcbmV4cG9ydHNbJ2VuX0VOJ10gPSBleHBvcnRzWydlbiddO1xuZXhwb3J0c1snZW5fVVMnXSA9IGV4cG9ydHNbJ2VuJ107XG5cbi8vIER1dGNoXG5leHBvcnRzWydubCddID0ge1xuICBjdXJyZW50OiAnaHVpZGlnZScsXG4gIHRpbWU6ICd0aWpkJ1xufTtcbmV4cG9ydHNbJ25sX05MJ10gPSBleHBvcnRzWydubCddO1xuZXhwb3J0c1snbmxfQkUnXSA9IGV4cG9ydHNbJ25sJ107XG4iXX0=
},{}],45:[function(require,module,exports){
/**
 * This object contains all possible options. It will check if the types are correct, if required if the option is one
 * of the allowed values.
 *
 * __any__ means that the name of the property does not matter.
 * __type__ is a required field for all objects and contains the allowed types of all objects
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var string = 'string';
var boolean = 'boolean';
var number = 'number';
var array = 'array';
var date = 'date';
var object = 'object'; // should only be in a __type__ property
var dom = 'dom';
var moment = 'moment';
var any = 'any';

var allOptions = {
  configure: {
    enabled: { boolean: boolean },
    filter: { boolean: boolean, 'function': 'function' },
    container: { dom: dom },
    __type__: { object: object, boolean: boolean, 'function': 'function' }
  },

  //globals :
  align: { string: string },
  autoResize: { boolean: boolean },
  throttleRedraw: { number: number },
  clickToUse: { boolean: boolean },
  dataAttributes: { string: string, array: array },
  editable: {
    add: { boolean: boolean, 'undefined': 'undefined' },
    remove: { boolean: boolean, 'undefined': 'undefined' },
    updateGroup: { boolean: boolean, 'undefined': 'undefined' },
    updateTime: { boolean: boolean, 'undefined': 'undefined' },
    __type__: { boolean: boolean, object: object }
  },
  end: { number: number, date: date, string: string, moment: moment },
  format: {
    minorLabels: {
      millisecond: { string: string, 'undefined': 'undefined' },
      second: { string: string, 'undefined': 'undefined' },
      minute: { string: string, 'undefined': 'undefined' },
      hour: { string: string, 'undefined': 'undefined' },
      weekday: { string: string, 'undefined': 'undefined' },
      day: { string: string, 'undefined': 'undefined' },
      month: { string: string, 'undefined': 'undefined' },
      year: { string: string, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    majorLabels: {
      millisecond: { string: string, 'undefined': 'undefined' },
      second: { string: string, 'undefined': 'undefined' },
      minute: { string: string, 'undefined': 'undefined' },
      hour: { string: string, 'undefined': 'undefined' },
      weekday: { string: string, 'undefined': 'undefined' },
      day: { string: string, 'undefined': 'undefined' },
      month: { string: string, 'undefined': 'undefined' },
      year: { string: string, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    __type__: { object: object }
  },
  moment: { 'function': 'function' },
  groupOrder: { string: string, 'function': 'function' },
  groupEditable: {
    add: { boolean: boolean, 'undefined': 'undefined' },
    remove: { boolean: boolean, 'undefined': 'undefined' },
    order: { boolean: boolean, 'undefined': 'undefined' },
    __type__: { boolean: boolean, object: object }
  },
  groupOrderSwap: { 'function': 'function' },
  height: { string: string, number: number },
  hiddenDates: {
    start: { date: date, number: number, string: string, moment: moment },
    end: { date: date, number: number, string: string, moment: moment },
    repeat: { string: string },
    __type__: { object: object, array: array }
  },
  locale: { string: string },
  locales: {
    __type__: { object: object }
  },
  margin: {
    axis: { number: number },
    item: {
      horizontal: { number: number, 'undefined': 'undefined' },
      vertical: { number: number, 'undefined': 'undefined' },
      __type__: { object: object, number: number }
    },
    __type__: { object: object, number: number }
  },
  max: { date: date, number: number, string: string, moment: moment },
  maxHeight: { number: number, string: string },
  min: { date: date, number: number, string: string, moment: moment },
  minHeight: { number: number, string: string },
  moveable: { boolean: boolean },
  multiselect: { boolean: boolean },
  onAdd: { 'function': 'function' },
  onUpdate: { 'function': 'function' },
  onMove: { 'function': 'function' },
  onMoving: { 'function': 'function' },
  onRemove: { 'function': 'function' },
  onAddGroup: { 'function': 'function' },
  onMoveGroup: { 'function': 'function' },
  onRemoveGroup: { 'function': 'function' },
  order: { 'function': 'function' },
  orientation: {
    axis: { string: string, 'undefined': 'undefined' },
    item: { string: string, 'undefined': 'undefined' },
    __type__: { string: string, object: object }
  },
  selectable: { boolean: boolean },
  showCurrentTime: { boolean: boolean },
  showMajorLabels: { boolean: boolean },
  showMinorLabels: { boolean: boolean },
  stack: { boolean: boolean },
  snap: { 'function': 'function', 'null': 'null' },
  start: { date: date, number: number, string: string, moment: moment },
  template: { 'function': 'function' },
  groupTemplate: { 'function': 'function' },
  timeAxis: {
    scale: { string: string, 'undefined': 'undefined' },
    step: { number: number, 'undefined': 'undefined' },
    __type__: { object: object }
  },
  type: { string: string },
  width: { string: string, number: number },
  zoomable: { boolean: boolean },
  zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
  zoomMax: { number: number },
  zoomMin: { number: number },

  __type__: { object: object }
};

var configureOptions = {
  global: {
    align: ['center', 'left', 'right'],
    autoResize: true,
    throttleRedraw: [10, 0, 1000, 10],
    clickToUse: false,
    // dataAttributes: ['all'], // FIXME: can be 'all' or string[]
    editable: {
      add: false,
      remove: false,
      updateGroup: false,
      updateTime: false
    },
    end: '',
    format: {
      minorLabels: {
        millisecond: 'SSS',
        second: 's',
        minute: 'HH:mm',
        hour: 'HH:mm',
        weekday: 'ddd D',
        day: 'D',
        month: 'MMM',
        year: 'YYYY'
      },
      majorLabels: {
        millisecond: 'HH:mm:ss',
        second: 'D MMMM HH:mm',
        minute: 'ddd D MMMM',
        hour: 'ddd D MMMM',
        weekday: 'MMMM YYYY',
        day: 'MMMM YYYY',
        month: 'YYYY',
        year: ''
      }
    },

    //groupOrder: {string, 'function': 'function'},
    groupsDraggable: false,
    height: '',
    //hiddenDates: {object, array},
    locale: '',
    margin: {
      axis: [20, 0, 100, 1],
      item: {
        horizontal: [10, 0, 100, 1],
        vertical: [10, 0, 100, 1]
      }
    },
    max: '',
    maxHeight: '',
    min: '',
    minHeight: '',
    moveable: false,
    multiselect: false,
    //onAdd: {'function': 'function'},
    //onUpdate: {'function': 'function'},
    //onMove: {'function': 'function'},
    //onMoving: {'function': 'function'},
    //onRename: {'function': 'function'},
    //order: {'function': 'function'},
    orientation: {
      axis: ['both', 'bottom', 'top'],
      item: ['bottom', 'top']
    },
    selectable: true,
    showCurrentTime: false,
    showMajorLabels: true,
    showMinorLabels: true,
    stack: true,
    //snap: {'function': 'function', nada},
    start: '',
    //template: {'function': 'function'},
    //timeAxis: {
    //  scale: ['millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'],
    //  step: [1, 1, 10, 1]
    //},
    type: ['box', 'point', 'range', 'background'],
    width: '100%',
    zoomable: true,
    zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
    zoomMax: [315360000000000, 10, 315360000000000, 1],
    zoomMin: [10, 10, 315360000000000, 1]
  }
};

exports.allOptions = allOptions;
exports.configureOptions = configureOptions;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL29wdGlvbnNUaW1lbGluZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFPQSxJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFDdEIsSUFBSSxPQUFPLEdBQUcsU0FBUyxDQUFDO0FBQ3hCLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQztBQUN0QixJQUFJLEtBQUssR0FBRyxPQUFPLENBQUM7QUFDcEIsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDO0FBQ2xCLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQztBQUN0QixJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUM7QUFDaEIsSUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDO0FBQ3RCLElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQzs7QUFHaEIsSUFBSSxVQUFVLEdBQUc7QUFDZixXQUFTLEVBQUU7QUFDVCxXQUFPLEVBQUUsRUFBQyxPQUFPLEVBQVAsT0FBTyxFQUFDO0FBQ2xCLFVBQU0sRUFBRSxFQUFDLE9BQU8sRUFBUCxPQUFPLEVBQUMsVUFBVSxFQUFFLFVBQVUsRUFBQztBQUN4QyxhQUFTLEVBQUUsRUFBQyxHQUFHLEVBQUgsR0FBRyxFQUFDO0FBQ2hCLFlBQVEsRUFBRSxFQUFDLE1BQU0sRUFBTixNQUFNLEVBQUMsT0FBTyxFQUFQLE9BQU8sRUFBQyxVQUFVLEVBQUUsVUFBVSxFQUFDO0dBQ2xEOzs7QUFHRCxPQUFLLEVBQUUsRUFBQyxNQUFNLEVBQU4sTUFBTSxFQUFDO0FBQ2YsWUFBVSxFQUFFLEVBQUMsT0FBTyxFQUFQLE9BQU8sRUFBQztBQUNyQixnQkFBYyxFQUFFLEVBQUMsTUFBTSxFQUFOLE1BQU0sRUFBQztBQUN4QixZQUFVLEVBQUUsRUFBQyxPQUFPLEVBQVAsT0FBTyxFQUFDO0FBQ3JCLGdCQUFjLEVBQUUsRUFBQyxNQUFNLEVBQU4sTUFBTSxF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U0FBUyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsRUFBRSxDQUFDO0FBQzdDLFdBQU8sRUFBRSxDQUFDLGVBQWUsRUFBRSxFQUFFLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQztBQUNsRCxXQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUM7R0FDdEM7Q0FDRixDQUFDOztRQUVNLFVBQVUsR0FBVixVQUFVO1FBQUUsZ0JBQWdCLEdBQWhCLGdCQUFnQiIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9vcHRpb25zVGltZWxpbmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGFsbCBwb3NzaWJsZSBvcHRpb25zLiBJdCB3aWxsIGNoZWNrIGlmIHRoZSB0eXBlcyBhcmUgY29ycmVjdCwgaWYgcmVxdWlyZWQgaWYgdGhlIG9wdGlvbiBpcyBvbmVcbiAqIG9mIHRoZSBhbGxvd2VkIHZhbHVlcy5cbiAqXG4gKiBfX2FueV9fIG1lYW5zIHRoYXQgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGRvZXMgbm90IG1hdHRlci5cbiAqIF9fdHlwZV9fIGlzIGEgcmVxdWlyZWQgZmllbGQgZm9yIGFsbCBvYmplY3RzIGFuZCBjb250YWlucyB0aGUgYWxsb3dlZCB0eXBlcyBvZiBhbGwgb2JqZWN0c1xuICovXG5sZXQgc3RyaW5nID0gJ3N0cmluZyc7XG5sZXQgYm9vbGVhbiA9ICdib29sZWFuJztcbmxldCBudW1iZXIgPSAnbnVtYmVyJztcbmxldCBhcnJheSA9ICdhcnJheSc7XG5sZXQgZGF0ZSA9ICdkYXRlJztcbmxldCBvYmplY3QgPSAnb2JqZWN0JzsgLy8gc2hvdWxkIG9ubHkgYmUgaW4gYSBfX3R5cGVfXyBwcm9wZXJ0eVxubGV0IGRvbSA9ICdkb20nO1xubGV0IG1vbWVudCA9ICdtb21lbnQnO1xubGV0IGFueSA9ICdhbnknO1xuXG5cbmxldCBhbGxPcHRpb25zID0ge1xuICBjb25maWd1cmU6IHtcbiAgICBlbmFibGVkOiB7Ym9vbGVhbn0sXG4gICAgZmlsdGVyOiB7Ym9vbGVhbiwnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICBjb250YWluZXI6IHtkb219LFxuICAgIF9fdHlwZV9fOiB7b2JqZWN0LGJvb2xlYW4sJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ31cbiAgfSxcblxuICAvL2dsb2JhbHMgOlxuICBhbGlnbjoge3N0cmluZ30sXG4gIGF1dG9SZXNpemU6IHtib29sZWFufSxcbiAgdGhyb3R0bGVSZWRyYXc6IHtudW1iZXJ9LFxuICBjbGlja1RvVXNlOiB7Ym9vbGVhbn0sXG4gIGRhdGFBdHRyaWJ1dGVzOiB7c3RyaW5nLCBhcnJheX0sXG4gIGVkaXRhYmxlOiB7XG4gICAgYWRkOiB7Ym9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICByZW1vdmU6IHtib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgIHVwZGF0ZUdyb3VwOiB7Ym9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICB1cGRhdGVUaW1lOiB7Ym9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICBfX3R5cGVfXzoge2Jvb2xlYW4sIG9iamVjdH1cbiAgfSxcbiAgZW5kOiB7bnVtYmVyLCBkYXRlLCBzdHJpbmcsIG1vbWVudH0sXG4gIGZvcm1hdDoge1xuICAgIG1pbm9yTGFiZWxzOiB7XG4gICAgICBtaWxsaXNlY29uZDoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgc2Vjb25kOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBtaW51dGU6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIGhvdXI6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIHdlZWtkYXk6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIGRheToge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgbW9udGg6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIHllYXI6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIF9fdHlwZV9fOiB7b2JqZWN0fVxuICAgIH0sXG4gICAgbWFqb3JMYWJlbHM6IHtcbiAgICAgIG1pbGxpc2Vjb25kOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBzZWNvbmQ6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIG1pbnV0ZToge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgaG91cjoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgd2Vla2RheToge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgZGF5OiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBtb250aDoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgeWVhcjoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgX190eXBlX186IHtvYmplY3R9XG4gICAgfSxcbiAgICBfX3R5cGVfXzoge29iamVjdH1cbiAgfSxcbiAgbW9tZW50OiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIGdyb3VwT3JkZXI6IHtzdHJpbmcsICdmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBncm91cEVkaXRhYmxlOiB7XG5cdCBhZGQ6IHtib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuXHQgcmVtb3ZlOiB7Ym9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcblx0IG9yZGVyOiB7Ym9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcblx0IF9fdHlwZV9fOiB7Ym9vbGVhbiwgb2JqZWN0fVxuICB9LFxuICBncm91cE9yZGVyU3dhcDogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBoZWlnaHQ6IHtzdHJpbmcsIG51bWJlcn0sXG4gIGhpZGRlbkRhdGVzOiB7XG4gICAgc3RhcnQ6IHtkYXRlLCBudW1iZXIsIHN0cmluZywgbW9tZW50fSxcbiAgICBlbmQ6IHtkYXRlLCBudW1iZXIsIHN0cmluZywgbW9tZW50fSxcbiAgICByZXBlYXQ6IHtzdHJpbmd9LFxuICAgIF9fdHlwZV9fOiB7b2JqZWN0LCBhcnJheX1cbiAgfSxcbiAgbG9jYWxlOntzdHJpbmd9LFxuICBsb2NhbGVzOntcbiAgICBfX3R5cGVfXzoge29iamVjdH1cbiAgfSxcbiAgbWFyZ2luOiB7XG4gICAgYXhpczoge251bWJlcn0sXG4gICAgaXRlbToge1xuICAgICAgaG9yaXpvbnRhbDoge251bWJlciwndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgdmVydGljYWw6IHtudW1iZXIsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIF9fdHlwZV9fOiB7b2JqZWN0LG51bWJlcn1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7b2JqZWN0LG51bWJlcn1cbiAgfSxcbiAgbWF4OiB7ZGF0ZSwgbnVtYmVyLCBzdHJpbmcsIG1vbWVudH0sXG4gIG1heEhlaWdodDoge251bWJlciwgc3RyaW5nfSxcbiAgbWluOiB7ZGF0ZSwgbnVtYmVyLCBzdHJpbmcsIG1vbWVudH0sXG4gIG1pbkhlaWdodDoge251bWJlciwgc3RyaW5nfSxcbiAgbW92ZWFibGU6IHtib29sZWFufSxcbiAgbXVsdGlzZWxlY3Q6IHtib29sZWFufSxcbiAgb25BZGQ6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgb25VcGRhdGU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgb25Nb3ZlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9uTW92aW5nOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9uUmVtb3ZlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9uQWRkR3JvdXA6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgb25Nb3ZlR3JvdXA6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgb25SZW1vdmVHcm91cDogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvcmRlcjogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvcmllbnRhdGlvbjoge1xuICAgIGF4aXM6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICBpdGVtOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgX190eXBlX186IHtzdHJpbmcsIG9iamVjdH1cbiAgfSxcbiAgc2VsZWN0YWJsZToge2Jvb2xlYW59LFxuICBzaG93Q3VycmVudFRpbWU6IHtib29sZWFufSxcbiAgc2hvd01ham9yTGFiZWxzOiB7Ym9vbGVhbn0sXG4gIHNob3dNaW5vckxhYmVsczoge2Jvb2xlYW59LFxuICBzdGFjazoge2Jvb2xlYW59LFxuICBzbmFwOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJywgJ251bGwnOiAnbnVsbCd9LFxuICBzdGFydDoge2RhdGUsIG51bWJlciwgc3RyaW5nLCBtb21lbnR9LFxuICB0ZW1wbGF0ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBncm91cFRlbXBsYXRlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIHRpbWVBeGlzOiB7XG4gICAgc2NhbGU6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICBzdGVwOiB7bnVtYmVyLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgX190eXBlX186IHtvYmplY3R9XG4gIH0sXG4gIHR5cGU6IHtzdHJpbmd9LFxuICB3aWR0aDoge3N0cmluZywgbnVtYmVyfSxcbiAgem9vbWFibGU6IHtib29sZWFufSxcbiAgem9vbUtleToge3N0cmluZzogWydjdHJsS2V5JywgJ2FsdEtleScsICdtZXRhS2V5JywgJyddfSxcbiAgem9vbU1heDoge251bWJlcn0sXG4gIHpvb21NaW46IHtudW1iZXJ9LFxuXG4gIF9fdHlwZV9fOiB7b2JqZWN0fVxufTtcblxubGV0IGNvbmZpZ3VyZU9wdGlvbnMgPSB7XG4gIGdsb2JhbDoge1xuICAgIGFsaWduOiAgWydjZW50ZXInLCAnbGVmdCcsICdyaWdodCddLFxuICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgdGhyb3R0bGVSZWRyYXc6IFsxMCwgMCwgMTAwMCwgMTBdLFxuICAgIGNsaWNrVG9Vc2U6IGZhbHNlLFxuICAgIC8vIGRhdGFBdHRyaWJ1dGVzOiBbJ2FsbCddLCAvLyBGSVhNRTogY2FuIGJlICdhbGwnIG9yIHN0cmluZ1tdXG4gICAgZWRpdGFibGU6IHtcbiAgICAgIGFkZDogZmFsc2UsXG4gICAgICByZW1vdmU6IGZhbHNlLFxuICAgICAgdXBkYXRlR3JvdXA6IGZhbHNlLFxuICAgICAgdXBkYXRlVGltZTogZmFsc2VcbiAgICB9LFxuICAgIGVuZDogJycsXG4gICAgZm9ybWF0OiB7XG4gICAgICBtaW5vckxhYmVsczoge1xuICAgICAgICBtaWxsaXNlY29uZDonU1NTJyxcbiAgICAgICAgc2Vjb25kOiAgICAgJ3MnLFxuICAgICAgICBtaW51dGU6ICAgICAnSEg6bW0nLFxuICAgICAgICBob3VyOiAgICAgICAnSEg6bW0nLFxuICAgICAgICB3ZWVrZGF5OiAgICAnZGRkIEQnLFxuICAgICAgICBkYXk6ICAgICAgICAnRCcsXG4gICAgICAgIG1vbnRoOiAgICAgICdNTU0nLFxuICAgICAgICB5ZWFyOiAgICAgICAnWVlZWSdcbiAgICAgIH0sXG4gICAgICBtYWpvckxhYmVsczoge1xuICAgICAgICBtaWxsaXNlY29uZDonSEg6bW06c3MnLFxuICAgICAgICBzZWNvbmQ6ICAgICAnRCBNTU1NIEhIOm1tJyxcbiAgICAgICAgbWludXRlOiAgICAgJ2RkZCBEIE1NTU0nLFxuICAgICAgICBob3VyOiAgICAgICAnZGRkIEQgTU1NTScsXG4gICAgICAgIHdlZWtkYXk6ICAgICdNTU1NIFlZWVknLFxuICAgICAgICBkYXk6ICAgICAgICAnTU1NTSBZWVlZJyxcbiAgICAgICAgbW9udGg6ICAgICAgJ1lZWVknLFxuICAgICAgICB5ZWFyOiAgICAgICAnJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvL2dyb3VwT3JkZXI6IHtzdHJpbmcsICdmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgIGdyb3Vwc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgaGVpZ2h0OiAnJyxcbiAgICAvL2hpZGRlbkRhdGVzOiB7b2JqZWN0LCBhcnJheX0sXG4gICAgbG9jYWxlOiAnJyxcbiAgICBtYXJnaW46IHtcbiAgICAgIGF4aXM6IFsyMCwgMCwgMTAwLCAxXSxcbiAgICAgIGl0ZW06IHtcbiAgICAgICAgaG9yaXpvbnRhbDogWzEwLCAwLCAxMDAsIDFdLFxuICAgICAgICB2ZXJ0aWNhbDogWzEwLCAwLCAxMDAsIDFdXG4gICAgICB9XG4gICAgfSxcbiAgICBtYXg6ICcnLFxuICAgIG1heEhlaWdodDogJycsXG4gICAgbWluOiAnJyxcbiAgICBtaW5IZWlnaHQ6ICcnLFxuICAgIG1vdmVhYmxlOiBmYWxzZSxcbiAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG4gICAgLy9vbkFkZDogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgIC8vb25VcGRhdGU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAvL29uTW92ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgIC8vb25Nb3Zpbmc6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAvL29uUmVuYW1lOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgLy9vcmRlcjogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICBheGlzOiBbJ2JvdGgnLCAnYm90dG9tJywgJ3RvcCddLFxuICAgICAgaXRlbTogWydib3R0b20nLCAndG9wJ11cbiAgICB9LFxuICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgc2hvd0N1cnJlbnRUaW1lOiBmYWxzZSxcbiAgICBzaG93TWFqb3JMYWJlbHM6IHRydWUsXG4gICAgc2hvd01pbm9yTGFiZWxzOiB0cnVlLFxuICAgIHN0YWNrOiB0cnVlLFxuICAgIC8vc25hcDogeydmdW5jdGlvbic6ICdmdW5jdGlvbicsIG5hZGF9LFxuICAgIHN0YXJ0OiAnJyxcbiAgICAvL3RlbXBsYXRlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgLy90aW1lQXhpczoge1xuICAgIC8vICBzY2FsZTogWydtaWxsaXNlY29uZCcsICdzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnd2Vla2RheScsICdkYXknLCAnbW9udGgnLCAneWVhciddLFxuICAgIC8vICBzdGVwOiBbMSwgMSwgMTAsIDFdXG4gICAgLy99LFxuICAgIHR5cGU6IFsnYm94JywgJ3BvaW50JywgJ3JhbmdlJywgJ2JhY2tncm91bmQnXSxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIHpvb21hYmxlOiB0cnVlLFxuICAgIHpvb21LZXk6IFsnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleScsICcnXSxcbiAgICB6b29tTWF4OiBbMzE1MzYwMDAwMDAwMDAwLCAxMCwgMzE1MzYwMDAwMDAwMDAwLCAxXSxcbiAgICB6b29tTWluOiBbMTAsIDEwLCAzMTUzNjAwMDAwMDAwMDAsIDFdXG4gIH1cbn07XG5cbmV4cG9ydCB7YWxsT3B0aW9ucywgY29uZmlndXJlT3B0aW9uc307Il19
},{}],46:[function(require,module,exports){
// utility functions

// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.

'use strict';

var moment = require('./module/moment');
var uuid = require('./module/uuid');

/**
 * Test whether given object is a number
 * @param {*} object
 * @return {Boolean} isNumber
 */
exports.isNumber = function (object) {
  return object instanceof Number || typeof object == 'number';
};

/**
 * Remove everything in the DOM object
 * @param DOMobject
 */
exports.recursiveDOMDelete = function (DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      exports.recursiveDOMDelete(DOMobject.firstChild);
      DOMobject.removeChild(DOMobject.firstChild);
    }
  }
};

/**
 * this function gives you a range between 0 and 1 based on the min and max values in the set, the total sum of all values and the current value.
 *
 * @param min
 * @param max
 * @param total
 * @param value
 * @returns {number}
 */
exports.giveRange = function (min, max, total, value) {
  if (max == min) {
    return 0.5;
  } else {
    var scale = 1 / (max - min);
    return Math.max(0, (value - min) * scale);
  }
};

/**
 * Test whether given object is a string
 * @param {*} object
 * @return {Boolean} isString
 */
exports.isString = function (object) {
  return object instanceof String || typeof object == 'string';
};

/**
 * Test whether given object is a Date, or a String containing a Date
 * @param {Date | String} object
 * @return {Boolean} isDate
 */
exports.isDate = function (object) {
  if (object instanceof Date) {
    return true;
  } else if (exports.isString(object)) {
    // test whether this string contains a date
    var match = ASPDateRegex.exec(object);
    if (match) {
      return true;
    } else if (!isNaN(Date.parse(object))) {
      return true;
    }
  }

  return false;
};

/**
 * Create a semi UUID
 * source: http://stackoverflow.com/a/105074/1262753
 * @return {String} uuid
 */
exports.randomUUID = function () {
  return uuid.v4();
};

/**
 * assign all keys of an object that are not nested objects to a certain value (used for color objects).
 * @param obj
 * @param value
 */
exports.assignAllKeys = function (obj, value) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      if (typeof obj[prop] !== 'object') {
        obj[prop] = value;
      }
    }
  }
};

/**
 * Fill an object with a possibly partially defined other object. Only copies values if the a object has an object requiring values.
 * That means an object is not created on a property if only the b object has it.
 * @param obj
 * @param value
 */
exports.fillIfDefined = function (a, b) {
  var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

  for (var prop in a) {
    if (b[prop] !== undefined) {
      if (typeof b[prop] !== 'object') {
        if ((b[prop] === undefined || b[prop] === null) && a[prop] !== undefined && allowDeletion === true) {
          delete a[prop];
        } else {
          a[prop] = b[prop];
        }
      } else {
        if (typeof a[prop] === 'object') {
          exports.fillIfDefined(a[prop], b[prop], allowDeletion);
        }
      }
    }
  }
};

/**
 * Extend object a with the properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.protoExtend = function (a, b) {
  for (var i = 1; i < arguments.length; i++) {
    var other = arguments[i];
    for (var prop in other) {
      a[prop] = other[prop];
    }
  }
  return a;
};

/**
 * Extend object a with the properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.extend = function (a, b) {
  for (var i = 1; i < arguments.length; i++) {
    var other = arguments[i];
    for (var prop in other) {
      if (other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveExtend = function (props, a, b) {
  if (!Array.isArray(props)) {
    throw new Error('Array with property names expected as first argument');
  }

  for (var i = 2; i < arguments.length; i++) {
    var other = arguments[i];

    for (var p = 0; p < props.length; p++) {
      var prop = props[p];
      if (other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveDeepExtend = function (props, a, b) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }
  for (var i = 2; i < arguments.length; i++) {
    var other = arguments[i];
    for (var p = 0; p < props.length; p++) {
      var prop = props[p];
      if (other.hasOwnProperty(prop)) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop], false, allowDeletion);
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        } else if (Array.isArray(b[prop])) {
          throw new TypeError('Arrays are not supported by deepExtend');
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveNotDeepExtend = function (props, a, b) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }
  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      if (props.indexOf(prop) == -1) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop]);
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        } else if (Array.isArray(b[prop])) {
          a[prop] = [];
          for (var i = 0; i < b[prop].length; i++) {
            a[prop].push(b[prop][i]);
          }
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      }
    }
  }
  return a;
};

/**
 * Deep extend an object a with the properties of object b
 * @param {Object} a
 * @param {Object} b
 * @param [Boolean] protoExtend --> optional parameter. If true, the prototype values will also be extended.
 *                                  (ie. the options objects that inherit from others will also get the inherited options)
 * @param [Boolean] global      --> optional parameter. If true, the values of fields that are null will not deleted
 * @returns {Object}
 */
exports.deepExtend = function (a, b, protoExtend, allowDeletion) {
  for (var prop in b) {
    if (b.hasOwnProperty(prop) || protoExtend === true) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          exports.deepExtend(a[prop], b[prop], protoExtend);
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      } else if (Array.isArray(b[prop])) {
        a[prop] = [];
        for (var i = 0; i < b[prop].length; i++) {
          a[prop].push(b[prop][i]);
        }
      } else {
        if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
          delete a[prop];
        } else {
          a[prop] = b[prop];
        }
      }
    }
  }
  return a;
};

/**
 * Test whether all elements in two arrays are equal.
 * @param {Array} a
 * @param {Array} b
 * @return {boolean} Returns true if both arrays have the same length and same
 *                   elements.
 */
exports.equalArray = function (a, b) {
  if (a.length != b.length) return false;

  for (var i = 0, len = a.length; i < len; i++) {
    if (a[i] != b[i]) return false;
  }

  return true;
};

/**
 * Convert an object to another type
 * @param {Boolean | Number | String | Date | Moment | Null | undefined} object
 * @param {String | undefined} type   Name of the type. Available types:
 *                                    'Boolean', 'Number', 'String',
 *                                    'Date', 'Moment', ISODate', 'ASPDate'.
 * @return {*} object
 * @throws Error
 */
exports.convert = function (object, type) {
  var match;

  if (object === undefined) {
    return undefined;
  }
  if (object === null) {
    return null;
  }

  if (!type) {
    return object;
  }
  if (!(typeof type === 'string') && !(type instanceof String)) {
    throw new Error('Type must be a string');
  }

  //noinspection FallthroughInSwitchStatementJS
  switch (type) {
    case 'boolean':
    case 'Boolean':
      return Boolean(object);

    case 'number':
    case 'Number':
      return Number(object.valueOf());

    case 'string':
    case 'String':
      return String(object);

    case 'Date':
      if (exports.isNumber(object)) {
        return new Date(object);
      }
      if (object instanceof Date) {
        return new Date(object.valueOf());
      } else if (moment.isMoment(object)) {
        return new Date(object.valueOf());
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])); // parse number
        } else {
            return moment(object).toDate(); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
        }

    case 'Moment':
      if (exports.isNumber(object)) {
        return moment(object);
      }
      if (object instanceof Date) {
        return moment(object.valueOf());
      } else if (moment.isMoment(object)) {
        return moment(object);
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return moment(Number(match[1])); // parse number
        } else {
            return moment(object); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
        }

    case 'ISODate':
      if (exports.isNumber(object)) {
        return new Date(object);
      } else if (object instanceof Date) {
        return object.toISOString();
      } else if (moment.isMoment(object)) {
        return object.toDate().toISOString();
      } else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])).toISOString(); // parse number
        } else {
            return new Date(object).toISOString(); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ISODate');
        }

    case 'ASPDate':
      if (exports.isNumber(object)) {
        return '/Date(' + object + ')/';
      } else if (object instanceof Date) {
        return '/Date(' + object.valueOf() + ')/';
      } else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        var value;
        if (match) {
          // object is an ASP date
          value = new Date(Number(match[1])).valueOf(); // parse number
        } else {
            value = new Date(object).valueOf(); // parse string
          }
        return '/Date(' + value + ')/';
      } else {
        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ASPDate');
      }

    default:
      throw new Error('Unknown type "' + type + '"');
  }
};

// parse ASP.Net Date pattern,
// for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
// code from http://momentjs.com/
var ASPDateRegex = /^\/?Date\((\-?\d+)/i;

/**
 * Get the type of an object, for example exports.getType([]) returns 'Array'
 * @param {*} object
 * @return {String} type
 */
exports.getType = function (object) {
  var type = typeof object;

  if (type == 'object') {
    if (object === null) {
      return 'null';
    }
    if (object instanceof Boolean) {
      return 'Boolean';
    }
    if (object instanceof Number) {
      return 'Number';
    }
    if (object instanceof String) {
      return 'String';
    }
    if (Array.isArray(object)) {
      return 'Array';
    }
    if (object instanceof Date) {
      return 'Date';
    }
    return 'Object';
  } else if (type == 'number') {
    return 'Number';
  } else if (type == 'boolean') {
    return 'Boolean';
  } else if (type == 'string') {
    return 'String';
  } else if (type === undefined) {
    return 'undefined';
  }

  return type;
};

/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr
 * @param newValue
 * @returns {Array}
 */
exports.copyAndExtendArray = function (arr, newValue) {
  var newArr = [];
  for (var i = 0; i < arr.length; i++) {
    newArr.push(arr[i]);
  }
  newArr.push(newValue);
  return newArr;
};

/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr
 * @param newValue
 * @returns {Array}
 */
exports.copyArray = function (arr) {
  var newArr = [];
  for (var i = 0; i < arr.length; i++) {
    newArr.push(arr[i]);
  }
  return newArr;
};

/**
 * Retrieve the absolute left value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} left        The absolute left position of this element
 *                              in the browser page.
 */
exports.getAbsoluteLeft = function (elem) {
  return elem.getBoundingClientRect().left;
};

/**
 * Retrieve the absolute top value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} top        The absolute top position of this element
 *                              in the browser page.
 */
exports.getAbsoluteTop = function (elem) {
  return elem.getBoundingClientRect().top;
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
exports.addClassName = function (elem, className) {
  var classes = elem.className.split(' ');
  if (classes.indexOf(className) == -1) {
    classes.push(className); // add the class to the array
    elem.className = classes.join(' ');
  }
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
exports.removeClassName = function (elem, className) {
  var classes = elem.className.split(' ');
  var index = classes.indexOf(className);
  if (index != -1) {
    classes.splice(index, 1); // remove the class from the array
    elem.className = classes.join(' ');
  }
};

/**
 * For each method for both arrays and objects.
 * In case of an array, the built-in Array.forEach() is applied.
 * In case of an Object, the method loops over all properties of the object.
 * @param {Object | Array} object   An Object or Array
 * @param {function} callback       Callback method, called for each item in
 *                                  the object or array with three parameters:
 *                                  callback(value, index, object)
 */
exports.forEach = function (object, callback) {
  var i, len;
  if (Array.isArray(object)) {
    // array
    for (i = 0, len = object.length; i < len; i++) {
      callback(object[i], i, object);
    }
  } else {
    // object
    for (i in object) {
      if (object.hasOwnProperty(i)) {
        callback(object[i], i, object);
      }
    }
  }
};

/**
 * Convert an object into an array: all objects properties are put into the
 * array. The resulting array is unordered.
 * @param {Object} object
 * @param {Array} array
 */
exports.toArray = function (object) {
  var array = [];

  for (var prop in object) {
    if (object.hasOwnProperty(prop)) array.push(object[prop]);
  }

  return array;
};

/**
 * Update a property in an object
 * @param {Object} object
 * @param {String} key
 * @param {*} value
 * @return {Boolean} changed
 */
exports.updateProperty = function (object, key, value) {
  if (object[key] !== value) {
    object[key] = value;
    return true;
  } else {
    return false;
  }
};

/**
 * Throttle the given function to be only executed once every `wait` milliseconds
 * @param {function} fn
 * @param {number} wait    Time in milliseconds
 * @returns {function} Returns the throttled function
 */
exports.throttle = function (fn, wait) {
  var timeout = null;
  var needExecution = false;

  return function throttled() {
    if (!timeout) {
      needExecution = false;
      fn();

      timeout = setTimeout(function () {
        timeout = null;
        if (needExecution) {
          throttled();
        }
      }, wait);
    } else {
      needExecution = true;
    }
  };
};

/**
 * Add and event listener. Works for all browsers
 * @param {Element}     element    An html element
 * @param {string}      action     The action, for example "click",
 *                                 without the prefix "on"
 * @param {function}    listener   The callback function to be executed
 * @param {boolean}     [useCapture]
 */
exports.addEventListener = function (element, action, listener, useCapture) {
  if (element.addEventListener) {
    if (useCapture === undefined) useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.addEventListener(action, listener, useCapture);
  } else {
    element.attachEvent("on" + action, listener); // IE browsers
  }
};

/**
 * Remove an event listener from an element
 * @param {Element}     element         An html dom element
 * @param {string}      action          The name of the event, for example "mousedown"
 * @param {function}    listener        The listener function
 * @param {boolean}     [useCapture]
 */
exports.removeEventListener = function (element, action, listener, useCapture) {
  if (element.removeEventListener) {
    // non-IE browsers
    if (useCapture === undefined) useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.removeEventListener(action, listener, useCapture);
  } else {
    // IE browsers
    element.detachEvent("on" + action, listener);
  }
};

/**
 * Cancels the event if it is cancelable, without stopping further propagation of the event.
 */
exports.preventDefault = function (event) {
  if (!event) event = window.event;

  if (event.preventDefault) {
    event.preventDefault(); // non-IE browsers
  } else {
      event.returnValue = false; // IE browsers
    }
};

/**
 * Get HTML element which is the target of the event
 * @param {Event} event
 * @return {Element} target element
 */
exports.getTarget = function (event) {
  // code from http://www.quirksmode.org/js/events_properties.html
  if (!event) {
    event = window.event;
  }

  var target;

  if (event.target) {
    target = event.target;
  } else if (event.srcElement) {
    target = event.srcElement;
  }

  if (target.nodeType != undefined && target.nodeType == 3) {
    // defeat Safari bug
    target = target.parentNode;
  }

  return target;
};

/**
 * Check if given element contains given parent somewhere in the DOM tree
 * @param {Element} element
 * @param {Element} parent
 */
exports.hasParent = function (element, parent) {
  var e = element;

  while (e) {
    if (e === parent) {
      return true;
    }
    e = e.parentNode;
  }

  return false;
};

exports.option = {};

/**
 * Convert a value into a boolean
 * @param {Boolean | function | undefined} value
 * @param {Boolean} [defaultValue]
 * @returns {Boolean} bool
 */
exports.option.asBoolean = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return value != false;
  }

  return defaultValue || null;
};

/**
 * Convert a value into a number
 * @param {Boolean | function | undefined} value
 * @param {Number} [defaultValue]
 * @returns {Number} number
 */
exports.option.asNumber = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return Number(value) || defaultValue || null;
  }

  return defaultValue || null;
};

/**
 * Convert a value into a string
 * @param {String | function | undefined} value
 * @param {String} [defaultValue]
 * @returns {String} str
 */
exports.option.asString = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return String(value);
  }

  return defaultValue || null;
};

/**
 * Convert a size or location into a string with pixels or a percentage
 * @param {String | Number | function | undefined} value
 * @param {String} [defaultValue]
 * @returns {String} size
 */
exports.option.asSize = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (exports.isString(value)) {
    return value;
  } else if (exports.isNumber(value)) {
    return value + 'px';
  } else {
    return defaultValue || null;
  }
};

/**
 * Convert a value into a DOM element
 * @param {HTMLElement | function | undefined} value
 * @param {HTMLElement} [defaultValue]
 * @returns {HTMLElement | null} dom
 */
exports.option.asElement = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  return value || defaultValue || null;
};

/**
 * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
 *
 * @param {String} hex
 * @returns {{r: *, g: *, b: *}} | 255 range
 */
exports.hexToRGB = function (hex) {
  // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, function (m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
};

/**
 * This function takes color in hex format or rgb() or rgba() format and overrides the opacity. Returns rgba() string.
 * @param color
 * @param opacity
 * @returns {*}
 */
exports.overrideOpacity = function (color, opacity) {
  if (color.indexOf("rgba") != -1) {
    return color;
  } else if (color.indexOf("rgb") != -1) {
    var rgb = color.substr(color.indexOf("(") + 1).replace(")", "").split(",");
    return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
  } else {
    var rgb = exports.hexToRGB(color);
    if (rgb == null) {
      return color;
    } else {
      return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + opacity + ")";
    }
  }
};

/**
 *
 * @param red     0 -- 255
 * @param green   0 -- 255
 * @param blue    0 -- 255
 * @returns {string}
 * @constructor
 */
exports.RGBToHex = function (red, green, blue) {
  return "#" + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
};

/**
 * Parse a color property into an object with border, background, and
 * highlight colors
 * @param {Object | String} color
 * @return {Object} colorObject
 */
exports.parseColor = function (color) {
  var c;
  if (exports.isString(color) === true) {
    if (exports.isValidRGB(color) === true) {
      var rgb = color.substr(4).substr(0, color.length - 5).split(',').map(function (value) {
        return parseInt(value);
      });
      color = exports.RGBToHex(rgb[0], rgb[1], rgb[2]);
    }
    if (exports.isValidHex(color) === true) {
      var hsv = exports.hexToHSV(color);
      var lighterColorHSV = { h: hsv.h, s: hsv.s * 0.8, v: Math.min(1, hsv.v * 1.02) };
      var darkerColorHSV = { h: hsv.h, s: Math.min(1, hsv.s * 1.25), v: hsv.v * 0.8 };
      var darkerColorHex = exports.HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      var lighterColorHex = exports.HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      c = {
        background: color,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      c = {
        background: color,
        border: color,
        highlight: {
          background: color,
          border: color
        },
        hover: {
          background: color,
          border: color
        }
      };
    }
  } else {
    c = {};
    c.background = color.background || undefined;
    c.border = color.border || undefined;

    if (exports.isString(color.highlight)) {
      c.highlight = {
        border: color.highlight,
        background: color.highlight
      };
    } else {
      c.highlight = {};
      c.highlight.background = color.highlight && color.highlight.background || undefined;
      c.highlight.border = color.highlight && color.highlight.border || undefined;
    }

    if (exports.isString(color.hover)) {
      c.hover = {
        border: color.hover,
        background: color.hover
      };
    } else {
      c.hover = {};
      c.hover.background = color.hover && color.hover.background || undefined;
      c.hover.border = color.hover && color.hover.border || undefined;
    }
  }

  return c;
};

/**
 * http://www.javascripter.net/faq/rgb2hsv.htm
 *
 * @param red
 * @param green
 * @param blue
 * @returns {*}
 * @constructor
 */
exports.RGBToHSV = function (red, green, blue) {
  red = red / 255;green = green / 255;blue = blue / 255;
  var minRGB = Math.min(red, Math.min(green, blue));
  var maxRGB = Math.max(red, Math.max(green, blue));

  // Black-gray-white
  if (minRGB == maxRGB) {
    return { h: 0, s: 0, v: minRGB };
  }

  // Colors other than black-gray-white:
  var d = red == minRGB ? green - blue : blue == minRGB ? red - green : blue - red;
  var h = red == minRGB ? 3 : blue == minRGB ? 1 : 5;
  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
  var saturation = (maxRGB - minRGB) / maxRGB;
  var value = maxRGB;
  return { h: hue, s: saturation, v: value };
};

var cssUtil = {
  // split a string with css styles into an object with key/values
  split: function split(cssText) {
    var styles = {};

    cssText.split(';').forEach(function (style) {
      if (style.trim() != '') {
        var parts = style.split(':');
        var key = parts[0].trim();
        var value = parts[1].trim();
        styles[key] = value;
      }
    });

    return styles;
  },

  // build a css text string from an object with key/values
  join: function join(styles) {
    return Object.keys(styles).map(function (key) {
      return key + ': ' + styles[key];
    }).join('; ');
  }
};

/**
 * Append a string with css styles to an element
 * @param {Element} element
 * @param {String} cssText
 */
exports.addCssText = function (element, cssText) {
  var currentStyles = cssUtil.split(element.style.cssText);
  var newStyles = cssUtil.split(cssText);
  var styles = exports.extend(currentStyles, newStyles);

  element.style.cssText = cssUtil.join(styles);
};

/**
 * Remove a string with css styles from an element
 * @param {Element} element
 * @param {String} cssText
 */
exports.removeCssText = function (element, cssText) {
  var styles = cssUtil.split(element.style.cssText);
  var removeStyles = cssUtil.split(cssText);

  for (var key in removeStyles) {
    if (removeStyles.hasOwnProperty(key)) {
      delete styles[key];
    }
  }

  element.style.cssText = cssUtil.join(styles);
};

/**
 * https://gist.github.com/mjijackson/5311256
 * @param h
 * @param s
 * @param v
 * @returns {{r: number, g: number, b: number}}
 * @constructor
 */
exports.HSVToRGB = function (h, s, v) {
  var r, g, b;

  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;break;
    case 1:
      r = q, g = v, b = p;break;
    case 2:
      r = p, g = v, b = t;break;
    case 3:
      r = p, g = q, b = v;break;
    case 4:
      r = t, g = p, b = v;break;
    case 5:
      r = v, g = p, b = q;break;
  }

  return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: Math.floor(b * 255) };
};

exports.HSVToHex = function (h, s, v) {
  var rgb = exports.HSVToRGB(h, s, v);
  return exports.RGBToHex(rgb.r, rgb.g, rgb.b);
};

exports.hexToHSV = function (hex) {
  var rgb = exports.hexToRGB(hex);
  return exports.RGBToHSV(rgb.r, rgb.g, rgb.b);
};

exports.isValidHex = function (hex) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  return isOk;
};

exports.isValidRGB = function (rgb) {
  rgb = rgb.replace(" ", "");
  var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
  return isOk;
};
exports.isValidRGBA = function (rgba) {
  rgba = rgba.replace(" ", "");
  var isOk = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(rgba);
  return isOk;
};

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param referenceObject
 * @returns {*}
 */
exports.selectiveBridgeObject = function (fields, referenceObject) {
  if (typeof referenceObject == "object") {
    var objectTo = Object.create(referenceObject);
    for (var i = 0; i < fields.length; i++) {
      if (referenceObject.hasOwnProperty(fields[i])) {
        if (typeof referenceObject[fields[i]] == "object") {
          objectTo[fields[i]] = exports.bridgeObject(referenceObject[fields[i]]);
        }
      }
    }
    return objectTo;
  } else {
    return null;
  }
};

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param referenceObject
 * @returns {*}
 */
exports.bridgeObject = function (referenceObject) {
  if (typeof referenceObject == "object") {
    var objectTo = Object.create(referenceObject);
    for (var i in referenceObject) {
      if (referenceObject.hasOwnProperty(i)) {
        if (typeof referenceObject[i] == "object") {
          objectTo[i] = exports.bridgeObject(referenceObject[i]);
        }
      }
    }
    return objectTo;
  } else {
    return null;
  }
};

/**
 * this is used to set the options of subobjects in the options object. A requirement of these subobjects
 * is that they have an 'enabled' element which is optional for the user but mandatory for the program.
 *
 * @param [object] mergeTarget | this is either this.options or the options used for the groups.
 * @param [object] options     | options
 * @param [String] option      | this is the option key in the options argument
 * @private
 */
exports.mergeOptions = function (mergeTarget, options, option) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
  var globalOptions = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

  if (options[option] === null) {
    mergeTarget[option] = Object.create(globalOptions[option]);
  } else {
    if (options[option] !== undefined) {
      if (typeof options[option] === 'boolean') {
        mergeTarget[option].enabled = options[option];
      } else {
        if (options[option].enabled === undefined) {
          mergeTarget[option].enabled = true;
        }
        for (var prop in options[option]) {
          if (options[option].hasOwnProperty(prop)) {
            mergeTarget[option][prop] = options[option][prop];
          }
        }
      }
    }
  }
};

/**
 * This function does a binary search for a visible item in a sorted list. If we find a visible item, the code that uses
 * this function will then iterate in both directions over this sorted list to find all visible items.
 *
 * @param {Item[]} orderedItems       | Items ordered by start
 * @param {function} searchFunction   | -1 is lower, 0 is found, 1 is higher
 * @param {String} field
 * @param {String} field2
 * @returns {number}
 * @private
 */
exports.binarySearchCustom = function (orderedItems, searchFunction, field, field2) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;

  while (low <= high && iteration < maxIterations) {
    var middle = Math.floor((low + high) / 2);

    var item = orderedItems[middle];
    var value = field2 === undefined ? item[field] : item[field][field2];

    var searchResult = searchFunction(value);
    if (searchResult == 0) {
      // jihaa, found a visible item!
      return middle;
    } else if (searchResult == -1) {
      // it is too small --> increase low
      low = middle + 1;
    } else {
      // it is too big --> decrease high
      high = middle - 1;
    }

    iteration++;
  }

  return -1;
};

/**
 * This function does a binary search for a specific value in a sorted array. If it does not exist but is in between of
 * two values, we return either the one before or the one after, depending on user input
 * If it is found, we return the index, else -1.
 *
 * @param {Array} orderedItems
 * @param {{start: number, end: number}} target
 * @param {String} field
 * @param {String} sidePreference   'before' or 'after'
 * @returns {number}
 * @private
 */
exports.binarySearchValue = function (orderedItems, target, field, sidePreference) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;
  var prevValue, value, nextValue, middle;

  while (low <= high && iteration < maxIterations) {
    // get a new guess
    middle = Math.floor(0.5 * (high + low));
    prevValue = orderedItems[Math.max(0, middle - 1)][field];
    value = orderedItems[middle][field];
    nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];

    if (value == target) {
      // we found the target
      return middle;
    } else if (prevValue < target && value > target) {
      // target is in between of the previous and the current
      return sidePreference == 'before' ? Math.max(0, middle - 1) : middle;
    } else if (value < target && nextValue > target) {
      // target is in between of the current and the next
      return sidePreference == 'before' ? middle : Math.min(orderedItems.length - 1, middle + 1);
    } else {
      // didnt find the target, we need to change our boundaries.
      if (value < target) {
        // it is too small --> increase low
        low = middle + 1;
      } else {
        // it is too big --> decrease high
        high = middle - 1;
      }
    }
    iteration++;
  }

  // didnt find anything. Return -1.
  return -1;
};

/*
 * Easing Functions - inspired from http://gizma.com/easing/
 * only considering the t value for the range [0, 1] => [0, 1]
 * https://gist.github.com/gre/1650294
 */
exports.easingFunctions = {
  // no easing, no acceleration
  linear: function linear(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function easeInOutQuad(t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },
  // decelerating to zero velocity
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function easeInOutCubic(t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function easeInOutQuart(t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function easeInOutQuint(t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbWlseWFzaGxleS9TVE9SWVRPT0xTL3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQU1BLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQ3hDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQzs7Ozs7OztBQU9wQyxPQUFPLENBQUMsUUFBUSxHQUFHLFVBQVUsTUFBTSxFQUFFO0FBQ25DLFNBQVEsTUFBTSxZQUFZLE1BQU0sSUFBSSxPQUFPLE1BQU0sSUFBSSxRQUFRLENBQUU7Q0FDaEUsQ0FBQzs7Ozs7O0FBT0YsT0FBTyxDQUFDLGtCQUFrQixHQUFHLFVBQVUsU0FBUyxFQUFFO0FBQ2hELE1BQUksU0FBUyxFQUFFO0FBQ2IsV0FBTyxTQUFTLENBQUMsYUFBYSxFQUFFLEtBQUssSUFBSSxFQUFFO0FBQ3pDLGFBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDakQsZUFBUyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7S0FDN0M7R0FDRjtDQUNGLENBQUM7Ozs7Ozs7Ozs7O0FBV0YsT0FBTyxDQUFDLFNBQVMsR0FBRyxVQUFVLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUNwRCxNQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUU7QUFDZCxXQUFPLEdBQUcsQ0FBQztHQUNaLE1BQ0k7QUFDSCxRQUFJLEtBQUssR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQSxBQUFDLENBQUM7QUFDNUIsV0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUEsR0FBSSxLQUFLLENBQUMsQ0FBQztHQUMzQztDQUNGLENBQUE7Ozs7Ozs7QUFPRCxPQUFPLENBQUMsUUFB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QUFDLENBQUEsQUFBQyxDQUFDOztBQUU5QixVQUFRLENBQUMsR0FBRyxDQUFDO0FBQ1gsU0FBSyxDQUFDO0FBQUUsT0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxNQUFNO0FBQUEsQUFDbkMsU0FBSyxDQUFDO0FBQUUsT0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxNQUFNO0FBQUEsQUFDbkMsU0FBSyxDQUFDO0FBQUUsT0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxNQUFNO0FBQUEsQUFDbkMsU0FBSyxDQUFDO0FBQUUsT0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxNQUFNO0FBQUEsQUFDbkMsU0FBSyxDQUFDO0FBQUUsT0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxNQUFNO0FBQUEsQUFDbkMsU0FBSyxDQUFDO0FBQUUsT0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxNQUFNO0FBQUEsR0FDcEM7O0FBRUQsU0FBTyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUM7Q0FDbkYsQ0FBQzs7QUFFRixPQUFPLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDcEMsTUFBSSxHQUFH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LEVBQUUsQ0FBQyxBQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0dBQ3hFO0NBQ0YsQ0FBQyIsImZpbGUiOiIvVXNlcnMvZW1pbHlhc2hsZXkvU1RPUllUT09MUy9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi91dGlsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxuLy8gZmlyc3QgY2hlY2sgaWYgbW9tZW50LmpzIGlzIGFscmVhZHkgbG9hZGVkIGluIHRoZSBicm93c2VyIHdpbmRvdywgaWYgc28sXG4vLyB1c2UgdGhpcyBpbnN0YW5jZS4gRWxzZSwgbG9hZCB2aWEgY29tbW9uanMuXG5cblxudmFyIG1vbWVudCA9IHJlcXVpcmUoJy4vbW9kdWxlL21vbWVudCcpO1xudmFyIHV1aWQgPSByZXF1aXJlKCcuL21vZHVsZS91dWlkJyk7XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIG51bWJlclxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzTnVtYmVyXG4gKi9cbmV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiAob2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyIHx8IHR5cGVvZiBvYmplY3QgPT0gJ251bWJlcicpO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBldmVyeXRoaW5nIGluIHRoZSBET00gb2JqZWN0XG4gKiBAcGFyYW0gRE9Nb2JqZWN0XG4gKi9cbmV4cG9ydHMucmVjdXJzaXZlRE9NRGVsZXRlID0gZnVuY3Rpb24gKERPTW9iamVjdCkge1xuICBpZiAoRE9Nb2JqZWN0KSB7XG4gICAgd2hpbGUgKERPTW9iamVjdC5oYXNDaGlsZE5vZGVzKCkgPT09IHRydWUpIHtcbiAgICAgIGV4cG9ydHMucmVjdXJzaXZlRE9NRGVsZXRlKERPTW9iamVjdC5maXJzdENoaWxkKTtcbiAgICAgIERPTW9iamVjdC5yZW1vdmVDaGlsZChET01vYmplY3QuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIHRoaXMgZnVuY3Rpb24gZ2l2ZXMgeW91IGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxIGJhc2VkIG9uIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgaW4gdGhlIHNldCwgdGhlIHRvdGFsIHN1bSBvZiBhbGwgdmFsdWVzIGFuZCB0aGUgY3VycmVudCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gbWluXG4gKiBAcGFyYW0gbWF4XG4gKiBAcGFyYW0gdG90YWxcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5naXZlUmFuZ2UgPSBmdW5jdGlvbiAobWluLCBtYXgsIHRvdGFsLCB2YWx1ZSkge1xuICBpZiAobWF4ID09IG1pbikge1xuICAgIHJldHVybiAwLjU7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCAodmFsdWUgLSBtaW4pICogc2NhbGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIHN0cmluZ1xuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzU3RyaW5nXG4gKi9cbmV4cG9ydHMuaXNTdHJpbmcgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiAob2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiBvYmplY3QgPT0gJ3N0cmluZycpO1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgRGF0ZSwgb3IgYSBTdHJpbmcgY29udGFpbmluZyBhIERhdGVcbiAqIEBwYXJhbSB7RGF0ZSB8IFN0cmluZ30gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc0RhdGVcbiAqL1xuZXhwb3J0cy5pc0RhdGUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWxzZSBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgLy8gdGVzdCB3aGV0aGVyIHRoaXMgc3RyaW5nIGNvbnRhaW5zIGEgZGF0ZVxuICAgIHZhciBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzTmFOKERhdGUucGFyc2Uob2JqZWN0KSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgc2VtaSBVVUlEXG4gKiBzb3VyY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwNTA3NC8xMjYyNzUzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHV1aWRcbiAqL1xuZXhwb3J0cy5yYW5kb21VVUlEID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdXVpZC52NCgpO1xufTtcblxuLyoqXG4gKiBhc3NpZ24gYWxsIGtleXMgb2YgYW4gb2JqZWN0IHRoYXQgYXJlIG5vdCBuZXN0ZWQgb2JqZWN0cyB0byBhIGNlcnRhaW4gdmFsdWUgKHVzZWQgZm9yIGNvbG9yIG9iamVjdHMpLlxuICogQHBhcmFtIG9ialxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydHMuYXNzaWduQWxsS2V5cyA9IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgaWYgKHR5cGVvZiBvYmpbcHJvcF0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogRmlsbCBhbiBvYmplY3Qgd2l0aCBhIHBvc3NpYmx5IHBhcnRpYWxseSBkZWZpbmVkIG90aGVyIG9iamVjdC4gT25seSBjb3BpZXMgdmFsdWVzIGlmIHRoZSBhIG9iamVjdCBoYXMgYW4gb2JqZWN0IHJlcXVpcmluZyB2YWx1ZXMuXG4gKiBUaGF0IG1lYW5zIGFuIG9iamVjdCBpcyBub3QgY3JlYXRlZCBvbiBhIHByb3BlcnR5IGlmIG9ubHkgdGhlIGIgb2JqZWN0IGhhcyBpdC5cbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnRzLmZpbGxJZkRlZmluZWQgPSBmdW5jdGlvbiAoYSwgYiwgYWxsb3dEZWxldGlvbiA9IGZhbHNlKSB7XG4gIGZvciAodmFyIHByb3AgaW4gYSkge1xuICAgIGlmIChiW3Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgYltwcm9wXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKChiW3Byb3BdID09PSB1bmRlZmluZWQgfHwgYltwcm9wXSA9PT0gbnVsbCkgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgYVtwcm9wXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBleHBvcnRzLmZpbGxJZkRlZmluZWQoYVtwcm9wXSwgYltwcm9wXSwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7Li4uIE9iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMucHJvdG9FeHRlbmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG90aGVyKSB7XG4gICAgICBhW3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHsuLi4gT2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgYVtwcm9wXSA9IG90aGVyW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqL1xuZXhwb3J0cy5zZWxlY3RpdmVFeHRlbmQgPSBmdW5jdGlvbiAocHJvcHMsIGEsIGIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJyYXkgd2l0aCBwcm9wZXJ0eSBuYW1lcyBleHBlY3RlZCBhcyBmaXJzdCBhcmd1bWVudCcpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHByb3BzLmxlbmd0aDsgcCsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW3BdO1xuICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGFbcHJvcF0gPSBvdGhlcltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHNlbGVjdGVkIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gcHJvcHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlRGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcywgYSwgYiwgYWxsb3dEZWxldGlvbiA9IGZhbHNlKSB7XG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBBcnJheXMgdG8gZGVlcEV4dGVuZFxuICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kJyk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1twXTtcbiAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdLCBmYWxzZSwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChiW3Byb3BdID09PSBudWxsKSAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQgJiYgYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKChiW3Byb3BdID09PSBudWxsKSAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQgJiYgYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHNlbGVjdGVkIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gcHJvcHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlTm90RGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcywgYSwgYiwgYWxsb3dEZWxldGlvbiA9IGZhbHNlKSB7XG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBBcnJheXMgdG8gZGVlcEV4dGVuZFxuICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kJyk7XG4gIH1cbiAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGlmIChwcm9wcy5pbmRleE9mKHByb3ApID09IC0xKSB7XG4gICAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgZXhwb3J0cy5kZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgoYltwcm9wXSA9PT0gbnVsbCkgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgICBhW3Byb3BdID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiW3Byb3BdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhW3Byb3BdLnB1c2goYltwcm9wXVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoYltwcm9wXSA9PT0gbnVsbCkgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRGVlcCBleHRlbmQgYW4gb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcGFyYW0gW0Jvb2xlYW5dIHByb3RvRXh0ZW5kIC0tPiBvcHRpb25hbCBwYXJhbWV0ZXIuIElmIHRydWUsIHRoZSBwcm90b3R5cGUgdmFsdWVzIHdpbGwgYWxzbyBiZSBleHRlbmRlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpZS4gdGhlIG9wdGlvbnMgb2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBvdGhlcnMgd2lsbCBhbHNvIGdldCB0aGUgaW5oZXJpdGVkIG9wdGlvbnMpXG4gKiBAcGFyYW0gW0Jvb2xlYW5dIGdsb2JhbCAgICAgIC0tPiBvcHRpb25hbCBwYXJhbWV0ZXIuIElmIHRydWUsIHRoZSB2YWx1ZXMgb2YgZmllbGRzIHRoYXQgYXJlIG51bGwgd2lsbCBub3QgZGVsZXRlZFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5kZWVwRXh0ZW5kID0gZnVuY3Rpb24gKGEsIGIsIHByb3RvRXh0ZW5kLCBhbGxvd0RlbGV0aW9uKSB7XG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApIHx8IHByb3RvRXh0ZW5kID09PSB0cnVlKSB7XG4gICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgZXhwb3J0cy5kZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIHByb3RvRXh0ZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoKGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICBhW3Byb3BdID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYltwcm9wXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFbcHJvcF0ucHVzaChiW3Byb3BdW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChiW3Byb3BdID09PSBudWxsKSAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQgJiYgYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYWxsIGVsZW1lbnRzIGluIHR3byBhcnJheXMgYXJlIGVxdWFsLlxuICogQHBhcmFtIHtBcnJheX0gYVxuICogQHBhcmFtIHtBcnJheX0gYlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGJvdGggYXJyYXlzIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFuZCBzYW1lXG4gKiAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5cbiAqL1xuZXhwb3J0cy5lcXVhbEFycmF5ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgdG8gYW5vdGhlciB0eXBlXG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBOdW1iZXIgfCBTdHJpbmcgfCBEYXRlIHwgTW9tZW50IHwgTnVsbCB8IHVuZGVmaW5lZH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZyB8IHVuZGVmaW5lZH0gdHlwZSAgIE5hbWUgb2YgdGhlIHR5cGUuIEF2YWlsYWJsZSB0eXBlczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Jvb2xlYW4nLCAnTnVtYmVyJywgJ1N0cmluZycsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdEYXRlJywgJ01vbWVudCcsIElTT0RhdGUnLCAnQVNQRGF0ZScuXG4gKiBAcmV0dXJuIHsqfSBvYmplY3RcbiAqIEB0aHJvd3MgRXJyb3JcbiAqL1xuZXhwb3J0cy5jb252ZXJ0ID0gZnVuY3Rpb24gKG9iamVjdCwgdHlwZSkge1xuICB2YXIgbWF0Y2g7XG5cbiAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGlmICghKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykgJiYgISh0eXBlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHlwZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICByZXR1cm4gQm9vbGVhbihvYmplY3QpO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdOdW1iZXInOlxuICAgICAgcmV0dXJuIE51bWJlcihvYmplY3QudmFsdWVPZigpKTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnU3RyaW5nJzpcbiAgICAgIHJldHVybiBTdHJpbmcob2JqZWN0KTtcblxuICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QudmFsdWVPZigpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG1vbWVudC5pc01vbWVudChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QudmFsdWVPZigpKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAvLyBvYmplY3QgaXMgYW4gQVNQIGRhdGVcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKG1hdGNoWzFdKSk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KS50b0RhdGUoKTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjb252ZXJ0IG9iamVjdCBvZiB0eXBlICcgKyBleHBvcnRzLmdldFR5cGUob2JqZWN0KSArXG4gICAgICAgICAgJyB0byB0eXBlIERhdGUnKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ01vbWVudCc6XG4gICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChtb21lbnQuaXNNb21lbnQob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdCk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgcmV0dXJuIG1vbWVudChOdW1iZXIobWF0Y2hbMV0pKTsgLy8gcGFyc2UgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICtcbiAgICAgICAgICAnIHRvIHR5cGUgRGF0ZScpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnSVNPRGF0ZSc6XG4gICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChtb21lbnQuaXNNb21lbnQob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0LnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAvLyBvYmplY3QgaXMgYW4gQVNQIGRhdGVcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKG1hdGNoWzFdKSkudG9JU09TdHJpbmcoKTsgLy8gcGFyc2UgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdCkudG9JU09TdHJpbmcoKTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjb252ZXJ0IG9iamVjdCBvZiB0eXBlICcgKyBleHBvcnRzLmdldFR5cGUob2JqZWN0KSArXG4gICAgICAgICAgJyB0byB0eXBlIElTT0RhdGUnKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ0FTUERhdGUnOlxuICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gJy9EYXRlKCcgKyBvYmplY3QgKyAnKS8nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJy9EYXRlKCcgKyBvYmplY3QudmFsdWVPZigpICsgJykvJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShOdW1iZXIobWF0Y2hbMV0pKS52YWx1ZU9mKCk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUob2JqZWN0KS52YWx1ZU9mKCk7IC8vIHBhcnNlIHN0cmluZ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnL0RhdGUoJyArIHZhbHVlICsgJykvJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjb252ZXJ0IG9iamVjdCBvZiB0eXBlICcgKyBleHBvcnRzLmdldFR5cGUob2JqZWN0KSArXG4gICAgICAgICAgJyB0byB0eXBlIEFTUERhdGUnKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSBcIicgKyB0eXBlICsgJ1wiJyk7XG4gIH1cbn07XG5cbi8vIHBhcnNlIEFTUC5OZXQgRGF0ZSBwYXR0ZXJuLFxuLy8gZm9yIGV4YW1wbGUgJy9EYXRlKDExOTg5MDg3MTcwNTYpLycgb3IgJy9EYXRlKDExOTg5MDg3MTcwNTYtMDcwMCkvJ1xuLy8gY29kZSBmcm9tIGh0dHA6Ly9tb21lbnRqcy5jb20vXG52YXIgQVNQRGF0ZVJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LCBmb3IgZXhhbXBsZSBleHBvcnRzLmdldFR5cGUoW10pIHJldHVybnMgJ0FycmF5J1xuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICovXG5leHBvcnRzLmdldFR5cGUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIG9iamVjdDtcblxuICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHJldHVybiAnU3RyaW5nJztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgcmV0dXJuICdBcnJheSc7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gJ0RhdGUnO1xuICAgIH1cbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAnTnVtYmVyJztcbiAgfVxuICBlbHNlIGlmICh0eXBlID09ICdib29sZWFuJykge1xuICAgIHJldHVybiAnQm9vbGVhbic7XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnU3RyaW5nJztcbiAgfVxuICBlbHNlIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cblxuXG4gIHJldHVybiB0eXBlO1xufTtcblxuXG4vKipcbiAqIFVzZWQgdG8gZXh0ZW5kIGFuIGFycmF5IGFuZCBjb3B5IGl0LiBUaGlzIGlzIHVzZWQgdG8gcHJvcGFnYXRlIHBhdGhzIHJlY3Vyc2l2ZWx5LlxuICpcbiAqIEBwYXJhbSBhcnJcbiAqIEBwYXJhbSBuZXdWYWx1ZVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5leHBvcnRzLmNvcHlBbmRFeHRlbmRBcnJheSA9IGZ1bmN0aW9uIChhcnIsIG5ld1ZhbHVlKSB7XG4gIGxldCBuZXdBcnIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBuZXdBcnIucHVzaChhcnJbaV0pO1xuICB9XG4gIG5ld0Fyci5wdXNoKG5ld1ZhbHVlKTtcbiAgcmV0dXJuIG5ld0Fycjtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cbiAqXG4gKiBAcGFyYW0gYXJyXG4gKiBAcGFyYW0gbmV3VmFsdWVcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0cy5jb3B5QXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGxldCBuZXdBcnIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBuZXdBcnIucHVzaChhcnJbaV0pO1xuICB9XG4gIHJldHVybiBuZXdBcnI7XG59XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIGxlZnQgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtICAgICAgICBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdlxuICogQHJldHVybiB7bnVtYmVyfSBsZWZ0ICAgICAgICBUaGUgYWJzb2x1dGUgbGVmdCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGJyb3dzZXIgcGFnZS5cbiAqL1xuZXhwb3J0cy5nZXRBYnNvbHV0ZUxlZnQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWJzb2x1dGUgdG9wIHZhbHVlIG9mIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAgICAgICAgQSBkb20gZWxlbWVudCwgZm9yIGV4YW1wbGUgYSBkaXZcbiAqIEByZXR1cm4ge251bWJlcn0gdG9wICAgICAgICBUaGUgYWJzb2x1dGUgdG9wIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgYnJvd3NlciBwYWdlLlxuICovXG5leHBvcnRzLmdldEFic29sdXRlVG9wID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xufTtcblxuLyoqXG4gKiBhZGQgYSBjbGFzc05hbWUgdG8gdGhlIGdpdmVuIGVsZW1lbnRzIHN0eWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqL1xuZXhwb3J0cy5hZGRDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWxlbSwgY2xhc3NOYW1lKSB7XG4gIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID09IC0xKSB7XG4gICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7IC8vIGFkZCB0aGUgY2xhc3MgdG8gdGhlIGFycmF5XG4gICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBhZGQgYSBjbGFzc05hbWUgdG8gdGhlIGdpdmVuIGVsZW1lbnRzIHN0eWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqL1xuZXhwb3J0cy5yZW1vdmVDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWxlbSwgY2xhc3NOYW1lKSB7XG4gIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSk7XG4gIGlmIChpbmRleCAhPSAtMSkge1xuICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTsgLy8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tIHRoZSBhcnJheVxuICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIGVhY2ggbWV0aG9kIGZvciBib3RoIGFycmF5cyBhbmQgb2JqZWN0cy5cbiAqIEluIGNhc2Ugb2YgYW4gYXJyYXksIHRoZSBidWlsdC1pbiBBcnJheS5mb3JFYWNoKCkgaXMgYXBwbGllZC5cbiAqIEluIGNhc2Ugb2YgYW4gT2JqZWN0LCB0aGUgbWV0aG9kIGxvb3BzIG92ZXIgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IG9iamVjdCAgIEFuIE9iamVjdCBvciBBcnJheVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgQ2FsbGJhY2sgbWV0aG9kLCBjYWxsZWQgZm9yIGVhY2ggaXRlbSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9iamVjdCBvciBhcnJheSB3aXRoIHRocmVlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIG9iamVjdClcbiAqL1xuZXhwb3J0cy5mb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgdmFyIGksXG4gICAgbGVuO1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgLy8gYXJyYXlcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmplY3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrKG9iamVjdFtpXSwgaSwgb2JqZWN0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gb2JqZWN0XG4gICAgZm9yIChpIGluIG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3RbaV0sIGksIG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYW4gYXJyYXk6IGFsbCBvYmplY3RzIHByb3BlcnRpZXMgYXJlIHB1dCBpbnRvIHRoZVxuICogYXJyYXkuIFRoZSByZXN1bHRpbmcgYXJyYXkgaXMgdW5vcmRlcmVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqL1xuZXhwb3J0cy50b0FycmF5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICB2YXIgYXJyYXkgPSBbXTtcblxuICBmb3IgKHZhciBwcm9wIGluIG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcCkpIGFycmF5LnB1c2gob2JqZWN0W3Byb3BdKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGEgcHJvcGVydHkgaW4gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cbmV4cG9ydHMudXBkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChvYmplY3Rba2V5XSAhPT0gdmFsdWUpIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaHJvdHRsZSB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gYmUgb25seSBleGVjdXRlZCBvbmNlIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge251bWJlcn0gd2FpdCAgICBUaW1lIGluIG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMge2Z1bmN0aW9ufSBSZXR1cm5zIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqL1xuZXhwb3J0cy50aHJvdHRsZSA9IGZ1bmN0aW9uIChmbiwgd2FpdCkge1xuICB2YXIgdGltZW91dCA9IG51bGw7XG4gIHZhciBuZWVkRXhlY3V0aW9uID0gZmFsc2U7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHRocm90dGxlZCAoKSB7XG4gICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICBuZWVkRXhlY3V0aW9uID0gZmFsc2U7XG4gICAgICBmbigpO1xuXG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmIChuZWVkRXhlY3V0aW9uKSB7XG4gICAgICAgICAgdGhyb3R0bGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHdhaXQpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbmVlZEV4ZWN1dGlvbiA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFkZCBhbmQgZXZlbnQgbGlzdGVuZXIuIFdvcmtzIGZvciBhbGwgYnJvd3NlcnNcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgIGVsZW1lbnQgICAgQW4gaHRtbCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICBhY3Rpb24gICAgIFRoZSBhY3Rpb24sIGZvciBleGFtcGxlIFwiY2xpY2tcIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCB0aGUgcHJlZml4IFwib25cIlxuICogQHBhcmFtIHtmdW5jdGlvbn0gICAgbGlzdGVuZXIgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFt1c2VDYXB0dXJlXVxuICovXG5leHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgaWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZClcbiAgICAgIHVzZUNhcHR1cmUgPSBmYWxzZTtcblxuICAgIGlmIChhY3Rpb24gPT09IFwibW91c2V3aGVlbFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgPj0gMCkge1xuICAgICAgYWN0aW9uID0gXCJET01Nb3VzZVNjcm9sbFwiOyAgLy8gRm9yIEZpcmVmb3hcbiAgICB9XG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5hdHRhY2hFdmVudChcIm9uXCIgKyBhY3Rpb24sIGxpc3RlbmVyKTsgIC8vIElFIGJyb3dzZXJzXG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYW4gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSAgICAgZWxlbWVudCAgICAgICAgIEFuIGh0bWwgZG9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIGFjdGlvbiAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQsIGZvciBleGFtcGxlIFwibW91c2Vkb3duXCJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259ICAgIGxpc3RlbmVyICAgICAgICBUaGUgbGlzdGVuZXIgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFt1c2VDYXB0dXJlXVxuICovXG5leHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgLy8gbm9uLUlFIGJyb3dzZXJzXG4gICAgaWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZClcbiAgICAgIHVzZUNhcHR1cmUgPSBmYWxzZTtcblxuICAgIGlmIChhY3Rpb24gPT09IFwibW91c2V3aGVlbFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgPj0gMCkge1xuICAgICAgYWN0aW9uID0gXCJET01Nb3VzZVNjcm9sbFwiOyAgLy8gRm9yIEZpcmVmb3hcbiAgICB9XG5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSUUgYnJvd3NlcnNcbiAgICBlbGVtZW50LmRldGFjaEV2ZW50KFwib25cIiArIGFjdGlvbiwgbGlzdGVuZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbmNlbHMgdGhlIGV2ZW50IGlmIGl0IGlzIGNhbmNlbGFibGUsIHdpdGhvdXQgc3RvcHBpbmcgZnVydGhlciBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQuXG4gKi9cbmV4cG9ydHMucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKCFldmVudClcbiAgICBldmVudCA9IHdpbmRvdy5ldmVudDtcblxuICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAgLy8gbm9uLUlFIGJyb3dzZXJzXG4gIH1cbiAgZWxzZSB7XG4gICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTsgIC8vIElFIGJyb3dzZXJzXG4gIH1cbn07XG5cbi8qKlxuICogR2V0IEhUTUwgZWxlbWVudCB3aGljaCBpcyB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9IHRhcmdldCBlbGVtZW50XG4gKi9cbmV4cG9ydHMuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIGNvZGUgZnJvbSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgaWYgKCFldmVudCkge1xuICAgIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuICB9XG5cbiAgdmFyIHRhcmdldDtcblxuICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICB9XG4gIGVsc2UgaWYgKGV2ZW50LnNyY0VsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSBldmVudC5zcmNFbGVtZW50O1xuICB9XG5cbiAgaWYgKHRhcmdldC5ub2RlVHlwZSAhPSB1bmRlZmluZWQgJiYgdGFyZ2V0Lm5vZGVUeXBlID09IDMpIHtcbiAgICAvLyBkZWZlYXQgU2FmYXJpIGJ1Z1xuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZ2l2ZW4gZWxlbWVudCBjb250YWlucyBnaXZlbiBwYXJlbnQgc29tZXdoZXJlIGluIHRoZSBET00gdHJlZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICovXG5leHBvcnRzLmhhc1BhcmVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQpIHtcbiAgdmFyIGUgPSBlbGVtZW50O1xuXG4gIHdoaWxlIChlKSB7XG4gICAgaWYgKGUgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGUgPSBlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnRzLm9wdGlvbiA9IHt9O1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgYm9vbGVhblxuICogQHBhcmFtIHtCb29sZWFuIHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWZhdWx0VmFsdWVdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbFxuICovXG5leHBvcnRzLm9wdGlvbi5hc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgIT0gZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIG51bWJlclxuICogQHBhcmFtIHtCb29sZWFuIHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IG51bWJlclxuICovXG5leHBvcnRzLm9wdGlvbi5hc051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgfHwgZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZyB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IFtkZWZhdWx0VmFsdWVdXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJcbiAqL1xuZXhwb3J0cy5vcHRpb24uYXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc2l6ZSBvciBsb2NhdGlvbiBpbnRvIGEgc3RyaW5nIHdpdGggcGl4ZWxzIG9yIGEgcGVyY2VudGFnZVxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge1N0cmluZ30gc2l6ZVxuICovXG5leHBvcnRzLm9wdGlvbi5hc1NpemUgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cblxuICBpZiAoZXhwb3J0cy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZWxzZSBpZiAoZXhwb3J0cy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH0gZG9tXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzRWxlbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZSB8fCBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjIzODM4L3JnYi10by1oZXgtYW5kLWhleC10by1yZ2JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4XG4gKiBAcmV0dXJucyB7e3I6ICosIGc6ICosIGI6ICp9fSB8IDI1NSByYW5nZVxuICovXG5leHBvcnRzLmhleFRvUkdCID0gZnVuY3Rpb24gKGhleCkge1xuICAvLyBFeHBhbmQgc2hvcnRoYW5kIGZvcm0gKGUuZy4gXCIwM0ZcIikgdG8gZnVsbCBmb3JtIChlLmcuIFwiMDAzM0ZGXCIpXG4gIHZhciBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gIGhleCA9IGhleC5yZXBsYWNlKHNob3J0aGFuZFJlZ2V4LCBmdW5jdGlvbiAobSwgciwgZywgYikge1xuICAgIHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7XG4gIH0pO1xuICB2YXIgcmVzdWx0ID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleCk7XG4gIHJldHVybiByZXN1bHQgPyB7XG4gICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXG4gICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxNiksXG4gICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxNilcbiAgfSA6IG51bGw7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgY29sb3IgaW4gaGV4IGZvcm1hdCBvciByZ2IoKSBvciByZ2JhKCkgZm9ybWF0IGFuZCBvdmVycmlkZXMgdGhlIG9wYWNpdHkuIFJldHVybnMgcmdiYSgpIHN0cmluZy5cbiAqIEBwYXJhbSBjb2xvclxuICogQHBhcmFtIG9wYWNpdHlcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnRzLm92ZXJyaWRlT3BhY2l0eSA9IGZ1bmN0aW9uIChjb2xvciwgb3BhY2l0eSkge1xuICBpZiAoY29sb3IuaW5kZXhPZihcInJnYmFcIikgIT0gLTEpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgZWxzZSBpZiAoY29sb3IuaW5kZXhPZihcInJnYlwiKSAhPSAtMSkge1xuICAgIHZhciByZ2IgPSBjb2xvci5zdWJzdHIoY29sb3IuaW5kZXhPZihcIihcIikgKyAxKS5yZXBsYWNlKFwiKVwiLCBcIlwiKS5zcGxpdChcIixcIik7XG4gICAgcmV0dXJuIFwicmdiYShcIiArIHJnYlswXSArIFwiLFwiICsgcmdiWzFdICsgXCIsXCIgKyByZ2JbMl0gKyBcIixcIiArIG9wYWNpdHkgKyBcIilcIlxuICB9XG4gIGVsc2Uge1xuICAgIHZhciByZ2IgPSBleHBvcnRzLmhleFRvUkdCKGNvbG9yKTtcbiAgICBpZiAocmdiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiLnIgKyBcIixcIiArIHJnYi5nICsgXCIsXCIgKyByZ2IuYiArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSByZWQgICAgIDAgLS0gMjU1XG4gKiBAcGFyYW0gZ3JlZW4gICAwIC0tIDI1NVxuICogQHBhcmFtIGJsdWUgICAgMCAtLSAyNTVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0cy5SR0JUb0hleCA9IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlKSB7XG4gIHJldHVybiBcIiNcIiArICgoMSA8PCAyNCkgKyAocmVkIDw8IDE2KSArIChncmVlbiA8PCA4KSArIGJsdWUpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBjb2xvciBwcm9wZXJ0eSBpbnRvIGFuIG9iamVjdCB3aXRoIGJvcmRlciwgYmFja2dyb3VuZCwgYW5kXG4gKiBoaWdobGlnaHQgY29sb3JzXG4gKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZ30gY29sb3JcbiAqIEByZXR1cm4ge09iamVjdH0gY29sb3JPYmplY3RcbiAqL1xuZXhwb3J0cy5wYXJzZUNvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHZhciBjO1xuICBpZiAoZXhwb3J0cy5pc1N0cmluZyhjb2xvcikgPT09IHRydWUpIHtcbiAgICBpZiAoZXhwb3J0cy5pc1ZhbGlkUkdCKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIHJnYiA9IGNvbG9yLnN1YnN0cig0KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNSkuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBwYXJzZUludCh2YWx1ZSkgfSk7XG4gICAgICBjb2xvciA9IGV4cG9ydHMuUkdCVG9IZXgocmdiWzBdLCByZ2JbMV0sIHJnYlsyXSk7XG4gICAgfVxuICAgIGlmIChleHBvcnRzLmlzVmFsaWRIZXgoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICB2YXIgaHN2ID0gZXhwb3J0cy5oZXhUb0hTVihjb2xvcik7XG4gICAgICB2YXIgbGlnaHRlckNvbG9ySFNWID0geyBoOiBoc3YuaCwgczogaHN2LnMgKiAwLjgsIHY6IE1hdGgubWluKDEsIGhzdi52ICogMS4wMikgfTtcbiAgICAgIHZhciBkYXJrZXJDb2xvckhTViA9IHsgaDogaHN2LmgsIHM6IE1hdGgubWluKDEsIGhzdi5zICogMS4yNSksIHY6IGhzdi52ICogMC44IH07XG4gICAgICB2YXIgZGFya2VyQ29sb3JIZXggPSBleHBvcnRzLkhTVlRvSGV4KGRhcmtlckNvbG9ySFNWLmgsIGRhcmtlckNvbG9ySFNWLnMsIGRhcmtlckNvbG9ySFNWLnYpO1xuICAgICAgdmFyIGxpZ2h0ZXJDb2xvckhleCA9IGV4cG9ydHMuSFNWVG9IZXgobGlnaHRlckNvbG9ySFNWLmgsIGxpZ2h0ZXJDb2xvckhTVi5zLCBsaWdodGVyQ29sb3JIU1Yudik7XG4gICAgICBjID0ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleCxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogbGlnaHRlckNvbG9ySGV4LFxuICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBsaWdodGVyQ29sb3JIZXgsXG4gICAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGMgPSB7XG4gICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLFxuICAgICAgICBib3JkZXI6IGNvbG9yLFxuICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgICBib3JkZXI6IGNvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgICAgYm9yZGVyOiBjb2xvclxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBjID0ge307XG4gICAgYy5iYWNrZ3JvdW5kID0gY29sb3IuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQ7XG4gICAgYy5ib3JkZXIgPSBjb2xvci5ib3JkZXIgfHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcoY29sb3IuaGlnaGxpZ2h0KSkge1xuICAgICAgYy5oaWdobGlnaHQgPSB7XG4gICAgICAgIGJvcmRlcjogY29sb3IuaGlnaGxpZ2h0LFxuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvci5oaWdobGlnaHRcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjLmhpZ2hsaWdodCA9IHt9O1xuICAgICAgYy5oaWdobGlnaHQuYmFja2dyb3VuZCA9IGNvbG9yLmhpZ2hsaWdodCAmJiBjb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQ7XG4gICAgICBjLmhpZ2hsaWdodC5ib3JkZXIgPSBjb2xvci5oaWdobGlnaHQgJiYgY29sb3IuaGlnaGxpZ2h0LmJvcmRlciB8fCB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcoY29sb3IuaG92ZXIpKSB7XG4gICAgICBjLmhvdmVyID0ge1xuICAgICAgICBib3JkZXI6IGNvbG9yLmhvdmVyLFxuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvci5ob3ZlclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGMuaG92ZXIgPSB7fTtcbiAgICAgIGMuaG92ZXIuYmFja2dyb3VuZCA9IGNvbG9yLmhvdmVyICYmIGNvbG9yLmhvdmVyLmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgICAgYy5ob3Zlci5ib3JkZXIgPSBjb2xvci5ob3ZlciAmJiBjb2xvci5ob3Zlci5ib3JkZXIgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjO1xufTtcblxuXG5cbi8qKlxuICogaHR0cDovL3d3dy5qYXZhc2NyaXB0ZXIubmV0L2ZhcS9yZ2IyaHN2Lmh0bVxuICpcbiAqIEBwYXJhbSByZWRcbiAqIEBwYXJhbSBncmVlblxuICogQHBhcmFtIGJsdWVcbiAqIEByZXR1cm5zIHsqfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydHMuUkdCVG9IU1YgPSBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZWQgPSByZWQgLyAyNTU7IGdyZWVuID0gZ3JlZW4gLyAyNTU7IGJsdWUgPSBibHVlIC8gMjU1O1xuICB2YXIgbWluUkdCID0gTWF0aC5taW4ocmVkLCBNYXRoLm1pbihncmVlbiwgYmx1ZSkpO1xuICB2YXIgbWF4UkdCID0gTWF0aC5tYXgocmVkLCBNYXRoLm1heChncmVlbiwgYmx1ZSkpO1xuXG4gIC8vIEJsYWNrLWdyYXktd2hpdGVcbiAgaWYgKG1pblJHQiA9PSBtYXhSR0IpIHtcbiAgICByZXR1cm4geyBoOiAwLCBzOiAwLCB2OiBtaW5SR0IgfTtcbiAgfVxuXG4gIC8vIENvbG9ycyBvdGhlciB0aGFuIGJsYWNrLWdyYXktd2hpdGU6XG4gIHZhciBkID0gKHJlZCA9PSBtaW5SR0IpID8gZ3JlZW4gLSBibHVlIDogKChibHVlID09IG1pblJHQikgPyByZWQgLSBncmVlbiA6IGJsdWUgLSByZWQpO1xuICB2YXIgaCA9IChyZWQgPT0gbWluUkdCKSA/IDMgOiAoKGJsdWUgPT0gbWluUkdCKSA/IDEgOiA1KTtcbiAgdmFyIGh1ZSA9IDYwICogKGggLSBkIC8gKG1heFJHQiAtIG1pblJHQikpIC8gMzYwO1xuICB2YXIgc2F0dXJhdGlvbiA9IChtYXhSR0IgLSBtaW5SR0IpIC8gbWF4UkdCO1xuICB2YXIgdmFsdWUgPSBtYXhSR0I7XG4gIHJldHVybiB7IGg6IGh1ZSwgczogc2F0dXJhdGlvbiwgdjogdmFsdWUgfTtcbn07XG5cbnZhciBjc3NVdGlsID0ge1xuICAvLyBzcGxpdCBhIHN0cmluZyB3aXRoIGNzcyBzdHlsZXMgaW50byBhbiBvYmplY3Qgd2l0aCBrZXkvdmFsdWVzXG4gIHNwbGl0OiBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgIHZhciBzdHlsZXMgPSB7fTtcblxuICAgIGNzc1RleHQuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlLnRyaW0oKSAhPSAnJykge1xuICAgICAgICB2YXIgcGFydHMgPSBzdHlsZS5zcGxpdCgnOicpO1xuICAgICAgICB2YXIga2V5ID0gcGFydHNbMF0udHJpbSgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0c1sxXS50cmltKCk7XG4gICAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9LFxuXG4gIC8vIGJ1aWxkIGEgY3NzIHRleHQgc3RyaW5nIGZyb20gYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlc1xuICBqb2luOiBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlcylcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ICsgJzogJyArIHN0eWxlc1trZXldO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCc7ICcpO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGVuZCBhIHN0cmluZyB3aXRoIGNzcyBzdHlsZXMgdG8gYW4gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzVGV4dFxuICovXG5leHBvcnRzLmFkZENzc1RleHQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY3NzVGV4dCkge1xuICB2YXIgY3VycmVudFN0eWxlcyA9IGNzc1V0aWwuc3BsaXQoZWxlbWVudC5zdHlsZS5jc3NUZXh0KTtcbiAgdmFyIG5ld1N0eWxlcyA9IGNzc1V0aWwuc3BsaXQoY3NzVGV4dCk7XG4gIHZhciBzdHlsZXMgPSBleHBvcnRzLmV4dGVuZChjdXJyZW50U3R5bGVzLCBuZXdTdHlsZXMpO1xuXG4gIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGNzc1V0aWwuam9pbihzdHlsZXMpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIGZyb20gYW4gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzVGV4dFxuICovXG5leHBvcnRzLnJlbW92ZUNzc1RleHQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY3NzVGV4dCkge1xuICB2YXIgc3R5bGVzID0gY3NzVXRpbC5zcGxpdChlbGVtZW50LnN0eWxlLmNzc1RleHQpO1xuICB2YXIgcmVtb3ZlU3R5bGVzID0gY3NzVXRpbC5zcGxpdChjc3NUZXh0KTtcblxuICBmb3IgKHZhciBrZXkgaW4gcmVtb3ZlU3R5bGVzKSB7XG4gICAgaWYgKHJlbW92ZVN0eWxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBkZWxldGUgc3R5bGVzW2tleV07XG4gICAgfVxuICB9XG5cbiAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gY3NzVXRpbC5qb2luKHN0eWxlcyk7XG59O1xuXG4vKipcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21qaWphY2tzb24vNTMxMTI1NlxuICogQHBhcmFtIGhcbiAqIEBwYXJhbSBzXG4gKiBAcGFyYW0gdlxuICogQHJldHVybnMge3tyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyfX1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLkhTVlRvUkdCID0gZnVuY3Rpb24gKGgsIHMsIHYpIHtcbiAgdmFyIHIsIGcsIGI7XG5cbiAgdmFyIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgdmFyIGYgPSBoICogNiAtIGk7XG4gIHZhciBwID0gdiAqICgxIC0gcyk7XG4gIHZhciBxID0gdiAqICgxIC0gZiAqIHMpO1xuICB2YXIgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcblxuICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgY2FzZSAwOiByID0gdiwgZyA9IHQsIGIgPSBwOyBicmVhaztcbiAgICBjYXNlIDE6IHIgPSBxLCBnID0gdiwgYiA9IHA7IGJyZWFrO1xuICAgIGNhc2UgMjogciA9IHAsIGcgPSB2LCBiID0gdDsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gcCwgZyA9IHEsIGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDQ6IHIgPSB0LCBnID0gcCwgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNTogciA9IHYsIGcgPSBwLCBiID0gcTsgYnJlYWs7XG4gIH1cblxuICByZXR1cm4geyByOiBNYXRoLmZsb29yKHIgKiAyNTUpLCBnOiBNYXRoLmZsb29yKGcgKiAyNTUpLCBiOiBNYXRoLmZsb29yKGIgKiAyNTUpIH07XG59O1xuXG5leHBvcnRzLkhTVlRvSGV4ID0gZnVuY3Rpb24gKGgsIHMsIHYpIHtcbiAgdmFyIHJnYiA9IGV4cG9ydHMuSFNWVG9SR0IoaCwgcywgdik7XG4gIHJldHVybiBleHBvcnRzLlJHQlRvSGV4KHJnYi5yLCByZ2IuZywgcmdiLmIpO1xufTtcblxuZXhwb3J0cy5oZXhUb0hTViA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgdmFyIHJnYiA9IGV4cG9ydHMuaGV4VG9SR0IoaGV4KTtcbiAgcmV0dXJuIGV4cG9ydHMuUkdCVG9IU1YocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59O1xuXG5leHBvcnRzLmlzVmFsaWRIZXggPSBmdW5jdGlvbiAoaGV4KSB7XG4gIHZhciBpc09rID0gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QoaGV4KTtcbiAgcmV0dXJuIGlzT2s7XG59O1xuXG5leHBvcnRzLmlzVmFsaWRSR0IgPSBmdW5jdGlvbiAocmdiKSB7XG4gIHJnYiA9IHJnYi5yZXBsYWNlKFwiIFwiLCBcIlwiKTtcbiAgdmFyIGlzT2sgPSAvcmdiXFwoKFxcZHsxLDN9KSwoXFxkezEsM30pLChcXGR7MSwzfSlcXCkvaS50ZXN0KHJnYik7XG4gIHJldHVybiBpc09rO1xufVxuZXhwb3J0cy5pc1ZhbGlkUkdCQSA9IGZ1bmN0aW9uIChyZ2JhKSB7XG4gIHJnYmEgPSByZ2JhLnJlcGxhY2UoXCIgXCIsIFwiXCIpO1xuICB2YXIgaXNPayA9IC9yZ2JhXFwoKFxcZHsxLDN9KSwoXFxkezEsM30pLChcXGR7MSwzfSksKC57MSwzfSlcXCkvaS50ZXN0KHJnYmEpO1xuICByZXR1cm4gaXNPaztcbn1cblxuLyoqXG4gKiBUaGlzIHJlY3Vyc2l2ZWx5IHJlZGlyZWN0cyB0aGUgcHJvdG90eXBlIG9mIEpTT04gb2JqZWN0cyB0byB0aGUgcmVmZXJlbmNlT2JqZWN0XG4gKiBUaGlzIGlzIHVzZWQgZm9yIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gcmVmZXJlbmNlT2JqZWN0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5zZWxlY3RpdmVCcmlkZ2VPYmplY3QgPSBmdW5jdGlvbiAoZmllbGRzLCByZWZlcmVuY2VPYmplY3QpIHtcbiAgaWYgKHR5cGVvZiByZWZlcmVuY2VPYmplY3QgPT0gXCJvYmplY3RcIikge1xuICAgIHZhciBvYmplY3RUbyA9IE9iamVjdC5jcmVhdGUocmVmZXJlbmNlT2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlZmVyZW5jZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShmaWVsZHNbaV0pKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0W2ZpZWxkc1tpXV0gPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG9iamVjdFRvW2ZpZWxkc1tpXV0gPSBleHBvcnRzLmJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3RbZmllbGRzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFRvO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgcmVjdXJzaXZlbHkgcmVkaXJlY3RzIHRoZSBwcm90b3R5cGUgb2YgSlNPTiBvYmplY3RzIHRvIHRoZSByZWZlcmVuY2VPYmplY3RcbiAqIFRoaXMgaXMgdXNlZCBmb3IgZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSByZWZlcmVuY2VPYmplY3RcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnRzLmJyaWRnZU9iamVjdCA9IGZ1bmN0aW9uIChyZWZlcmVuY2VPYmplY3QpIHtcbiAgaWYgKHR5cGVvZiByZWZlcmVuY2VPYmplY3QgPT0gXCJvYmplY3RcIikge1xuICAgIHZhciBvYmplY3RUbyA9IE9iamVjdC5jcmVhdGUocmVmZXJlbmNlT2JqZWN0KTtcbiAgICBmb3IgKHZhciBpIGluIHJlZmVyZW5jZU9iamVjdCkge1xuICAgICAgaWYgKHJlZmVyZW5jZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlZmVyZW5jZU9iamVjdFtpXSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgb2JqZWN0VG9baV0gPSBleHBvcnRzLmJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3RbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RUbztcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuXG4vKipcbiAqIHRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIG9wdGlvbnMgb2Ygc3Vib2JqZWN0cyBpbiB0aGUgb3B0aW9ucyBvYmplY3QuIEEgcmVxdWlyZW1lbnQgb2YgdGhlc2Ugc3Vib2JqZWN0c1xuICogaXMgdGhhdCB0aGV5IGhhdmUgYW4gJ2VuYWJsZWQnIGVsZW1lbnQgd2hpY2ggaXMgb3B0aW9uYWwgZm9yIHRoZSB1c2VyIGJ1dCBtYW5kYXRvcnkgZm9yIHRoZSBwcm9ncmFtLlxuICpcbiAqIEBwYXJhbSBbb2JqZWN0XSBtZXJnZVRhcmdldCB8IHRoaXMgaXMgZWl0aGVyIHRoaXMub3B0aW9ucyBvciB0aGUgb3B0aW9ucyB1c2VkIGZvciB0aGUgZ3JvdXBzLlxuICogQHBhcmFtIFtvYmplY3RdIG9wdGlvbnMgICAgIHwgb3B0aW9uc1xuICogQHBhcmFtIFtTdHJpbmddIG9wdGlvbiAgICAgIHwgdGhpcyBpcyB0aGUgb3B0aW9uIGtleSBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAobWVyZ2VUYXJnZXQsIG9wdGlvbnMsIG9wdGlvbiwgYWxsb3dEZWxldGlvbiA9IGZhbHNlLCBnbG9iYWxPcHRpb25zID0ge30pIHtcbiAgaWYgKG9wdGlvbnNbb3B0aW9uXSA9PT0gbnVsbCkge1xuICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0gPSBPYmplY3QuY3JlYXRlKGdsb2JhbE9wdGlvbnNbb3B0aW9uXSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKG9wdGlvbnNbb3B0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNbb3B0aW9uXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0uZW5hYmxlZCA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9uc1tvcHRpb25dLmVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zW29wdGlvbl0pIHtcbiAgICAgICAgICBpZiAob3B0aW9uc1tvcHRpb25dLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBtZXJnZVRhcmdldFtvcHRpb25dW3Byb3BdID0gb3B0aW9uc1tvcHRpb25dW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIGEgYmluYXJ5IHNlYXJjaCBmb3IgYSB2aXNpYmxlIGl0ZW0gaW4gYSBzb3J0ZWQgbGlzdC4gSWYgd2UgZmluZCBhIHZpc2libGUgaXRlbSwgdGhlIGNvZGUgdGhhdCB1c2VzXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgdGhlbiBpdGVyYXRlIGluIGJvdGggZGlyZWN0aW9ucyBvdmVyIHRoaXMgc29ydGVkIGxpc3QgdG8gZmluZCBhbGwgdmlzaWJsZSBpdGVtcy5cbiAqXG4gKiBAcGFyYW0ge0l0ZW1bXX0gb3JkZXJlZEl0ZW1zICAgICAgIHwgSXRlbXMgb3JkZXJlZCBieSBzdGFydFxuICogQHBhcmFtIHtmdW5jdGlvbn0gc2VhcmNoRnVuY3Rpb24gICB8IC0xIGlzIGxvd2VyLCAwIGlzIGZvdW5kLCAxIGlzIGhpZ2hlclxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGQyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5iaW5hcnlTZWFyY2hDdXN0b20gPSBmdW5jdGlvbiAob3JkZXJlZEl0ZW1zLCBzZWFyY2hGdW5jdGlvbiwgZmllbGQsIGZpZWxkMikge1xuICB2YXIgbWF4SXRlcmF0aW9ucyA9IDEwMDAwO1xuICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgdmFyIGxvdyA9IDA7XG4gIHZhciBoaWdoID0gb3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGxvdyA8PSBoaWdoICYmIGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcblxuICAgIHZhciBpdGVtID0gb3JkZXJlZEl0ZW1zW21pZGRsZV07XG4gICAgdmFyIHZhbHVlID0gKGZpZWxkMiA9PT0gdW5kZWZpbmVkKSA/IGl0ZW1bZmllbGRdIDogaXRlbVtmaWVsZF1bZmllbGQyXTtcblxuICAgIHZhciBzZWFyY2hSZXN1bHQgPSBzZWFyY2hGdW5jdGlvbih2YWx1ZSk7XG4gICAgaWYgKHNlYXJjaFJlc3VsdCA9PSAwKSB7IC8vIGppaGFhLCBmb3VuZCBhIHZpc2libGUgaXRlbSFcbiAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlYXJjaFJlc3VsdCA9PSAtMSkgeyAgLy8gaXQgaXMgdG9vIHNtYWxsIC0tPiBpbmNyZWFzZSBsb3dcbiAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgfVxuICAgIGVsc2UgeyAgLy8gaXQgaXMgdG9vIGJpZyAtLT4gZGVjcmVhc2UgaGlnaFxuICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgfVxuXG4gICAgaXRlcmF0aW9uKys7XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBhIGJpbmFyeSBzZWFyY2ggZm9yIGEgc3BlY2lmaWMgdmFsdWUgaW4gYSBzb3J0ZWQgYXJyYXkuIElmIGl0IGRvZXMgbm90IGV4aXN0IGJ1dCBpcyBpbiBiZXR3ZWVuIG9mXG4gKiB0d28gdmFsdWVzLCB3ZSByZXR1cm4gZWl0aGVyIHRoZSBvbmUgYmVmb3JlIG9yIHRoZSBvbmUgYWZ0ZXIsIGRlcGVuZGluZyBvbiB1c2VyIGlucHV0XG4gKiBJZiBpdCBpcyBmb3VuZCwgd2UgcmV0dXJuIHRoZSBpbmRleCwgZWxzZSAtMS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBvcmRlcmVkSXRlbXNcbiAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWRlUHJlZmVyZW5jZSAgICdiZWZvcmUnIG9yICdhZnRlcidcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmFyeVNlYXJjaFZhbHVlID0gZnVuY3Rpb24gKG9yZGVyZWRJdGVtcywgdGFyZ2V0LCBmaWVsZCwgc2lkZVByZWZlcmVuY2UpIHtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gIHZhciBsb3cgPSAwO1xuICB2YXIgaGlnaCA9IG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxO1xuICB2YXIgcHJldlZhbHVlLCB2YWx1ZSwgbmV4dFZhbHVlLCBtaWRkbGU7XG5cbiAgd2hpbGUgKGxvdyA8PSBoaWdoICYmIGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAvLyBnZXQgYSBuZXcgZ3Vlc3NcbiAgICBtaWRkbGUgPSBNYXRoLmZsb29yKDAuNSAqIChoaWdoICsgbG93KSk7XG4gICAgcHJldlZhbHVlID0gb3JkZXJlZEl0ZW1zW01hdGgubWF4KDAsIG1pZGRsZSAtIDEpXVtmaWVsZF07XG4gICAgdmFsdWUgPSBvcmRlcmVkSXRlbXNbbWlkZGxlXVtmaWVsZF07XG4gICAgbmV4dFZhbHVlID0gb3JkZXJlZEl0ZW1zW01hdGgubWluKG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxLCBtaWRkbGUgKyAxKV1bZmllbGRdO1xuXG4gICAgaWYgKHZhbHVlID09IHRhcmdldCkgeyAvLyB3ZSBmb3VuZCB0aGUgdGFyZ2V0XG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmV2VmFsdWUgPCB0YXJnZXQgJiYgdmFsdWUgPiB0YXJnZXQpIHsgIC8vIHRhcmdldCBpcyBpbiBiZXR3ZWVuIG9mIHRoZSBwcmV2aW91cyBhbmQgdGhlIGN1cnJlbnRcbiAgICAgIHJldHVybiBzaWRlUHJlZmVyZW5jZSA9PSAnYmVmb3JlJyA/IE1hdGgubWF4KDAsIG1pZGRsZSAtIDEpIDogbWlkZGxlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA8IHRhcmdldCAmJiBuZXh0VmFsdWUgPiB0YXJnZXQpIHsgLy8gdGFyZ2V0IGlzIGluIGJldHdlZW4gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBuZXh0XG4gICAgICByZXR1cm4gc2lkZVByZWZlcmVuY2UgPT0gJ2JlZm9yZScgPyBtaWRkbGUgOiBNYXRoLm1pbihvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMSwgbWlkZGxlICsgMSk7XG4gICAgfVxuICAgIGVsc2UgeyAgLy8gZGlkbnQgZmluZCB0aGUgdGFyZ2V0LCB3ZSBuZWVkIHRvIGNoYW5nZSBvdXIgYm91bmRhcmllcy5cbiAgICAgIGlmICh2YWx1ZSA8IHRhcmdldCkgeyAvLyBpdCBpcyB0b28gc21hbGwgLS0+IGluY3JlYXNlIGxvd1xuICAgICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7ICAvLyBpdCBpcyB0b28gYmlnIC0tPiBkZWNyZWFzZSBoaWdoXG4gICAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRpb24rKztcbiAgfVxuXG4gIC8vIGRpZG50IGZpbmQgYW55dGhpbmcuIFJldHVybiAtMS5cbiAgcmV0dXJuIC0xO1xufTtcblxuLypcbiAqIEVhc2luZyBGdW5jdGlvbnMgLSBpbnNwaXJlZCBmcm9tIGh0dHA6Ly9naXptYS5jb20vZWFzaW5nL1xuICogb25seSBjb25zaWRlcmluZyB0aGUgdCB2YWx1ZSBmb3IgdGhlIHJhbmdlIFswLCAxXSA9PiBbMCwgMV1cbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dyZS8xNjUwMjk0XG4gKi9cbmV4cG9ydHMuZWFzaW5nRnVuY3Rpb25zID0ge1xuICAvLyBubyBlYXNpbmcsIG5vIGFjY2VsZXJhdGlvblxuICBsaW5lYXI6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHRcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWFkOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogdFxuICB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVhZDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqICgyIC0gdClcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgPCAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdFxuICB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuICgtLXQpICogdCAqIHQgKyAxXG4gIH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMVxuICB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gMSAtICgtLXQpICogdCAqIHQgKiB0XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IC41ID8gOCAqIHQgKiB0ICogdCAqIHQgOiAxIC0gOCAqICgtLXQpICogdCAqIHQgKiB0XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWludDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gMSArICgtLXQpICogdCAqIHQgKiB0ICogdFxuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgPCAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAoLS10KSAqIHQgKiB0ICogdCAqIHRcbiAgfVxufTtcbiJdfQ==
},{"./module/moment":20,"./module/uuid":21}]},{},[1])(1)
});
(function() {
    'use strict';

    var module = angular.module('storytools.core.boxes', [
    ]);

    var boxes = storytools.core.maps.boxes;

    function StoryBoxLayerManager() {
        this.storyBoxes = [];
        this.map = null;
    }
    StoryBoxLayerManager.prototype.boxesChanged = function(boxes, action) {
        var i;
        if (action == 'delete') {
            for (i = 0; i < boxes.length; i++) {
                var box = boxes[i];
                for (var j = 0, jj = this.storyBoxes.length; j < jj; j++) {
                    if (this.storyBoxes[j].id == box.id) {
                        this.storyBoxes.splice(j, 1);
                        break;
                    }
                }
            }
        } else if (action == 'add') {
            for (i = 0; i < boxes.length; i++) {
                this.storyBoxes.push(boxes[i]);
            }
        } else if (action == 'change') {
            // provided edits could be used to optimize below
        } else {
            throw new Error('action? :' + action);
        }
        // @todo optimize by looking at changes
        var times = this.storyBoxes.map(function(p) {
            return p.range;
        });
        this.map.storyBoxesLayer.set('times', times);
        this.map.storyBoxesLayer.set('features', this.storyBoxes);
    };
    StoryBoxLayerManager.prototype.loadFromGeoJSON = function(geojson, projection, overwrite) {

        if (overwrite){
             this.storyBoxes = [];
        }

        if (geojson && geojson.features) {
            var loaded = boxes.loadFromGeoJSON(geojson, projection);
            this.boxesChanged(loaded, 'add', true);
        }
    };

    module.service('StoryBoxLayerManager', StoryBoxLayerManager);

    module.constant('StoryBox', boxes.Box);

})();

(function() {
  var module = angular.module('storytools.core.loading.directives', []);

  module.directive('stLoading',
      function() {
        return {
          restrict: 'C',
          templateUrl: 'loading/loading.html',
          scope: {
            spinnerHidden: '='
          },
          link: function(scope, element, attrs) {
            scope.spinnerWidth = 3;
            scope.spinnerRadius = 28;
            if (goog.isDefAndNotNull(attrs.spinnerWidth)) {
              scope.spinnerWidth = parseInt(attrs.spinnerWidth, 10);
            }
            if (goog.isDefAndNotNull(attrs.spinnerRadius)) {
              scope.spinnerRadius = parseInt(attrs.spinnerRadius, 10);
            }
            var loading = element.find('.loading');
            loading.css('width', scope.spinnerRadius + 'px');
            loading.css('height', scope.spinnerRadius + 'px');
            loading.css('margin', '-' + scope.spinnerRadius / 2 + 'px 0 0 -' + scope.spinnerRadius / 2 + 'px');

            var loadingSpinner = element.find('.loading-spinner');
            loadingSpinner.css('width', (scope.spinnerRadius - scope.spinnerWidth) + 'px');
            loadingSpinner.css('height', (scope.spinnerRadius - scope.spinnerWidth) + 'px');
            loadingSpinner.css('border', scope.spinnerWidth + 'px solid');
            loadingSpinner.css('border-radius', (scope.spinnerRadius / 2) + 'px');

            var mask = element.find('.mask');
            mask.css('width', (scope.spinnerRadius / 2) + 'px');
            mask.css('height', (scope.spinnerRadius / 2) + 'px');

            var spinner = element.find('.spinner');
            spinner.css('width', scope.spinnerRadius + 'px');
            spinner.css('height', scope.spinnerRadius + 'px');

          }
        };
      });
}());
(function() {
  'use strict';
   var module = angular.module('storytools.core.loading', [
        'storytools.core.loading.directives'
    ]);
})();

(function() {
      'use strict';

    /**
     * @namespace storytools.core.legend.directives
     */
  var module = angular.module('storytools.core.legend.directives', []);

  var legendOpen = false;

  module.directive('stLegend',
      ["$rootScope", "MapManager", function($rootScope, MapManager) {
        return {
          restrict: 'C',
          replace: true,
          templateUrl: 'legend/legend.html',
          // The linking function will add behavior to the template
          link: function(scope, element) {
            scope.mapManager = MapManager;

            var openLegend = function() {
              angular.element(document.getElementById('legend-container'))[0].style.visibility = 'visible';
              angular.element(document.getElementById('legend-panel'))[0].style.display = 'block';
              legendOpen = true;
            };
            var closeLegend = function() {
              angular.element(document.getElementById('legend-panel'))[0].style.display = 'none';
              legendOpen = false;

              //the timeout is so the transition will finish before hiding the div
              setTimeout(function() {
                angular.element('#legend-container')[0].style.visibility = 'hidden';
              }, 350);
            };

            scope.toggleLegend = function() {
              if (legendOpen === false) {
                console.log(angular.element(document.getElementsByClassName('legend-item')));
                //if (angular.element(document.getElementsByClassName('.legend-item')).length > 0) {
                  openLegend();
                //}
              } else {
                closeLegend();
              }
            };

            scope.getLegendUrl = function(layer) {
              var url = null;
              var server = '/geoserver/wms';
              var layer_name = layer.get('typeName') || layer.get('id');
              url = server + '?request=GetLegendGraphic&format=image%2Fpng&width=20&height=20&layer=' +
                  layer_name + '&transparent=true&legend_options=fontColor:0xFFFFFF;' +
                  'fontAntiAliasing:true;fontSize:14;fontStyle:bold;';
              //if (layer.get('params').STYLES) {
               // url += '&style=' + layer.get('params').STYLES;
              //}
              return url;
            };

            scope.$on('layer-added', function() {
              if (legendOpen === false) {
                openLegend();
              }
            });

            scope.$on('layerRemoved', function() {
              //close the legend if the last layer is removed
              if (legendOpen === true && angular.element('.legend-item').length == 1) {
                closeLegend();
              }
            });
          }
        };
      }]);
}());
(function() {
  'use strict';
   var module = angular.module('storytools.core.legend', [
        'storytools.core.legend.directives'
    ]);
})();
(function() {
    'use strict';

    var module = angular.module('storytools.core.mapstory', [
      'storytools.core.mapstory.services'
    ]);

})();

(function() {
    'use strict';

    /**
     * @namespace storytools.core.measure.directives
     */
    var module = angular.module('storytools.core.measure.directives', []);


    module.directive('stMeasurepanel',
         ["$rootScope", "MapManager", function($rootScope, MapManager) {
            return {
                replace: true,
                templateUrl: 'measure/measurepanel.tpl.html',
                // The linking function will add behavior to the template
                link: function(scope, element) {
                    scope.mapManager = MapManager;

                    /** Handy flag for when measuring is happening */
                    scope.isMeasuring = false;

                    /** measuring feature. */
                    scope.feature = null;

                    /** label for hte output */
                    scope.measureType = '';

                    /** measuring 'source' */
                    scope.source = new ol.source.Vector();

                    /** measuring layer */
                    scope.layer = new ol.layer.Vector({
                        source: scope.source
                    });

                    /** which units to use as output. */
                    scope.units = 'm';

                    /** array of units options */
                    scope.unitTypes = [
                        {type: 'm', label: 'M/KM'},
                        {type: 'mi', label: 'Mi'},
                        {type: 'ft', label: 'Ft'}
                    ];

                    /** Change the units */
                    scope.changeUnits = function(newUnits) {
                        scope.units = newUnits;
                    };

                    /** A formatted string describing the measure */
                    scope.measureLabel = 0;

                    /** Formatted units label. */
                    scope.unitsLabel = '';

                    /** The interaction for drawing on the map,
                     *   defaults to null, set when measuring is started.
                     */
                    scope.interaction = null;

                    /** Create the interaction.
                     */
                    var createInteraction = function(measureType) {
                        return new ol.interaction.Draw({
                            source: scope.source,
                            type: (measureType == 'line' ? 'LineString' : 'Polygon')
                        });
                    };

                    /** This comes striaght from the OL Measuring example.
                     *
                     *  http://openlayers.org/en/latest/examples/measure.html
                     *
                     */
                    var wgs84Sphere = new ol.Sphere(6378137);

                    /** The map's projection should not change. */
                    var mapProjection = MapManager.storyMap.getMap().getView().getProjection();

                    /** When the measure has changed, update the UI.
                     *
                     *  Calculations are always done geodesically.
                     *
                     */
                    scope.updateMeasure = function() {
                        var geo = scope.feature.getGeometry();
                        // convert the geography to wgs84
                        var wgs84_geo = geo.clone().transform(mapProjection, 'EPSG:4326');
                        var coords = [];

                        if (geo instanceof ol.geom.Polygon) {
                            // get the polygon coordinates
                            coords = wgs84_geo.getLinearRing(0).getCoordinates();
                            // ensure polygon has at least 3 points.
                            if (coords.length > 2) {
                                // and calculate the area
                                var area = Math.abs(wgs84Sphere.geodesicArea(coords));
                                // convert to km's.
                                if (area > 1000000 && scope.units == 'm') {
                                    // m -> km
                                    area = area / 1000000;
                                    scope.unitsLabel = 'km^2';
                                } else if (scope.units == 'ft') {
                                    area = area * 10.7639;
                                    scope.unitsLabel = 'ft^2';
                                } else if (scope.units == 'mi') {
                                    area = (area / 1000) * 0.000386102;
                                    scope.unitsLabel = 'mi^2';
                                } else {
                                    scope.unitsLabel = 'm^2';
                                }
                                scope.measureLabel = area;
                                scope.feature.set('measureLabel', area);

                                // this updates outside of the standard angular event cycle,
                                //  so it is necessary to notify angular to update.
                                scope.$apply();
                            }
                        } else {
                            var length = 0;
                            coords = wgs84_geo.getCoordinates();
                            if (coords.length > 1) {
                                for (var i = 1, ii = coords.length; i < ii; i++) {
                                    length += wgs84Sphere.haversineDistance(coords[i - 1], coords[i]);
                                }

                                if (length > 1000 && scope.units == 'm') {
                                    // m -> km
                                    length = length / 1000;
                                    scope.unitsLabel = 'km';
                                } else if (scope.units == 'ft') {
                                    // m -> ft
                                    length = length * 3.28084;
                                    scope.unitsLabel = 'ft';
                                } else if (scope.units == 'mi') {
                                    // m -> mi
                                    length = length / 1609;
                                    scope.unitsLabel = 'mi';
                                } else {
                                    // assumes meters
                                    scope.unitsLabel = 'm';
                                }

                                scope.measureLabel = length;
                                scope.feature.set('measureLabel', length);
                                // see the note above re: forcing the update.
                                scope.$apply();
                            }
                        }
                    };

                    /** Initiate the measuring tool
                     *
                     *  @param {String} measureType 'line' or 'area' to determine what
                     *                              type of measuring should be done.
                     */
                    scope.startMeasuring = function(measureType) {
                        // cancel whatever current measuring is happening.
                        if (scope.isMeasuring) {
                            scope.stopMeasuring();
                        }

                        scope.measureType = measureType;

                        // add the measuring layer to the map.
                        MapManager.storyMap.getMap().addLayer(scope.layer);

                        // configure and add the interaction
                        scope.interaction = createInteraction(measureType);
                        MapManager.storyMap.getMap().addInteraction(scope.interaction);

                        scope.interaction.on('drawstart', function(event) {
                            // clear out the drawing of a feature whenever
                            //  a drawing starts.
                            scope.source.clear();

                            // reset the measure label.
                            scope.measureLabel = 0;

                            // configure the listener for the geometry changes.
                            scope.feature = event.feature;
                            scope.feature.set('id', 'measure-tool');
                            scope.feature.getGeometry().on('change', scope.updateMeasure);
                        });

                        scope.isMeasuring = true;
                    };

                    /** Stop the measuring process.
                     *
                     *  Cleans up the artifacts
                     *   of the measure tool from the map.
                     */
                    scope.stopMeasuring = function() {
                        // remove the layer from the map
                        MapManager.storyMap.getMap().removeLayer(scope.layer);

                        // clear the measure.
                        scope.measureLabel = 0;

                        // remove the interaction.
                        if (scope.interaction !== null) {
                            MapManager.storyMap.getMap().removeInteraction(scope.interaction);
                        }

                        // reset the measure type
                        scope.measureType = '';

                        // flag measuring as 'stopped'
                        scope.isMeasuring = false;
                    };

                }
            };
        }]);
}());
(function() {
  'use strict';
   var module = angular.module('storytools.core.measure', [
        'storytools.core.measure.directives'
    ]);
})();
(function() {
    'use strict';

    /**
     * @namespace storytools.core.ogc.directives
     */
    var module = angular.module('storytools.core.ogc.directives', []);

    module.directive('featureinfobox', ["MapManager", "$rootScope", "stFeatureInfoService", function(MapManager, $rootScope, stFeatureInfoService) {

            return {
                replace: false,
                restrict: 'A',
                templateUrl: 'ogc/featureinfobox.tpl.html',
                link: function(scope, el, atts) {
                    scope.mapManager = MapManager;
                    scope.featureInfoService = stFeatureInfoService;

                    scope.isUrl = function(str) {
                        if (!/^(f|ht)tps?:\/\//i.test(str)) {
                            return false;
                        }
                        return true;
                    };

                    scope.isShowingAttributes = function() {
                        var schema = null;//featureManagerService.getSelectedLayer().get('metadata').schema;

                        // if there is no schema, do not hide attributes
                        if (!goog.isDefAndNotNull(schema)) {
                            return true;
                        }

                        var properties = featureInfoService.getSelectedItemProperties();
                        for (var index = 0; index < properties.length; index++) {
                            if (goog.isDefAndNotNull(schema[properties[index][0]]) && schema[properties[index][0]].visible) {
                                return true;
                            }
                        }
                        return false;
                    };

                    scope.isAttributeVisible = function(property) {
                        var schema = null;//featureManagerService.getSelectedLayer().get('metadata').schema;

                        // if there is no schema, show the attribute. only filter out if there is schema and attr is set to hidden
                        if (!goog.isDefAndNotNull(schema) || !schema.hasOwnProperty(property)) {
                            return true;
                        }

                        return schema[property].visible;
                    };
                }
            };
        }]
    );
}());
(function() {
  'use strict';

  var module = angular.module('storytools.core.ogc', ['storytools.core.ogc.directives', 'storytools.core.ogc.services']);

  // @todo - provisional default story pins style
  var defaultStyle = [new ol.style.Style({
    fill: new ol.style.Fill({color: 'rgba(255, 0, 0, 0.1)'}),
    stroke: new ol.style.Stroke({color: 'red', width: 1}),
    image: new ol.style.Circle({
      radius: 10,
      fill: new ol.style.Fill({color: 'rgba(255, 0, 0, 0.1)'}),
      stroke: new ol.style.Stroke({color: 'red', width: 1})
    })
  })];

  var enabled_ = true;

  $('#map .metric-scale-line').css('bottom', '-=40px');
  $('#map .imperial-scale-line').css('bottom', '-=40px');
  $('#map .nautical-scale-line').css('bottom', '-=40px');
  $('#map .ol-mouse-position').css('bottom', '-=40px');
  $('#switch-coords-border').css('bottom', '-=40px');


  var nauticalScale = new ol.control.ScaleLine({className: 'nautical-scale-line ol-scale-line', units: ol.control.ScaleLineUnits.NAUTICAL,
        render: function(mapEvent) {
          //Have to write a custom render function as this scale always needs to display 20 nautical miles
          var frameState = mapEvent.frameState;
          if (!frameState) {
            this.viewState_ = null;
          } else {
            this.viewState_ = frameState.viewState;
          }


          var viewState = this.viewState_;

          if (!viewState) {
            if (this.renderedVisible_) {
              this.element_.style.display = 'none';
              this.renderedVisible_ = false;
            }
            return;
          }

          var center = viewState.center;
          var projection = viewState.projection;
          var metersPerUnit = projection.getMetersPerUnit();
          var pointResolution =
              projection.getPointResolution(viewState.resolution, center) *
              metersPerUnit;

          pointResolution /= 1852;
          var suffix = 'nm';

          var nauticalMiles = 20;
          var width = Math.round(nauticalMiles / pointResolution);

          var html = nauticalMiles + ' ' + suffix;
          if (this.renderedHTML_ != html) {
            this.innerElement_.innerHTML = html;
            this.renderedHTML_ = html;
          }

          //If the scale is wider than 60% the screen, hide it
          //If it's smaller than 15 pixels, hide it as the text won't fit inside the scale
          if (width > mapEvent.frameState.size[0] * 0.6 || width < 15) {
            this.element_.style.display = 'none';
            this.renderedVisible_ = false;
            return;
          }

          if (this.renderedWidth_ != width) {
            this.innerElement_.style.width = width + 'px';
            this.renderedWidth_ = width;
          }

          if (!this.renderedVisible_) {
            this.element_.style.display = '';
            this.renderedVisible_ = true;
          }

        }});


  function StoryMap(data) {
    ol.Object.call(this, data);
    this.map_ = new ol.Map({target: data.target, pixelRatio: 1,
        controls: ol.control.defaults().extend([
      /*new ol.control.ZoomSlider(),*/
      new ol.control.MousePosition({
        projection: 'EPSG:4326',
        coordinateFormat: ol.coordinate.toStringHDMS
      }),
      new ol.control.ScaleLine({className: 'metric-scale-line ol-scale-line',
        units: ol.control.ScaleLineUnits.METRIC}),
      new ol.control.ScaleLine({className: 'imperial-scale-line ol-scale-line',
        units: ol.control.ScaleLineUnits.IMPERIAL}),
            nauticalScale
    ])});
    this.overlay = new ol.layer.Vector({
      map: this.map_,
      style: defaultStyle
    });

    if (data.overlayElement) {
      this.map_.addOverlay(new ol.Overlay({
        element: data.overlayElement,
        stopEvent: true
      }));
    }
    this.title = "Default Mapstory";
    this.abstract = "No Information Supplied.";
    this.owner = "";
    this.mode = "instant";
    this.returnToExtent = data.returnToExtent || false;
    this.center = [0, 0];
    this.zoom = 2;
    this.storyLayers_ = new ol.Collection();
    this.animationDuration_ = data.animationDuration || 500;
    this.storyBoxesLayer = new StoryLayer({
      timeAttribute: 'start_time',
      endTimeAttribute: 'end_time',
      layer: new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: defaultStyle
      })
    });
    this.storyPinsLayer = new StoryLayer({
      timeAttribute: 'start_time',
      endTimeAttribute: 'end_time',
      layer: new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: defaultStyle
      })
    });
    this.addStoryPinsLayer();
    this.addStoryBoxesLayer();
  }

  StoryMap.prototype = Object.create(ol.Object.prototype);
  StoryMap.prototype.constructor = StoryMap;

  StoryMap.prototype.addStoryPinsLayer = function() {
    this.map_.addLayer(this.storyPinsLayer.getLayer());
  };

  StoryMap.prototype.addStoryBoxesLayer = function() {
    this.map_.addLayer(this.storyBoxesLayer.getLayer());
  };

  StoryMap.prototype.setStoryOwner = function(storyOwner) {
    this.owner = storyOwner;
  };

  StoryMap.prototype.getStoryOwner = function() {
    return this.owner;
  };

  StoryMap.prototype.getCenter = function() {
    return this.center;
  };

  StoryMap.prototype.getZoom = function() {
    return this.zoom;
  };

  StoryMap.prototype.setStoryTitle = function(storyTitle) {
    this.title = storyTitle;
  };

  StoryMap.prototype.setCenter = function(center) {
    this.center = center;
  };

  StoryMap.prototype.setZoom = function(zoom) {
    this.zoom = zoom;
  };

  StoryMap.prototype.setMode = function(playbackMode) {
    this.mode = playbackMode;
  };

  StoryMap.prototype.setStoryAbstract = function(storyAbstract) {
    this.abstract = storyAbstract;
  };


  StoryMap.prototype.getStoryTitle = function() {
    return this.title;
  };

  StoryMap.prototype.getStoryAbstract = function() {
    return this.abstract;
  };

  StoryMap.prototype.setBaseLayer = function(baseLayer) {
    this.set('baselayer', baseLayer);
    this.map_.getLayers().forEach(function(lyr) {
      if (lyr.get('group') === 'background') {
        this.map_.removeLayer(lyr);
      }
    }, this);
    this.map_.getLayers().insertAt(0, this.get('baselayer'));
  };

  StoryMap.prototype.addStoryLayer = function(storyLayer) {
    storyLayer.storyMap_ = this;
    this.storyLayers_.push(storyLayer);
    // keep pins layer on top
    var idx = this.map_.getLayers().getLength(), me = this;
    this.map_.getLayers().forEach(function(sl) {
      if (sl === me.storyPinsLayer || sl instanceof ol.layer.Vector) {
        idx -= 1;
      }
    });
    this.map_.getLayers().insertAt(
          idx,
          storyLayer.getLayer()
    );
  };

  StoryMap.prototype.getStoryLayers = function() {
    return this.storyLayers_;
  };

  StoryMap.prototype.getMap = function() {
    return this.map_;
  };

  StoryMap.prototype.clear = function() {
    this.map_.getLayers().clear();
    this.storyLayers_.clear();
    this.addStoryPinsLayer();
  };

  StoryMap.prototype.animatePanAndBounce = function(center, zoom) {

    var duration = 2000;
    var start = +new Date();

    var view = this.map_.getView();

    if (view.getCenter() != center) {

      var pan = ol.animation.pan({
        duration: this.animationDuration_,
        source: view.getCenter(),
        start: start
      });


      var bounce = ol.animation.bounce({
        duration: duration,
        resolution: 2 * view.getResolution(),
        start: start
      });

      this.map_.beforeRender(pan, bounce);

      view.setCenter(center);
      view.setZoom(zoom);
    }
  };

  StoryMap.prototype.animateCenterAndZoom = function(center, zoom) {
    var view = this.map_.getView();
    if (view.getCenter() !== center || view.getZoom() !== zoom) {
      this.map_.beforeRender(ol.animation.pan({
        duration: this.animationDuration_,
        source: view.getCenter()
      }));
      view.setCenter(center);
      this.map_.beforeRender(ol.animation.zoom({
        resolution: view.getResolution(),
        duration: this.animationDuration_
      }));
      view.setZoom(zoom);
    }
  };

  StoryMap.prototype.setAllowPan = function(allowPan) {
    this.map_.getInteractions().forEach(function(i) {
      if (i instanceof ol.interaction.KeyboardPan ||
            i instanceof ol.interaction.DragPan) {
        i.setActive(allowPan);
      }
    });
  };

  StoryMap.prototype.setAllowZoom = function(allowZoom) {
    var zoomCtrl;
    this.map_.getControls().forEach(function(c) {
      if (c instanceof ol.control.Zoom) {
        zoomCtrl = c;
      }
    });
    if (!allowZoom) {
      this.map_.removeControl(zoomCtrl);
    } else {
      this.map_.addControl(new ol.control.Zoom());
    }
    this.map_.getInteractions().forEach(function(i) {
      if (i instanceof ol.interaction.DoubleClickZoom ||
            i instanceof ol.interaction.PinchZoom ||
            i instanceof ol.interaction.DragZoom ||
            i instanceof ol.interaction.MouseWheelZoom) {
        i.setActive(allowZoom);
      }
    });
  };

  StoryMap.prototype.toggleStoryLayer = function(storyLayer) {
    var layer = storyLayer.getLayer();
    storyLayer.set('visibility', !layer.getVisible());
    layer.setVisible(!layer.getVisible());
  };

  module.constant('StoryMap', StoryMap);

  function EditableStoryMap(data) {
    StoryMap.call(this, data);
  }

  EditableStoryMap.prototype = Object.create(StoryMap.prototype);
  EditableStoryMap.prototype.constructor = EditableStoryMap;

  module.constant('EditableStoryMap', EditableStoryMap);

  EditableStoryMap.prototype.getState = function() {
    var config = {};
    config.map = {
      center: this.map_.getView().getCenter(),
      projection: this.map_.getView().getProjection().getCode(),
      zoom: this.map_.getView().getZoom(),
      layers: []
    };
    var mapId = this.get('id');
    if (mapId >= 0) {
      config.id = mapId;
    }
    var baseLayer = this.get('baselayer');
    if (baseLayer) {
      var baseLayerState = this.get('baselayer').get('state');
      baseLayerState.group = 'background';
      baseLayerState.visibility = true;
      config.map.layers.push(baseLayerState);
    }
    this.storyLayers_.forEach(function(storyLayer) {
      config.map.layers.push(storyLayer.getState());
    });
    return config;
  };

  EditableStoryMap.prototype.removeStoryLayer = function(storyLayer) {
    this.storyLayers_.remove(storyLayer);
    this.map_.removeLayer(storyLayer.getLayer());
  };

  function StoryLayer(data) {
    var layerParams= {};

    if (data.times && storytools.core.time.utils.isRangeLike(data.times)) {
      data.times = new storytools.core.time.utils.Interval(data.times);
    }
    ol.Object.call(this, data);
    var layer;
    if (this.get('type') === 'VECTOR') {

      var vectorSource = new ol.source.Vector({});

      if(data.cluster){
        var clusterSource = new ol.source.Cluster({distance: 20, source: vectorSource});
        layerParams = {source: clusterSource, style: data.style || defaultStyle};
      }
      else{
        layerParams = {source: vectorSource, style: data.style || defaultStyle};
      }

      layer = new ol.layer.Vector(layerParams);

      if(data.animate) {
        window.setInterval(function () {
          vectorSource.dispatchEvent('change');
        }, 1000 / 75);
      }

    } else if (this.get('type') === 'HEATMAP') {
      layer = new ol.layer.Heatmap({
        radius: data.style.radius,
        opacity: data.style.opacity,
        source: new ol.source.Vector()
      });
    } else if (this.get('type') === 'WMS') {
      var config = {
        useOldAsInterimTiles: true
      };
      if (this.get('singleTile') === true) {
        layer = new ol.layer.Image(config);
      } else {
        layer = new ol.layer.Tile(config);
      }
    } else {
      layer = data.layer;
    }
    this.layer_ = layer;
  }

  StoryLayer.prototype = Object.create(ol.Object.prototype);
  StoryLayer.prototype.constructor = StoryLayer;

  StoryLayer.prototype.getStoryMap = function() {
    return this.storyMap_;
  };

  StoryLayer.prototype.setWMSSource = function() {
    var layer = this.getLayer();
    var name = this.get('name');
    var times = this.get('times');
    var singleTile = this.get('singleTile');
    var params = this.get('params') || {
            'LAYERS': name,
            'VERSION': '1.1.0',
            'TILED': true
          };
    if (times) {
      params.TIME = new Date(times.start || times[0]).toISOString();
    }
    if (singleTile) {
      layer.setSource(new ol.source.ImageWMS({
        params: params,
        url: this.get('url'),
        serverType: 'geoserver'
      }));
    } else {
      var tileGrid, resolutions = this.get('resolutions'),
            bbox = this.get('bbox');
      if (resolutions && bbox) {
        tileGrid = new ol.tilegrid.TileGrid({
          extent: bbox,
          resolutions: resolutions
        });
      }
      // @todo use urls for subdomain loading
      layer.setSource(new ol.source.TileWMS({
        url: this.get('url'),
        params: params,
        tileGrid: tileGrid,
        serverType: 'geoserver'
      }));
    }
  };

  StoryLayer.prototype.getState = function() {
    var state = this.getProperties();
    delete state.features;
    return state;
  };

  StoryLayer.prototype.getLayer = function() {
    return this.layer_;
  };

  StoryLayer.prototype.setLayer = function(layer) {
    if (this.layer_ && this.storyMap_) {
      var map = this.storyMap_.map_;
      var idx = map.getLayers().getArray().indexOf(this.layer_);
      map.getLayers().setAt(idx, layer);
    }
    this.layer_ = layer;
  };

  module.constant('StoryLayer', StoryLayer);

  function EditableStoryLayer(data) {
    StoryLayer.call(this, data);
  }

  EditableStoryLayer.prototype = Object.create(StoryLayer.prototype);
  EditableStoryLayer.prototype.constructor = EditableStoryLayer;

  module.constant('EditableStoryLayer', EditableStoryLayer);

  module.service('stAnnotateLayer', ["$rootScope", "$http", "$q", function($rootScope, $http, $q) {
    return {
      loadCapabilities: function(storyLayer) {
        var request = 'GetCapabilities', service = 'WMS';
        // always use the virtual service for GetCapabilities
        var url = storyLayer.get('url');
        if (url === '/geoserver/wms') {
          var name = storyLayer.get('name');
          var parts = name.split(':');
          url = url.replace('/geoserver', '/geoserver/' + parts[0] + '/' + parts[1]);
        }
        url = url.replace('http:', '');
        $rootScope.$broadcast('layer-status', { name: storyLayer.get('name'),
          phase: 'capabilities',
          status: 'loading' });

        return $http({
          method: 'GET',
          url: url,
          params: {
            'REQUEST': request,
            'SERVICE': service,
            'VERSION': '1.3.0',
            'TILED': true
          }
        }).then(function(response) {
          var context = new owsjs.Jsonix.Context([
            owsjs.mappings.XLink_1_0,
            owsjs.mappings.WMS_1_3_0
          ]);
          var unmarshaller = context.createUnmarshaller();
          var caps = unmarshaller.unmarshalString(response.data);
          var layer = caps.value.capability.layer;
          storyLayer.set('latlonBBOX', [
            parseFloat(layer.boundingBox[0].minx),
            parseFloat(layer.boundingBox[0].miny),
            parseFloat(layer.boundingBox[0].maxx),
            parseFloat(layer.boundingBox[0].maxy)
          ]);
          var vendorSpecificCapabilities = caps.value.capability.vendorSpecificCapabilities;
          var tileSets = (vendorSpecificCapabilities) ? vendorSpecificCapabilities.tileSet || [] : [];
          for (var i = 0, ii = tileSets.length; i < ii; ++i) {
            if (tileSets[i].srs === 'EPSG:900913') {
              storyLayer.set('resolutions', tileSets[i].resolutions.split(' '));
              var bbox = tileSets[i].boundingBox;
              storyLayer.set('bbox', [
                parseFloat(bbox.minx),
                parseFloat(bbox.miny),
                parseFloat(bbox.maxx),
                parseFloat(bbox.maxy)
              ]);
              break;
            }
          }
          var found = storytools.core.time.maps.readCapabilitiesTimeDimensions(caps);
          var name = storyLayer.get('name');
          if (name in found) {
            storyLayer.set('times', found[name]);
          }

          $rootScope.$broadcast('layer-status', { name: storyLayer.get('name'),
            phase: 'capabilities',
            status: 'done' });

        }).catch(function(response){});
      },
      describeFeatureType: function(storyLayer) {
        var me = this;
        var request = 'DescribeFeatureType', service = 'WFS';
        var id = storyLayer.get('id');
        $rootScope.$broadcast('layer-status', { name: storyLayer.get('name'),  phase: 'featureType',
            status: 'loading' });
        return $http({
          method: 'GET',
          url: storyLayer.get('url').replace('http:', ''),
          params: {
            'SERVICE': service,
            'VERSION': '1.0.0',
            'REQUEST': request,
            'TYPENAME': id
          }
        }).then(function(response) {
          var parser = (storytools.edit)? new storytools.edit.WFSDescribeFeatureType.WFSDescribeFeatureType():null;
          if(parser) {
            var layerInfo = parser.parseResult(response.data);
            if (layerInfo.timeAttribute) {
              storyLayer.set('timeAttribute', layerInfo.timeAttribute);
            } else if (storyLayer.get('timeEndpoint')) {
              me.getTimeAttribute(storyLayer);
            }
            var parts = id.split(':');
            storyLayer.set('typeName', id);
            storyLayer.set('featurePrefix', parts[0]);
            storyLayer.set('featureNS', layerInfo.featureNS);
            storyLayer.set('geomType', layerInfo.geomType);
            storyLayer.set('attributes', layerInfo.attributes);
          }
          $rootScope.$broadcast('layer-status', { name: storyLayer.get('name'), phase: 'featureType', status: 'done' });
        }).catch(function(response){});
      },
      getTimeAttribute: function(storyLayer) {
        var me = this;
        return $http({
          method: 'GET',
          url: storyLayer.get('timeEndpoint')
        }).then(function(response) {
          storyLayer.set('timeAttribute', response.data.attribute);
          if (data.endAttribute) {
            storyLayer.set('endTimeAttribute', response.data.endAttribute);
          }
        }).catch(function(response){});
      },
      getStyleName: function(storyLayer) {
        if (storyLayer.get('canStyleWMS')) {
          var me = this;
          return $http({
            method: 'GET',
            url: storyLayer.get('path') + 'rest/layers/' + storyLayer.get('id') + '.json'
          }).then(function(response) {
            storyLayer.set('styleName', response.data.layer.defaultStyle.name);
          }).catch(function(response){});
        } else {
          return $q.when('');
        }
      },
      getFeatures: function(storyLayer, map) {
        var name = storyLayer.get('id');
        var cql = storyLayer.get('cql');
        var wfsUrl = storyLayer.get('url') + '?service=WFS&version=1.1.0&request=GetFeature&typename=' +
              name + '&outputFormat=application/json' +
              '&srsName=' + map.getView().getProjection().getCode();

        if (cql){
          wfsUrl += "&cql_filter=" + cql;
        }

        wfsUrl += "&t=" + new Date().getTime();

        $rootScope.$broadcast('layer-status', { name: storyLayer.get('name'), phase: 'features', status: 'loading' });

        return $http({
          method: 'GET',
          url: wfsUrl
        }).then(function(response) {
          var layer = storyLayer.getLayer();
          var filter = storyLayer.get('filter');
          var features = new ol.format.GeoJSON().readFeatures(response.data);

          if (filter) {
              features = filter(features);
          }

          storyLayer.set('features', features);

          if(layer.getSource() instanceof ol.source.Cluster) {
            layer.getSource().getSource().clear(true);
            layer.getSource().getSource().addFeatures(features);
          }else if(layer.getSource() instanceof ol.source.Vector){
            layer.getSource().clear(true);
            layer.getSource().addFeatures(features);
          }

          $rootScope.$broadcast('layer-status', { name: storyLayer.get('name'), phase: 'features', status: 'done' });

        }).catch(function(response){});
      }
    };
  }]);

  module.service('stBaseLayerBuilder', function() {
    return {
      buildLayer: function(data) {
        if (data.type === 'MapQuest') {
          return new ol.layer.Tile({
            state: data,
            name: data.title,
            title: data.title,
            group: 'background',
            source: new ol.source.MapQuest({layer: data.layer})
          });
        } else if (data.type === 'ESRI') {
          return new ol.layer.Tile({
            state: data,
            name: data.title,
            title: data.title,
            group: 'background',
            source: new ol.source.XYZ({
              attributions: [
                new ol.Attribution({
                  html: 'Tiles &copy; <a href="//services.arcgisonline.com/ArcGIS/' +
                  'rest/services/NatGeo_World_Map/MapServer">ArcGIS</a>'
                })
              ],
              url: '//server.arcgisonline.com/ArcGIS/rest/services/' +
              'NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}'
            })
          });
        } else if (data.type === 'HOT') {
          return new ol.layer.Tile({
            state: data,
            name: data.title,
            title: data.title,
            group: 'background',
            source: new ol.source.OSM({
              attributions: [
                new ol.Attribution({
                  html: 'Tiles courtesy of <a href="//hot.openstreetmap.org/" target="_blank">Humanitarian OpenStreetMap Team</a>'
                }),
                ol.source.OSM.ATTRIBUTION
              ],
              crossOrigin: null,
              url: '//{a-c}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png'
            })
          });
        } else if (data.type === 'OSM') {
          return new ol.layer.Tile({
            state: data,
            name: data.title,
            title: data.title,
            group: 'background',
            source: new ol.source.OSM()
          });
        } else if (data.type === 'MapBox') {
          var layer = new ol.layer.Tile({state: data, name: data.title, title: data.title, group: 'background'});
          var name = data.name;
          var urls = [
            '//a.tiles.mapbox.com/v1/mapbox.',
            '//b.tiles.mapbox.com/v1/mapbox.',
            '//c.tiles.mapbox.com/v1/mapbox.',
            '//d.tiles.mapbox.com/v1/mapbox.'
          ];
          var tileUrlFunction = function(tileCoord, pixelRatio, projection) {
            var zxy = tileCoord;
            if (zxy[1] < 0 || zxy[2] < 0) {
              return "";
            }
            return urls[Math.round(Math.random() * 3)] + name + '/' +
                  zxy[0].toString() + '/' + zxy[1].toString() + '/' +
                  zxy[2].toString() + '.png';
          };
          layer.setSource(new ol.source.TileImage({
            crossOrigin: null,
            attributions: [
              new ol.Attribution({
                html: /^world/.test(name) ?
                      "<a href='//mapbox.com'>MapBox</a> | Some Data &copy; OSM CC-BY-SA | <a href='//mapbox.com/tos'>Terms of Service</a>" :
                      "<a href='//mapbox.com'>MapBox</a> | <a href='//mapbox.com/tos'>Terms of Service</a>"
              })
            ],
            tileGrid: new ol.tilegrid.TileGrid({
              origin: [-128 * 156543.03390625, -128 * 156543.03390625],
              resolutions: [
                156543.03390625, 78271.516953125, 39135.7584765625,
                19567.87923828125, 9783.939619140625, 4891.9698095703125,
                2445.9849047851562, 1222.9924523925781, 611.4962261962891,
                305.74811309814453, 152.87405654907226, 76.43702827453613,
                38.218514137268066, 19.109257068634033, 9.554628534317017,
                4.777314267158508, 2.388657133579254, 1.194328566789627,
                0.5971642833948135
              ]
            }),
            tileUrlFunction: tileUrlFunction
          }));
          return layer;
        } else if (data.type === 'WMS') {
          return new ol.layer.Tile({
            group: "background",
            source: new ol.source.TileWMS({
              url: data.url,
              params: data.params
            })
          });
        } else {
          throw new Error('no type for : ' + JSON.stringify(data));
        }
      }
    };
  });

  module.service('stEditableLayerBuilder', ["$q", "stAnnotateLayer", "stBaseLayerBuilder", function($q, stAnnotateLayer, stBaseLayerBuilder) {
    return {
      buildEditableLayer: function(data, map) {
        var layer = new EditableStoryLayer(data);
        var deferred = $q.defer();
        var promises = [];
        // TODO add this back when we have WMS-C GetCaps
        var needsCaps = !(data.latlonBBOX && data.times/* && data.bbox && data.resolutions*/);
        if (needsCaps) {
          promises.push(stAnnotateLayer.loadCapabilities(layer));
        }
        var needsDFT = !data.attributes;
        if (needsDFT) {
          promises.push(stAnnotateLayer.describeFeatureType(layer));
        }
        if ((data.type === 'VECTOR' || data.type === 'HEATMAP') && !data.features) {
          promises.push(stAnnotateLayer.getFeatures(layer, map));
        } else {
          promises.push(stAnnotateLayer.getStyleName(layer));
        }
        $q.all(
              promises
        ).then(function() {
                // this needs to be done here when everything is resolved
                if (layer.get('features')) {
                  var times = layer.get('times');
                  if (times) {
                    var start = times.start || times[0];
                    storytools.core.time.maps.filterVectorLayer(layer, {start: start, end: start});
                  } else {
                    layer.getLayer().getSource().addFeatures(layer.get('features'));
                  }
                } else {
                  layer.setWMSSource();
                }
                deferred.resolve(layer);
              }, function() {
                deferred.reject(arguments);
              });
        return deferred.promise;
      }
    };
  }]);

  module.service('stLayerBuilder', ["$q", function($q) {
    return {
      buildLayer: function(data, map) {
        var layer = new StoryLayer(data);
        var deferred = $q.defer();
        layer.setWMSSource();
        deferred.resolve(layer);
        return deferred.promise;
      }
    };
  }]);

  module.service('stStoryMapBaseBuilder', ["$rootScope", "$compile", "stBaseLayerBuilder", function($rootScope, $compile, stBaseLayerBuilder) {
    return {
      defaultMap: function(storymap) {
        storymap.getMap().setView(new ol.View({center: [0, 0], zoom: 3, minZoom: 3, maxZoom: 16}));
        this.setBaseLayer(storymap, {
          title: 'World Topo Map',
          type: 'ESRI',
          name: 'world-topo-map'
        });
      },
      setBaseLayer: function(storymap, data) {
        var baseLayer = stBaseLayerBuilder.buildLayer(data);
        storymap.setBaseLayer(baseLayer);
      }
    };
  }]);

  module.service('stStoryMapBuilder', ["$rootScope", "$compile", "stLayerBuilder", "stStoryMapBaseBuilder", function($rootScope, $compile, stLayerBuilder, stStoryMapBaseBuilder) {
    return {
      modifyStoryMap: function(storymap, data) {
        storymap.clear();
        var mapConfig = storytools.mapstory.MapConfigTransformer.MapConfigTransformer(data);
        if (mapConfig.id >= 0) {
          storymap.set('id', mapConfig.id);
          storymap.setMode(mapConfig.playbackMode);
          if (data.about !== undefined) {
            storymap.setStoryTitle(data.about.title);
            storymap.setStoryAbstract(data.about.abstract);
            storymap.setStoryOwner(data.about.owner);
          }

          storymap.setCenter(mapConfig.map.center);
          storymap.setZoom(mapConfig.map.zoom);
        }
        for (var i = 0, ii = mapConfig.map.layers.length; i < ii; ++i) {
          var layerConfig = mapConfig.map.layers[i];
          if (layerConfig.group === 'background' && layerConfig.visibility === true) {
            stStoryMapBaseBuilder.setBaseLayer(storymap, layerConfig);
          } else {
            /*jshint loopfunc: true */
            stLayerBuilder.buildLayer(layerConfig, storymap.getMap()).then(function(sl) {
              // TODO insert at the correct index
              storymap.addStoryLayer(sl);
            });
          }
        }
        storymap.getMap().setView(new ol.View({
          center: mapConfig.map.center,
          zoom: mapConfig.map.zoom,
          minZoom: 3,
          maxZoom: 17
        }));
      }
    };
  }]);

  module.service('stEditableStoryMapBuilder', ["$rootScope", "$compile", "stStoryMapBaseBuilder", "stEditableLayerBuilder", function($rootScope, $compile, stStoryMapBaseBuilder, stEditableLayerBuilder) {
    return {
      modifyStoryLayer: function(storylayer, newType) {
        var data = storylayer.getProperties();
        var storymap = storylayer.getStoryMap();
        data.type = newType ? newType : ((data.type === 'WMS') ? 'VECTOR' : 'WMS');
        if (data.type === 'WMS') {
          delete data.features;
        }
        return stEditableLayerBuilder.buildEditableLayer(data, storymap.getMap()).then(function(sl) {
          // sequence is important here, first change layer, then the type.
          storylayer.setLayer(sl.getLayer());
          storylayer.set('type', sl.get('type'));
        });
      },
      modifyStoryMap: function(storymap, data) {
        storymap.clear();
        var mapConfig = storytools.mapstory.MapConfigTransformer.MapConfigTransformer(data);
        if (mapConfig.id >= 0) {
          storymap.set('id', mapConfig.id);
          storymap.setMode(mapConfig.playbackMode);
          if (data.about !== undefined) {
            storymap.setStoryTitle(data.about.title);
            storymap.setStoryAbstract(data.about.abstract);
            storymap.setStoryOwner(data.about.owner);
          }
        }
        for (var i = 0, ii = mapConfig.map.layers.length; i < ii; ++i) {
          var layerConfig = mapConfig.map.layers[i];
          if (layerConfig.group === 'background' && layerConfig.visibility === true) {
            stStoryMapBaseBuilder.setBaseLayer(storymap, layerConfig);
          } else {
            /*jshint loopfunc: true */
            stEditableLayerBuilder.buildEditableLayer(layerConfig, storymap.getMap()).then(function(sl) {
              // TODO insert at the correct index
              storymap.addStoryLayer(sl);
            });
          }
        }
        
        storymap.getMap().setView(new ol.View({
          center: mapConfig.map.center,
          zoom: mapConfig.map.zoom,
          projection: mapConfig.map.projection,
          minZoom: 3,
          maxZoom: 17
        }));
      }
    };
  }]);

     ol.Overlay.Popup = function(opt_options) {

        var options = opt_options || {};

        this.panMapIfOutOfView = options.panMapIfOutOfView;
        if (this.panMapIfOutOfView === undefined) {
            this.panMapIfOutOfView = true;
        }

        this.ani = options.ani;
        if (this.ani === undefined) {
            this.ani = ol.animation.pan;
        }

        this.ani_opts = options.ani_opts;
        if (this.ani_opts === undefined) {
            this.ani_opts = {'duration': 250};
        }

        this.container = document.createElement('div');
        this.container.className = 'ol-popup';
        this.container.id = (options.hasOwnProperty('id')) ? options.id : '';


        this.closer = document.createElement('a');
        this.closer.className = 'ol-popup-closer';
        this.closer.href = '#';
        this.container.appendChild(this.closer);

        var that = this;
        this.closer.addEventListener('click', function (evt) {
            that.container.style.display = 'none';
            that.closer.blur();
            evt.preventDefault();
        }, false);

        this.content = document.createElement('div');
        this.content.className = 'ol-popup-content';
        this.container.appendChild(this.content);

        ol.Overlay.call(this, {
            id: (options.hasOwnProperty('id')) ? options.id : 'popup',
            element: this.container,
            positioning: (options.hasOwnProperty('positioning')) ? options.positioning : 'top-left',
            stopEvent: (options.hasOwnProperty('stopEvent')) ? options.stopEvent : true,
            insertFirst: (options.hasOwnProperty('insertFirst')) ? options.insertFirst : true
        });

    };

    ol.inherits(ol.Overlay.Popup, ol.Overlay);

    ol.Overlay.Popup.prototype.getId = function() {
        return this.container.id;
    };

    ol.Overlay.Popup.prototype.show = function(coord, html) {
        this.setPosition(coord);
        if (html instanceof HTMLElement) {
            this.content.innerHTML = "";
            this.content.appendChild(html);
        } else {
            this.content.innerHTML = html;
        }
        this.container.style.display = 'block';
        if (this.panMapIfOutOfView) {
            this.panIntoView_(coord);
        }
        this.content.scrollTop = 0;
        return this;
    };

    /**
     * @private
     */
    ol.Overlay.Popup.prototype.panIntoView_ = function(coord) {

        var popSize = {
                width: this.getElement().clientWidth + 20,
                height: this.getElement().clientHeight + 20
            },
            mapSize = this.getMap().getSize();

        var tailHeight = 20,
            tailOffsetLeft = 60,
            tailOffsetRight = popSize.width - tailOffsetLeft,
            popOffset = this.getOffset(),
            popPx = this.getMap().getPixelFromCoordinate(coord);

        var fromLeft = (popPx[0] - tailOffsetLeft),
            fromRight = mapSize[0] - (popPx[0] + tailOffsetRight);

        var fromTop = popPx[1] - popSize.height + popOffset[1],
            fromBottom = mapSize[1] - (popPx[1] + tailHeight) - popOffset[1];

        var center = this.getMap().getView().getCenter(),
            curPx = this.getMap().getPixelFromCoordinate(center),
            newPx = curPx.slice();

        if (fromRight < 0) {
            newPx[0] -= fromRight;
        } else if (fromLeft < 0) {
            newPx[0] += fromLeft;
        }

        if (fromTop < 0) {
            newPx[1] += fromTop;
        } else if (fromBottom < 0) {
            newPx[1] -= fromBottom;
        }

        if (this.ani && this.ani_opts) {
            this.ani_opts.source = center;
            this.getMap().beforeRender(this.ani(this.ani_opts));
        }

        if (newPx[0] !== curPx[0] || newPx[1] !== curPx[1]) {
            this.getMap().getView().setCenter(this.getMap().getCoordinateFromPixel(newPx));
        }

        return this.getMap().getView().getCenter();

    };

    /**
     * Hide the popup.
     */
    ol.Overlay.Popup.prototype.hide = function() {
        this.container.style.display = 'none';
        return this;
    };


    /**
     * Indicates if the popup is in open state
     */
    ol.Overlay.Popup.prototype.isOpened = function() {
        return this.container.style.display == 'block';
    };





})();

(function() {
    var module = angular.module('storytools.core.ogc.services', []);

    var featureInfoPerLayer_ = [];
    // valid values: 'layers', 'layer', 'feature', or ''
    var state_ = '';
    var selectedItem_ = null;
    var selectedItemMedia_ = null;
    var selectedLayer_ = null;
    var selectedItemProperties_ = null;
    var position_ = null;
    var enabled_ = true;
    var containerInstance_ = null;
    var overlay_ = null;



    module.provider('stFeatureInfoService', function() {

        this.$get = ["$rootScope", "$q", "MapManager", "$compile", "$http", function ($rootScope, $q, MapManager, $compile, $http) {
            rootScope_ = $rootScope;
            service_ = this;
            mapService_ = MapManager.storyMap;
            //translate_ = $translate;
            httpService_ = $http;
            q_ = $q;
            registerOnMapClick($rootScope, $compile);
            
            overlay_ = new ol.Overlay({
                insertFirst: false,
                element: document.getElementById('info-box')
            });

            mapService_.getMap().addOverlay(overlay_);

            rootScope_.$on('rangeChange', function(evt, layer) {
                if (goog.isDefAndNotNull(service_.getSelectedLayer())) {
                    service_.hide();
                }
            });


            return this;
        }];


        function classifyItem(item) {
            var type = '';

            if (goog.isDefAndNotNull(item)) {
                if (item.properties) {
                    type = 'feature';
                } else if (item.features) {
                    type = 'layer';
                } else if (item.length && item[0].features) {
                    type = 'layers';
                }
            }
            console.log(type);
            return type;
        }

        this.show = function (item, position) {

            // if item is not specified, return
            if (!goog.isDefAndNotNull(item)) {
                return false;
            }

            var selectedItemOld = selectedItem_;

            //classify the item parameter as a layer, feature, or layers
            var type = classifyItem(item);


            // when there is nothing in featureInfoPerLayer_, we need to used the passed in item to initialize it
            // this is done when the user clicks on a single feature (on the map) vice selecting a feature from the pop-up
            // (such as clicking on overlapping features)
            if (featureInfoPerLayer_.length === 0) {

                if (type === 'feature') {
                    featureInfoPerLayer_.push({features: [item], layer: selectedLayer_});
                } else if (type === 'layer') {
                    featureInfoPerLayer_.push(item);
                } else if (type === 'layers') {
                    featureInfoPerLayer_ = item;
                } else {
                    throw ({
                        name: 'featureInfoBox',
                        level: 'High',
                        message: 'Expected layers, layer, or feature.',
                        toString: function () {
                            return this.name + ': ' + this.message;
                        }
                    });
                }
            }


            //set the service's state_ variable (feature, layer, or layers)
            //the state is 'layer' when the user clicks on multiple (aka overlapping) features in a single layer
            //the state is 'layers' when the user clicks on multiple (overlapping) features that exist in separate layers
            //the state is 'feature' when the user finishes creating a feature, they clicked on a single (non-overlapping)
            //feature, or they select a feature from the deconfliction pop-up

            //we are also going to set the selectedItem_ variable
            //the selectedItem will be a single feature, a single layer, or a collection of layers
            //the state is essentially a designation of the selectedItem type
            if (type === 'feature') {
                state_ = 'feature';
                selectedItem_ = item;
            } else if (type === 'layer') {
                if (item.features.length === 1) {
                    state_ = 'feature';
                    selectedItem_ = item.features[0];
                } else {
                    state_ = 'layer';
                    selectedItem_ = item;
                }
            } else if (type === 'layers') {
                if (item.length === 1) {
                    if (item[0].features.length === 1) {
                        state_ = 'feature';
                        selectedItem_ = item[0].features[0];
                    } else {
                        state_ = 'layer';
                        selectedItem_ = item[0];
                    }
                } else {
                    state_ = 'layers';
                    selectedItem_ = item;
                }
            } else {
                throw ({
                    name: 'featureInfoBox',
                    level: 'High',
                    message: 'Invalid item passed in. Expected layers, layer, or feature.',
                    toString: function () {
                        return this.name + ': ' + this.message;
                    }
                });
            }
            var forceUpdate = true;

            //---- if selected item changed
            if (selectedItem_ !== selectedItemOld) {

                // -- select the geometry if it is a feature, clear otherwise
                // -- store the selected layer of the feature
                if (classifyItem(selectedItem_) === 'feature') {

                    selectedLayer_ = this.getSelectedItemLayer().layer;

                    // -- update selectedItemProperties_ to contain the props from the newly selected item
                    var tempProps = {};
                    var props = [];

                    //if the selectedItem_ is a feature go through and collect the properties in tempProps
                    //if the property is a media property (like photo or video), we need to parse out
                    //the value into an array (since there may be multiple photos or videos)
                    goog.object.forEach(selectedItem_.properties, function (v, k) {
                        tempProps[k] = [k, v];
                    });

                    //ensure we only take properties that are defined in the layer schema, the selectedLayer_
                    //may be some other layer so
                    var propName = null;
                    /*  if (goog.isDefAndNotNull(selectedLayer_) && goog.isDefAndNotNull(selectedLayer_.get('metadata').schema)) {
                     for (propName in selectedLayer_.get('metadata').schema) {
                     if (tempProps.hasOwnProperty(propName)) {
                     props.push(tempProps[propName]);
                     }
                     }
                     } else {*/
                    for (propName in tempProps) {
                        if (tempProps.hasOwnProperty(propName)) {
                            props.push(tempProps[propName]);
                        }
                    }
                    // }
                    selectedItemProperties_ = props;
                    console.log('---- selectedItemProperties_: ', selectedItemProperties_);

                    // -- update the selectedItemMedia_
                    //selectedItemMedia_ = service_.getSelectedItemMediaByProp(null);
                    //console.log('---- selectedItemMedia_: ', selectedItemMedia_);
                }
            }

            if (goog.isDefAndNotNull(position)) {
                position_ = position;
                mapService_.getMap().getOverlays().array_[0].setPosition(position_);
            }


        };

        this.getSelectedItemLayer = function () {
            for (var i = 0; i < featureInfoPerLayer_.length; i++) {
                for (var j = 0; j < featureInfoPerLayer_[i].features.length; j++) {
                    console.log(featureInfoPerLayer_[i].features[j] === selectedItem_);
                    console.log(featureInfoPerLayer_[i].features[j]);
                    console.log(selectedItem_);
                    if (featureInfoPerLayer_[i].features[j].id === selectedItem_.id) {
                        return featureInfoPerLayer_[i];
                    }
                }
            }
            return null;
        };

        this.showPreviousState = function () {
            //Note: might want to get position and pass it in again
            this.show(this.getPreviousState().item);
        };

        this.getPreviousState = function () {

            var state = null;
            var item = null;

            if (state_ === 'feature') {
                var layer = this.getSelectedItemLayer();
                if (layer) {
                    if (layer.features.length > 1) {
                        state = 'layer';
                        item = layer;
                    } else if (layer.features.length === 1 && featureInfoPerLayer_.length > 1) {
                        item = featureInfoPerLayer_;
                        state = 'layers';
                    }
                } else {
                    throw ({
                        name: 'featureInfoBox',
                        level: 'High',
                        message: 'Could not find feature!',
                        toString: function () {
                            return this.name + ': ' + this.message;
                        }
                    });
                }
            } else if (state_ === 'layer') {
                if (featureInfoPerLayer_.length > 1) {
                    state = 'layers';
                    item = featureInfoPerLayer_;
                }
            }

            if (item !== null) {
                return {
                    state: state,
                    item: item
                };
            }

            return '';
        };

        this.getState = function () {
            return state_;
        };

        this.getSelectedItem = function () {
            return selectedItem_;
        };

        this.getMediaUrl = function (mediaItem) {
            var url = mediaItem;
            // if the item doesn't start with 'http' then assume the item can be found in the fileservice and so convert it to
            // a url. This means if the item is, say, at https://mysite.com/mypic.jpg, leave it as is
            if (goog.isString(mediaItem) && mediaItem.indexOf('http') === -1) {
                url = configService_.configuration.fileserviceUrlTemplate.replace('{}', mediaItem);
            }
            return url;
        };

        this.getSelectedItemMedia = function () {
            return selectedItemMedia_;
        };

        // Warning, returns new array objects, not to be 'watched' / bound. use getSelectedItemMedia instead.
        this.getSelectedItemMediaByProp = function (propName) {
            var media = null;

            if (classifyItem(selectedItem_) === 'feature' && goog.isDefAndNotNull(selectedItem_) &&
                goog.isDefAndNotNull(selectedItemProperties_)) {

                goog.object.forEach(selectedItemProperties_, function (prop, index) {
                    if (service_.isMediaPropertyName(prop[0])) {
                        if (!goog.isDefAndNotNull(propName) || propName === prop[0]) {
                            if (!goog.isDefAndNotNull(media)) {
                                //TODO: media should no longer be objects
                                media = [];
                            }

                            goog.object.forEach(prop[1], function (mediaItem) {
                                media.push(mediaItem);
                            });
                        }
                    }
                });
            }

            return media;
        };

        this.isMediaPropertyName = function (name) {
            var lower = name.toLowerCase();
            return lower.indexOf('fotos') === 0 || lower.indexOf('photos') === 0 ||
                lower.indexOf('audios') === 0 || lower.indexOf('videos') === 0;
        };

        this.getMediaTypeFromPropertyName = function (name) {
            var lower = name.toLowerCase();
            var type = null;
            if (lower.indexOf('fotos') === 0 || lower.indexOf('photos') === 0) {
                type = 'photos';
            } else if (lower.indexOf('audios') === 0) {
                type = 'audios';
            } else if (lower.indexOf('videos') === 0) {
                type = 'videos';
            }
            return type;
        };

        this.getMediaUrlThumbnail = function (mediaItem) {
            var url = mediaItem;
            if (goog.isDefAndNotNull(mediaItem) && (typeof mediaItem === 'string')) {
                var ext = mediaItem.split('.').pop().split('/')[0]; // handle cases; /file.ext or /file.ext/endpoint
                if (supportedVideoFormats_.indexOf(ext) >= 0) {
                    url = service_.getMediaUrlDefault();
                } else {
                    url = service_.getMediaUrl(mediaItem);
                }
            }
            return url;
        };

        this.getMediaUrlDefault = function () {
            return '/static/maploom/assets/media-default.png';
        };

        this.getMediaUrlError = function () {
            return '/static/maploom/assets/media-error.png';
        };

        this.getSelectedItemProperties = function () {
            return selectedItemProperties_;
        };

        //this method is intended for unit testing only
        this.setSelectedItemProperties = function (props) {
            selectedItemProperties_ = props;
        };

        this.getSelectedLayer = function () {
            return selectedLayer_;
        };

        this.getPosition = function () {
            return position_;
        };

        this.getEnabled = function () {
            return enabled_;
        };

        this.hide = function () {
            selectedItem_ = null;
            selectedItemMedia_ = null;
            selectedItemProperties_ = null;
            state_ = null;
            featureInfoPerLayer_ = [];
            mapService_.getMap().getOverlays().array_[0].setPosition(undefined);
        };

    });

    function registerOnMapClick($rootScope, $compile) {
        mapService_.getMap().on('singleclick', function(evt) {

            // Overlay clones the element so we need to compile it after it is cloned so that ng knows about it
            if (!goog.isDefAndNotNull(containerInstance_)) {
                containerInstance_ = mapService_.getMap().getOverlays().array_[0].getElement();
                $compile(containerInstance_)($rootScope);

            }

            service_.hide();
            featureInfoPerLayer_ = [];
            selectedItem_ = null;
            selectedItemMedia_ = null;
            selectedItemProperties_ = null;
            state_ = null;

            var infoPerLayer = [];
            // Attempt to find a marker from the planningAppsLayer
            var view = mapService_.getMap().getView();
            var layers = mapService_.getStoryLayers().getArray();
            var validRequestCount = 0;
            var completedRequestCount = 0;

            goog.array.forEach(layers, function(layer, index) {
                var source = layer.getLayer().getSource();
                if (goog.isDefAndNotNull(source.getGetFeatureInfoUrl)) {
                    validRequestCount++;
                }
            });
            //This function is called each time a get feature info request returns (call is made below).
            //when the completedRequestCount == validRequestCount, we can display the popup
            var getFeatureInfoCompleted = function() {
                completedRequestCount++;

                if (completedRequestCount === validRequestCount) {
                    if (infoPerLayer.length > 0) {
                        var clickPosition_ = evt.coordinate;
                        service_.show(infoPerLayer, clickPosition_);
                    }
                } else {
                    service_.hide();
                    selectedItem_ = null;
                    selectedItemMedia_ = null;
                    selectedItemProperties_ = null;
                    state_ = null;
                    featureInfoPerLayer_ = [];
                }
            };

            goog.array.forEach(layers, function(layer, index) {
                var source = layer.getLayer().getSource();

                if (goog.isDefAndNotNull(source.getGetFeatureInfoUrl)) {

                    var url = source.getGetFeatureInfoUrl(evt.coordinate, view.getResolution(), view.getProjection(),
                        {
                            'INFO_FORMAT': 'application/json',
                            'FEATURE_COUNT': 5
                        });

                    //Local Mod for testing
                    //url = url.split('https://mapstory.org')[1];

                    httpService_.get(url).then(function(response) {
                        var layerInfo = {};
                        layerInfo.features = response.data.features;

                        if (layerInfo.features && layerInfo.features.length > 0 && goog.isDefAndNotNull(layers[index])) {
                            layerInfo.layer = layers[index];
                            goog.array.insert(infoPerLayer, layerInfo);
                        }

                        getFeatureInfoCompleted();
                    }, function(reject) {
                        getFeatureInfoCompleted();
                    });

                }
            });
        });


    }

}());
(function() {
  var module = angular.module('loom_media_service', []);
  var service_ = null;
  var mediaHandlers_ = null;
  var q_ = null;
  var noembedProviders_ = null;

  module.config(["$sceDelegateProvider", function($sceDelegateProvider) {
    $sceDelegateProvider.resourceUrlWhitelist([
      // Allow same origin resource loads.
      'self',
      new RegExp(/https?:\/\/.*\.flickr\.com\/photos\/.*/),
      new RegExp(/https?:\/\/flic\.kr\/p\/.*/),
      new RegExp(/https?:\/\/instagram\.com\/p\/.*/),
      new RegExp(/https?:\/\/instagr\.am\/p\/.*/),
      new RegExp(/https?:\/\/vine\.co\/v\/.*/),
      new RegExp(/https?:\/\/(?:www\.)?vimeo\.com\/.+/),
      new RegExp(/https?:\/\/((?:www\.)|(?:pic\.)?)twitter\.com\/.*/),
      new RegExp(/https?:\/\/(?:w{3}\.)?(?:youtu\.be\/|youtube(?:-nocookie)?\.com).+/im),
      new RegExp(/https?:\/\/(w{3}\.)?soundcloud\.com\/.+/im),
      new RegExp(/https?:\/\/(?:((?:m)\.)|((?:www)\.)|((?:i)\.))?imgur\.com\/?.+/im)
    ]);

  }]);

  module.provider('mediaService', function() {

    this.$get = ["$rootScope", "$http", "$q", "$sce", function($rootScope, $http, $q, $sce) {
      http_ = $http;
      q_ = $q;
      service_ = this;
      sce_ = $sce;

      http_.jsonp($sce.trustAsResourceUrl('https://noembed.com/providers'), {
        jsonCallbackParam: 'cb',
        headers: {
          'Content-Type': 'application/json'
        }
      }).then(function(result) {
        noembedProviders_ = result.data;
      });

      mediaHandlers_ = service_.configureDefaultHandlers();

      return service_;
    }];

    this.isNOEmbedProvided = function(url) {
      for (var iProvider = 0; iProvider < noembedProviders_.length; iProvider += 1) {
        var provider = noembedProviders_[iProvider];
        for (var iUrlScheme = 0; iUrlScheme < provider.patterns.length; iUrlScheme += 1) {
          var regExp = new RegExp(provider.patterns[iUrlScheme], 'i');
          if (url.match(regExp) !== null) {
            return true;
          }
        }
      }
      return false;
    };

    this.configureDefaultHandlers = function() {

      var defaultHandlers = [
        //{name: 'youtube', regex: /https?:\/\/(?:[0-9A-Z-]+\.)?(?:youtu\.be\/|youtube(?:-nocookie)?\.com\S*?[^\w\s-])/i, callback: embed_youtube},
        {name: 'imgur', regex: /(https?:\/\/(\w+\.)?imgur\.com)/i, callback: embed_imgur}
      ];

      return defaultHandlers;
    };

    this.isUrl = function(str) {
      if (!/^(f|ht)tps?:\/\//i.test(str)) {
        return false;
      }
      return true;
    };

    this.getEmbedContent = function(url, embed_params) {

      var unsafeReturn = '<a href="' + url + '"> Unable to Embed Content </a>';

      //Check to see if we have a specialized handler first for this site
      for (var iHandler = 0; iHandler < mediaHandlers_.length; iHandler += 1) {
        var testHandler = mediaHandlers_[iHandler];
        if (testHandler.regex.test(url)) {
          return testHandler.callback(url, embed_params);
        }
      }

      //Check and see if the embed content is handled through the noembed service
      if (service_.isNOEmbedProvided(url) !== null) {
        return noembed_handler(url, embed_params);
      }

      //Unable to embed allowed content. Return a link to content.
      return unsafeReturn;
    };

    //Handler callbacks
    function getNOEmbedRequestUrl(url, params) {
      var api_url = 'https://noembed.com/embed?url=' + url,
          qs = '',
          i;

      for (i in params) {
        if (params[i] !== null) {
          qs += '&' + encodeURIComponent(i) + '=' + params[i];
        }
      }

      api_url += qs;

      return api_url;
    }

    function noembed_handler(url, embed_params) {

      var response = q_.defer();

      var request_url = getNOEmbedRequestUrl(url, embed_params);

      http_.jsonp(sce_.trustAsResourceUrl(request_url), {
        jsonCallbackParam: 'cb',
        headers: {
          'Content-Type': 'application/json'
        }
      }).then(
        /*success*/
        function(result) {
          response.resolve(result.data.html);
        },
        /*failure*/
        function(result) {
          console.log("error", result)
        });

      return response.promise;

    }

    function embed_imgur(url, embed_params) {

      var response = q_.defer();

      var regex = /(https?:\/\/(\w+\.)?imgur\.com)/ig;

      var matches = url.match(regex);

      var embed = '';
      if (matches.length > 1) {
        //dealing with a basic image link from something like i.imgur.blah.png
        embed = '<iframe src="' + url + '" width="' + embed_params.maxwidth + '" height="' + embed_params.maxheight + '"></iframe>';
      } else {
        //dealing with link to post or album
        var id_regex = /https?:\/\/imgur\.com\/(?:\w+)\/?(.*?)(?:[#\/].*|$)/i;
        embed = url.replace(id_regex,
            '<blockquote class="imgur-embed-pub" lang="en" data-id="a/$1"></blockquote><script async src="//s.imgur.com/min/embed.js" charset="utf-8"></script>');
      }

      response.resolve(embed);
      return response.promise;

    }

  });

})();

(function() {
    'use strict';

    var module = angular.module('storytools.core.pins', [
    ]);

    var pins = storytools.core.maps.pins;
    var stutils = storytools.core.time.utils;
    var rootScope_ = null;

    function StoryPinLayerManager($rootScope) {
        this.storyPins = [];
        this.map = null;
        rootScope_ = $rootScope;
    }
    StoryPinLayerManager.$inject = ["$rootScope"];
    StoryPinLayerManager.prototype.autoDisplayPins = function (range) {
        var pinsToCheck = this.storyPins.filter(function (pin) {
            return pin.get('auto_show');
        });

        for (var iPin = 0; iPin < pinsToCheck.length; iPin += 1) {
            var pin = pinsToCheck[iPin];
            var pinRange = stutils.createRange(pin.start_time, pin.end_time);
            if (pinRange.intersects(range)) {
                rootScope_.$broadcast('showPin', pin);
            } else {
                rootScope_.$broadcast('hidePinOverlay', pin);
            }
        }
    };
    StoryPinLayerManager.prototype.pinsChanged = function(pins, action) {
        var i;
        if (action == 'delete') {
            for (i = 0; i < pins.length; i++) {
                var pin = pins[i];
                for (var j = 0, jj = this.storyPins.length; j < jj; j++) {
                    if (this.storyPins[j].id == pin.id) {
                        this.storyPins.splice(j, 1);
                        break;
                    }
                }
            }
        } else if (action == 'add') {
            for (i = 0; i < pins.length; i++) {
                this.storyPins.push(pins[i]);
            }
        } else if (action == 'change') {
            // provided edits could be used to optimize below
        } else {
            throw new Error('action? :' + action);
        }
        // @todo optimize by looking at changes
        var times = this.storyPins.map(function(p) {
            if (p.start_time > p.end_time) {
                return storytools.core.utils.createRange(p.end_time, p.start_time);
            } else {
                return storytools.core.utils.createRange(p.start_time, p.end_time);
            }
        });
        this.map.storyPinsLayer.set('times', times);
        this.map.storyPinsLayer.set('features', this.storyPins);
    };

    StoryPinLayerManager.prototype.clear = function(){
        this.storyPins = [];
        this.map.storyPinsLayer.set('times', []);
        this.map.storyPinsLayer.set('features', this.storyPins);
    };

    StoryPinLayerManager.prototype.loadFromGeoJSON = function(geojson, projection, overwrite) {

        if (overwrite){
            this.storyPins = [];
        }

        if (geojson && geojson.features) {
            var loaded = pins.loadFromGeoJSON(geojson, projection);
            this.pinsChanged(loaded, 'add', true);
        }
    };

    module.service('StoryPinLayerManager', StoryPinLayerManager);

    module.constant('StoryPin', pins.StoryPin);

    // @todo naive implementation on local storage for now
    module.service('stAnnotationsStore', ["StoryPinLayerManager", function(StoryPinLayerManager) {
        function path(mapid) {
            return '/maps/' + mapid + '/annotations';
        }
        function get(mapid) {
            var saved = localStorage.getItem(path(mapid));
            saved = (saved === null) ? [] : JSON.parse(saved);
            // TODO is this still needed?
            /*saved.forEach(function(s) {
                s.the_geom = format.readGeometry(s.the_geom);
            });*/
            return saved;
        }
        function set(mapid, annotations) {
            // TODO is this still needed?
            /*annotations.forEach(function(s) {
                if (s.the_geom && !angular.isString(s.the_geom)) {
                    s.the_geom = format.writeGeometry(s.the_geom);
                }
            });*/
            localStorage.setItem(path(mapid),
                new ol.format.GeoJSON().writeFeatures(annotations,
                    {dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'})
            );
        }
        return {
            loadAnnotations: function(mapid, projection) {
                return StoryPinLayerManager.loadFromGeoJSON(get(mapid), projection);
            },
            deleteAnnotations: function(annotations) {
                var saved = get();
                var toDelete = annotations.map(function(d) {
                    return d.id;
                });
                saved = saved.filter(function(s) {
                    return toDelete.indexOf(s.id) < 0;
                });
                set(saved);
            },
            saveAnnotations: function(mapid, annotations) {
                var saved = get();
                var maxId = 0;
                saved.forEach(function(s) {
                    maxId = Math.max(maxId, s.id);
                });
                var clones = [];
                annotations.forEach(function(a) {
                    if (typeof a.id == 'undefined') {
                        a.id = ++maxId;
                    }
                    var clone = a.clone();
                    if (a.get('start_time') !== undefined) {
                        clone.set('start_time', a.get('start_time')/1000);
                    }
                    if (a.get('end_time') !== undefined) {
                        clone.set('end_time', a.get('end_time')/1000);
                    }
                    clones.push(clone);
                });
                set(mapid, clones);
            }
        };
    }]);

})();

(function() {
    'use strict';

    angular.module('storytools.core.style', [
        'storytools.core.style.ol3StyleConverter',
        'storytools.core.style.svgIcon'
    ]);

})();
(function() {
    'use strict';

    var module = angular.module('storytools.core.style.ol3StyleConverter', []);

    module.factory('ol3MarkRenderer', ["ol3StyleConverter", function(ol3StyleConverter) {
        return function(shapeName, size) {
            var black = ol3StyleConverter.getColor('#000000');
            var strokeWidth = 3; // hack to fix down-scaling for x and cross
            var opts = {color: black, width: strokeWidth};
            var canvas = angular.element(ol3StyleConverter.generateShape({
                    symbol: {shape: shapeName, size: size - strokeWidth}
                },
                new ol.style.Fill(opts),
                new ol.style.Stroke(opts)).getImage());
            return canvas;
        };
    }]);

    module.factory('ol3StyleConverter', ["stSvgIcon", function(stSvgIcon) {
        return {
            generateShapeConfig: function(style, fill, stroke) {
                var shape = style.symbol.shape,
                    // final size is actually (2 * (radius + stroke.width)) + 1
                    radius = style.symbol.size / 2;
                if (shape === 'circle') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        radius: radius
                    };
                } else if (shape === 'square') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 4,
                        radius: radius,
                        angle: Math.PI / 4
                    };
                } else if (shape === 'triangle') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 3,
                        radius: radius,
                        angle: 0
                    };
                } else if (shape === 'star') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 5,
                        radius: radius,
                        radius2: 0.5*radius,
                        angle: 0
                    };
                } else if (shape === 'cross') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 4,
                        radius: radius,
                        radius2: 0,
                        angle: 0
                    };
                } else if (shape === 'x') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 4,
                        radius: radius,
                        radius2: 0,
                        angle: Math.PI / 4
                    };
                }
            },
            calculateRotation: function(style, feature) {
                if (style.symbol && style.symbol.rotationAttribute) {
                    if (style.symbol.rotationUnits === 'radians') {
                        return feature.get(style.symbol.rotationAttribute);
                    } else {
                        return (feature.get(style.symbol.rotationAttribute)/360)*Math.PI;
                    }
                } else {
                    return undefined;
                }
            },
            generateShape: function(style, fill, stroke, feature) {
                var config = this.generateShapeConfig(style, fill, stroke);
                if (config && feature) {
                    config.rotation = this.calculateRotation(style, feature);
                }
                if (style.symbol.graphic) {
                    var info = stSvgIcon.getImage(style.symbol.graphic, fill.getColor(), stroke.getColor(), true);
                    return new ol.style.Icon({
                        src: info.dataURI,
                        rotation: this.calculateRotation(style, feature),
                        scale: style.symbol.size / Math.max(info.width, info.height),
                        opacity: style.symbol.opacity
                    });
                } else if (style.symbol.shape === 'circle') {
                    return new ol.style.Circle(config);
                } else {
                    return new ol.style.RegularShape(config);
                }
            },
            getText: function(style, feature) {
                if (style.label && style.label.attribute) {
                    return '' + feature.get(style.label.attribute);
                } else {
                    return undefined;
                }
            },
            generateText: function(style, stroke, feature) {
                if (style.label && style.label.attribute !== null) {
                    return new ol.style.Text({
                        fill: new ol.style.Fill({color: style.label.fillColor}),
                        stroke: stroke,
                        font: style.label.fontStyle + ' ' + style.label.fontWeight + ' ' + style.label.fontSize + 'px ' + style.label.fontFamily,
                        text: this.getText(style, feature)
                    });
                }
            },
            getColor: function(color, opacity) {
                var rgba = ol.color.asArray(color);
                if (opacity !== undefined) {
                    rgba = rgba.slice();
                    rgba[3] = opacity/100;
                }
                return 'rgba(' + rgba.join(',') + ')';
            },
            generateCacheKey: function(style, feature) {
                var text = this.getText(style, feature);
                var classify = (style.classify && style.classify.attribute) ? feature.get(style.classify.attribute) : undefined;
                var rotation = (style.symbol && style.symbol.rotationAttribute) ? feature.get(style.symbol.rotationAttribute): undefined;
                return text + '|' + classify + '|' + rotation;
            },
            generateStyle: function(style, feature, resolution) {
                var result, key2;
                if (!this.styleCache_) {
                    this.styleCache_ = {};
                }
                var key = JSON.stringify(style);
                if (this.styleCache_[key]) {
                    if (!this.styleCache_[key].length) {
                        key2 = this.generateCacheKey(style, feature);
                        if (this.styleCache_[key][key2]) {
                            return this.styleCache_[key][key2];
                        }
                    } else {
                        return this.styleCache_[key];
                    }
                }
                var stroke;
                if (style.stroke) {
                    var lineDash;
                    if (style.stroke.strokeStyle === 'dashed') {
                        lineDash = [5];
                    } else if (style.stroke.strokeStyle === 'dotted') {
                        lineDash = [1,2];
                    }
                    stroke = new ol.style.Stroke({
                        lineDash: lineDash,
                        color: this.getColor(style.stroke.strokeColor, style.stroke.strokeOpacity),
                        width: style.stroke.strokeWidth
                    });
                }
                if (style.classify && style.classify.attribute !== null) {
                    var label;
                    for (var i=0, ii=style.rules.length; i<ii; ++i) {
                        var rule = style.rules[i];
                        var attrVal = feature.get(style.classify.attribute);
                        var match = false;
                        if (rule.value !== undefined) {
                            match = attrVal === rule.value;
                        } else if (rule.range) {
                            match = (attrVal >= rule.range.min && attrVal <= rule.range.max);
                        }
                        if (match) {
                            label = this.generateText(style, stroke, feature);
                            if (style.geomType === 'point' && rule.style.symbol.fillColor) {
                                result = [new ol.style.Style({
                                    text: label,
                                    image: this.generateShape(style, new ol.style.Fill({color: rule.style.symbol.fillColor}), stroke, feature)
                                })];
                            } else if (style.geomType === 'line' && rule.style.stroke.strokeColor) {
                                result = [new ol.style.Style({
                                    text: label,
                                    stroke: new ol.style.Stroke({
                                        color: rule.style.stroke.strokeColor,
                                        width: 2
                                    })
                                })];
                            } else if (style.geomType === 'polygon' && rule.style.symbol.fillColor) {
                                result = [new ol.style.Style({
                                    text: label,
                                    stroke: stroke,
                                    fill: new ol.style.Fill({
                                        color: rule.style.symbol.fillColor
                                    })
                                })];
                            }
                        }
                    }
                    if (result) {
                        if (!this.styleCache_[key]) {
                            this.styleCache_[key] = {};
                        }
                        key2 = this.generateCacheKey(style, feature);
                        this.styleCache_[key][key2] = result;
                    }
                } else {
                    var fill = new ol.style.Fill({
                        color: this.getColor(style.symbol.fillColor, style.symbol.fillOpacity)
                    });
                    result = [
                        new ol.style.Style({
                            image: this.generateShape(style, fill, stroke, feature),
                            fill: fill,
                            stroke: stroke,
                            text: this.generateText(style, stroke, feature)
                        })
                    ];
                }
                if (result) {
                    var hasText = result[0].getText();
                    if (hasText || (style.classify && style.classify.attribute) || (style.symbol && style.symbol.rotationAttribute)) {
                        if (!this.styleCache_[key]) {
                            this.styleCache_[key] = {};
                        }
                        key2= this.generateCacheKey(style, feature);
                        this.styleCache_[key][key2] = result;
                    } else {
                        this.styleCache_[key] = result;
                    }
                }
                return result;
            }
        };
    }]);
})();

(function() {
    'use strict';

    var module = angular.module('storytools.core.style.svgIcon', []);

    module.factory('stSvgIcon', ["$cacheFactory", "$http", "$q", "$log", function($cacheFactory, $http, $q, $log) {
        var element = angular.element(document.createElement('div'));
        var imageCache = $cacheFactory('stSvgImage');
        var dataCache = $cacheFactory('stSvgData');
        function process(svg, fill, stroke) {
            element.html(svg);
            // @todo make smarter
            ['path', 'polygon', 'circle', 'ellipse', 'rect', 'line', 'polyline'].forEach(function(el) {
                angular.forEach(element.find(el), function(e) {
                    // @todo does it make sense to override stroke width?
                    e = angular.element(e);
                    var css = {
                        opacity: 1
                    };
                    var existingFill = e.css('fill') || e.attr('fill') || '';
                    if (existingFill != 'none' && existingFill != 'rgb(255, 255, 255)' && existingFill.toLowerCase() != '#ffffff') {
                        css.fill = fill;
                    }
                    var existingStroke = e.css('stroke') || e.attr('stroke');
                    if (existingStroke != 'none') {
                        css.stroke = stroke;
                    }
                    e.css(css);
                });
            });
            var root = element.find('svg');
            var width = parseInt(root.attr('width'));
            var height = parseInt(root.attr('height'));
            // ugh - we're totally guessing here but things go badly without:
            // on firefox: ns_error_not_available on calling canvas.drawimage
            // on chrome: very large icon (default size as it renders)
            // we might be able to set the src on an img element and figure this out...
            if (isNaN(width) || isNaN(height)) {
                root.attr('width', 64);
                root.attr('height', 64);
                width = 64;
                height = 64;
            }
            var dataURI = 'data:image/svg+xml;base64,' + btoa(element.html());
            return {
                dataURI: dataURI,
                width: width,
                height: height
            };
        }
        return {
            getImage: function(svgURI, fill, stroke, sync) {
                var key = svgURI + fill + stroke;
                var cached = imageCache.get(key);
                var deferred = $q.defer();
                if (cached) {
                    if (sync) {
                        return cached;
                    }
                    deferred.resolve(cached);
                } else {
                    if (sync) {
                        var svg = dataCache.get(svgURI);
                        if (svg) {
                            var imageInfo = process(svg, fill, stroke);
                            imageInfo.uri = svgURI;
                            imageCache.put(key, imageInfo);
                            return imageInfo;
                        }
                        $log.warning('no svg for', svgURI);
                        return null;
                    }
                    this.getImageData(svgURI).then(function(response) {
                        var imageInfo = process(response.data, fill, stroke);
                        imageInfo.uri = svgURI;
                        imageCache.put(key, imageInfo);
                        deferred.resolve(imageInfo);
                    }, function() {
                        deferred.reject('error');
                    });
                }
                return deferred.promise;
            },
            getImageData: function(svgURI) {
                return $http.get(svgURI, {cache: true}).success(function(response) {
                    dataCache.put(svgURI, response);
                    return response;
                }).error(function() {
                    $log.warn('error fetching ' + svgURI);
                });
            }
        };
    }]);

})();

(function () {
  'use strict';

  /**
   * @namespace storytools.core.time.directives
   */
  var module = angular.module('storytools.core.time.directives', []);

  /**
   * @ngdoc directive
   * @name stPlaybackControls
   * @memberOf storytools.core.time.directives
   * @description
   * Directive that presents playback controls to manipulate the provided
   * TimeController instance.
   *
   * @param {TimeController} time-controls attribute
   */
  module.directive('stPlaybackControls', function () {
    return {
      restrict: 'E',
      templateUrl: 'time/playback-controls.html',
      scope: {
        timeControls: '=',
        playbackOptions: '='
      },
      link: function (scope, elem) {
        scope.playbackState = "Play";
        scope.loopText = 'Loop Chapter';
        scope.loopStoryEnabled = false;
        scope.loopChapterEnabled = false;
        scope.showTimeLine = false;
        scope.next = function () {
          scope.timeControls.next();
        };
        scope.prev = function () {
          scope.timeControls.prev();
        };
        scope.$watch('timeControls', function (neu, old) {
          if (neu !== old) {
            neu.on('stateChange', function () {
              var started = scope.timeControls.isStarted();
              scope.started = started;
              scope.playbackState = started ? "Pause" : "Play";
              scope.$apply();
            });
            neu.on('rangeChange', function (range) {
              scope.currentRange = range;
              scope.$apply();
            });
          }
        });
        scope.$on('pausePlayback', function () {
          var tc = scope.timeControls;
          var started = tc.isStarted();
          if (started) {
            tc.stop();
          }
        });
        scope.play = function () {
          var tc = scope.timeControls;
          var started = tc.isStarted();
          if (started) {
            tc.stop();
          } else {
            tc.start();
          }
        };

        /**
         * Check if window is in full screen mode.
         * @return {Boolean} full screen mode
         */
        scope.isInFullScreen = function (doc) {


          if (doc.fullScreenElement !== undefined) {
            return !!doc.fullScreenElement;
          }


          if (doc.mozFullScreen !== undefined) {
            return !!doc.mozFullScreen;
          }


          if (doc.webkitIsFullScreen !== undefined) {
            return !!doc.webkitIsFullScreen;
          }


          if (window.fullScreen !== undefined) {
            return !!window.fullScreen;
          }


          if (window.navigator.standalone !== undefined) {
            return !!window.navigator.standalone;
          }
        };

        scope.toggleFullScreen = function () {
          var elem = window.parent.document.getElementById('embedded_map');

          if (!this.isInFullScreen(document) && !this.isInFullScreen(parent.document)) {
            if (!document.webkitFullScreen || !document.mozFullScreen || !document.msFullscreenElement || !document.fullscreenElement) {
              if (elem.requestFullscreen) {
                elem.requestFullscreen();
              } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
              } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
              } else if (elem.webkitRequestFullScreen) {
                elem.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
              }
            }
          } else {
            if (document.mozCancelFullScreen) {
              parent.document.mozCancelFullScreen();
              document.mozCancelFullScreen();
            } else {
              parent.document.webkitCancelFullScreen();
              document.webkitCancelFullScreen();
            }
          }
        };

        scope.toggleLoop = function () {
          var tc = scope.timeControls;
          if (tc.loop === 'none') {
            scope.loop = tc.loop = 'chapter';
            scope.loopText = 'Loop Story';
            scope.loopChapterEnabled = true;
          } else if (tc.loop === 'chapter') {
            scope.loop = tc.loop = 'story';
            scope.loopText = 'Disable Loop';
            scope.loopStoryEnabled = true;
            scope.loopChapterEnabled = false;
          } else {
            scope.loopText = 'Loop Chapter';
            scope.loop = tc.loop = 'none';
            scope.loopStoryEnabled = false;
            scope.loopChapterEnabled = false;          }
        };

        scope.getLoopButtonGlyph = function(){
          if (scope.loop === 'story') {
            return 'glyphicon glyphicon-refresh';
          } else {
            return 'glyphicon glyphicon-repeat';
          }
        };

        scope.toggleTimeLine = function () {
          var tc = scope.timeControls;
          scope.showTimeLine = tc.showTimeLine = !tc.showTimeLine;
          var element = $('#timeline');

          if (tc.showTimeLine) {
            element.show("slow");

          } else {
            element.hide("slow");
          }
        };
      }
    };
  });

  /**
   * @ngdoc directive
   * @name stPlaybackSettings
   * @memberOf storytools.core.time.directives
   * @description
   * Directive that presents playback settings that manipulate the provided
   * TimeController instance.
   *
   * @param {TimeController} time-controls attribute
   * @param {object} playbackOptions (will go away)
   */
  module.directive('stPlaybackSettings', function () {
    return {
      restrict: 'E',
      templateUrl: 'time/playback-settings.html',
      scope: {
        timeControls: '=',
        // @todo remove once timeControls properly exposes access to this
        playbackOptions: '='
      },
      link: function (scope, elem) {
        scope.optionsChanged = function () {
          if (scope.timeControls) {
            scope.timeControls.update(scope.playbackOptions);
          }
        };
      }
    };
  });
})();

(function() {
    'use strict';

    var module = angular.module('storytools.core.time', [
        'storytools.core.time.directives',
        'storytools.core.time.services',
        'storytools.core.templates'
    ]);

    module.filter('isodate', function() {
        // @todo should support optional precision specifier (as unit?)
        return function(input) {
            return input !== null && angular.isDefined(input)  ?
                angular.isNumber(input) ? new Date(input).toISOString():
                    Date.parse(input).toISOString():
                    '';
        };
    });

})();
(function() {
    'use strict';

    var module = angular.module('storytools.core.time.services', []);

    var stutils = storytools.core.time.utils;

    /**
     * Compute a sorted, unique array of ticks for the provided layers. The
     * algorithm uses any provided instant or extent(start value used) list values
     * and looks at the total range of all interval values creating a tick at the
     * minimum interval for the total range. See the tests for examples.
     * @param {array|ol.Map} layersWithTime
     * @returns array of ticks
     */
    function computeTicks(layersWithTime) {
        // allow a map to be passed in
        if (!angular.isArray(layersWithTime)) {
            var storyMap = layersWithTime;
            layersWithTime = storyMap.getStoryLayers().getArray().filter(function(l) {
                var times = l.get('times');
                /*jshint eqnull:true */
                return times != null;
            });
            layersWithTime.push(storyMap.storyPinsLayer);
            layersWithTime.push(storyMap.storyBoxesLayer);
        }
        var ticks = {};
        var totalRange = null;
        var intervals = [];
        function addTick(add) {
            add = stutils.getTime(add);
            if (add !== null && ! (add in ticks)) {
                ticks[add] = 1;
            }
        }
        layersWithTime.forEach(function(l) {
            var times = l.get('times');
            var range;
            if (angular.isArray(times)) {
                // an array of instants or extents
                range = stutils.computeRange(times);
                if (times.length) {
                    if (stutils.isRangeLike(times[0])) {
                        times.forEach(function(r) {
                            addTick(r.start);
                            if (totalRange === null) {
                                totalRange = stutils.createRange(r);
                            } else {
                                totalRange.extend(r);
                            }
                        });
                    } else {
                        times.forEach(function(r) {
                            addTick(r);
                        });
                    }
                }
                // add a tick at the end to ensure we get there
                /*jshint eqnull:true */
                if (range.end != null) {
                    addTick(range.end);
                }
            } else if (times) {
                // a interval (range+duration)
                range = times;
                intervals.push(times);
            }
            if (totalRange === null) {
                // copy, will be modifying
                totalRange = stutils.createRange(range);
            } else {
                totalRange.extend(range);
            }
        });
        if (intervals.length) {
            intervals.sort(function(a, b) {
                return a.interval - b.interval;
            });
            var smallest = intervals[0];
            var start = totalRange.start;
            while (start <= totalRange.end) {
                addTick(start);
                start = smallest.offset(start);
            }
        }
        ticks = Object.getOwnPropertyNames(ticks).map(function(t) {
            return parseInt(t);
        });
        return ticks.sort(function(a, b) {
            return a - b;
        });
    }

    function TimeControlsManager($log, $rootScope, StoryPinLayerManager, MapManager) {
        this.timeControls = null;
        var timeControlsManager = this;

        function maybeCreateTimeControls(update) {
            if (timeControlsManager.timeControls !== null) {
                if (update) {
                    var values = update();
                    if (values) {
                        timeControlsManager.timeControls.update(values);
                    }
                }
                return;
            }
            var range = computeTicks(MapManager.storyMap);
            if (range.length) {
                var annotations = StoryPinLayerManager.storyPins;
                timeControlsManager.timeControls = storytools.core.time.create({
                    annotations: annotations,
                    storyMap: MapManager.storyMap,
                    storyLayers: MapManager.storyMap.getStoryLayers().getArray(),
                    data: range,
                    mode: MapManager.storyMap.mode,
                    tileStatusCallback: function(remaining) {
                        $rootScope.$broadcast('tilesLoaded', remaining);
                    },
                    chapterCount: MapManager.chapterCount
                });
                timeControlsManager.timeControls.on('rangeChange', function(range) {
                    timeControlsManager.currentRange = range;
                    $rootScope.$broadcast('rangeChange', range);
                });
            }
        }

        MapManager.storyMap.getStoryLayers().on('change:length', function() {
            maybeCreateTimeControls(function() {
                var range = computeTicks(MapManager.storyMap);
                if (range.length >= 0) {
                    return {
                        storyLayers: MapManager.storyMap.getStoryLayers().getArray(),
                        data: range
                    };
                }
            });
        });
        var pinsLayer = MapManager.storyMap.storyPinsLayer;
        var boxesLayer = MapManager.storyMap.storyBoxesLayer;
        pinsLayer.on('change:features', function() {
            maybeCreateTimeControls(function() {
                var range = computeTicks(MapManager.storyMap);
                if (range.length >= 0) {
                    return {
                        annotations: pinsLayer.get("features"),
                        data: range
                    };
                }
            });
        });

        boxesLayer.on('change:features', function() {
            maybeCreateTimeControls(function() {
                var range = computeTicks(MapManager.storyMap);
                if (range.length >= 0) {
                    return {
                        boxes: boxesLayer.get("features"),
                        data: range
                    };
                }
            });
        });

        maybeCreateTimeControls();
    }

    module.constant('TimeControlsManager', TimeControlsManager);

    module.service('TimeMachine', function() {
        return {
            computeTicks: computeTicks
        };
    });
})();

(function() {
    'use strict';
    var module = angular.module('storytools.core.mapstory.localStorageSvc', []);

    module.service('stLocalStorageSvc', ["$http", function($http) {
        function path(mapid) {
            return '/maps/' + mapid;
        }

        var localStorageHandler = {};

        localStorageHandler.get = function(mapid) {
            var saved = localStorage.getItem(path(mapid));
            saved = (saved === null) ? {} : angular.fromJson(saved);
            return saved;
        };

        localStorageHandler.set = function(mapConfig) {
            localStorage.setItem(path(mapConfig.id), angular.toJson(mapConfig));
        };

        localStorageHandler.list = function() {
            var maps = [];
            var pattern = new RegExp('/maps/(\\d+)$');
            Object.getOwnPropertyNames(localStorage).forEach(function(key) {
                var match = pattern.exec(key);
                if (match) {
                    // name/title eventually
                    maps.push({
                        id: match[1]
                    });
                }
            });
            return maps;
        };

        localStorageHandler.nextId = function() {
            var lastId = 0;
            var existing = localStorageHandler.list().map(function(m) {
                return m.id;
            });
            existing.sort();
            if (existing.length) {
                lastId = parseInt(existing[existing.length - 1]);
            }
            return lastId + 1;
        };

        return {
            listMaps: function() {
                return localStorageHandler.list();
            },
            loadConfig: function(mapid) {
                return localStorageHandler.get(mapid);
            },
            saveConfig: function(mapConfig) {
                if (!angular.isDefined(mapConfig.id)) {
                    mapConfig.id = localStorageHandler.nextId();
                }
                localStorageHandler.set(mapConfig);
            }
        };
    }]);
})();

(function() {
    'use strict';

    var module = angular.module('storytools.core.mapstory.remoteStorageSvc', []);

    module.factory('stRemoteStorageSvc', ["$q", "$http", function($q, $http) {

    this.save = function(map_config) {

      // @TODO: Update window.config and save to server

    };
  }]);
})();

(function() {
    'use strict';

    var module = angular.module('storytools.core.mapstory.services', [
        'storytools.core.mapstory.localStorageSvc',
        'storytools.core.mapstory.remoteStorageSvc'
    ]);
})();

!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.owsjs=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
//'use strict';
exports.Jsonix = require('../../bower_components/jsonix/dist/Jsonix-all.js').Jsonix;
exports.mappings = {};
exports.mappings.XLink_1_0 = require('../../bower_components/w3c-schemas/scripts/lib/XLink_1_0.js').XLink_1_0;
exports.mappings.Filter_1_0_0 = require('../../bower_components/ogc-schemas/scripts/lib/Filter_1_0_0.js').Filter_1_0_0;
exports.mappings.GML_2_1_2 = require('../../bower_components/ogc-schemas/scripts/lib/GML_2_1_2.js').GML_2_1_2;
exports.mappings.SLD_1_0_0 = require('../../bower_components/ogc-schemas/scripts/lib/SLD_1_0_0.js').SLD_1_0_0;
exports.mappings.OWS_1_1_0 = require('../../bower_components/ogc-schemas/scripts/lib/OWS_1_1_0.js').OWS_1_1_0;
exports.mappings.Filter_1_1_0 = require('../../bower_components/ogc-schemas/scripts/lib/Filter_1_1_0.js').Filter_1_1_0;
exports.mappings.OWS_1_0_0 = require('../../bower_components/ogc-schemas/scripts/lib/OWS_1_0_0.js').OWS_1_0_0;
exports.mappings.SMIL_2_0 = require('../../bower_components/ogc-schemas/scripts/lib/SMIL_2_0.js').SMIL_2_0;
exports.mappings.SMIL_2_0_Language = require('../../bower_components/ogc-schemas/scripts/lib/SMIL_2_0_Language.js').SMIL_2_0_Language;
exports.mappings.GML_3_1_1 = require('../../bower_components/ogc-schemas/scripts/lib/GML_3_1_1.js').GML_3_1_1;
exports.mappings.WFS_1_1_0 = require('../../bower_components/ogc-schemas/scripts/lib/WFS_1_1_0.js').WFS_1_1_0;
exports.mappings.WPS_1_0_0 = require('../../bower_components/ogc-schemas/scripts/lib/WPS_1_0_0.js').WPS_1_0_0;
exports.mappings.XSD_1_0 = require('../../bower_components/w3c-schemas/scripts/lib/XSD_1_0.js').XSD_1_0;
exports.mappings.WMSC_1_1_1 = require('../../bower_components/ogc-schemas/scripts/lib/WMSC_1_1_1.js').WMSC_1_1_1;
exports.mappings.WMS_1_3_0 = require('../../bower_components/ogc-schemas/scripts/lib/WMS_1_3_0.js').WMS_1_3_0;
exports.mappings.WMS_1_3_0_Exceptions = require('../../bower_components/ogc-schemas/scripts/lib/WMS_1_3_0_Exceptions.js').WMS_1_3_0_Exceptions;

// modify the JSONIX mapping to add the GeoServer specific VendorOption
exports.mappings.SLD_1_0_0.tis.push({
    ln: 'VendorOption',
    ps: [{
        n: 'name',
        an: {
            lp: 'name'
        },
            t: 'a'
        }, {
            n: 'content',
            t: 'v'
        }
    ]
});

for (var i=0, ii=exports.mappings.SLD_1_0_0.tis.length; i<ii; i++) {
    if (exports.mappings.SLD_1_0_0.tis[i].ln === 'TextSymbolizer') {
        exports.mappings.SLD_1_0_0.tis[i].ps.push({
            n: 'vendorOption',
            en: 'VendorOption',
            col: true,
            ti: '.VendorOption'
        });
    }
}
// end of modification

},{"../../bower_components/jsonix/dist/Jsonix-all.js":2,"../../bower_components/ogc-schemas/scripts/lib/Filter_1_0_0.js":3,"../../bower_components/ogc-schemas/scripts/lib/Filter_1_1_0.js":4,"../../bower_components/ogc-schemas/scripts/lib/GML_2_1_2.js":5,"../../bower_components/ogc-schemas/scripts/lib/GML_3_1_1.js":6,"../../bower_components/ogc-schemas/scripts/lib/OWS_1_0_0.js":7,"../../bower_components/ogc-schemas/scripts/lib/OWS_1_1_0.js":8,"../../bower_components/ogc-schemas/scripts/lib/SLD_1_0_0.js":9,"../../bower_components/ogc-schemas/scripts/lib/SMIL_2_0.js":10,"../../bower_components/ogc-schemas/scripts/lib/SMIL_2_0_Language.js":11,"../../bower_components/ogc-schemas/scripts/lib/WFS_1_1_0.js":12,"../../bower_components/ogc-schemas/scripts/lib/WMSC_1_1_1.js":13,"../../bower_components/ogc-schemas/scripts/lib/WMS_1_3_0.js":14,"../../bower_components/ogc-schemas/scripts/lib/WMS_1_3_0_Exceptions.js":15,"../../bower_components/ogc-schemas/scripts/lib/WPS_1_0_0.js":16,"../../bower_components/w3c-schemas/scripts/lib/XLink_1_0.js":17,"../../bower_components/w3c-schemas/scripts/lib/XSD_1_0.js":18}],2:[function(require,module,exports){
/*global window */
var _jsonix_factory = function(_jsonix_xmldom, _jsonix_xmlhttprequest, _jsonix_fs)
{
	// Complete Jsonix script is included below 
var Jsonix = {
	singleFile : true
};
Jsonix.Util = {};

Jsonix.Util.extend = function(destination, source) {
	var property, value, sourceIsEvt;
	destination = destination || {};
	if (source) {
		/*jslint forin: true */
		for (property in source) {
			value = source[property];
			if (value !== undefined) {
				destination[property] = value;
			}
		}

		/**
		 * IE doesn't include the toString property when iterating over an
		 * object's properties with the for(property in object) syntax.
		 * Explicitly check if the source has its own toString property.
		 */

		/*
		 * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
		 * prototype object" when calling hawOwnProperty if the source object is
		 * an instance of window.Event.
		 */

		// REWORK
		// Node.js
		sourceIsEvt = typeof window !== 'undefined' && window !== null && typeof window.Event === "function" && source instanceof window.Event;

		if (!sourceIsEvt && source.hasOwnProperty && source.hasOwnProperty('toString')) {
			destination.toString = source.toString;
		}
	}
	return destination;
};
Jsonix.Class = function() {
	var Class = function() {
		this.initialize.apply(this, arguments);
	};
        var extended = {};
	var empty = function() {
	};
	var parent, initialize, Type;
	for (var i = 0, len = arguments.length; i < len; ++i) {
		Type = arguments[i];
		if (typeof Type == "function") {
			// make the class passed as the first argument the superclass
			if (i === 0 && len > 1) {
				initialize = Type.prototype.initialize;
				// replace the initialize method with an empty function,
				// because we do not want to create a real instance here
				Type.prototype.initialize = empty;
				// the line below makes sure that the new class has a
				// superclass
				extended = new Type();
				// restore the original initialize method
				if (initialize === undefined) {
					delete Type.prototype.initialize;
				} else {
					Type.prototype.initialize = initialize;
				}
			}
			// get the prototype of the superclass
			parent = Type.prototype;
		} else {
			// in this case we're extending with the prototype
			parent = Type;
		}
		Jsonix.Util.extend(extended, parent);
	}
	Class.prototype = extended;
	return Class;
};

Jsonix.XML = {
		XMLNS_NS : 'http://www.w3.org/2000/xmlns/',
		XMLNS_P : 'xmlns'
		
};


Jsonix.DOM = {
	createDocument : function() {
		// REWORK
		// Node.js
		if (typeof _jsonix_xmldom !== 'undefined')
		{
			return new (_jsonix_xmldom.DOMImplementation)().createDocument();
		} else if (typeof document !== 'undefined' && Jsonix.Util.Type.exists(document.implementation) && Jsonix.Util.Type.isFunction(document.implementation.createDocument)) {
			return document.implementation.createDocument('', '', null);
		} else if (typeof ActiveXObject !== 'undefined') {
			return new ActiveXObject('MSXML2.DOMDocument');
		} else {
			throw new Error('Error created the DOM document.');
		}
	},
	serialize : function(node) {
		Jsonix.Util.Ensure.ensureExists(node);
		// REWORK
		// Node.js
		if (typeof _jsonix_xmldom !== 'undefined')
		{
			return (new (_jsonix_xmldom).XMLSerializer()).serializeToString(node);
		} else if (Jsonix.Util.Type.exists(XMLSerializer)) {
			return (new XMLSerializer()).serializeToString(node);
		} else if (Jsonix.Util.Type.exists(node.xml)) {
			return node.xml;
		} else {
			throw new Error('Could not serialize the node, neither XMLSerializer nor the [xml] property were found.');
		}
	},
	parse : function(text) {
		Jsonix.Util.Ensure.ensureExists(text);
		if (typeof _jsonix_xmldom !== 'undefined')
		{
			return (new (_jsonix_xmldom).DOMParser()).parseFromString(text, 'application/xml');
		} else if (typeof DOMParser != 'undefined') {
			return (new DOMParser()).parseFromString(text, 'application/xml');
		} else if (typeof ActiveXObject != 'undefined') {
			var doc = Jsonix.DOM.createDocument('', '');
			doc.loadXML(text);
			return doc;
		} else {
			var url = 'data:text/xml;charset=utf-8,' + encodeURIComponent(text);
			var request = new XMLHttpRequest();
			request.open('GET', url, false);
			if (request.overrideMimeType) {
				request.overrideMimeType("text/xml");
			}
			request.send(null);
			return request.responseXML;
		}
	},
	load : function(url, callback, options) {

		var request = Jsonix.Request.INSTANCE;

		request.issue(
						url,
						function(transport) {
							var result;
							if (Jsonix.Util.Type.exists(transport.responseXML) && Jsonix.Util.Type.exists(transport.responseXML.documentElement)) {
								result = transport.responseXML;
							} else if (Jsonix.Util.Type.isString(transport.responseText)) {
								result = Jsonix.DOM.parse(transport.responseText);
							} else {
								throw new Error('Response does not have valid [responseXML] or [responseText].');
							}
							callback(result);

						}, function(transport) {
							throw new Error('Could not retrieve XML from URL [' + url	+ '].');

						}, options);
	},
	xlinkFixRequired : null,
	isXlinkFixRequired : function ()
	{
		if (Jsonix.DOM.xlinkFixRequired === null)
		{
			if (typeof navigator === 'undefined')
			{
				Jsonix.DOM.xlinkFixRequired = false;
			}
			else if (!!navigator.userAgent && (/Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)))
			{
				var doc = Jsonix.DOM.createDocument();
				var el = doc.createElement('test');
				el.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', 'urn:test');
				doc.appendChild(el);
				var testString = Jsonix.DOM.serialize(doc);
				Jsonix.DOM.xlinkFixRequired = (testString.indexOf('xmlns:xlink') === -1);
			}
			else
			{
				Jsonix.DOM.xlinkFixRequired = false;
			}
		}
		return Jsonix.DOM.xlinkFixRequired;
	}
};
Jsonix.Request = Jsonix
		.Class({
			// REWORK
			factories : [ function() {
				return new XMLHttpRequest();
			}, function() {
				return new ActiveXObject('Msxml2.XMLHTTP');
			}, function() {
				return new ActiveXObject("Msxml2.XMLHTTP.6.0");
			}, function() {
				return new ActiveXObject("Msxml2.XMLHTTP.3.0");
			}, function() {
				return new ActiveXObject('Microsoft.XMLHTTP');
			}, function() {
				// Node.js
				if (typeof _jsonix_xmlhttprequest !== 'undefined')
				{
					var XMLHttpRequest = _jsonix_xmlhttprequest.XMLHttpRequest;
					return new XMLHttpRequest();
				}
				else
				{
					return null;
				}
			}],
			initialize : function() {
			},
			issue : function(url, onSuccess, onFailure, options) {
				Jsonix.Util.Ensure.ensureString(url);
				if (Jsonix.Util.Type.exists(onSuccess)) {
					Jsonix.Util.Ensure.ensureFunction(onSuccess);
				} else {
					onSuccess = function() {
					};
				}
				if (Jsonix.Util.Type.exists(onFailure)) {
					Jsonix.Util.Ensure.ensureFunction(onFailure);
				} else {
					onFailure = function() {
					};
				}
				if (Jsonix.Util.Type.exists(options)) {
					Jsonix.Util.Ensure.ensureObject(options);
				} else {
					options = {};
				}

				var transport = this.createTransport();

				var method = Jsonix.Util.Type.isString(options.method) ? options.method
						: 'GET';
				var async = Jsonix.Util.Type.isBoolean(options.async) ? options.async
						: true;
				var proxy = Jsonix.Util.Type.isString(options.proxy) ? options.proxy
						: Jsonix.Request.PROXY;

				var user = Jsonix.Util.Type.isString(options.user) ? options.user
						: null;
				var password = Jsonix.Util.Type.isString(options.password) ? options.password
						: null;

				if (Jsonix.Util.Type.isString(proxy) && (url.indexOf("http") === 0)) {
					url = proxy + encodeURIComponent(url);
				}

				if (Jsonix.Util.Type.isString(user)) {
					transport.open(method, url, async, user, password);
				} else {
					transport.open(method, url, async);
				}

				if (Jsonix.Util.Type.isObject(options.headers)) {

					for ( var header in options.headers) {
						if (options.headers.hasOwnProperty(header)) {
							transport.setRequestHeader(header,
									options.headers[header]);
						}
					}
				}

				var data = Jsonix.Util.Type.exists(options.data) ? options.data
						: null;
				if (!async) {
					transport.send(data);
					this.handleTransport(transport, onSuccess, onFailure);
				} else {
					var that = this;
					if (typeof window !== 'undefined') {

						transport.onreadystatechange = function() {
							that.handleTransport(transport, onSuccess,
									onFailure);
						};

						window.setTimeout(function() {
							transport.send(data);
						}, 0);
					} else {

						transport.onreadystatechange = function() {
							that.handleTransport(transport, onSuccess, onFailure);
						};
						console.log('Sending.');
						transport.send(data);
					}
				}
				return transport;

			},
			handleTransport : function(transport, onSuccess, onFailure) {
				if (transport.readyState == 4) {
					if (!transport.status || (transport.status >= 200 && transport.status < 300)) {
						onSuccess(transport);
					}
					if (transport.status && (transport.status < 200 || transport.status >= 300)) {
						onFailure(transport);
					}
				}
			},
			createTransport : function() {
				for ( var index = 0, length = this.factories.length; index < length; index++) {
					try {
						var transport = this.factories[index]();
						if (transport !== null) {
							return transport;
						}
					} catch (e) {
						// TODO log
					}
				}
				throw new Error('Could not create XML HTTP transport.');
			},
			CLASS_NAME : 'Jsonix.Request'
		});
Jsonix.Request.INSTANCE = new Jsonix.Request();
Jsonix.Request.PROXY = null;
Jsonix.Schema = {};
Jsonix.Model = {};
Jsonix.Util.Type = {
	exists : function(value) {
		return (typeof value !== 'undefined' && value !== null);
	},
	isString : function(value) {
		return typeof value === 'string';
	},
	isBoolean : function(value) {
		return typeof value === 'boolean';
	},
	isObject : function(value) {
		return typeof value === 'object';
	},
	isFunction : function(value) {
		return typeof value === 'function';
	},
	isNumber : function(value) {
		return (typeof value === 'number') && !isNaN(value);
	},
	isNumberOrNaN : function(value) {
		return (value === +value) || (Object.prototype.toString.call(value) === '[object Number]');
	},
	isNaN : function(value) {
		return Jsonix.Util.Type.isNumberOrNaN(value) && isNaN(value);
	},
	isArray : function(value) {
		// return value instanceof Array;
		return !!(value && value.concat && value.unshift && !value.callee);
	},
	isDate : function(value) {
		return !!(value && value.getTimezoneOffset && value.setUTCFullYear);
	},
	isRegExp : function(value) {
		return !!(value && value.test && value.exec && (value.ignoreCase || value.ignoreCase === false));
	},
	isEqual : function(a, b, report) {
		var doReport = Jsonix.Util.Type.isFunction(report);
		// TODO rework
		var _range = function(start, stop, step) {
			var args = slice.call(arguments);
			var solo = args.length <= 1;
			var start_ = solo ? 0 : args[0];
			var stop_ = solo ? args[0] : args[1];
			var step_ = args[2] || 1;
			var len = Math.max(Math.ceil((stop_ - start_) / step_), 0);
			var idx = 0;
			var range = new Array(len);
			while (idx < len) {
				range[idx++] = start_;
				start_ += step_;
			}
			return range;
		};

		var _keys = Object.keys || function(obj) {
			if (Jsonix.Util.Type.isArray(obj)) {
				return _range(0, obj.length);
			}
			var keys = [];
			for ( var key in obj) {
				if (obj.hasOwnProperty(key)) {
					keys[keys.length] = key;
				}
			}
			return keys;
		};

		// Check object identity.
		if (a === b) {
			return true;
		}

		// Check if both are NaNs
		if (Jsonix.Util.Type.isNaN(a) && Jsonix.Util.Type.isNaN(b)) {
			return true;
		}
		// Different types?
		var atype = typeof a;
		var btype = typeof b;
		if (atype != btype) {
			if (doReport) {
				report('Types differ [' + atype + '], [' + btype + '].');
			}
			return false;
		}
		// Basic equality test (watch out for coercions).
		if (a == b) {
			return true;
		}
		// One is falsy and the other truthy.
		if ((!a && b) || (a && !b)) {
			if (doReport) {
				report('One is falsy, the other is truthy.');
			}
			return false;
		}
		// Check dates' integer values.
		if (Jsonix.Util.Type.isDate(a) && Jsonix.Util.Type.isDate(b)) {
			return a.getTime() === b.getTime();
		}
		// Both are NaN?
		if (Jsonix.Util.Type.isNaN(a) && Jsonix.Util.Type.isNaN(b)) {
			return false;
		}
		// Compare regular expressions.
		if (Jsonix.Util.Type.isRegExp(a) && Jsonix.Util.Type.isRegExp(b)) {
			return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline;
		}
		// If a is not an object by this point, we can't handle it.
		if (atype !== 'object') {
			return false;
		}
		// Check for different array lengths before comparing contents.
		if (a.length && (a.length !== b.length)) {
			if (doReport) {
					report('Lengths differ.');
					report('A.length=' + a.length);
					report('B.length=' + b.length);
			}
			return false;
		}
		// Nothing else worked, deep compare the contents.
		var aKeys = _keys(a);
		var bKeys = _keys(b);
		// Different object sizes?
		if (aKeys.length != bKeys.length) {
			if (doReport) {
				report('Different number of properties [' + aKeys.length + '], [' + bKeys.length + '].');
			}
			for ( var andex = 0; andex < aKeys.length; andex++) {
				if (doReport) {
					report('A [' + aKeys[andex] + ']=' + a[aKeys[andex]]);
				}
			}
			for ( var bndex = 0; bndex < bKeys.length; bndex++) {
				if (doReport) {
					report('B [' + bKeys[bndex] + ']=' + b[bKeys[bndex]]);
				}
			}
			return false;
		}
		// Recursive comparison of contents.
		for (var kndex = 0; kndex < aKeys.length; kndex++) {
			var key = aKeys[kndex];
			if (!(key in b) || !Jsonix.Util.Type.isEqual(a[key], b[key], report)) {
				if (doReport) {
					report('One of the properties differ.');
					report('Key: [' + key + '].');
					report('Left: [' + a[key] + '].');
					report('Right: [' + b[key] + '].');
				}
				return false;
			}
		}
		return true;
	},
	cloneObject : function (source, target)
	{
		target = target || {};
		for (var p in source)
		{
			if (source.hasOwnProperty(p))
			{
				target[p] = source[p];
			}
		}
		return target;
	}
};
Jsonix.Util.NumberUtils = {
	isInteger : function(value) {
		return Jsonix.Util.Type.isNumber(value) && ((value % 1) === 0);
	}
};
Jsonix.Util.StringUtils = {
	trim : (!!String.prototype.trim) ?
	function(str) {
		Jsonix.Util.Ensure.ensureString(str);
		return str.trim();
	} :
	function(str) {
		Jsonix.Util.Ensure.ensureString(str);
		return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	},
	/* isEmpty : function(str) {
		var wcm = Jsonix.Util.StringUtils.whitespaceCharactersMap;
		for (var index = 0; index < str.length; index++)
		{
			if (!wcm[str[index]])
			{
				return false;
			}
		}
		return true;
	}, */
	isEmpty : function(str) {
		var length = str.length;
		if (!length) {
			return true;
		}
		for (var index = 0; index < length; index++)
		{
			var c = str[index];
			if (c === ' ')
			{
				// skip
			}
			else if (c > '\u000D' && c < '\u0085')
			{
				return false;
			}
			else if (c < '\u00A0')
			{
				if (c < '\u0009')
				{
					return false;
				}
				else if (c > '\u0085')
				{
					return false;
				}
			}
			else if (c > '\u00A0')
			{
				if (c < '\u2028')
				{
					if (c < '\u180E')
					{
						if (c < '\u1680')
						{
							return false;
						}
						else if(c > '\u1680')
						{
							return false;
						}
					}
					else if (c > '\u180E')
					{
						if (c < '\u2000')
						{
							return false;
						}
						else if (c > '\u200A')
						{
							return false;
						}
					}
				}
				else if (c > '\u2029')
				{
					if (c < '\u205F')
					{
						if (c < '\u202F')
						{
							return false;
						}
						else if (c > '\u202F')
						{
							return false;
						}
					}
					else if (c > '\u205F')
					{
						if (c < '\u3000')
						{
							return false;
						}
						else if (c > '\u3000')
						{
							return false;
						}
					}
				}
			}
		}
		return true;
	},
	isNotBlank : function(str) {
		return Jsonix.Util.Type.isString(str) && !Jsonix.Util.StringUtils.isEmpty(str);
	},
	whitespaceCharacters: '\u0009\u000A\u000B\u000C\u000D \u0085\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000',
	whitespaceCharactersMap: {
		'\u0009' : true,
		'\u000A' : true,
		'\u000B' : true,
		'\u000C' : true,
		'\u000D' : true,
		' ' : true,
		'\u0085' : true,
		'\u00A0' : true,
		'\u1680' : true,
		'\u180E' : true,
		'\u2000' : true,
		'\u2001' : true,
		'\u2002' : true,
		'\u2003' : true,
		'\u2004' : true,
		'\u2005' : true,
		'\u2006' : true,
		'\u2007' : true,
		'\u2008' : true,
		'\u2009' : true,
		'\u200A' : true,
		'\u2028' : true,
		'\u2029' : true,
		'\u202F' : true,
		'\u205F' : true,
		'\u3000' : true
	},
	splitBySeparatorChars : function(str, separatorChars) {
		Jsonix.Util.Ensure.ensureString(str);
		Jsonix.Util.Ensure.ensureString(separatorChars);
		var len = str.length;
		if (len === 0) {
			return [];
		}
		if (separatorChars.length === 1)
		{
			return str.split(separatorChars);
		}
		else
		{
			var list = [];
			var sizePlus1 = 1;
			var i = 0;
			var start = 0;
			var match = false;
			var lastMatch = false;
			var max = -1;
			var preserveAllTokens = false;
			// standard case
				while (i < len) {
						if (separatorChars.indexOf(str.charAt(i)) >= 0) {
								if (match || preserveAllTokens) {
										lastMatch = true;
										if (sizePlus1++ == max) {
												i = len;
												lastMatch = false;
										}
										list.push(str.substring(start, i));
										match = false;
								}
								start = ++i;
								continue;
						}
						lastMatch = false;
						match = true;
						i++;
				}
				if (match || (preserveAllTokens && lastMatch)) {
					list.push(str.substring(start, i));
			}
			return list;
		}
	}
};
Jsonix.Util.Ensure = {
	ensureBoolean : function(value) {
		if (!Jsonix.Util.Type.isBoolean(value)) {
			throw new Error('Argument [' + value + '] must be a boolean.');
		}
	},
	ensureString : function(value) {
		if (!Jsonix.Util.Type.isString(value)) {
			throw new Error('Argument [' + value + '] must be a string.');
		}
	},
	ensureNumber : function(value) {
		if (!Jsonix.Util.Type.isNumber(value)) {
			throw new Error('Argument [' + value + '] must be a number.');
		}
	},
	ensureNumberOrNaN : function(value) {
		if (!Jsonix.Util.Type.isNumberOrNaN(value)) {
			throw new Error('Argument [' + value + '] must be a number or NaN.');
		}
	},
	ensureInteger : function(value) {
		if (!Jsonix.Util.Type.isNumber(value)) {
			throw new Error('Argument must be an integer, but it is not a number.');
		} else if (!Jsonix.Util.NumberUtils.isInteger(value)) {
			throw new Error('Argument [' + value + '] must be an integer.');
		}
	},
	ensureDate : function(value) {
		if (!(value instanceof Date)) {
			throw new Error('Argument [' + value + '] must be a date.');
		}
	},
	ensureObject : function(value) {
		if (!Jsonix.Util.Type.isObject(value)) {
			throw new Error('Argument [' + value + '] must be an object.');
		}
	},
	ensureArray : function(value) {
		if (!Jsonix.Util.Type.isArray(value)) {
			throw new Error('Argument [' + value + '] must be an array.');
		}
	},
	ensureFunction : function(value) {
		if (!Jsonix.Util.Type.isFunction(value)) {
			throw new Error('Argument [' + value + '] must be a function.');
		}
	},
	ensureExists : function(value) {
		if (!Jsonix.Util.Type.exists(value)) {
			throw new Error('Argument [' + value + '] does not exist.');
		}
	}
};
Jsonix.XML.QName = Jsonix.Class({
	key : null,
	namespaceURI : null,
	localPart : null,
	prefix : null,
	string : null,
	initialize : function(one, two, three) {
		var namespaceURI;
		var localPart;
		var prefix;
		var key;
		var string;

		if (!Jsonix.Util.Type.exists(two)) {
			namespaceURI = '';
			localPart = one;
			prefix = '';
		} else if (!Jsonix.Util.Type.exists(three)) {
			namespaceURI = Jsonix.Util.Type.exists(one) ? one : '';
			localPart = two;
			var colonPosition = two.indexOf(':');
			if (colonPosition > 0 && colonPosition < two.length) {
				prefix = two.substring(0, colonPosition);
				localPart = two.substring(colonPosition + 1);
			} else {
				prefix = '';
				localPart = two;
			}
		} else {
			namespaceURI = Jsonix.Util.Type.exists(one) ? one : '';
			localPart = two;
			prefix = Jsonix.Util.Type.exists(three) ? three : '';
		}
		this.namespaceURI = namespaceURI;
		this.localPart = localPart;
		this.prefix = prefix;

		this.key = (namespaceURI !== '' ? ('{' + namespaceURI + '}') : '') + localPart;
		this.string = (namespaceURI !== '' ? ('{' + namespaceURI + '}') : '') + (prefix !== '' ? (prefix + ':') : '') + localPart;
	},
	toString : function() {
		return this.string;
	},
	clone : function() {
		return new Jsonix.XML.QName(this.namespaceURI, this.localPart, this.prefix);
	},
	equals : function(that) {
		if (!that) {
			return false;
		} else {
			return (this.namespaceURI == that.namespaceURI) && (this.localPart == that.localPart);
		}

	},
	CLASS_NAME : "Jsonix.XML.QName"
});
Jsonix.XML.QName.fromString = function(qNameAsString) {
	var leftBracket = qNameAsString.indexOf('{');
	var rightBracket = qNameAsString.lastIndexOf('}');
	var namespaceURI;
	var prefixedName;
	if ((leftBracket === 0) && (rightBracket > 0) && (rightBracket < qNameAsString.length)) {
		namespaceURI = qNameAsString.substring(1, rightBracket);
		prefixedName = qNameAsString.substring(rightBracket + 1);
	} else {
		namespaceURI = '';
		prefixedName = qNameAsString;
	}
	var colonPosition = prefixedName.indexOf(':');
	var prefix;
	var localPart;
	if (colonPosition > 0 && colonPosition < prefixedName.length) {
		prefix = prefixedName.substring(0, colonPosition);
		localPart = prefixedName.substring(colonPosition + 1);
	} else {
		prefix = '';
		localPart = prefixedName;
	}
	return new Jsonix.XML.QName(namespaceURI, localPart, prefix);
};
Jsonix.XML.QName.fromObject = function(object) {
	Jsonix.Util.Ensure.ensureObject(object);
	if (object instanceof Jsonix.XML.QName || (Jsonix.Util.Type.isString(object.CLASS_NAME) && object.CLASS_NAME === 'Jsonix.XML.QName')) {
		return object;
	}
	var localPart = object.localPart||object.lp||null;
	Jsonix.Util.Ensure.ensureString(localPart);
	var namespaceURI = object.namespaceURI||object.ns||'';
	var prefix = object.prefix||object.p||'';
	return new Jsonix.XML.QName(namespaceURI, localPart, prefix);
};
Jsonix.XML.QName.key = function(namespaceURI, localPart) {
	Jsonix.Util.Ensure.ensureString(localPart);
	if (namespaceURI) {
		var colonPosition = localPart.indexOf(':');
		if (colonPosition > 0 && colonPosition < localPart.length) {
			localName = localPart.substring(colonPosition + 1);
		} else {
			localName = localPart;
		}
		return '{' + namespaceURI + '}' + localName;
	} else {
		return localPart;
	}
};
Jsonix.XML.Calendar = Jsonix.Class({
	year : NaN,
	month : NaN,
	day : NaN,
	hour : NaN,
	minute : NaN,
	second : NaN,
	fractionalSecond : NaN,
	timezone : NaN,
	initialize : function(data) {
		Jsonix.Util.Ensure.ensureObject(data);
		// Year
		if (Jsonix.Util.Type.exists(data.year)) {
			Jsonix.Util.Ensure.ensureInteger(data.year);
			if (data.year >= -9999 && data.year <= 9999) {
				this.year = data.year;
			} else {
				throw new Error('Invalid year [' + data.year + '].');
			}

		} else {
			this.year = NaN;
		}
		// Month
		if (Jsonix.Util.Type.exists(data.month)) {
			Jsonix.Util.Ensure.ensureInteger(data.month);
			if (data.month >= 1 && data.month <= 12) {
				this.month = data.month;
			} else {
				throw new Error('Invalid month [' + data.month + '].');
			}

		} else {
			this.month = NaN;
		}
		// Day
		if (Jsonix.Util.Type.exists(data.day)) {
			Jsonix.Util.Ensure.ensureInteger(data.day);
			if (data.day >= 1 && data.day <= 31) {
				this.day = data.day;
			} else {
				throw new Error('Invalid day [' + data.day + '].');
			}

		} else {
			this.day = NaN;
		}
		// Hour
		if (Jsonix.Util.Type.exists(data.hour)) {
			Jsonix.Util.Ensure.ensureInteger(data.hour);
			if (data.hour >= 0 && data.hour <= 23) {
				this.hour = data.hour;
			} else {
				throw new Error('Invalid hour [' + data.hour + '].');
			}

		} else {
			this.hour = NaN;
		}
		// Minute
		if (Jsonix.Util.Type.exists(data.minute)) {
			Jsonix.Util.Ensure.ensureInteger(data.minute);
			if (data.minute >= 0 && data.minute <= 59) {
				this.minute = data.minute;
			} else {
				throw new Error('Invalid minute [' + data.minute + '].');
			}

		} else {
			this.minute = NaN;
		}
		// Second
		if (Jsonix.Util.Type.exists(data.second)) {
			Jsonix.Util.Ensure.ensureInteger(data.second);
			if (data.second >= 0 && data.second <= 59) {
				this.second = data.second;
			} else {
				throw new Error('Invalid second [' + data.second + '].');
			}

		} else {
			this.second = NaN;
		}
		// Fractional second
		if (Jsonix.Util.Type.exists(data.fractionalSecond)) {
			Jsonix.Util.Ensure.ensureNumber(data.fractionalSecond);
			if (data.fractionalSecond >= 0 && data.fractionalSecond < 1) {
				this.fractionalSecond = data.fractionalSecond;
			} else {
				throw new Error('Invalid fractional second [' + data.fractionalSecond + '].');
			}

		} else {
			this.fractionalSecond = NaN;
		}
		// Timezone
		if (Jsonix.Util.Type.exists(data.timezone)) {
			if (Jsonix.Util.Type.isNaN(data.timezone)) {
				this.timezone = NaN;
			} else {
				Jsonix.Util.Ensure.ensureInteger(data.timezone);
				if (data.timezone >= -1440 && data.timezone < 1440) {
					this.timezone = data.timezone;
				} else {
					throw new Error('Invalid timezone [' + data.timezone + '].');
				}
			}
		} else {
			this.timezone = NaN;
		}
	},
	CLASS_NAME : "Jsonix.XML.Calendar"
});
Jsonix.XML.Calendar.fromObject = function(object) {
	Jsonix.Util.Ensure.ensureObject(object);
	if (Jsonix.Util.Type.isString(object.CLASS_NAME) && object.CLASS_NAME === 'Jsonix.XML.Calendar') {
		return object;
	}
	return new Jsonix.XML.Calendar(object);
};
Jsonix.XML.Input = Jsonix.Class({
	root : null,
	node : null,
	attributes : null,
	eventType : null,
	pns : null,
	initialize : function(node) {
		Jsonix.Util.Ensure.ensureExists(node);
		this.root = node;
		var rootPnsItem =
		{
			'' : ''
		};
		rootPnsItem[Jsonix.XML.XMLNS_P] = Jsonix.XML.XMLNS_NS;
		this.pns = [rootPnsItem];
	},
	hasNext : function() {
		// No current node, we've not started yet
		if (this.node === null) {
			return true;
		} else if (this.node === this.root) {
			var nodeType = this.node.nodeType;
			// Root node is document, last event type is END_DOCUMENT
			if (nodeType === 9 && this.eventType === 8) {
				return false;
			}
			// Root node is element, last event type is END_ELEMENT
			else if (nodeType === 1 && this.eventType === 2) {
				return false;
			} else {
				return true;
			}
		} else {
			return true;
		}
	},
	next : function() {
		if (this.eventType === null) {
			return this.enter(this.root);
		}
		// START_DOCUMENT
		if (this.eventType === 7) {
			var documentElement = this.node.documentElement;
			if (documentElement) {
				return this.enter(documentElement);
			} else {
				return this.leave(this.node);
			}
		} else if (this.eventType === 1) {
			var firstChild = this.node.firstChild;
			if (firstChild) {
				return this.enter(firstChild);
			} else {
				return this.leave(this.node);
			}
		} else if (this.eventType === 2) {
			var nextSibling = this.node.nextSibling;
			if (nextSibling) {
				return this.enter(nextSibling);
			} else {
				return this.leave(this.node);
			}
		} else {
			return this.leave(this.node);
		}
	},
	enter : function(node) {
		var nodeType = node.nodeType;
		this.node = node;
		this.attributes = null;
		// Document node
		if (nodeType === 1) {
			// START_ELEMENT
			this.eventType = 1;
			this.pushNS(node);
			return this.eventType;
		} else if (nodeType === 2) {
			// ATTRIBUTE
			this.eventType = 10;
			return this.eventType;
		} else if (nodeType === 3) {
			var nodeValue = node.nodeValue;
			if (Jsonix.Util.StringUtils.isEmpty(nodeValue)) {
				// SPACE
				this.eventType = 6;
			} else {
				// CHARACTERS
				this.eventType = 4;
			}
			return this.eventType;
		} else if (nodeType === 4) {
			// CDATA
			this.eventType = 12;
			return this.eventType;
		} else if (nodeType === 5) {
			// ENTITY_REFERENCE_NODE = 5
			// ENTITY_REFERENCE
			this.eventType = 9;
			return this.eventType;
		} else if (nodeType === 6) {
			// ENTITY_DECLARATION
			this.eventType = 15;
			return this.eventType;
		} else if (nodeType === 7) {
			// PROCESSING_INSTRUCTION
			this.eventType = 3;
			return this.eventType;
		} else if (nodeType === 8) {
			// COMMENT
			this.eventType = 5;
			return this.eventType;
		} else if (nodeType === 9) {
			// START_DOCUMENT
			this.eventType = 7;
			return this.eventType;
		} else if (nodeType === 10) {
			// DTD
			this.eventType = 12;
			return this.eventType;
		} else if (nodeType === 12) {
			// NOTATION_DECLARATION
			this.eventType = 14;
			return this.eventType;
		} else {
			// DOCUMENT_FRAGMENT_NODE = 11
			throw new Error("Node type [" + nodeType + '] is not supported.');
		}
	},
	leave : function(node) {
		if (node.nodeType === 9) {
			if (this.eventType == 8) {
				throw new Error("Invalid state.");
			} else {
				this.node = node;
				this.attributes = null;
				// END_ELEMENT
				this.eventType = 8;
				return this.eventType;
			}
		} else if (node.nodeType === 1) {
			if (this.eventType == 2) {
				var nextSibling = node.nextSibling;
				if (nextSibling) {
					return this.enter(nextSibling);
				}
			} else {
				this.node = node;
				this.attributes = null;
				// END_ELEMENT
				this.eventType = 2;
				this.popNS();
				return this.eventType;
			}
		}

		var nextSibling1 = node.nextSibling;
		if (nextSibling1) {
			return this.enter(nextSibling1);
		} else {
			var parentNode = node.parentNode;
			this.node = parentNode;
			this.attributes = null;
			if (parentNode.nodeType === 9) {
				this.eventType = 8;
			} else {
				this.eventType = 2;
			}
			return this.eventType;
		}
	},
	getName : function() {
		var node = this.node;
		if (Jsonix.Util.Type.isString(node.nodeName)) {
			if (Jsonix.Util.Type.isString(node.namespaceURI)) {
				return new Jsonix.XML.QName(node.namespaceURI, node.nodeName);
			} else {
				return new Jsonix.XML.QName(node.nodeName);
			}
		} else {
			return null;
		}
	},
	getNameKey : function() {
		var node = this.node;
		if (Jsonix.Util.Type.isString(node.nodeName)) {
			return Jsonix.XML.QName.key(node.namespaceURI, node.nodeName);
		} else {
			return null;
		}
	},
	getText : function() {
		return this.node.nodeValue;
	},
	nextTag : function() {
		var et = this.next();
		// TODO isWhiteSpace
		while (et === 7 || et === 4 || et === 12 || et === 6 || et === 3 || et === 5) {
			et = this.next();
		}
		if (et !== 1 && et !== 2) {
			// TODO location
			throw new Error('Expected start or end tag.');
		}
		return et;
	},
	skipElement : function() {
		if (this.eventType !== Jsonix.XML.Input.START_ELEMENT) {
			throw new Error("Parser must be on START_ELEMENT to skip element.");
		}
		var numberOfOpenTags = 1;
		var et;
		do {
			et = this.nextTag();
		    numberOfOpenTags += (et === Jsonix.XML.Input.START_ELEMENT) ? 1 : -1;
		  } while (numberOfOpenTags > 0);
		return et;
	},	
	getElementText : function() {
		if (this.eventType != 1) {
			throw new Error("Parser must be on START_ELEMENT to read next text.");
		}
		var et = this.next();
		var content = '';
		while (et !== 2) {
			if (et === 4 || et === 12 || et === 6 || et === 9) {
				content = content + this.getText();
			} else if (et === 3 || et === 5) {
				// Skip PI or comment
			} else if (et === 8) {
				// End document
				throw new Error("Unexpected end of document when reading element text content.");
			} else if (et === 1) {
				// End element
				// TODO location
				throw new Error("Element text content may not contain START_ELEMENT.");
			} else {
				// TODO location
				throw new Error("Unexpected event type [" + et + "].");
			}
			et = this.next();
		}
		return content;
	},
	getAttributeCount : function() {
		var attributes;
		if (this.attributes) {
			attributes = this.attributes;
		} else if (this.eventType === 1) {
			attributes = this.node.attributes;
			this.attributes = attributes;
		} else if (this.eventType === 10) {
			attributes = this.node.parentNode.attributes;
			this.attributes = attributes;
		} else {
			throw new Error("Number of attributes can only be retrieved for START_ELEMENT or ATTRIBUTE.");
		}
		return attributes.length;
	},
	getAttributeName : function(index) {
		var attributes;
		if (this.attributes) {
			attributes = this.attributes;
		} else if (this.eventType === 1) {
			attributes = this.node.attributes;
			this.attributes = attributes;
		} else if (this.eventType === 10) {
			attributes = this.node.parentNode.attributes;
			this.attributes = attributes;
		} else {
			throw new Error("Attribute name can only be retrieved for START_ELEMENT or ATTRIBUTE.");
		}
		if (index < 0 || index >= attributes.length) {
			throw new Error("Invalid attribute index [" + index + "].");
		}
		var attribute = attributes[index];
		
		
		if (Jsonix.Util.Type.isString(attribute.namespaceURI)) {
			return new Jsonix.XML.QName(attribute.namespaceURI, attribute.nodeName);
		} else {
			return new Jsonix.XML.QName(attribute.nodeName);
		}
	},
	getAttributeNameKey : function(index) {
		var attributes;
		if (this.attributes) {
			attributes = this.attributes;
		} else if (this.eventType === 1) {
			attributes = this.node.attributes;
			this.attributes = attributes;
		} else if (this.eventType === 10) {
			attributes = this.node.parentNode.attributes;
			this.attributes = attributes;
		} else {
			throw new Error("Attribute name key can only be retrieved for START_ELEMENT or ATTRIBUTE.");
		}
		if (index < 0 || index >= attributes.length) {
			throw new Error("Invalid attribute index [" + index + "].");
		}
		var attribute = attributes[index];

		return Jsonix.XML.QName.key(attribute.namespaceURI, attribute.nodeName);
	},
	getAttributeValue : function(index) {
		var attributes;
		if (this.attributes)
		{
			attributes = this.attributes;
		} else if (this.eventType === 1) {
			attributes = this.node.attributes;
			this.attributes = attributes;
		} else if (this.eventType === 10) {
			attributes = this.node.parentNode.attributes;
			this.attributes = attributes;
		} else {
			throw new Error("Attribute value can only be retrieved for START_ELEMENT or ATTRIBUTE.");
		}
		if (index < 0 || index >= attributes.length) {
			throw new Error("Invalid attribute index [" + index + "].");
		}
		var attribute = attributes[index];
		return attribute.value;
	},
	getElement : function() {
		if (this.eventType === 1 || this.eventType === 2) {
			// Go to the END_ELEMENT
			this.eventType = 2;
			return this.node;
		} else {
			throw new Error("Parser must be on START_ELEMENT or END_ELEMENT to return current element.");
		}
	},
	pushNS : function (node) {
		var pindex = this.pns.length - 1;
		var parentPnsItem = this.pns[pindex];
		var pnsItem = Jsonix.Util.Type.isObject(parentPnsItem) ? pindex : parentPnsItem;
		this.pns.push(pnsItem);
		pindex++;
		var reference = true;
		if (node.attributes)
		{
			var attributes = node.attributes;
			var alength = attributes.length;
			if (alength > 0)
			{
				// If given node has attributes
				for (var aindex = 0; aindex < alength; aindex++)
				{
					var attribute = attributes[aindex];
					var attributeName = attribute.nodeName;
					var p = null;
					var ns = null;
					var isNS = false;
					if (attributeName === 'xmlns')
					{
						p = '';
						ns = attribute.value;
						isNS = true;
					}
					else if (attributeName.substring(0, 6) === 'xmlns:')
					{
						p = attributeName.substring(6);
						ns = attribute.value;
						isNS = true;
					}
					// Attribute is a namespace declaration
					if (isNS)
					{
						if (reference)
						{
							pnsItem = Jsonix.Util.Type.cloneObject(this.pns[pnsItem], {});
							this.pns[pindex] = pnsItem;
							reference = false;
						}
						pnsItem[p] = ns;
					}
				}
			}
		}		
	},
	popNS : function () {
		this.pns.pop();
	},
	getNamespaceURI : function (p) {
		var pindex = this.pns.length - 1;
		var pnsItem = this.pns[pindex];
		pnsItem = Jsonix.Util.Type.isObject(pnsItem) ? pnsItem : this.pns[pnsItem];
		return pnsItem[p];
	},
	CLASS_NAME : "Jsonix.XML.Input"

});

Jsonix.XML.Input.START_ELEMENT = 1;
Jsonix.XML.Input.END_ELEMENT = 2;
Jsonix.XML.Input.PROCESSING_INSTRUCTION = 3;
Jsonix.XML.Input.CHARACTERS = 4;
Jsonix.XML.Input.COMMENT = 5;
Jsonix.XML.Input.SPACE = 6;
Jsonix.XML.Input.START_DOCUMENT = 7;
Jsonix.XML.Input.END_DOCUMENT = 8;
Jsonix.XML.Input.ENTITY_REFERENCE = 9;
Jsonix.XML.Input.ATTRIBUTE = 10;
Jsonix.XML.Input.DTD = 11;
Jsonix.XML.Input.CDATA = 12;
Jsonix.XML.Input.NAMESPACE = 13;
Jsonix.XML.Input.NOTATION_DECLARATION = 14;
Jsonix.XML.Input.ENTITY_DECLARATION = 15;

Jsonix.XML.Output = Jsonix.Class({
	document : null,
	documentElement : null,
	node : null,
	nodes : null,
	nsp : null,
	pns : null,
	namespacePrefixIndex : 0,
	xmldom : null,
	initialize : function(options) {
		// REWORK
		if (typeof ActiveXObject !== 'undefined') {
			this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
		} else {
			this.xmldom = null;
		}
		this.nodes = [];
		var rootNspItem =
		{
			'' : ''
		};
		rootNspItem[Jsonix.XML.XMLNS_NS] = Jsonix.XML.XMLNS_P;
		if (Jsonix.Util.Type.isObject(options)) {
			if (Jsonix.Util.Type.isObject(options.namespacePrefixes)) {
				Jsonix.Util.Type.cloneObject(options.namespacePrefixes, rootNspItem);
			}
		}
		this.nsp = [rootNspItem];
		var rootPnsItem =
		{
			'' : ''
		};
		rootPnsItem[Jsonix.XML.XMLNS_P] = Jsonix.XML.XMLNS_NS;
		this.pns = [rootPnsItem];
	},
	destroy : function() {
		this.xmldom = null;
	},
	writeStartDocument : function() {
		// TODO Check
		var doc = Jsonix.DOM.createDocument();
		this.document = doc;
		return this.push(doc);
	},
	writeEndDocument : function() {
		return this.pop();

	},
	writeStartElement : function(name) {
		Jsonix.Util.Ensure.ensureObject(name);
		var localPart = name.localPart || name.lp || null;
		Jsonix.Util.Ensure.ensureString(localPart);
		var ns = name.namespaceURI || name.ns || null;
		var namespaceURI = Jsonix.Util.Type.isString(ns) ? ns : '';

		var p = name.prefix || name.p;
		var prefix = this.getPrefix(namespaceURI, p);

		var qualifiedName = (!prefix ? localPart : prefix + ':' + localPart);

		var element;
		if (Jsonix.Util.Type.isFunction(this.document.createElementNS))	{
			element = this.document.createElementNS(namespaceURI, qualifiedName);
		}
		else if (this.xmldom) {
			element = this.xmldom.createNode(1, qualifiedName, namespaceURI);

		} else {
			throw new Error("Could not create an element node.");
		}
		this.peek().appendChild(element);
		this.push(element);
		this.declareNamespace(namespaceURI, prefix);
		if (this.documentElement === null)
		{
			this.documentElement = element;
			this.declareNamespaces();
		}
		return element;
	},
	writeEndElement : function() {
		return this.pop();
	},
	writeCharacters : function(text) {
		var node;
		if (Jsonix.Util.Type.isFunction(this.document.createTextNode))	{
			node = this.document.createTextNode(text);
		}
		else if (this.xmldom) {
			node = this.xmldom.createTextNode(text);
		} else {
			throw new Error("Could not create a text node.");
		}
		this.peek().appendChild(node);
		return node;

	},
	writeAttribute : function(name, value) {
		Jsonix.Util.Ensure.ensureString(value);
		Jsonix.Util.Ensure.ensureObject(name);
		var localPart = name.localPart || name.lp || null;
		Jsonix.Util.Ensure.ensureString(localPart);
		var ns = name.namespaceURI || name.ns || null;
		var namespaceURI = Jsonix.Util.Type.isString(ns) ? ns : '';
		var p = name.prefix || name.p || null;
		var prefix = this.getPrefix(namespaceURI, p);

		var qualifiedName = (!prefix ? localPart : prefix + ':' + localPart);

		var node = this.peek();

		if (namespaceURI === '') {
			node.setAttribute(qualifiedName, value);
		} else {
			if (node.setAttributeNS) {
				node.setAttributeNS(namespaceURI, qualifiedName, value);
			} else {
				if (this.xmldom) {
					var attribute = this.document.createNode(2, qualifiedName, namespaceURI);
					attribute.nodeValue = value;
					node.setAttributeNode(attribute);
				}
				else if (namespaceURI === Jsonix.XML.XMLNS_NS)
				{
					// XMLNS namespace may be processed unqualified
					node.setAttribute(qualifiedName, value);
				}
				else
				{
					throw new Error("The [setAttributeNS] method is not implemented");
				}
			}
			this.declareNamespace(namespaceURI, prefix);
		}
		
	},
	writeNode : function(node) {
		var importedNode;
		if (Jsonix.Util.Type.exists(this.document.importNode)) {
			importedNode = this.document.importNode(node, true);
		} else {
			importedNode = node;
		}
		this.peek().appendChild(importedNode);
		return importedNode;
	},
	push : function(node) {
		this.nodes.push(node);
		this.pushNS();
		return node;
	},
	peek : function() {
		return this.nodes[this.nodes.length - 1];
	},
	pop : function() {
		this.popNS();
		var result = this.nodes.pop();
		return result;
	},
	pushNS : function ()
	{
		var nindex = this.nsp.length - 1;
		var pindex = this.pns.length - 1;
		var parentNspItem = this.nsp[nindex];
		var parentPnsItem = this.pns[pindex];
		var nspItem = Jsonix.Util.Type.isObject(parentNspItem) ? nindex : parentNspItem;
		var pnsItem = Jsonix.Util.Type.isObject(parentPnsItem) ? pindex : parentPnsItem;
		this.nsp.push(nspItem);
		this.pns.push(pnsItem);
	},
	popNS : function ()
	{
		this.nsp.pop();
		this.pns.pop();
	},
	declareNamespaces : function ()
	{
		var index = this.nsp.length - 1;
		var nspItem = this.nsp[index];
		nspItem = Jsonix.Util.Type.isNumber(nspItem) ? this.nsp[nspItem] : nspItem;
		var ns, p;
		for (ns in nspItem)
		{
			if (nspItem.hasOwnProperty(ns))
			{
				p = nspItem[ns];
				this.declareNamespace(ns, p);
			}
		}
	},
	declareNamespace : function (ns, p)
	{
		var index = this.pns.length - 1;
		var pnsItem = this.pns[index];
		var reference;
		if (Jsonix.Util.Type.isNumber(pnsItem))
		{
			// Resolve the reference
			reference = true;
			pnsItem = this.pns[pnsItem];
		}
		else
		{
			reference = false;
		}
		// If this prefix is mapped to a different namespace and must be redeclared
		if (pnsItem[p] !== ns)
		{
			if (p === '')
			{
				this.writeAttribute({ns : Jsonix.XML.XMLNS_NS, lp : Jsonix.XML.XMLNS_P}, ns);
			}
			else
			{
				this.writeAttribute({ns : Jsonix.XML.XMLNS_NS, lp : p, p : Jsonix.XML.XMLNS_P}, ns);
			}
			if (reference)
			{
				// If this was a reference, clone it and replace the reference
				pnsItem = Jsonix.Util.Type.cloneObject(pnsItem, {});
				this.pns[index] = pnsItem;
			}
			pnsItem[p] = ns;
		}
	},
	getPrefix : function (ns, p)
	{
		var index = this.nsp.length - 1;
		var nspItem = this.nsp[index];
		var reference;
		if (Jsonix.Util.Type.isNumber(nspItem))
		{
			// This is a reference, the item is the index of the parent item
			reference = true;
			nspItem = this.nsp[nspItem];
		}
		else
		{
			reference = false;
		}
		if (Jsonix.Util.Type.isString(p))
		{
			var oldp = nspItem[ns];
			// If prefix is already declared and equals the proposed prefix 
			if (p === oldp)
			{
				// Nothing to do
			}
			else
			{
				// If this was a reference, we have to clone it now
				if (reference)
				{
					nspItem = Jsonix.Util.Type.cloneObject(nspItem, {});
					this.nsp[index] = nspItem;
				}
				nspItem[ns] = p;
			}
		}
		else
		{
			p = nspItem[ns];
			if (!Jsonix.Util.Type.exists(p)) {
				p = 'p' + (this.namespacePrefixIndex++);
				// If this was a reference, we have to clone it now
				if (reference)
				{
					nspItem = Jsonix.Util.Type.cloneObject(nspItem, {});
					this.nsp[index] = nspItem;
				}
				nspItem[ns] = p;
			}
		}
		return p;
	},
	CLASS_NAME : "Jsonix.XML.Output"
});
Jsonix.Model.TypeInfo = Jsonix.Class({
	name : null,
	initialize : function() {
	},
	CLASS_NAME : 'Jsonix.Model.TypeInfo'
});
Jsonix.Model.Adapter = Jsonix.Class({
	initialize : function() {
	},
	unmarshal: function(typeInfo, context, input, scope)
	{
		return typeInfo.unmarshal(context, input, scope);
	},
	marshal: function(typeInfo, value, context, output, scope)
	{
		typeInfo.marshal(value, context, output, scope);
	},	
	CLASS_NAME : "Jsonix.Model.Adapter"
});
Jsonix.Model.Adapter.INSTANCE = new Jsonix.Model.Adapter();
// TODO is this correct?
Jsonix.Model.Adapter.getAdapter = function (elementInfo)
{
	Jsonix.Util.Ensure.ensureObject(elementInfo);
	return Jsonix.Util.Type.exists(elementInfo.adapter) ? elementInfo.adapter : Jsonix.Model.Adapter.INSTANCE;
};
Jsonix.Model.ClassInfo = Jsonix
		.Class(Jsonix.Model.TypeInfo, {
			name : null,
			baseTypeInfo : null,
			instanceFactory : null,
			properties : null,
			structure : null,
			defaultElementNamespaceURI : '',
			defaultAttributeNamespaceURI : '',
			built : false,
			initialize : function(mapping) {
				Jsonix.Model.TypeInfo.prototype.initialize.apply(this, []);
				Jsonix.Util.Ensure.ensureObject(mapping);
				var n = mapping.name||mapping.n||undefined;
				Jsonix.Util.Ensure.ensureString(n);
				this.name = n;
				
				var dens = mapping.defaultElementNamespaceURI||mapping.dens||'';
				this.defaultElementNamespaceURI = dens;

				var dans = mapping.defaultAttributeNamespaceURI||mapping.dans||'';
				this.defaultAttributeNamespaceURI = dans;
				
				var bti = mapping.baseTypeInfo||mapping.bti||null;
				this.baseTypeInfo = bti;
				
				var inF = mapping.instanceFactory||mapping.inF||undefined;
				if (Jsonix.Util.Type.exists(inF)) {
					// TODO: should we support instanceFactory as functions?
					// For the pure JSON configuration?
					Jsonix.Util.Ensure.ensureFunction(inF);
					this.instanceFactory = inF;
				}
				
				this.properties = [];
				var ps = mapping.propertyInfos||mapping.ps||[];
				Jsonix.Util.Ensure.ensureArray(ps);
				for ( var index = 0; index < ps.length; index++) {
					this.p(ps[index]);
				}
			},
			// Obsolete
			destroy : function() {
			},
			build : function(context, module) {
				if (!this.built) {
					this.baseTypeInfo = context.resolveTypeInfo(this.baseTypeInfo, module);
					if (Jsonix.Util.Type.exists(this.baseTypeInfo)) {
						this.baseTypeInfo.build(context, module);
					}

					// Build properties in this context
					for ( var index = 0; index < this.properties.length; index++) {
						var propertyInfo = this.properties[index];
						propertyInfo.build(context, module);
					}

					// Build the structure
					var structure = {
						elements : null,
						attributes : {},
						anyAttribute : null,
						value : null,
						any : null
					};
					this.buildStructure(context, structure);
					this.structure = structure;
				}
			},
			buildStructure : function(context, structure) {
				if (Jsonix.Util.Type.exists(this.baseTypeInfo)) {
					this.baseTypeInfo.buildStructure(context, structure);
				}
				for ( var index = 0; index < this.properties.length; index++) {
					var propertyInfo = this.properties[index];
					propertyInfo.buildStructure(context, structure);
				}
			},
			unmarshal : function(context, input) {
				this.build(context);
				var result;
				
				if (this.instanceFactory) {
					result = new this.instanceFactory();
				}
				else
				{
					result = { TYPE_NAME : this.name }; 
				}
				
				if (input.eventType !== 1) {
					throw new Error("Parser must be on START_ELEMENT to read a class info.");
				}

				// Read attributes
				if (Jsonix.Util.Type.exists(this.structure.attributes)) {
					var attributeCount = input.getAttributeCount();
					if (attributeCount !== 0) {
						for ( var index = 0; index < attributeCount; index++) {
							var attributeNameKey = input
									.getAttributeNameKey(index);
							if (Jsonix.Util.Type
									.exists(this.structure.attributes[attributeNameKey])) {
								var attributeValue = input
										.getAttributeValue(index);
								if (Jsonix.Util.Type.isString(attributeValue)) {
									var attributePropertyInfo = this.structure.attributes[attributeNameKey];
									this.unmarshalPropertyValue(context, input,
											attributePropertyInfo, result,
											attributeValue);
								}
							}
						}
					}
				}
				// Read any attribute
				if (Jsonix.Util.Type.exists(this.structure.anyAttribute)) {
					var propertyInfo = this.structure.anyAttribute;
					this
							.unmarshalProperty(context, input, propertyInfo,
									result);
				}
				// Read elements
				if (Jsonix.Util.Type.exists(this.structure.elements)) {

					var et = input.next();
					while (et !== Jsonix.XML.Input.END_ELEMENT) {
						if (et === Jsonix.XML.Input.START_ELEMENT) {
							// New sub-element starts
							var elementNameKey = input.getNameKey();
							if (Jsonix.Util.Type
									.exists(this.structure.elements[elementNameKey])) {
								var elementPropertyInfo = this.structure.elements[elementNameKey];
								this.unmarshalProperty(context, input,
										elementPropertyInfo, result);
							} else if (Jsonix.Util.Type
									.exists(this.structure.any)) {
								// TODO Refactor

								var anyPropertyInfo = this.structure.any;
								this.unmarshalProperty(context, input,
										anyPropertyInfo, result);
							} else {
								// TODO optionally report a validation error that the element is not expected
								et = input.skipElement();
							}
						} else if ((et === Jsonix.XML.Input.CHARACTERS || et === Jsonix.XML.Input.CDATA || et === Jsonix.XML.Input.ENTITY_REFERENCE) && Jsonix.Util.Type.exists(this.structure.mixed)) {
							// Characters and structure has a mixed property
							var mixedPropertyInfo = this.structure.mixed;
							this.unmarshalProperty(context, input,
									mixedPropertyInfo, result);
						} else if (et === Jsonix.XML.Input.SPACE || et === Jsonix.XML.Input.COMMENT	|| et === Jsonix.XML.Input.PROCESSING_INSTRUCTION) {
							// Ignore
						} else {
							throw new Error("Illegal state: unexpected event type [" + et	+ "].");
						}
						et = input.next();
					}
				} else if (Jsonix.Util.Type.exists(this.structure.value)) {
					var valuePropertyInfo = this.structure.value;
					this.unmarshalProperty(context, input, valuePropertyInfo,
							result);
				} else {
					// Just skip everything
					input.nextTag();
				}
				if (input.eventType !== 2) {
					throw new Error("Illegal state: must be END_ELEMENT.");
				}
				return result;
			},
			unmarshalProperty : function(context, input, propertyInfo, result) {
				var propertyValue = propertyInfo
						.unmarshal(context, input, this);
				propertyInfo.setProperty(result, propertyValue);
			},
			unmarshalPropertyValue : function(context, input, propertyInfo,
					result, value) {
				var propertyValue = propertyInfo.unmarshalValue(value, context, input, this);
				propertyInfo.setProperty(result, propertyValue);
			},
			marshal : function(value, context, output) {
				// TODO This must be reworked
				if (Jsonix.Util.Type.exists(this.baseTypeInfo)) {
					this.baseTypeInfo.marshal(value, context, output);
				}
				for ( var index = 0; index < this.properties.length; index++) {
					var propertyInfo = this.properties[index];
					var propertyValue = value[propertyInfo.name];
					if (Jsonix.Util.Type.exists(propertyValue)) {
						propertyInfo.marshal(propertyValue, context, output, this);
					}
				}
			},
			isInstance : function(value, context, scope) {
				if (this.instanceFactory) {
					return value instanceof this.instanceFactory;
				}
				else {
					return Jsonix.Util.Type.isObject(value) && Jsonix.Util.Type.isString(value.TYPE_NAME) && value.TYPE_NAME === this.name;
				}
			},

			// Obsolete, left for backwards compatibility
			b : function(baseTypeInfo) {
				Jsonix.Util.Ensure.ensureObject(baseTypeInfo);
				this.baseTypeInfo = baseTypeInfo;
				return this;
			},
			// Obsolete, left for backwards compatibility
			ps : function() {
				return this;
			},
			p : function(property) {
				Jsonix.Util.Ensure.ensureObject(property);
				// If property is an instance of the property class
				if (property instanceof Jsonix.Model.PropertyInfo) {
					this.addProperty(property);
				}
				// Else create it via generic mapping configuration
				else {
					var type = property.type||property.t||'element';
					// Locate the creator function
					if (Jsonix.Util.Type
							.isFunction(this.propertyInfoCreators[type])) {
						var propertyInfoCreator = this.propertyInfoCreators[type];
						// Call the creator function
						propertyInfoCreator.call(this, property);
					} else {
						throw new Error("Unknown property info type [" + type + "].");
					}
				}
			},
			aa : function(mapping) {
				this.addDefaultNamespaces(mapping);
				return this
						.addProperty(new Jsonix.Model.AnyAttributePropertyInfo(
								mapping));
			},
			ae : function(mapping) {
				this.addDefaultNamespaces(mapping);
				return this
						.addProperty(new Jsonix.Model.AnyElementPropertyInfo(
								mapping));
			},
			a : function(mapping) {
				this.addDefaultNamespaces(mapping);
				return this.addProperty(new Jsonix.Model.AttributePropertyInfo(
						mapping));
			},
			em : function(mapping) {
				this.addDefaultNamespaces(mapping);
				return this
						.addProperty(new Jsonix.Model.ElementMapPropertyInfo(
								mapping));
			},
			e : function(mapping) {
				this.addDefaultNamespaces(mapping);
				return this.addProperty(new Jsonix.Model.ElementPropertyInfo(
						mapping));
			},
			es : function(mapping) {
				this.addDefaultNamespaces(mapping);
				return this.addProperty(new Jsonix.Model.ElementsPropertyInfo(
						mapping));
			},
			er : function(mapping) {
				this.addDefaultNamespaces(mapping);
				return this
						.addProperty(new Jsonix.Model.ElementRefPropertyInfo(
								mapping));
			},
			ers : function(mapping) {
				this.addDefaultNamespaces(mapping);
				return this
						.addProperty(new Jsonix.Model.ElementRefsPropertyInfo(
								mapping));
			},
			v : function(mapping) {
				this.addDefaultNamespaces(mapping);
				return this.addProperty(new Jsonix.Model.ValuePropertyInfo(
						mapping));
			},
			addDefaultNamespaces : function(mapping) {
				if (Jsonix.Util.Type.isObject(mapping)) {
					if (!Jsonix.Util.Type
							.isString(mapping.defaultElementNamespaceURI)) {
						mapping.defaultElementNamespaceURI = this.defaultElementNamespaceURI;
					}
					if (!Jsonix.Util.Type
							.isString(mapping.defaultAttributeNamespaceURI)) {
						mapping.defaultAttributeNamespaceURI = this.defaultAttributeNamespaceURI;
					}
				}
			},
			addProperty : function(property) {
				this.properties.push(property);
				return this;
			},
			CLASS_NAME : 'Jsonix.Model.ClassInfo'
		});
Jsonix.Model.ClassInfo.prototype.propertyInfoCreators = {
	"aa" : Jsonix.Model.ClassInfo.prototype.aa,
	"anyAttribute" : Jsonix.Model.ClassInfo.prototype.aa,
	"ae" : Jsonix.Model.ClassInfo.prototype.ae,
	"anyElement" : Jsonix.Model.ClassInfo.prototype.ae,
	"a" : Jsonix.Model.ClassInfo.prototype.a,
	"attribute" : Jsonix.Model.ClassInfo.prototype.a,
	"em" : Jsonix.Model.ClassInfo.prototype.em,
	"elementMap" : Jsonix.Model.ClassInfo.prototype.em,
	"e" : Jsonix.Model.ClassInfo.prototype.e,
	"element" : Jsonix.Model.ClassInfo.prototype.e,
	"es" : Jsonix.Model.ClassInfo.prototype.es,
	"elements" : Jsonix.Model.ClassInfo.prototype.es,
	"er" : Jsonix.Model.ClassInfo.prototype.er,
	"elementRef" : Jsonix.Model.ClassInfo.prototype.er,
	"ers" : Jsonix.Model.ClassInfo.prototype.ers,
	"elementRefs" : Jsonix.Model.ClassInfo.prototype.ers,
	"v" : Jsonix.Model.ClassInfo.prototype.v,
	"value" : Jsonix.Model.ClassInfo.prototype.v
};
Jsonix.Model.EnumLeafInfo = Jsonix.Class(Jsonix.Model.TypeInfo, {
	name : null,
	baseTypeInfo : 'String',
	entries : null,
	keys : null,
	values : null,
	built : false,
	initialize : function(mapping) {
		Jsonix.Model.TypeInfo.prototype.initialize.apply(this, []);
		Jsonix.Util.Ensure.ensureObject(mapping);
		
		var n = mapping.name||mapping.n||undefined;
		Jsonix.Util.Ensure.ensureString(n);
		this.name = n;
		
		var bti = mapping.baseTypeInfo||mapping.bti||'String';
		this.baseTypeInfo = bti;
		
		var vs = mapping.values||mapping.vs||undefined;
		Jsonix.Util.Ensure.ensureExists(vs);
		if (!(Jsonix.Util.Type.isObject(vs) || Jsonix.Util.Type.isArray(vs))) {
			throw new Error('Enum values must be either an array or an object.');
		}
		else
		{
			this.entries = vs;
		}		
	},
	build : function(context, module) {
		if (!this.built) {
			this.baseTypeInfo = context.resolveTypeInfo(this.baseTypeInfo, module);
			this.baseTypeInfo.build(context, module);
			var items = this.entries;
			var entries = {};
			var keys = [];
			var values = [];
			var index = 0;
			var key;
			var value;
			// If values is an array, process individual items
			if (Jsonix.Util.Type.isArray(items))
			{
				// Build properties in this context
				for (index = 0; index < items.length; index++) {
					value = items[index];
					if (Jsonix.Util.Type.isString(value)) {
						key = value;
						if (!(Jsonix.Util.Type.isFunction(this.baseTypeInfo.parse)))
						{
							throw new Error('Enum value is provided as string but the base type ['+this.baseTypeInfo.name+'] of the enum info [' + this.name + '] does not implement the parse method.');
						}
						// Using null as input since input is not available
						value = this.baseTypeInfo.parse(value, context, null, this);
					}
					else
					{
						if (this.baseTypeInfo.isInstance(value, context, this))
						{
							if (!(Jsonix.Util.Type.isFunction(this.baseTypeInfo.print)))
							{
								throw new Error('The base type ['+this.baseTypeInfo.name+'] of the enum info [' + this.name + '] does not implement the print method, unable to produce the enum key as string.');
							}
							// Using null as output since output is not available at this moment
							key = this.baseTypeInfo.print(value, context, null, this);
						}
						else
						{
							throw new Error('Enum value [' + value + '] is not an instance of the enum base type [' + this.baseTypeInfo.name + '].');
						}
					}
					entries[key] = value;
					keys[index] = key;
					values[index] = value;
				}
			}
			else if (Jsonix.Util.Type.isObject(items))
			{
				for (key in items) {
					if (items.hasOwnProperty(key)) {
						value = items[key];
						if (Jsonix.Util.Type.isString(value)) {
							if (!(Jsonix.Util.Type.isFunction(this.baseTypeInfo.parse)))
							{
								throw new Error('Enum value is provided as string but the base type ['+this.baseTypeInfo.name+'] of the enum info [' + this.name + '] does not implement the parse method.');
							}
							// Using null as input since input is not available
							value = this.baseTypeInfo.parse(value, context, null, this);
						}
						else
						{
							if (!this.baseTypeInfo.isInstance(value, context, this))
							{
								throw new Error('Enum value [' + value + '] is not an instance of the enum base type [' + this.baseTypeInfo.name + '].');
							}
						}
						entries[key] = value;
						keys[index] = key;
						values[index] = value;
						index++;
					}
				}
			}
			else {
				throw new Error('Enum values must be either an array or an object.');
			}
			this.entries = entries;
			this.keys = keys;
			this.values = values;
			this.built = true;
		}
	},
	unmarshal : function(context, input, scope) {
		var text = input.getElementText();
		if (Jsonix.Util.StringUtils.isNotBlank(text)) {
			return this.parse(text, context, input, scope);
		} else {
			return null;
		}
	},
	marshal : function(value, context, output, scope) {
		if (Jsonix.Util.Type.exists(value)) {
			output.writeCharacters(this.reprint(value, context, output, scope));
		}
	},
	reprint : function(value, context, output, scope) {
		if (Jsonix.Util.Type.isString(value) && !this.isInstance(value, context, scope)) {
			// Using null as input since input is not available
			return this.print(this.parse(value, context, null, scope), context, output, scope);
		} else {
			return this.print(value, context, output, scope);
		}
	},
	print : function(value, context, output, scope) {
		for (var index = 0; index < this.values.length; index++)
		{
			if (this.values[index] === value)
			{
				return this.keys[index];
			}
		}
		throw new Error('Value [' + value + '] is invalid for the enum type [' + this.name + '].');
	},
	parse : function(text, context, input, scope) {
		Jsonix.Util.Ensure.ensureString(text);
		if (this.entries.hasOwnProperty(text))
		{
			return this.entries[text];
		}
		else
		{
			throw new Error('Value [' + text + '] is invalid for the enum type [' + this.name + '].');
		}
	},
	isInstance : function(value, context, scope) {
		for (var index = 0; index < this.values.length; index++)
		{
			if (this.values[index] === value)
			{
				return true;
			}
		}
		return false;
	},
	CLASS_NAME : 'Jsonix.Model.EnumLeafInfo'
});
Jsonix.Model.ElementInfo = Jsonix.Class({
	elementName : null,
	typeInfo : null,
	substitutionHead : null,
	scope : null,
	built : false,
	initialize : function(mapping) {
		Jsonix.Util.Ensure.ensureObject(mapping);
		
		var dens = mapping.defaultElementNamespaceURI||mapping.dens||'';
		this.defaultElementNamespaceURI = dens;
		
		var en = mapping.elementName || mapping.en||undefined;
		if (Jsonix.Util.Type.isObject(en)) {
			this.elementName = Jsonix.XML.QName.fromObject(en);
		} else {
			Jsonix.Util.Ensure.ensureString(en);
			this.elementName = new Jsonix.XML.QName(this.defaultElementNamespaceURI, en);
		}
		
		var ti = mapping.typeInfo||mapping.ti||'String';
		this.typeInfo = ti;
		
		var sh = mapping.substitutionHead||mapping.sh||null;
		this.substitutionHead = sh;
		
		var sc = mapping.scope||mapping.sc||null;
		this.scope = sc;
	},
	build : function(context, module) {
		// If element info is not yet built
		if (!this.built) {
			this.typeInfo = context.resolveTypeInfo(this.typeInfo, module);
			this.scope = context.resolveTypeInfo(this.scope, module);
			this.built = true;
		}
	},
	CLASS_NAME : 'Jsonix.Model.ElementInfo'
});
Jsonix.Model.PropertyInfo = Jsonix
		.Class({
			name : null,
			collection : false,
			defaultElementNamespaceURI : '',
			defaultAttributeNamespaceURI : '',
			built : false,
			initialize : function(mapping) {
				Jsonix.Util.Ensure.ensureObject(mapping);
				var n = mapping.name||mapping.n||undefined;
				Jsonix.Util.Ensure.ensureString(n);
				this.name = n;
				var dens = mapping.defaultElementNamespaceURI||mapping.dens||'';
				this.defaultElementNamespaceURI = dens;
				var dans = mapping.defaultAttributeNamespaceURI||mapping.dans||'';
				this.defaultAttributeNamespaceURI = dans;
				var col = mapping.collection||mapping.col||false;
				this.collection = col;
			},
			build : function(context, module) {
				if (!this.built) {
					this.doBuild(context, module);
					this.built = true;
				}
			},
			doBuild : function(context, module) {
				throw new Error("Abstract method [doBuild].");
			},
			buildStructure : function(context, structure) {
				throw new Error("Abstract method [buildStructure].");
			},
			setProperty : function(object, value) {
				if (Jsonix.Util.Type.exists(value)) {
					if (this.collection) {
						Jsonix.Util.Ensure.ensureArray(value,
								'Collection property requires an array value.');
						if (!Jsonix.Util.Type.exists(object[this.name])) {
							object[this.name] = [];
						}
						for ( var index = 0; index < value.length; index++) {
							object[this.name].push(value[index]);
						}

					} else {
						object[this.name] = value;
					}
				}
			},
			CLASS_NAME : 'Jsonix.Model.PropertyInfo'
		});
Jsonix.Model.AnyAttributePropertyInfo = Jsonix.Class(Jsonix.Model.PropertyInfo, {
	initialize : function(mapping) {
		Jsonix.Util.Ensure.ensureObject(mapping);
		Jsonix.Model.PropertyInfo.prototype.initialize.apply(this, [ mapping ]);
	},
	unmarshal : function(context, input, scope) {
		var attributeCount = input.getAttributeCount();
		if (attributeCount === 0) {
			return null;
		} else {
			var result = {};
			for ( var index = 0; index < attributeCount; index++) {
				var attributeNameKey = input.getAttributeNameKey(index);
				var attributeValue = input.getAttributeValue(index);
				if (Jsonix.Util.Type.isString(attributeValue)) {
					result[attributeNameKey] = attributeValue;
				}
			}
			return result;
		}
	},
	marshal : function(value, context, output, scope) {
		if (!Jsonix.Util.Type.isObject(value)) {
			// Nothing to do
			return;
		}
		for ( var attributeName in value) {
			if (value.hasOwnProperty(attributeName)) {
				var attributeValue = value[attributeName];
				if (Jsonix.Util.Type.isString(attributeValue)) {
					output.writeAttribute(Jsonix.XML.QName.fromString(attributeName), attributeValue);
				}
			}
		}

	},
	doBuild : function(context, module)	{
		// Nothing to do
	},
	buildStructure : function(context, structure) {
		Jsonix.Util.Ensure.ensureObject(structure);
		// if (Jsonix.Util.Type.exists(structure.anyAttribute))
		// {
		// // TODO better exception
		// throw new Error("The structure already defines an any attribute
		// property.");
		// } else
		// {
		structure.anyAttribute = this;
		// }
	},
	CLASS_NAME : 'Jsonix.Model.AnyAttributePropertyInfo'
});

Jsonix.Model.SingleTypePropertyInfo = Jsonix.Class(Jsonix.Model.PropertyInfo,
		{
			typeInfo : 'String',
			initialize : function(mapping) {
				Jsonix.Util.Ensure.ensureObject(mapping);
				Jsonix.Model.PropertyInfo.prototype.initialize.apply(this,
						[ mapping ]);
				var ti = mapping.typeInfo || mapping.ti || 'String';
				this.typeInfo = ti;
			},
			doBuild : function(context, module) {
				this.typeInfo = context.resolveTypeInfo(this.typeInfo, module);
			},
			unmarshalValue : function(value, context, input, scope) {
				return this.parse(value, context, input, scope);
			},
			parse : function(value, context, input, scope) {
				return this.typeInfo.parse(value, context, input, scope);
			},
			print : function(value, context, output, scope) {
				return this.typeInfo.reprint(value, context, output, scope);
			},
			CLASS_NAME : 'Jsonix.Model.SingleTypePropertyInfo'
		});

Jsonix.Model.AttributePropertyInfo = Jsonix.Class(Jsonix.Model.SingleTypePropertyInfo, {
	attributeName : null,
	initialize : function(mapping) {
		Jsonix.Util.Ensure.ensureObject(mapping);
		Jsonix.Model.SingleTypePropertyInfo.prototype.initialize.apply(this, [ mapping ]);
		var an = mapping.attributeName||mapping.an||undefined;
		if (Jsonix.Util.Type.isObject(an)) {
			this.attributeName = Jsonix.XML.QName.fromObject(an);
		} else if (Jsonix.Util.Type.isString(an)) {
			this.attributeName = new Jsonix.XML.QName(this.defaultAttributeNamespaceURI, an);
		} else {
			this.attributeName = new Jsonix.XML.QName(this.defaultAttributeNamespaceURI, this.name);
		}
	},
	unmarshal : function(context, input, scope) {
		var attributeCount = input.getAttributeCount();
		var result = null;
		for ( var index = 0; index < attributeCount; index++) {
			var attributeNameKey = input.getAttributeNameKey(index);
			if (this.attributeName.key === attributeNameKey) {
				var attributeValue = input.getAttributeValue(index);
				if (Jsonix.Util.Type.isString(attributeValue)) {
					result = this.unmarshalValue(attributeValue, context, input, scope);
				}
			}
		}
		return result;
	},
	marshal : function(value, context, output, scope) {
		if (Jsonix.Util.Type.exists(value)) {
			output.writeAttribute(this.attributeName, this.print(value, context, output, scope));
		}

	},
	buildStructure : function(context, structure) {
		Jsonix.Util.Ensure.ensureObject(structure);
		Jsonix.Util.Ensure.ensureObject(structure.attributes);
		var key = this.attributeName.key;
		// if (Jsonix.Util.Type.exists(structure.attributes[key])) {
		// // TODO better exception
		// throw new Error("The structure already defines an attribute for the key
		// ["
		// + key + "].");
		// } else
		// {
		structure.attributes[key] = this;
		// }
	},
	CLASS_NAME : 'Jsonix.Model.AttributePropertyInfo'
});

Jsonix.Model.ValuePropertyInfo = Jsonix.Class(Jsonix.Model.SingleTypePropertyInfo, {
	initialize : function(mapping) {
		Jsonix.Util.Ensure.ensureObject(mapping);
		Jsonix.Model.SingleTypePropertyInfo.prototype.initialize.apply(this, [ mapping ]);
	},
	unmarshal : function(context, input, scope) {
		var text = input.getElementText();
		if (Jsonix.Util.StringUtils.isNotBlank(text)) {
			return this.unmarshalValue(text, context, input, scope);
		} else {
			return null;
		}
	},
	marshal : function(value, context, output, scope) {
		if (!Jsonix.Util.Type.exists(value)) {
			return;
		}
		output.writeCharacters(this.print(value, context, output, scope));
	},
	buildStructure : function(context, structure) {
		Jsonix.Util.Ensure.ensureObject(structure);
		// if (Jsonix.Util.Type.exists(structure.value)) {
		// // TODO better exception
		// throw new Error("The structure already defines a value
		// property.");
		// } else
		if (Jsonix.Util.Type.exists(structure.elements)) {
			// TODO better exception
			throw new Error("The structure already defines element mappings, it cannot define a value property.");
		} else {
			structure.value = this;
		}
	},
	CLASS_NAME : 'Jsonix.Model.ValuePropertyInfo'
});

Jsonix.Model.AbstractElementsPropertyInfo = Jsonix.Class(Jsonix.Model.PropertyInfo, {
	wrapperElementName : null,
	initialize : function(mapping) {
		Jsonix.Util.Ensure.ensureObject(mapping);
		Jsonix.Model.PropertyInfo.prototype.initialize.apply(this, [ mapping ]);
		var wen = mapping.wrapperElementName||mapping.wen||undefined;
		if (Jsonix.Util.Type.isObject(wen)) {
			this.wrapperElementName = Jsonix.XML.QName.fromObject(wen);
		} else if (Jsonix.Util.Type.isString(wen)) {
			this.wrapperElementName = new Jsonix.XML.QName(this.defaultElementNamespaceURI, wen);
		} else {
			this.wrapperElementName = null;
		}
	},
	unmarshal : function(context, input, scope) {
		var result = null;
		var that = this;
		var callback = function(value) {
			if (that.collection) {
				if (result === null) {
					result = [];
				}
				result.push(value);

			} else {
				if (result === null) {
					result = value;
				} else {
					// TODO Report validation error
					throw new Error("Value already set.");
				}
			}
		};

		if (Jsonix.Util.Type.exists(this.wrapperElementName)) {
			this.unmarshalWrapperElement(context, input, scope, callback);
		} else {
			this.unmarshalElement(context, input, scope, callback);
		}
		return result;
	},
	unmarshalWrapperElement : function(context, input, scope, callback) {
		var et = input.next();
		while (et !== Jsonix.XML.Input.END_ELEMENT) {
			// New sub-element starts
			if (et === Jsonix.XML.Input.START_ELEMENT) {
				this.unmarshalElement(context, input, scope, callback);
			} else if (et === Jsonix.XML.Input.SPACE || et === Jsonix.XML.Input.COMMENT || et === Jsonix.XML.Input.PROCESSING_INSTRUCTION) {
				// Skip whitespace
			} else {
				// TODO ignore comments, processing
				// instructions
				throw new Error("Illegal state: unexpected event type [" + et + "].");
			}
			et = input.next();
		}
	},
	unmarshalElement : function(context, input, scope, callback) {
		throw new Error("Abstract method [unmarshalElement].");
	},
	marshal : function(value, context, output, scope) {

		if (!Jsonix.Util.Type.exists(value)) {
			// Do nothing
			return;
		}

		if (Jsonix.Util.Type.exists(this.wrapperElementName)) {
			output.writeStartElement(this.wrapperElementName);
		}

		if (!this.collection) {
			this.marshalElement(value, context, output, scope);
		} else {
			Jsonix.Util.Ensure.ensureArray(value);
			// TODO Exception if not array
			for ( var index = 0; index < value.length; index++) {
				var item = value[index];
				// TODO Exception if item does not exist
				this.marshalElement(item, context, output, scope);
			}
		}

		if (Jsonix.Util.Type.exists(this.wrapperElementName)) {
			output.writeEndElement();
		}
	},
	marshalElement : function(value, context, output, scope) {
		throw new Error("Abstract method [marshalElement].");
	},
	marshalElementTypeInfo : function(elementName, typeInfo,  value, context, output, scope) {
		output.writeStartElement(elementName);
		typeInfo.marshal(value, context, output, scope);
		output.writeEndElement();
	},
	buildStructure : function(context, structure) {
		Jsonix.Util.Ensure.ensureObject(structure);
		if (Jsonix.Util.Type.exists(structure.value)) {
			// TODO better exception
			throw new Error("The structure already defines a value property.");
		} else if (!Jsonix.Util.Type.exists(structure.elements)) {
			structure.elements = {};
		}

		if (Jsonix.Util.Type.exists(this.wrapperElementName)) {
			structure.elements[this.wrapperElementName.key] = this;
		} else {
			this.buildStructureElements(context, structure);
		}
	},
	buildStructureElements : function(context, structure) {
		throw new Error("Abstract method [buildStructureElements].");
	},
	CLASS_NAME : 'Jsonix.Model.AbstractElementsPropertyInfo'
});

Jsonix.Model.ElementPropertyInfo = Jsonix.Class(
		Jsonix.Model.AbstractElementsPropertyInfo, {
			typeInfo : 'String',
			elementName : null,
			initialize : function(mapping) {
				Jsonix.Util.Ensure.ensureObject(mapping);
				Jsonix.Model.AbstractElementsPropertyInfo.prototype.initialize
						.apply(this, [ mapping ]);
				var ti = mapping.typeInfo||mapping.ti||'String';
				if (Jsonix.Util.Type.isObject(ti)) {
					this.typeInfo = ti;
				} else {
					Jsonix.Util.Ensure.ensureString(ti);
					this.typeInfo = ti;
				}
				var en = mapping.elementName||mapping.en||undefined;
				if (Jsonix.Util.Type.isObject(en)) {
					this.elementName = Jsonix.XML.QName.fromObject(en);
				} else if (Jsonix.Util.Type.isString(en)) {
					this.elementName = new Jsonix.XML.QName(this.defaultElementNamespaceURI, en);
				} else {
					this.elementName = new Jsonix.XML.QName(this.defaultElementNamespaceURI, this.name);
				}
			},
			unmarshalElement : function(context, input, scope, callback) {
				return callback(this.typeInfo.unmarshal(context, input, scope));
			},
			marshalElement : function(value, context, output, scope) {
				this.marshalElementTypeInfo(this.elementName, this.typeInfo, value, context, output, scope);
			},
			doBuild : function(context, module) {
				this.typeInfo = context.resolveTypeInfo(this.typeInfo, module);
			},
			buildStructureElements : function(context, structure) {
				structure.elements[this.elementName.key] = this;
			},
			CLASS_NAME : 'Jsonix.Model.ElementPropertyInfo'
		});

Jsonix.Model.ElementsPropertyInfo = Jsonix
		.Class(
				Jsonix.Model.AbstractElementsPropertyInfo,
				{
					elementTypeInfos : null,
					elementTypeInfosMap : null,
					initialize : function(mapping) {
						Jsonix.Util.Ensure.ensureObject(mapping);
						Jsonix.Model.AbstractElementsPropertyInfo.prototype.initialize
								.apply(this, [ mapping ]);
						var etis = mapping.elementTypeInfos||mapping.etis||[];
						Jsonix.Util.Ensure.ensureArray(etis);
						this.elementTypeInfos = etis;
					},
					unmarshalElement : function(context, input, scope, callback) {
						// TODO make sure it's the right event type
						var elementNameKey = input.getNameKey();
						var typeInfo = this.elementTypeInfosMap[elementNameKey];
						if (Jsonix.Util.Type.exists(typeInfo)) {
							return callback(typeInfo.unmarshal(context, input, scope));
						}
						// TODO better exception
						throw new Error("Element [" + elementNameKey + "] is not known in this context");
					},
					marshalElement : function(value, context, output, scope) {
						for ( var index = 0; index < this.elementTypeInfos.length; index++) {
							var elementTypeInfo = this.elementTypeInfos[index];
							var typeInfo = elementTypeInfo.typeInfo;
							if (typeInfo.isInstance(value, context, scope)) {
								var elementName = elementTypeInfo.elementName;
								this.marshalElementTypeInfo(elementName, typeInfo, value, context, output, scope);
								return;
							}
						}
						throw new Error("Could not find an element with type info supporting the value ["	+ value + "].");
					},
					doBuild : function(context, module) {
						this.elementTypeInfosMap = {};
						var etiti, etien;
						for ( var index = 0; index < this.elementTypeInfos.length; index++) {
							var elementTypeInfo = this.elementTypeInfos[index];
							Jsonix.Util.Ensure.ensureObject(elementTypeInfo);
							etiti = elementTypeInfo.typeInfo||elementTypeInfo.ti||'String';
							elementTypeInfo.typeInfo = context.resolveTypeInfo(etiti, module);
							etien = elementTypeInfo.elementName||elementTypeInfo.en||undefined;
							if (Jsonix.Util.Type.isObject(etien)) {
								elementTypeInfo.elementName = Jsonix.XML.QName.fromObject(etien);
							} else {
								Jsonix.Util.Ensure.ensureString(etien);
								elementTypeInfo.elementName = new Jsonix.XML.QName(this.defaultElementNamespaceURI, etien);
							}
							this.elementTypeInfosMap[elementTypeInfo.elementName.key] = elementTypeInfo.typeInfo;
						}
					},
					buildStructureElements : function(context, structure) {
						for ( var index = 0; index < this.elementTypeInfos.length; index++) {
							var elementTypeInfo = this.elementTypeInfos[index];
							structure.elements[elementTypeInfo.elementName.key] = this;
						}
					},
					CLASS_NAME : 'Jsonix.Model.ElementsPropertyInfo'
				});

Jsonix.Model.ElementMapPropertyInfo = Jsonix.Class(Jsonix.Model.AbstractElementsPropertyInfo, {
	elementName : null,
	key : null,
	value : null,
	entryTypeInfo : null,
	initialize : function(mapping) {
		Jsonix.Util.Ensure.ensureObject(mapping);
		Jsonix.Model.AbstractElementsPropertyInfo.prototype.initialize.apply(this, [ mapping ]);
		// TODO Ensure correct argument
		var k = mapping.key||mapping.k||undefined;
		Jsonix.Util.Ensure.ensureObject(k);
		var v = mapping.value||mapping.v||undefined;
		Jsonix.Util.Ensure.ensureObject(v);
		// TODO Ensure correct argument
		var en = mapping.elementName||mapping.en||undefined;
		if (Jsonix.Util.Type.isObject(en)) {
			this.elementName = Jsonix.XML.QName.fromObject(en);
		} else if (Jsonix.Util.Type.isString(en)) {
			this.elementName = new Jsonix.XML.QName(this.defaultElementNamespaceURI, en);
		} else {
			this.elementName = new Jsonix.XML.QName(this.defaultElementNamespaceURI, this.name);
		}
		this.entryTypeInfo = new Jsonix.Model.ClassInfo({
			name: 'Map<' + k.name + ',' + v.name + '>',
			propertyInfos : [ k, v ]
		});

	},
	unmarshalWrapperElement : function(context, input, scope) {
		var result = Jsonix.Model.AbstractElementsPropertyInfo.prototype.unmarshalWrapperElement.apply(this, arguments);
	},
	unmarshal : function(context, input, scope) {
		var result = null;
		var that = this;
		var callback = function(value) {

			if (Jsonix.Util.Type.exists(value)) {
				Jsonix.Util.Ensure.ensureObject(value, 'Map property requires an object.');
				if (!Jsonix.Util.Type.exists(result)) {
					result = {};
				}
				for ( var attributeName in value) {
					if (value.hasOwnProperty(attributeName)) {
						var attributeValue = value[attributeName];
						if (that.collection) {
							if (!Jsonix.Util.Type.exists(result[attributeName])) {
								result[attributeName] = [];
							}
							result[attributeName].push(attributeValue);
						} else {
							if (!Jsonix.Util.Type.exists(result[attributeName])) {
								result[attributeName] = attributeValue;
							} else {
								// TODO Report validation error
								throw new Error("Value was already set.");
							}
						}
					}
				}
			}
		};

		if (Jsonix.Util.Type.exists(this.wrapperElementName)) {
			this.unmarshalWrapperElement(context, input, scope, callback);
		} else {
			this.unmarshalElement(context, input, scope, callback);
		}
		return result;
	},
	unmarshalElement : function(context, input, scope, callback) {
		var entry = this.entryTypeInfo.unmarshal(context, input, scope);
		var result = {};
		if (!!entry[this.key.name]) {
			result[entry[this.key.name]] = entry[this.value.name];
		}
		return callback(result);
	},
	marshal : function(value, context, output, scope) {

		if (!Jsonix.Util.Type.exists(value)) {
			// Do nothing
			return;
		}

		if (Jsonix.Util.Type.exists(this.wrapperElementName)) {
			output.writeStartElement(this.wrapperElementName);
		}

		this.marshalElement(value, context, output, scope);

		if (Jsonix.Util.Type.exists(this.wrapperElementName)) {
			output.writeEndElement();
		}
	},
	marshalElement : function(value, context, output, scope) {
		if (!!value) {
			for ( var attributeName in value) {
				if (value.hasOwnProperty(attributeName)) {
					var attributeValue = value[attributeName];
					if (!this.collection) {
						var singleEntry = {};
						singleEntry[this.key.name] = attributeName;
						singleEntry[this.value.name] = attributeValue;
						output.writeStartElement(this.elementName);
						this.entryTypeInfo.marshal(singleEntry, context, output, scope);
						output.writeEndElement();

					} else {
						for ( var index = 0; index < attributeValue.length; index++) {
							var collectionEntry = {};
							collectionEntry[this.key.name] = attributeName;
							collectionEntry[this.value.name] = attributeValue[index];
							output.writeStartElement(this.elementName);
							this.entryTypeInfo.marshal(collectionEntry, context, output, scope);
							output.writeEndElement();
						}
					}
				}
			}
		}
	},
	doBuild: function(context, module) {
		this.entryTypeInfo.build(context, module);
		// TODO get property by name
		this.key = this.entryTypeInfo.properties[0]; 
		this.value = this.entryTypeInfo.properties[1];
	},
	buildStructureElements : function(context, structure) {
		structure.elements[this.elementName.key] = this;
	},
	setProperty : function(object, value) {
		if (Jsonix.Util.Type.exists(value)) {
			Jsonix.Util.Ensure.ensureObject(value, 'Map property requires an object.');
			if (!Jsonix.Util.Type.exists(object[this.name])) {
				object[this.name] = {};
			}
			var map = object[this.name];
			for ( var attributeName in value) {
				if (value.hasOwnProperty(attributeName)) {
					var attributeValue = value[attributeName];
					if (this.collection) {
						if (!Jsonix.Util.Type.exists(map[attributeName])) {
							map[attributeName] = [];
						}

						for ( var index = 0; index < attributeValue.length; index++) {
							map[attributeName].push(attributeValue[index]);
						}
					} else {
						map[attributeName] = attributeValue;
					}
				}
			}
		}
	},
	CLASS_NAME : 'Jsonix.Model.ElementMapPropertyInfo'
});

Jsonix.Model.AbstractElementRefsPropertyInfo = Jsonix.Class(Jsonix.Model.PropertyInfo, {
	wrapperElementName : null,
	mixed : true,
	initialize : function(mapping) {
		Jsonix.Util.Ensure.ensureObject(mapping, 'Mapping must be an object.');
		Jsonix.Model.PropertyInfo.prototype.initialize.apply(this, [ mapping ]);
		var wen = mapping.wrapperElementName||mapping.wen||undefined;
		var mx = mapping.mixed||mapping.mx||true;
		if (Jsonix.Util.Type.isObject(wen)) {
			this.wrapperElementName = Jsonix.XML.QName.fromObject(wen);
		} else if (Jsonix.Util.Type.isString(wen)) {
			this.wrapperElementName = new Jsonix.XML.QName(this.defaultElementNamespaceURI, wen);
		} else {
			this.wrapperElementName = null;
		}
		this.mixed = mx;
	},
	unmarshal : function(context, input, scope) {
		var et = input.eventType;

		if (et === Jsonix.XML.Input.START_ELEMENT) {
			if (Jsonix.Util.Type.exists(this.wrapperElementName)) {
				return this.unmarshalWrapperElement(context, input, scope);
			} else {
				return this.unmarshalElement(context, input, scope);
			}
		} else if (this.mixed && (et === Jsonix.XML.Input.CHARACTERS || et === Jsonix.XML.Input.CDATA || et === Jsonix.XML.Input.ENTITY_REFERENCE)) {
			var value = input.getText();
			if (this.collection) {
				return [ value ];

			} else {
				return value;
			}
		} else if (et === Jsonix.XML.Input.SPACE || et === Jsonix.XML.Input.COMMENT || et === Jsonix.XML.Input.PROCESSING_INSTRUCTION) {
			// Skip whitespace
		} else {
			// TODO better exception
			throw new Error("Illegal state: unexpected event type [" + et + "].");
		}
	},
	unmarshalWrapperElement : function(context, input, scope) {
		var result = null;
		var et = input.next();
		while (et !== Jsonix.XML.Input.END_ELEMENT) {
			if (et === Jsonix.XML.Input.START_ELEMENT) {
				var value = this.unmarshalElement(context, input, scope);
				if (this.collection) {
					if (result === null) {
						result = [];
					}
					for ( var index = 0; index < value.length; index++) {
						result.push(value[index]);
					}

				} else {
					if (result === null) {
						result = value;
					} else {
						// TODO Report validation error
						throw new Error("Value already set.");
					}
				}
			} else
			// Characters
			if (this.mixed && (et === Jsonix.XML.Input.CHARACTERS || et === Jsonix.XML.Input.CDATA || et === Jsonix.XML.Input.ENTITY_REFERENCE)) {
				var text = input.getText();
				if (this.collection) {
					if (result === null) {
						result = [];
					}
					result.push(text);
				} else {
					if (result === null) {
						result = text;
					} else {
						// TODO Report validation error
						throw new Error("Value already set.");
					}
				}
			} else if (et === Jsonix.XML.Input.SPACE || et === Jsonix.XML.Input.COMMENT || et === Jsonix.XML.Input.PROCESSING_INSTRUCTION) {
				// Skip whitespace
			} else {
				throw new Error("Illegal state: unexpected event type [" + et + "].");
			}
			et = input.next();
		}
		return result;
	},
	unmarshalElement : function(context, input, scope) {
		var name = input.getName();
		var typeInfo = this.getElementTypeInfo(context, name, scope);
		var value = {
			name : name,
			value : typeInfo.unmarshal(context, input, scope)
		};
		if (this.collection) {
			return [ value ];
		} else {
			return value;
		}
	},
	marshal : function(value, context, output, scope) {

		if (Jsonix.Util.Type.exists(value)) {
			if (Jsonix.Util.Type.exists(this.wrapperElementName)) {
				output.writeStartElement(this.wrapperElementName);
			}

			if (!this.collection) {
				this.marshalItem(value, context, output, scope);
			} else {
				Jsonix.Util.Ensure.ensureArray(value, 'Collection property requires an array value.');
				for ( var index = 0; index < value.length; index++) {
					var item = value[index];
					this.marshalItem(item, context, output, scope);
				}
			}

			if (Jsonix.Util.Type.exists(this.wrapperElementName)) {
				output.writeEndElement();
			}
		}

	},
	marshalItem : function(value, context, output, scope) {

		if (Jsonix.Util.Type.isString(value)) {
			if (!this.mixed) {
				// TODO
				throw new Error("Property is not mixed, can't handle string values.");
			} else {
				output.writeCharacters(value);
			}
		} else if (Jsonix.Util.Type.isObject(value)) {
			this.marshalElement(value, context, output, scope);

		} else {
			if (this.mixed) {
				throw new Error("Unsupported content type, either objects or strings are supported.");
			} else {
				throw new Error("Unsupported content type, only objects are supported.");
			}
		}

	},
	marshalElement : function(value, context, output, scope) {
		var elementName = Jsonix.XML.QName.fromObject(value.name);
		var typeInfo = this.getElementTypeInfo(context, elementName, scope);
		return this.marshalElementTypeInfo(elementName, typeInfo, value, context, output, scope);
	},
	marshalElementTypeInfo : function(elementName, typeInfo, value, context, output, scope) {
		output.writeStartElement(elementName);
		if (Jsonix.Util.Type.exists(value.value)) {
			typeInfo.marshal(value.value, context, output, scope);
		}
		output.writeEndElement();

	},
	getElementTypeInfo : function(context, elementName, scope) {
		var propertyElementTypeInfo = this.getPropertyElementTypeInfo(elementName);
		if (Jsonix.Util.Type.exists(propertyElementTypeInfo)) {
			return propertyElementTypeInfo.typeInfo;
		} else {
			var contextElementTypeInfo = context.getElementInfo(elementName, scope);
			if (Jsonix.Util.Type.exists(contextElementTypeInfo)) {
				return contextElementTypeInfo.typeInfo;
			} else {
				throw new Error("Element [" + elementName.key + "] is not known in this context.");
			}
		}

	},
	getPropertyElementTypeInfo : function(elementName) {
		throw new Error("Abstract method [getPropertyElementTypeInfo].");
	},
	buildStructure : function(context, structure) {
		Jsonix.Util.Ensure.ensureObject(structure);
		if (Jsonix.Util.Type.exists(structure.value)) {
			// TODO better exception
			throw new Error("The structure already defines a value property.");
		} else if (!Jsonix.Util.Type.exists(structure.elements)) {
			structure.elements = {};
		}

		if (Jsonix.Util.Type.exists(this.wrapperElementName)) {
			structure.elements[this.wrapperElementName.key] = this;
		} else {
			this.buildStructureElements(context, structure);
		}

		// if (Jsonix.Util.Type.exists(structure.elements[key]))
		// {
		// // TODO better exception
		// throw new Error("The structure already defines an element for
		// the key ["
		// + key + "].");
		// } else
		// {
		// structure.elements[key] = this;
		// }

		if (this.mixed && !Jsonix.Util.Type.exists(this.wrapperElementName)) {
			// if (Jsonix.Util.Type.exists(structure.mixed)) {
			// // TODO better exception
			// throw new Error("The structure already defines the mixed
			// property.");
			// } else
			// {
			structure.mixed = this;
			// }
		}
	},
	buildStructureElements : function(context, structure) {
		throw new Error("Abstract method [buildStructureElements].");
	},
	buildStructureElementTypeInfos : function(context, structure, elementTypeInfo) {
		structure.elements[elementTypeInfo.elementName.key] = this;
		var substitutionMembers = context.getSubstitutionMembers(elementTypeInfo.elementName);
		if (Jsonix.Util.Type.isArray(substitutionMembers)) {
			for ( var jndex = 0; jndex < substitutionMembers.length; jndex++) {
				var substitutionElementInfo = substitutionMembers[jndex];
				this.buildStructureElementTypeInfos(context, structure, substitutionElementInfo);
			}

		}
	},
	CLASS_NAME : 'Jsonix.Model.ElementRefPropertyInfo'
});

Jsonix.Model.ElementRefPropertyInfo = Jsonix
		.Class(
				Jsonix.Model.AbstractElementRefsPropertyInfo,
				{
					typeInfo : 'String',
					elementName : null,
					initialize : function(mapping) {
						Jsonix.Util.Ensure.ensureObject(mapping);
						Jsonix.Model.AbstractElementRefsPropertyInfo.prototype.initialize
								.apply(this, [ mapping ]);
						// TODO Ensure correct argument
						var ti = mapping.typeInfo||mapping.ti||'String';
						if (Jsonix.Util.Type.isObject(ti)) {
							this.typeInfo = ti;
						} else {
							Jsonix.Util.Ensure.ensureString(ti);
							this.typeInfo = ti;
						}
						var en = mapping.elementName||mapping.en||undefined;
						if (Jsonix.Util.Type.isObject(en)) {
							this.elementName = Jsonix.XML.QName.fromObject(en);
						} else if (Jsonix.Util.Type.isString(en)) {
							this.elementName = new Jsonix.XML.QName(this.defaultElementNamespaceURI, en);
						} else {
							this.elementName = new Jsonix.XML.QName(this.defaultElementNamespaceURI, this.name);
						}
					},
					getPropertyElementTypeInfo : function(elementName) {
						Jsonix.Util.Ensure.ensureObject(elementName);
						var name = Jsonix.XML.QName.fromObject(elementName);

						if (name.key === this.elementName.key) {
							return this;
						} else {
							return null;
						}
					},
					doBuild : function(context, module) {
						this.typeInfo = context.resolveTypeInfo(this.typeInfo, module);
					},
					buildStructureElements : function(context, structure) {
						this.buildStructureElementTypeInfos(context, structure,	this);
					},
					CLASS_NAME : 'Jsonix.Model.ElementRefPropertyInfo'
				});

Jsonix.Model.ElementRefsPropertyInfo = Jsonix
		.Class(
				Jsonix.Model.AbstractElementRefsPropertyInfo,
				{
					elementTypeInfos : null,
					elementTypeInfosMap : null,
					initialize : function(mapping) {
						Jsonix.Util.Ensure.ensureObject(mapping);
						Jsonix.Model.AbstractElementRefsPropertyInfo.prototype.initialize
								.apply(this, [ mapping ]);
						// TODO Ensure correct arguments
						var etis = mapping.elementTypeInfos||mapping.etis||[];
						Jsonix.Util.Ensure.ensureArray(etis);
						this.elementTypeInfos = etis;
					},
					getPropertyElementTypeInfo : function(elementName) {
						Jsonix.Util.Ensure.ensureObject(elementName);
						var name = Jsonix.XML.QName.fromObject(elementName);

						var typeInfo = this.elementTypeInfosMap[name.key];
						if (Jsonix.Util.Type.exists(typeInfo)) {
							return {
								elementName : name,
								typeInfo : typeInfo
							};
						} else {
							return null;
						}
					},
					doBuild : function(context, module) {
						this.elementTypeInfosMap = {};
						var etiti, etien;
						for ( var index = 0; index < this.elementTypeInfos.length; index++) {
							var elementTypeInfo = this.elementTypeInfos[index];
							Jsonix.Util.Ensure.ensureObject(elementTypeInfo);
							etiti = elementTypeInfo.typeInfo || elementTypeInfo.ti || 'String';
							elementTypeInfo.typeInfo = context.resolveTypeInfo(etiti, module);
							etien = elementTypeInfo.elementName || elementTypeInfo.en||undefined;
							if (Jsonix.Util.Type.isObject(etien)) {
								elementTypeInfo.elementName = Jsonix.XML.QName.fromObject(etien);
							} else {
								Jsonix.Util.Ensure
										.ensureString(etien);
								elementTypeInfo.elementName = new Jsonix.XML.QName(
										this.defaultElementNamespaceURI,
										etien);
							}
							this.elementTypeInfosMap[elementTypeInfo.elementName.key] = elementTypeInfo.typeInfo;
						}
					},
					buildStructureElements : function(context, structure) {
						for ( var index = 0; index < this.elementTypeInfos.length; index++) {
							var elementTypeInfo = this.elementTypeInfos[index];
							this.buildStructureElementTypeInfos(context, structure, elementTypeInfo);
						}
					},
					CLASS_NAME : 'Jsonix.Model.ElementRefsPropertyInfo'
				});

Jsonix.Model.AnyElementPropertyInfo = Jsonix.Class(Jsonix.Model.PropertyInfo, {
	allowDom : true,
	allowTypedObject : true,
	mixed : true,
	initialize : function(mapping) {
		Jsonix.Util.Ensure.ensureObject(mapping);
		Jsonix.Model.PropertyInfo.prototype.initialize.apply(this, [ mapping ]);
		var dom = mapping.allowDom || mapping.dom || true;
		var typed = mapping.allowTypedObject || mapping.typed || true;
		var mx = mapping.mixed || mapping.mx || true;
		this.allowDom = dom;
		this.allowTypedObject = typed;
		this.mixed = mx;
	},
	unmarshal : function(context, input, scope) {
		var et = input.eventType;

		if (et === Jsonix.XML.Input.START_ELEMENT) {
			return this.unmarshalElement(context, input, scope);
		} else if (this.mixed && (et === Jsonix.XML.Input.CHARACTERS || et === Jsonix.XML.Input.CDATA || et === Jsonix.XML.Input.ENTITY_REFERENCE)) {
			var value = input.getText();
			if (this.collection) {
				return [ value ];

			} else {
				return value;
			}
		} else if (this.mixed && (et === Jsonix.XML.Input.SPACE)) {
			// Whitespace
			return null;
		} else if (et === Jsonix.XML.Input.COMMENT || et === Jsonix.XML.Input.PROCESSING_INSTRUCTION) {
			return null;

		} else {
			// TODO better exception
			throw new Error("Illegal state: unexpected event type [" + et + "].");

		}
	},
	unmarshalElement : function(context, input, scope) {

		var name = input.getName();
		var value;

		if (this.allowTypedObject && Jsonix.Util.Type.exists(context.getElementInfo(name, scope))) {
			// TODO optimize
			var elementDeclaration = context.getElementInfo(name, scope);
			var typeInfo = elementDeclaration.typeInfo;
			var adapter = Jsonix.Model.Adapter.getAdapter(elementDeclaration);
			value = {
				name : name,
				value : adapter.unmarshal(typeInfo, context, input, scope)
			};
		} else if (this.allowDom) {
			value = input.getElement();
		} else {
			// TODO better exception
			throw new Error("Element [" + name.toString() + "] is not known in this context and property does not allow DOM.");
		}
		if (this.collection) {
			return [ value ];
		} else {
			return value;
		}
	},
	marshal : function(value, context, output, scope) {
		if (!Jsonix.Util.Type.exists(value)) {
			return;
		}
		if (!this.collection) {
			this.marshalItem(value, context, output, scope);
		} else {
			Jsonix.Util.Ensure.ensureArray(value);
			for ( var index = 0; index < value.length; index++) {
				this.marshalItem(value[index], context, output, scope);
			}
		}
	},
	marshalItem : function(value, context, output, scope) {
		if (this.mixed && Jsonix.Util.Type.isString(value)) {
			// Mixed
			output.writeCharacters(value);
		} else if (this.allowDom && Jsonix.Util.Type.exists(value.nodeType)) {
			// DOM node
			output.writeNode(value);

		} else {
			// Typed object
			var name = Jsonix.XML.QName.fromObject(value.name);
			if (this.allowTypedObject && Jsonix.Util.Type.exists(context.getElementInfo(name, scope))) {
				var elementDeclaration = context.getElementInfo(name, scope);
				var typeInfo = elementDeclaration.typeInfo;
				var adapter = Jsonix.Model.Adapter.getAdapter(elementDeclaration);
				output.writeStartElement(name);
				adapter.marshal(typeInfo, value.value, context, output, scope);
				output.writeEndElement();
			} else {
				// TODO better exception
				throw new Error("Element [" + name.toString() + "] is not known in this context");
			}
		}
	},
	doBuild : function(context, module)	{
		// Nothing to do
	},
	buildStructure : function(context, structure) {
		Jsonix.Util.Ensure.ensureObject(structure);
		if (Jsonix.Util.Type.exists(structure.value)) {
			// TODO better exception
			throw new Error("The structure already defines a value property.");
		} else if (!Jsonix.Util.Type.exists(structure.elements)) {
			structure.elements = {};
		}

		if ((this.allowDom || this.allowTypedObject)) {
			// if (Jsonix.Util.Type.exists(structure.any)) {
			// // TODO better exception
			// throw new Error("The structure already defines the any
			// property.");
			// } else
			// {
			structure.any = this;
			// }
		}
		if (this.mixed) {
			// if (Jsonix.Util.Type.exists(structure.mixed)) {
			// // TODO better exception
			// throw new Error("The structure already defines the mixed
			// property.");
			// } else
			// {
			structure.mixed = this;
			// }
		}
	},
	CLASS_NAME : 'Jsonix.Model.AnyElementPropertyInfo'
});

Jsonix.Model.Module = Jsonix
		.Class({
			name : null,
			typeInfos : null,
			elementInfos : null,
			defaultElementNamespaceURI : '',
			defaultAttributeNamespaceURI : '',
			initialize : function(mapping) {
				this.typeInfos = [];
				this.elementInfos = [];
				if (typeof mapping !== 'undefined') {
					Jsonix.Util.Ensure.ensureObject(mapping);
					var n = mapping.name||mapping.n||null;
					this.name = n;
					var dens = mapping.defaultElementNamespaceURI||mapping.dens||'';
					this.defaultElementNamespaceURI = dens;
					var dans = mapping.defaultAttributeNamespaceURI||mapping.dans||'';
					this.defaultAttributeNamespaceURI = dans;
					// Initialize type infos
					var tis = mapping.typeInfos||mapping.tis||[];
					this.initializeTypeInfos(tis);

					// Backwards compatibility: class infos can also be defined
					// as properties of the schema, for instance Schema.MyType
					for ( var typeInfoName in mapping) {
						if (mapping.hasOwnProperty(typeInfoName)) {
							if (mapping[typeInfoName] instanceof Jsonix.Model.ClassInfo) {
								this.typeInfos.push(mapping[typeInfoName]);
							}
						}
					}
					var eis = mapping.elementInfos||mapping.eis||[];
					// Initialize element infos
					this.initializeElementInfos(eis);
				}
			},
			initializeTypeInfos : function(typeInfoMappings) {
				Jsonix.Util.Ensure.ensureArray(typeInfoMappings);
				var index, typeInfoMapping, typeInfo;
				for (index = 0; index < typeInfoMappings.length; index++) {
					typeInfoMapping = typeInfoMappings[index];
					typeInfo = this.createTypeInfo(typeInfoMapping);
					this.typeInfos.push(typeInfo);
				}
			},
			initializeElementInfos : function(elementInfoMappings) {
				Jsonix.Util.Ensure.ensureArray(elementInfoMappings);
				var index, elementInfoMapping, elementInfo;
				for (index = 0; index < elementInfoMappings.length; index++) {
					elementInfoMapping = elementInfoMappings[index];
					elementInfo = this.createElementInfo(elementInfoMapping);
					this.elementInfos.push(elementInfo);
				}
			},
			createTypeInfo : function(mapping) {
				Jsonix.Util.Ensure.ensureObject(mapping);
				var typeInfo;
				// If mapping is already a type info, do nothing
				if (mapping instanceof Jsonix.Model.TypeInfo) {
					typeInfo = mapping;
				}
				// Else create it via generic mapping configuration
				else {
					var type = mapping.type||mapping.t||'classInfo';
					// Locate the creator function
					if (Jsonix.Util.Type
							.isFunction(this.typeInfoCreators[type])) {
						var typeInfoCreator = this.typeInfoCreators[type];
						// Call the creator function
						typeInfo = typeInfoCreator.call(this, mapping);
					} else {
						throw new Error("Unknown type info type [" + type + "].");
					}
				}
				return typeInfo;
			},
			initializeNames : function(mapping) {
				var ln = mapping.localName||mapping.ln||null;
				mapping.localName = ln;
				var n = mapping.name||mapping.n||null;
				mapping.name = n;
				// Calculate both name as well as localName
				// name is provided
				if (Jsonix.Util.Type.isString(mapping.name)) {
					// Nothing to do - only name matters
					
					// Obsolete code below
//					// localName is not provided
//					if (!Jsonix.Util.Type.isString(mapping.localName)) {
//						// But module name is provided
//						if (Jsonix.Util.Type.isString(this.name)) {
//							// If name starts with module name, use second part
//							// as local name
//							if (mapping.name.indexOf(this.name + '.') === 0) {
//								mapping.localName = mapping.name
//										.substring(this.name.length + 1);
//							}
//							// Else use name as local name
//							else {
//								mapping.localName = mapping.name;
//							}
//						}
//						// Module name is not provided, use name as local name
//						else {
//							mapping.localName = mapping.name;
//						}
//					}
					if (mapping.name.length > 0 && mapping.name.charAt(0) === '.' && Jsonix.Util.Type.isString(this.name))
					{
						mapping.name = this.name + mapping.name;
					}
				}
				// name is not provided but local name is provided
				else if (Jsonix.Util.Type.isString(mapping.localName)) {
					// Module name is provided
					if (Jsonix.Util.Type.isString(this.name)) {
						mapping.name = this.name + '.' + mapping.localName;
					}
					// Module name is not provided
					else {
						mapping.name = mapping.localName;
					}
				} else {
					throw new Error("Neither [name/n] nor [localName/ln] was provided for the class info.");
				}
			},
			createClassInfo : function(mapping) {
				Jsonix.Util.Ensure.ensureObject(mapping);
				var dens = mapping.defaultElementNamespaceURI||mapping.dens||this.defaultElementNamespaceURI;
				mapping.defaultElementNamespaceURI = dens;
				var dans = mapping.defaultAttributeNamespaceURI||mapping.dans||this.defaultAttributeNamespaceURI;
				mapping.defaultAttributeNamespaceURI = dans;
				this.initializeNames(mapping);
				// Now both name an local name are initialized
				var classInfo = new Jsonix.Model.ClassInfo(mapping);
				return classInfo;
			},
			createEnumLeafInfo : function(mapping) {
				Jsonix.Util.Ensure.ensureObject(mapping);
				this.initializeNames(mapping);
				// Now both name an local name are initialized
				var enumLeafInfo = new Jsonix.Model.EnumLeafInfo(mapping);
				return enumLeafInfo;
			},
			createList : function(mapping) {
				Jsonix.Util.Ensure.ensureObject(mapping);
				var ti = mapping.baseTypeInfo||mapping.typeInfo||mapping.bti||mapping.ti||'String';
				var tn = mapping.typeName||mapping.tn||null;
				var s = mapping.separator||mapping.sep||' ';
				Jsonix.Util.Ensure.ensureExists(ti);
				return new Jsonix.Schema.XSD.List(ti, tn, s);
			},
			createElementInfo : function(mapping) {
				Jsonix.Util.Ensure.ensureObject(mapping);
				var dens = mapping.defaultElementNamespaceURI||mapping.dens||this.defaultElementNamespaceURI;
				mapping.defaultElementNamespaceURI = dens;
				var en = mapping.elementName||mapping.en||undefined;
				Jsonix.Util.Ensure.ensureExists(en);
				
				var ti = mapping.typeInfo||mapping.ti||'String';
				Jsonix.Util.Ensure.ensureExists(ti);
				
				mapping.typeInfo = ti;
				if (Jsonix.Util.Type.isObject(en)) {
					mapping.elementName = Jsonix.XML.QName.fromObject(en);
				} else if (Jsonix.Util.Type.isString(en)) {
					mapping.elementName = new Jsonix.XML.QName(this.defaultElementNamespaceURI, en);
				} else {
					throw new Error('Element info [' + mapping + '] must provide an element name.');
				}
				
				var sh = mapping.substitutionHead||mapping.sh||null;
				if (Jsonix.Util.Type.exists(sh)) {
					if (Jsonix.Util.Type.isObject(sh)) {
						mapping.substitutionHead = Jsonix.XML.QName.fromObject(sh);
					} else {
						Jsonix.Util.Ensure.ensureString(sh);
						mapping.substitutionHead = new Jsonix.XML.QName(this.defaultElementNamespaceURI, sh);
					}
				}
				
				var elementInfo = new Jsonix.Model.ElementInfo(mapping);
				return elementInfo;
			},
			registerTypeInfos : function(context) {
				for ( var index = 0; index < this.typeInfos.length; index++) {
					var typeInfo = this.typeInfos[index];
					context.registerTypeInfo(typeInfo, this);
				}
			},
			buildTypeInfos : function(context) {
				for ( var index = 0; index < this.typeInfos.length; index++) {
					var typeInfo = this.typeInfos[index];
					typeInfo.build(context, this);
				}
			},
			registerElementInfos : function(context) {
				for ( var index = 0; index < this.elementInfos.length; index++) {
					var elementInfo = this.elementInfos[index];
					context.registerElementInfo(elementInfo, this);
				}
			},
			buildElementInfos : function(context) {
				for ( var index = 0; index < this.elementInfos.length; index++) {
					var elementInfo = this.elementInfos[index];
					elementInfo.build(context, this);
				}
			},
			// Obsolete, retained for backwards compatibility
			cs : function() {
				return this;
			},
			// Obsolete, retained for backwards compatibility
			es : function() {
				return this;
			},
			CLASS_NAME : 'Jsonix.Model.Module'
		});
Jsonix.Model.Module.prototype.typeInfoCreators = {
	"classInfo" : Jsonix.Model.Module.prototype.createClassInfo,
	"c" : Jsonix.Model.Module.prototype.createClassInfo,
	"enumInfo" : Jsonix.Model.Module.prototype.createEnumLeafInfo,
	"enum" : Jsonix.Model.Module.prototype.createEnumLeafInfo,
	"list" : Jsonix.Model.Module.prototype.createList,
	"l" : Jsonix.Model.Module.prototype.createList
};
Jsonix.Schema.XSD = {};
Jsonix.Schema.XSD.NAMESPACE_URI = 'http://www.w3.org/2001/XMLSchema';
Jsonix.Schema.XSD.PREFIX = 'xsd';
Jsonix.Schema.XSD.qname = function(localPart) {
	Jsonix.Util.Ensure.ensureString(localPart);
	return new Jsonix.XML.QName(Jsonix.Schema.XSD.NAMESPACE_URI, localPart,
			Jsonix.Schema.XSD.PREFIX);
};

Jsonix.Schema.XSD.AnyType = Jsonix.Class(Jsonix.Model.ClassInfo, {
	typeName : Jsonix.Schema.XSD.qname('anyType'),
	initialize : function() {
		Jsonix.Model.ClassInfo.prototype.initialize.call(this, {
			name : 'AnyType',
			propertyInfos : [ {
				type : 'anyAttribute',
				name : 'attributes'
			}, {
				type : 'anyElement',
				name : 'content',
				collection : true
			} ]
		});
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.AnyType'
});
Jsonix.Schema.XSD.AnyType.INSTANCE = new Jsonix.Schema.XSD.AnyType();
Jsonix.Schema.XSD.AnySimpleType = Jsonix.Class(Jsonix.Model.TypeInfo, {
	name : 'AnySimpleType',
	typeName : Jsonix.Schema.XSD.qname('anySimpleType'),
	initialize : function() {
		Jsonix.Model.TypeInfo.prototype.initialize.apply(this, []);
	},	
	print : function(value, context, output, scope) {
		throw new Error('Abstract method [print].');
	},
	parse : function(text, context, input, scope) {
		throw new Error('Abstract method [parse].');
	},
	reprint : function(value, context, output, scope) {
		// Only reprint when the value is a string but not an instance
		if (Jsonix.Util.Type.isString(value) && !this.isInstance(value, context, scope)) {
			// Using null as input as input is not available
			return this.print(this.parse(value, context, null, scope), context, output, scope);
		}
		else
		{
			return this.print(value, context, output, scope);
		}
	},
	unmarshal : function(context, input, scope) {
		var text = input.getElementText();
		if (Jsonix.Util.StringUtils.isNotBlank(text)) {
			return this.parse(text, context, input, scope);
		} else {
			return null;
		}
	},
	marshal : function(value, context, output, scope) {
		if (Jsonix.Util.Type.exists(value)) {
			output.writeCharacters(this.reprint(value, context, output, scope));
		}
	},
	build: function(context, module)
	{
		// Nothing to do
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.AnySimpleType'
});

Jsonix.Schema.XSD.List = Jsonix
		.Class(
				Jsonix.Schema.XSD.AnySimpleType,
				{
					name : null,
					typeName : null,
					typeInfo : null,
					separator : ' ',
					trimmedSeparator : Jsonix.Util.StringUtils.whitespaceCharacters,
					simpleType : true,
					built : false,
					initialize : function(typeInfo, typeName, separator) {
						Jsonix.Util.Ensure.ensureExists(typeInfo);
						// TODO Ensure correct argument
						this.typeInfo = typeInfo;
						if (!Jsonix.Util.Type.exists(this.name)) {
							this.name = typeInfo.name + "*";
						}
						if (Jsonix.Util.Type.exists(typeName)) {
							// TODO Ensure correct argument
							this.typeName = typeName;
						}

						if (Jsonix.Util.Type.isString(separator)) {
							// TODO Ensure correct argument
							this.separator = separator;
						} else {
							this.separator = ' ';
						}

						var trimmedSeparator = Jsonix.Util.StringUtils
								.trim(this.separator);
						if (trimmedSeparator.length === 0) {
							this.trimmedSeparator = Jsonix.Util.StringUtils.whitespaceCharacters;
						} else {
							this.trimmedSeparator = trimmedSeparator;
						}
					},
					build : function(context, module) {
						if (!this.built) {
							this.typeInfo = context.resolveTypeInfo(this.typeInfo, module);
							this.built = true;
						}
					},
					print : function(value, context, output, scope) {
						if (!Jsonix.Util.Type.exists(value)) {
							return null;
						}
						// TODO Exception if not an array
						Jsonix.Util.Ensure.ensureArray(value);
						var result = '';
						for ( var index = 0; index < value.length; index++) {
							if (index > 0) {
								result = result + this.separator;
							}
							result = result + this.typeInfo.reprint(value[index], context, output, scope);
						}
						return result;
					},
					parse : function(text, context, input, scope) {
						Jsonix.Util.Ensure.ensureString(text);
						var items = Jsonix.Util.StringUtils
								.splitBySeparatorChars(text,
										this.trimmedSeparator);
						var result = [];
						for ( var index = 0; index < items.length; index++) {
							result.push(this.typeInfo
									.parse(Jsonix.Util.StringUtils.trim(items[index]), context, input, scope));
						}
						return result;
					},
					// TODO isInstance?
					CLASS_NAME : 'Jsonix.Schema.XSD.List'
				});

Jsonix.Schema.XSD.String = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'String',
	typeName : Jsonix.Schema.XSD.qname('string'),
	print : function(value, context, output, scope) {
		Jsonix.Util.Ensure.ensureString(value);
		return value;
	},
	parse : function(text, context, input, scope) {
		Jsonix.Util.Ensure.ensureString(text);
		return text;
	},
	isInstance : function(value, context, scope) {
		return Jsonix.Util.Type.isString(value);
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.String'
});
Jsonix.Schema.XSD.String.INSTANCE = new Jsonix.Schema.XSD.String();
Jsonix.Schema.XSD.String.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.String.INSTANCE);
Jsonix.Schema.XSD.Strings = Jsonix.Class(Jsonix.Schema.XSD.List, {
	name : 'Strings',
	initialize : function() {
		Jsonix.Schema.XSD.List.prototype.initialize.apply(this, [ Jsonix.Schema.XSD.String.INSTANCE, Jsonix.Schema.XSD.qname('strings'), ' ' ]);
	},
	// TODO Constraints
	CLASS_NAME : 'Jsonix.Schema.XSD.Strings'
});
Jsonix.Schema.XSD.Strings.INSTANCE = new Jsonix.Schema.XSD.Strings();
Jsonix.Schema.XSD.NormalizedString = Jsonix.Class(Jsonix.Schema.XSD.String, {
	name : 'NormalizedString',
	typeName : Jsonix.Schema.XSD.qname('normalizedString'),
	// TODO Constraints
	CLASS_NAME : 'Jsonix.Schema.XSD.NormalizedString'
});
Jsonix.Schema.XSD.NormalizedString.INSTANCE = new Jsonix.Schema.XSD.NormalizedString();
Jsonix.Schema.XSD.NormalizedString.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.NormalizedString.INSTANCE);
Jsonix.Schema.XSD.Token = Jsonix.Class(Jsonix.Schema.XSD.NormalizedString, {
	name : 'Token',
	typeName : Jsonix.Schema.XSD.qname('token'),
	// TODO Constraints
	CLASS_NAME : 'Jsonix.Schema.XSD.Token'
});
Jsonix.Schema.XSD.Token.INSTANCE = new Jsonix.Schema.XSD.Token();
Jsonix.Schema.XSD.Token.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Token.INSTANCE);
Jsonix.Schema.XSD.Language = Jsonix.Class(Jsonix.Schema.XSD.Token, {
	name : 'Language',
	typeName : Jsonix.Schema.XSD.qname('language'),
	// TODO Constraints
	CLASS_NAME : 'Jsonix.Schema.XSD.Language'
});
Jsonix.Schema.XSD.Language.INSTANCE = new Jsonix.Schema.XSD.Language();
Jsonix.Schema.XSD.Language.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Language.INSTANCE);
Jsonix.Schema.XSD.Name = Jsonix.Class(Jsonix.Schema.XSD.Token, {
	name : 'Name',
	typeName : Jsonix.Schema.XSD.qname('Name'),
	// TODO Constraints
	CLASS_NAME : 'Jsonix.Schema.XSD.Name'
});
Jsonix.Schema.XSD.Name.INSTANCE = new Jsonix.Schema.XSD.Name();
Jsonix.Schema.XSD.Name.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Name.INSTANCE);
Jsonix.Schema.XSD.NCName = Jsonix.Class(Jsonix.Schema.XSD.Name, {
	name : 'NCName',
	typeName : Jsonix.Schema.XSD.qname('NCName'),
	// TODO Constraints
	CLASS_NAME : 'Jsonix.Schema.XSD.NCName'
});
Jsonix.Schema.XSD.NCName.INSTANCE = new Jsonix.Schema.XSD.NCName();
Jsonix.Schema.XSD.NCName.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.NCName.INSTANCE);
Jsonix.Schema.XSD.NMToken = Jsonix.Class(Jsonix.Schema.XSD.Token, {
	name : 'NMToken',
	typeName : Jsonix.Schema.XSD.qname('NMTOKEN'),
	// TODO Constraints
	CLASS_NAME : 'Jsonix.Schema.XSD.NMToken'
});
Jsonix.Schema.XSD.NMToken.INSTANCE = new Jsonix.Schema.XSD.NMToken();
Jsonix.Schema.XSD.NMTokens = Jsonix.Class(Jsonix.Schema.XSD.List, {
	name : 'NMTokens',
	initialize : function() {
		Jsonix.Schema.XSD.List.prototype.initialize.apply(this, [ Jsonix.Schema.XSD.NMToken.INSTANCE, Jsonix.Schema.XSD.qname('NMTOKEN'), ' ' ]);
	},
	// TODO Constraints
	CLASS_NAME : 'Jsonix.Schema.XSD.NMTokens'
});
Jsonix.Schema.XSD.NMTokens.INSTANCE = new Jsonix.Schema.XSD.NMTokens();
Jsonix.Schema.XSD.Boolean = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'Boolean',
	typeName : Jsonix.Schema.XSD.qname('boolean'),
	print : function(value, context, output, scope) {
		Jsonix.Util.Ensure.ensureBoolean(value);
		return value ? 'true' : 'false';
	},
	parse : function(text, context, input, scope) {
		Jsonix.Util.Ensure.ensureString(text);
		if (text === 'true' || text === '1') {
			return true;
		} else if (text === 'false' || text === '0') {
			return false;
		} else {
			throw new Error("Either [true], [1], [0] or [false] expected as boolean value.");
		}
	},
	isInstance : function(value, context, scope) {
		return Jsonix.Util.Type.isBoolean(value);
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.Boolean'
});
Jsonix.Schema.XSD.Boolean.INSTANCE = new Jsonix.Schema.XSD.Boolean();
Jsonix.Schema.XSD.Boolean.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Boolean.INSTANCE);
Jsonix.Schema.XSD.Base64Binary = Jsonix
		.Class(
				Jsonix.Schema.XSD.AnySimpleType,
				{
					name : 'Base64Binary',
					typeName : Jsonix.Schema.XSD.qname('base64Binary'),
					charToByte : {},
					byteToChar : [],
					initialize : function() {
						Jsonix.Schema.XSD.AnySimpleType.prototype.initialize
								.apply(this);
						// Initialize charToByte and byteToChar table for fast
						// lookups
						var charTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
						for ( var i = 0; i < charTable.length; i++) {
							var _char = charTable.charAt(i);
							var _byte = charTable.charCodeAt(i);
							this.byteToChar[i] = _char;
							this.charToByte[_char] = i;
						}
					},
					print : function(value, context, output, scope) {
						Jsonix.Util.Ensure.ensureArray(value);
						return this.encode(value);
					},

					parse : function(text, context, input, scope) {
						Jsonix.Util.Ensure.ensureString(text);
						return this.decode(text);
					},
					encode : function(uarray) {
						var output = "";
						var byte0;
						var byte1;
						var byte2;
						var char0;
						var char1;
						var char2;
						var char3;
						var i = 0;
						var j = 0;
						var length = uarray.length;

						for (i = 0; i < length; i += 3) {
							byte0 = uarray[i] & 0xFF;
							char0 = this.byteToChar[byte0 >> 2];

							if (i + 1 < length) {
								byte1 = uarray[i + 1] & 0xFF;
								char1 = this.byteToChar[((byte0 & 0x03) << 4)
										| (byte1 >> 4)];
								if (i + 2 < length) {
									byte2 = uarray[i + 2] & 0xFF;
									char2 = this.byteToChar[((byte1 & 0x0F) << 2)
											| (byte2 >> 6)];
									char3 = this.byteToChar[byte2 & 0x3F];
								} else {
									char2 = this.byteToChar[(byte1 & 0x0F) << 2];
									char3 = "=";
								}
							} else {
								char1 = this.byteToChar[(byte0 & 0x03) << 4];
								char2 = "=";
								char3 = "=";
							}
							output = output + char0 + char1 + char2 + char3;
						}
						return output;
					},
					decode : function(text) {

						input = text.replace(/[^A-Za-z0-9\+\/\=]/g, "");

						var length = (input.length / 4) * 3;
						if (input.charAt(input.length - 1) === "=") {
							length--;
						}
						if (input.charAt(input.length - 2) === "=") {
							length--;
						}

						var uarray = new Array(length);

						var byte0;
						var byte1;
						var byte2;
						var char0;
						var char1;
						var char2;
						var char3;
						var i = 0;
						var j = 0;

						for (i = 0; i < length; i += 3) {
							// get the 3 octects in 4 ascii chars
							char0 = this.charToByte[input.charAt(j++)];
							char1 = this.charToByte[input.charAt(j++)];
							char2 = this.charToByte[input.charAt(j++)];
							char3 = this.charToByte[input.charAt(j++)];

							byte0 = (char0 << 2) | (char1 >> 4);
							byte1 = ((char1 & 0x0F) << 4) | (char2 >> 2);
							byte2 = ((char2 & 0x03) << 6) | char3;

							uarray[i] = byte0;
							if (char2 != 64) {
								uarray[i + 1] = byte1;
							}
							if (char3 != 64) {
								uarray[i + 2] = byte2;
							}
						}
						return uarray;
					},
					isInstance : function(value, context, scope) {
						return Jsonix.Util.Type.isArray(value);
					},
					CLASS_NAME : 'Jsonix.Schema.XSD.Base64Binary'
				});
Jsonix.Schema.XSD.Base64Binary.INSTANCE = new Jsonix.Schema.XSD.Base64Binary();
Jsonix.Schema.XSD.Base64Binary.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.Base64Binary.INSTANCE);
Jsonix.Schema.XSD.HexBinary = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'HexBinary',
	typeName : Jsonix.Schema.XSD.qname('hexBinary'),
	charToQuartet : {},
	byteToDuplet : [],
	initialize : function() {
		Jsonix.Schema.XSD.AnySimpleType.prototype.initialize.apply(this);
		var charTableUpperCase = "0123456789ABCDEF";
		var charTableLowerCase = charTableUpperCase.toLowerCase();
		var i;
		for (i = 0; i < 16; i++) {
			this.charToQuartet[charTableUpperCase.charAt(i)] = i;
			if (i >= 0xA) {
				this.charToQuartet[charTableLowerCase.charAt(i)] = i;
			}
		}
		for (i = 0; i < 256; i++) {
			this.byteToDuplet[i] =
			//
			charTableUpperCase[i >> 4] + charTableUpperCase[i & 0xF];
		}
	},
	print : function(value, context, output, scope) {
		Jsonix.Util.Ensure.ensureArray(value);
		return this.encode(value);
	},

	parse : function(text, context, input, scope) {
		Jsonix.Util.Ensure.ensureString(text);
		return this.decode(text);
	},
	encode : function(uarray) {
		var output = "";
		for ( var i = 0; i < uarray.length; i++) {
			output = output + this.byteToDuplet[uarray[i] & 0xFF];
		}
		return output;
	},
	decode : function(text) {
		var input = text.replace(/[^A-Fa-f0-9]/g, "");
		// Round by two
		var length = input.length >> 1;
		var uarray = new Array(length);
		for ( var i = 0; i < length; i++) {
			var char0 = input.charAt(2 * i);
			var char1 = input.charAt(2 * i + 1);
			uarray[i] = this.charToQuartet[char0] << 4
					| this.charToQuartet[char1];
		}
		return uarray;
	},
	isInstance : function(value, context, scope) {
		return Jsonix.Util.Type.isArray(value);
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.HexBinary'
});
Jsonix.Schema.XSD.HexBinary.INSTANCE = new Jsonix.Schema.XSD.HexBinary();
Jsonix.Schema.XSD.HexBinary.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.HexBinary.INSTANCE);
Jsonix.Schema.XSD.Number = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'Number',
	typeName : Jsonix.Schema.XSD.qname('number'),
	print : function(value, context, output, scope) {
		Jsonix.Util.Ensure.ensureNumberOrNaN(value);
		if (Jsonix.Util.Type.isNaN(value)) {
			return 'NaN';
		} else if (value === Infinity) {
			return 'INF';
		} else if (value === -Infinity) {
			return '-INF';
		} else {
			var text = String(value);
			return text;
		}
	},
	parse : function(text, context, input, scope) {
		Jsonix.Util.Ensure.ensureString(text);
		if (text === '-INF') {
			return -Infinity;
		} else if (text === 'INF') {
			return Infinity;
		} else if (text === 'NaN') {
			return NaN;
		} else {
			var value = Number(text);
			Jsonix.Util.Ensure.ensureNumber(value);
			return value;
		}
	},
	isInstance : function(value, context, scope) {
		return Jsonix.Util.Type.isNumberOrNaN(value);
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.Number'
});
Jsonix.Schema.XSD.Number.INSTANCE = new Jsonix.Schema.XSD.Number();
Jsonix.Schema.XSD.Number.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Number.INSTANCE);
Jsonix.Schema.XSD.Float = Jsonix.Class(Jsonix.Schema.XSD.Number, {
	name : 'Float',
	typeName : Jsonix.Schema.XSD.qname('float'),
	isInstance : function(value, context, scope) {
		return Jsonix.Util.Type.isNaN(value) || value === -Infinity || value === Infinity || (Jsonix.Util.Type.isNumber(value) && value >= this.MIN_VALUE && value <= this.MAX_VALUE);
	},
	MIN_VALUE : -3.4028235e+38,
	MAX_VALUE : 3.4028235e+38,
	CLASS_NAME : 'Jsonix.Schema.XSD.Float'
});
Jsonix.Schema.XSD.Float.INSTANCE = new Jsonix.Schema.XSD.Float();
Jsonix.Schema.XSD.Float.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Float.INSTANCE);
Jsonix.Schema.XSD.Decimal = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'Decimal',
	typeName : Jsonix.Schema.XSD.qname('decimal'),
	print : function(value, context, output, scope) {
		Jsonix.Util.Ensure.ensureNumber(value);
		var text = String(value);
		return text;
	},
	parse : function(text, context, input, scope) {
		Jsonix.Util.Ensure.ensureString(text);
		var value = Number(text);
		Jsonix.Util.Ensure.ensureNumber(value);
		return value;
	},
	isInstance : function(value, context, scope) {
		return Jsonix.Util.Type.isNumber(value);
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.Decimal'
});
Jsonix.Schema.XSD.Decimal.INSTANCE = new Jsonix.Schema.XSD.Decimal();
Jsonix.Schema.XSD.Decimal.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Decimal.INSTANCE);
Jsonix.Schema.XSD.Integer = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'Integer',
	typeName : Jsonix.Schema.XSD.qname('integer'),
	print : function(value, context, output, scope) {
		Jsonix.Util.Ensure.ensureInteger(value);
		var text = String(value);
		return text;
	},
	parse : function(text, context, input, scope) {
		Jsonix.Util.Ensure.ensureString(text);
		var value = Number(text);
		Jsonix.Util.Ensure.ensureInteger(value);
		return value;
	},
	isInstance : function(value, context, scope) {
		return Jsonix.Util.NumberUtils.isInteger(value) && value >= this.MIN_VALUE && value <= this.MAX_VALUE;
	},
	MIN_VALUE : -9223372036854775808,
	MAX_VALUE : 9223372036854775807,
	CLASS_NAME : 'Jsonix.Schema.XSD.Integer'
});
Jsonix.Schema.XSD.Integer.INSTANCE = new Jsonix.Schema.XSD.Integer();
Jsonix.Schema.XSD.Integer.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Integer.INSTANCE);
Jsonix.Schema.XSD.NonPositiveInteger = Jsonix.Class(Jsonix.Schema.XSD.Integer, {
	name : 'NonPositiveInteger',
	typeName : Jsonix.Schema.XSD.qname('nonPositiveInteger'),
	MIN_VALUE: -9223372036854775808,
	MAX_VALUE: 0,
	CLASS_NAME : 'Jsonix.Schema.XSD.NonPositiveInteger'
});
Jsonix.Schema.XSD.NonPositiveInteger.INSTANCE = new Jsonix.Schema.XSD.NonPositiveInteger();
Jsonix.Schema.XSD.NonPositiveInteger.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.NonPositiveInteger.INSTANCE);
Jsonix.Schema.XSD.NegativeInteger = Jsonix.Class(Jsonix.Schema.XSD.NonPositiveInteger, {
	name : 'NegativeInteger',
	typeName : Jsonix.Schema.XSD.qname('negativeInteger'),
	MIN_VALUE: -9223372036854775808,
	MAX_VALUE: -1,
	CLASS_NAME : 'Jsonix.Schema.XSD.NegativeInteger'
});
Jsonix.Schema.XSD.NegativeInteger.INSTANCE = new Jsonix.Schema.XSD.NegativeInteger();
Jsonix.Schema.XSD.NegativeInteger.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.NegativeInteger.INSTANCE);
Jsonix.Schema.XSD.Long = Jsonix.Class(Jsonix.Schema.XSD.Integer, {
	name : 'Long',
	typeName : Jsonix.Schema.XSD.qname('long'),
	MIN_VALUE : -9223372036854775808,
	MAX_VALUE : 9223372036854775807,
	CLASS_NAME : 'Jsonix.Schema.XSD.Long'
});
Jsonix.Schema.XSD.Long.INSTANCE = new Jsonix.Schema.XSD.Long();
Jsonix.Schema.XSD.Long.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.Long.INSTANCE);
Jsonix.Schema.XSD.Int = Jsonix.Class(Jsonix.Schema.XSD.Long, {
	name : 'Int',
	typeName : Jsonix.Schema.XSD.qname('int'),
	MIN_VALUE : -2147483648,
	MAX_VALUE : 2147483647,
	CLASS_NAME : 'Jsonix.Schema.XSD.Int'
});
Jsonix.Schema.XSD.Int.INSTANCE = new Jsonix.Schema.XSD.Int();
Jsonix.Schema.XSD.Int.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.Int.INSTANCE);
Jsonix.Schema.XSD.Short = Jsonix.Class(Jsonix.Schema.XSD.Int, {
	name : 'Short',
	typeName : Jsonix.Schema.XSD.qname('short'),
	MIN_VALUE : -32768,
	MAX_VALUE : 32767,
	CLASS_NAME : 'Jsonix.Schema.XSD.Short'
});
Jsonix.Schema.XSD.Short.INSTANCE = new Jsonix.Schema.XSD.Short();
Jsonix.Schema.XSD.Short.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Short.INSTANCE);
Jsonix.Schema.XSD.Byte = Jsonix.Class(Jsonix.Schema.XSD.Short, {
	name : 'Byte',
	typeName : Jsonix.Schema.XSD.qname('byte'),
	MIN_VALUE : -128,
	MAX_VALUE : 127,
	CLASS_NAME : 'Jsonix.Schema.XSD.Byte'
});
Jsonix.Schema.XSD.Byte.INSTANCE = new Jsonix.Schema.XSD.Byte();
Jsonix.Schema.XSD.Byte.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Byte.INSTANCE);
Jsonix.Schema.XSD.NonNegativeInteger = Jsonix.Class(Jsonix.Schema.XSD.Integer, {
	name : 'NonNegativeInteger',
	typeName : Jsonix.Schema.XSD.qname('nonNegativeInteger'),
	MIN_VALUE: 0,
	MAX_VALUE: 9223372036854775807,
	CLASS_NAME : 'Jsonix.Schema.XSD.NonNegativeInteger'
});
Jsonix.Schema.XSD.NonNegativeInteger.INSTANCE = new Jsonix.Schema.XSD.NonNegativeInteger();
Jsonix.Schema.XSD.NonNegativeInteger.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.NonNegativeInteger.INSTANCE);
Jsonix.Schema.XSD.UnsignedLong = Jsonix.Class(Jsonix.Schema.XSD.NonNegativeInteger, {
	name : 'UnsignedLong',
	typeName : Jsonix.Schema.XSD.qname('unsignedLong'),
	MIN_VALUE : 0,
	MAX_VALUE : 18446744073709551615,
	CLASS_NAME : 'Jsonix.Schema.XSD.UnsignedLong'
});
Jsonix.Schema.XSD.UnsignedLong.INSTANCE = new Jsonix.Schema.XSD.UnsignedLong();
Jsonix.Schema.XSD.UnsignedLong.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.UnsignedLong.INSTANCE);
Jsonix.Schema.XSD.UnsignedInt = Jsonix.Class(Jsonix.Schema.XSD.UnsignedLong, {
	name : 'UnsignedInt',
	typeName : Jsonix.Schema.XSD.qname('unsignedInt'),
	MIN_VALUE : 0,
	MAX_VALUE : 4294967295,
	CLASS_NAME : 'Jsonix.Schema.XSD.UnsignedInt'
});
Jsonix.Schema.XSD.UnsignedInt.INSTANCE = new Jsonix.Schema.XSD.UnsignedInt();
Jsonix.Schema.XSD.UnsignedInt.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.UnsignedInt.INSTANCE);
Jsonix.Schema.XSD.UnsignedShort = Jsonix.Class(Jsonix.Schema.XSD.UnsignedInt, {
	name : 'UnsignedShort',
	typeName : Jsonix.Schema.XSD.qname('unsignedShort'),
	MIN_VALUE : 0,
	MAX_VALUE : 65535,
	CLASS_NAME : 'Jsonix.Schema.XSD.UnsignedShort'
});
Jsonix.Schema.XSD.UnsignedShort.INSTANCE = new Jsonix.Schema.XSD.UnsignedShort();
Jsonix.Schema.XSD.UnsignedShort.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.UnsignedShort.INSTANCE);
Jsonix.Schema.XSD.UnsignedByte = Jsonix.Class(Jsonix.Schema.XSD.UnsignedShort, {
	name : 'UnsignedByte',
	typeName : Jsonix.Schema.XSD.qname('unsignedByte'),
	MIN_VALUE : 0,
	MAX_VALUE : 255,
	CLASS_NAME : 'Jsonix.Schema.XSD.UnsignedByte'
});
Jsonix.Schema.XSD.UnsignedByte.INSTANCE = new Jsonix.Schema.XSD.UnsignedByte();
Jsonix.Schema.XSD.UnsignedByte.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.UnsignedByte.INSTANCE);
Jsonix.Schema.XSD.PositiveInteger = Jsonix.Class(Jsonix.Schema.XSD.NonNegativeInteger, {
	name : 'PositiveInteger',
	typeName : Jsonix.Schema.XSD.qname('positiveInteger'),
	MIN_VALUE : 1,
	MAX_VALUE : 9223372036854775807,
	CLASS_NAME : 'Jsonix.Schema.XSD.PositiveInteger'
});
Jsonix.Schema.XSD.PositiveInteger.INSTANCE = new Jsonix.Schema.XSD.PositiveInteger();
Jsonix.Schema.XSD.PositiveInteger.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.PositiveInteger.INSTANCE);
Jsonix.Schema.XSD.Double = Jsonix.Class(Jsonix.Schema.XSD.Number, {
	name : 'Double',
	typeName : Jsonix.Schema.XSD.qname('double'),
	isInstance : function(value, context, scope) {
		return Jsonix.Util.Type.isNaN(value) || value === -Infinity || value === Infinity || (Jsonix.Util.Type.isNumber(value) && value >= this.MIN_VALUE && value <= this.MAX_VALUE);
	},
	MIN_VALUE : -1.7976931348623157e+308,
	MAX_VALUE : 1.7976931348623157e+308,
	CLASS_NAME : 'Jsonix.Schema.XSD.Double'
});
Jsonix.Schema.XSD.Double.INSTANCE = new Jsonix.Schema.XSD.Double();
Jsonix.Schema.XSD.Double.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Double.INSTANCE);
Jsonix.Schema.XSD.AnyURI = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'AnyURI',
	typeName : Jsonix.Schema.XSD.qname('anyURI'),
	print : function(value, context, output, scope) {
		Jsonix.Util.Ensure.ensureString(value);
		return value;
	},
	parse : function(text, context, input, scope) {
		Jsonix.Util.Ensure.ensureString(text);
		return text;
	},
	isInstance : function(value, context, scope) {
		return Jsonix.Util.Type.isString(value);
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.AnyURI'
});
Jsonix.Schema.XSD.AnyURI.INSTANCE = new Jsonix.Schema.XSD.AnyURI();
Jsonix.Schema.XSD.AnyURI.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.AnyURI.INSTANCE);
Jsonix.Schema.XSD.QName = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'QName',
	typeName : Jsonix.Schema.XSD.qname('QName'),
	print : function(value, context, output, scope) {
		var qName = Jsonix.XML.QName.fromObject(value);
		var prefix;
		var localPart = qName.localPart;
		if (output) {
			// If QName does not provide the prefix, let it be generated
			prefix = output.getPrefix(qName.namespaceURI, qName.prefix||null);
			output.declareNamespace(qName.namespaceURI, prefix);
		} else {
			prefix = qName.prefix;
		}
		return !prefix ? localPart : (prefix + ':' + localPart);
	},
	parse : function(value, context, input, scope) {
		Jsonix.Util.Ensure.ensureString(value);
		value = Jsonix.Util.StringUtils.trim(value);
		var prefix;
		var localPart;
		var colonPosition = value.indexOf(':');
		if (colonPosition === -1) {
			prefix = '';
			localPart = value;
		} else if (colonPosition > 0 && colonPosition < (value.length - 1)) {
			prefix = value.substring(0, colonPosition);
			localPart = value.substring(colonPosition + 1);
		} else {
			throw new Error('Invalid QName [' + value + '].');
		}
		var namespaceContext = input || context || null;
		if (!namespaceContext)
		{
			return value;
		}
		else
		{
			var namespaceURI = namespaceContext.getNamespaceURI(prefix);
			if (Jsonix.Util.Type.isString(namespaceURI))
			{
				return new Jsonix.XML.QName(namespaceURI, localPart, prefix);
			}
			else
			{
				throw new Error('Prefix [' + prefix + '] of the QName [' + value + '] is not bound in this context.');
			}
		}
	},
	isInstance : function(value, context, scope) {
		return (value instanceof Jsonix.XML.QName) || (Jsonix.Util.Type.isObject(value) && Jsonix.Util.Type.isString(value.localPart || value.lp));
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.QName'
});
Jsonix.Schema.XSD.QName.INSTANCE = new Jsonix.Schema.XSD.QName();
Jsonix.Schema.XSD.QName.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.QName.INSTANCE);
Jsonix.Schema.XSD.Calendar = Jsonix
		.Class(
				Jsonix.Schema.XSD.AnySimpleType,
				{
					name : 'Calendar',
					typeName : Jsonix.Schema.XSD.qname('calendar'),
					parse : function(text, context, input, scope) {
						Jsonix.Util.Ensure.ensureString(text);
						var negative = (text.charAt(0) === '-');
						var sign = negative ? -1 : 1;
						var data = negative ? text.substring(1) : text;

						// Detect pattern

						var result;
						if (data.length >= 19 && data.charAt(4) === '-' && data.charAt(7) === '-' && data.charAt(10) === 'T' && data.charAt(13) === ':' && data.charAt(16) === ':') {
							return this.parseDateTime(text);
						} else if (data.length >= 10 && data.charAt(4) === '-' && data.charAt(7) === '-') {
							return this.parseDate(text);
						} else if (data.length >= 8 && data.charAt(2) === ':' && data.charAt(5) === ':') {
							return this.parseTime(text);
						} else {
							throw new Error('Value [' + text + '] does not match dateTime, date or time patterns.');
						}
					},
					parseDateTime : function(text) {
						Jsonix.Util.Ensure.ensureString(text);
						var negative = (text.charAt(0) === '-');
						var sign = negative ? -1 : 1;

						var dateTimeWithTimeZone = negative ? text.substring(1) : text;

						if (dateTimeWithTimeZone.length < 19 || dateTimeWithTimeZone.charAt(4) !== '-' || dateTimeWithTimeZone.charAt(7) !== '-' || dateTimeWithTimeZone.charAt(10) !== 'T' || dateTimeWithTimeZone.charAt(13) !== ':' || dateTimeWithTimeZone.charAt(16) !== ':') {
							throw new Error('Date time string [' + dateTimeWithTimeZone + '] must be a string in format [\'-\'? yyyy \'-\' mm \'-\' dd \'T\' hh \':\' mm \':\' ss (\'.\' s+)? (zzzzzz)?].');
						}

						var timeZoneIndex;
						var plusIndex = dateTimeWithTimeZone.indexOf('+', 19);
						if (plusIndex >= 0) {
							timeZoneIndex = plusIndex;
						} else {
							var minusIndex = dateTimeWithTimeZone.indexOf('-', 19);
							if (minusIndex >= 0) {
								timeZoneIndex = minusIndex;
							} else {
								var zIndex = dateTimeWithTimeZone.indexOf('Z', 19);
								if (zIndex >= 0) {
									timeZoneIndex = zIndex;
								} else {
									timeZoneIndex = dateTimeWithTimeZone.length;
								}
							}
						}

						var validTimeZoneIndex = timeZoneIndex > 0 && timeZoneIndex < dateTimeWithTimeZone.length;

						var dateString = dateTimeWithTimeZone.substring(0, 10);
						var timeString = validTimeZoneIndex ? dateTimeWithTimeZone.substring(11, timeZoneIndex) : dateTimeWithTimeZone.substring(11);
						var timeZoneString = validTimeZoneIndex ? dateTimeWithTimeZone.substring(timeZoneIndex) : '';
						var date = this.parseDateString(dateString);
						var time = this.parseTimeString(timeString);
						var timezone = this.parseTimeZoneString(timeZoneString);

						return Jsonix.XML.Calendar.fromObject({
							year : sign * date.year,
							month : date.month,
							day : date.day,
							hour : time.hour,
							minute : time.minute,
							second : time.second,
							fractionalSecond : time.fractionalSecond,
							timezone : timezone
						});

					},
					parseDate : function(text) {
						Jsonix.Util.Ensure.ensureString(text);

						var negative = (text.charAt(0) === '-');
						var sign = negative ? -1 : 1;

						var dateWithTimeZone = negative ? text.substring(1) : text;

						var timeZoneIndex;
						var plusIndex = dateWithTimeZone.indexOf('+', 10);
						if (plusIndex >= 0) {
							timeZoneIndex = plusIndex;
						} else {
							var minusIndex = dateWithTimeZone.indexOf('-', 10);
							if (minusIndex >= 0) {
								timeZoneIndex = minusIndex;
							} else {
								var zIndex = dateWithTimeZone.indexOf('Z', 10);
								if (zIndex >= 0) {
									timeZoneIndex = zIndex;
								} else {
									timeZoneIndex = dateWithTimeZone.length;
								}
							}
						}
						var validTimeZoneIndex = timeZoneIndex > 0 && timeZoneIndex < dateWithTimeZone.length;
						var dateString = validTimeZoneIndex ? dateWithTimeZone.substring(0, timeZoneIndex) : dateWithTimeZone;

						var date = this.parseDateString(dateString);
						var timeZoneString = validTimeZoneIndex ? text.substring(timeZoneIndex) : '';
						var timezone = this.parseTimeZoneString(timeZoneString);

						return Jsonix.XML.Calendar.fromObject({
							year : sign * date.year,
							month : date.month,
							day : date.day,
							timezone : timezone
						});

					},
					parseTime : function(text) {
						Jsonix.Util.Ensure.ensureString(text);
						var timeZoneIndex;
						var plusIndex = text.indexOf('+', 7);
						if (plusIndex >= 0) {
							timeZoneIndex = plusIndex;
						} else {
							var minusIndex = text.indexOf('-', 7);
							if (minusIndex >= 0) {
								timeZoneIndex = minusIndex;
							} else {
								var zIndex = text.indexOf('Z', 7);
								if (zIndex >= 0) {
									timeZoneIndex = zIndex;
								} else {
									timeZoneIndex = text.length;
								}
							}
						}

						var validTimeZoneIndex = timeZoneIndex > 0 && timeZoneIndex < text.length;
						var timeString = validTimeZoneIndex ? text.substring(0, timeZoneIndex) : text;

						var time = this.parseTimeString(timeString);
						var timeZoneString = validTimeZoneIndex ? text.substring(timeZoneIndex) : '';
						var timezone = this.parseTimeZoneString(timeZoneString);

						return Jsonix.XML.Calendar.fromObject({
							hour : time.hour,
							minute : time.minute,
							second : time.second,
							fractionalSecond : time.fractionalSecond,
							timezone : timezone
						});

					},
					parseDateString : function(text) {
						Jsonix.Util.Ensure.ensureString(text);
						if (text.length !== 10) {
							throw new Error('Date string [' + text + '] must be 10 characters long.');
						}

						if (text.charAt(4) !== '-' || text.charAt(7) !== '-') {
							throw new Error('Date string [' + text + '] must be a string in format [yyyy \'-\' mm \'-\' ss ].');
						}

						var year = this.parseYear(text.substring(0, 4));
						var month = this.parseMonth(text.substring(5, 7));
						var day = this.parseDay(text.substring(8, 10));

						return {
							year : year,
							month : month,
							day : day
						};
					},
					parseTimeString : function(timeString) {
						Jsonix.Util.Ensure.ensureString(timeString);
						if (timeString.length < 8 || timeString.charAt(2) !== ':' || timeString.charAt(5) !== ':') {
							throw new Error('Time string [' + timeString + '] must be a string in format [hh \':\' mm \':\' ss (\'.\' s+)?].');
						}
						var hourString = timeString.substring(0, 2);
						var minuteString = timeString.substring(3, 5);
						var secondString = timeString.substring(6, 8);
						var fractionalSecondString = timeString.length >= 9 ? timeString.substring(8) : '';
						var hour = this.parseHour(hourString);
						var minute = this.parseHour(minuteString);
						var second = this.parseSecond(secondString);
						var fractionalSecond = this.parseFractionalSecond(fractionalSecondString);
						return {
							hour : hour,
							minute : minute,
							second : second,
							fractionalSecond : fractionalSecond
						};

					},
					parseTimeZoneString : function(text) {
						// (('+' | '-') hh ':' mm) | 'Z'
						Jsonix.Util.Ensure.ensureString(text);
						if (text === '') {
							return NaN;
						} else if (text === 'Z') {
							return 0;
						} else {
							if (text.length !== 6) {
								throw new Error('Time zone must be an empty string, \'Z\' or a string in format [(\'+\' | \'-\') hh \':\' mm].');
							}
							var signString = text.charAt(0);
							var sign;
							if (signString === '+') {
								sign = 1;
							} else if (signString === '-') {
								sign = -1;
							} else {
								throw new Error('First character of the time zone [' + text + '] must be \'+\' or \'-\'.');
							}
							var hour = this.parseHour(text.substring(1, 3));
							var minute = this.parseMinute(text.substring(4, 6));
							return -1 * sign * (hour * 60 + minute);
						}

					},
					parseYear : function(text) {
						Jsonix.Util.Ensure.ensureString(text);
						if (text.length !== 4) {
							throw new Error('Year [' + text + '] must be a four-digit number.');
						}
						var year = Number(text);
						// TODO message
						Jsonix.Util.Ensure.ensureInteger(year);
						return year;
					},
					parseMonth : function(text) {
						Jsonix.Util.Ensure.ensureString(text);
						if (text.length !== 2) {
							throw new Error('Month [' + text + '] must be a two-digit number.');
						}
						var month = Number(text);
						// TODO message
						Jsonix.Util.Ensure.ensureInteger(month);
						return month;
					},
					parseDay : function(text) {
						Jsonix.Util.Ensure.ensureString(text);
						if (text.length !== 2) {
							throw new Error('Day [' + text + '] must be a two-digit number.');
						}
						var day = Number(text);
						// TODO message
						Jsonix.Util.Ensure.ensureInteger(day);
						return day;
					},
					parseHour : function(text) {
						Jsonix.Util.Ensure.ensureString(text);
						if (text.length !== 2) {
							throw new Error('Hour [' + text + '] must be a two-digit number.');
						}
						var hour = Number(text);
						// TODO message
						Jsonix.Util.Ensure.ensureInteger(hour);
						return hour;
					},
					parseMinute : function(text) {
						Jsonix.Util.Ensure.ensureString(text);
						if (text.length !== 2) {
							throw new Error('Minute [' + text + '] must be a two-digit number.');
						}
						var minute = Number(text);
						// TODO message
						Jsonix.Util.Ensure.ensureInteger(minute);
						return minute;
					},
					parseSecond : function(text) {
						Jsonix.Util.Ensure.ensureString(text);
						if (text.length !== 2) {
							throw new Error('Second [' + text + '] must be a two-digit number.');
						}
						var second = Number(text);
						// TODO message
						Jsonix.Util.Ensure.ensureNumber(second);
						return second;
					},
					parseFractionalSecond : function(text) {
						Jsonix.Util.Ensure.ensureString(text);
						if (text === '') {
							return 0;
						} else {
							var fractionalSecond = Number(text);
							// TODO message
							Jsonix.Util.Ensure.ensureNumber(fractionalSecond);
							return fractionalSecond;
						}
					},
					print : function(value, context, output, scope) {
						Jsonix.Util.Ensure.ensureObject(value);
						if (Jsonix.Util.NumberUtils.isInteger(value.year) && Jsonix.Util.NumberUtils.isInteger(value.month) && Jsonix.Util.NumberUtils.isInteger(value.day) && Jsonix.Util.NumberUtils.isInteger(value.hour) && Jsonix.Util.NumberUtils.isInteger(value.minute) && Jsonix.Util.NumberUtils
								.isInteger(value.second)) {
							return this.printDateTime(value);
						} else if (Jsonix.Util.NumberUtils.isInteger(value.year) && Jsonix.Util.NumberUtils.isInteger(value.month) && Jsonix.Util.NumberUtils.isInteger(value.day)) {
							return this.printDate(value);
						} else if (Jsonix.Util.NumberUtils.isInteger(value.hour) && Jsonix.Util.NumberUtils.isInteger(value.minute) && Jsonix.Util.NumberUtils.isInteger(value.second)) {
							return this.printTime(value);
						} else {
							throw new Error('Value [' + value + '] is not recognized as dateTime, date or time.');
						}
					},
					printDateTime : function(value) {
						Jsonix.Util.Ensure.ensureObject(value);
						Jsonix.Util.Ensure.ensureInteger(value.year);
						Jsonix.Util.Ensure.ensureInteger(value.month);
						Jsonix.Util.Ensure.ensureInteger(value.day);
						Jsonix.Util.Ensure.ensureInteger(value.hour);
						Jsonix.Util.Ensure.ensureInteger(value.minute);
						Jsonix.Util.Ensure.ensureNumber(value.second);
						if (Jsonix.Util.Type.exists(value.fractionalString)) {
							Jsonix.Util.Ensure.ensureNumber(value.fractionalString);
						}
						if (Jsonix.Util.Type.exists(value.timezone) && !Jsonix.Util.Type.isNaN(value.timezone)) {
							Jsonix.Util.Ensure.ensureInteger(value.timezone);
						}
						var result = this.printDateString(value);
						result = result + 'T';
						result = result + this.printTimeString(value);
						if (Jsonix.Util.Type.exists(value.timezone)) {
							result = result + this.printTimeZoneString(value.timezone);
						}
						return result;
					},
					printDate : function(value) {
						Jsonix.Util.Ensure.ensureObject(value);
						Jsonix.Util.Ensure.ensureNumber(value.year);
						Jsonix.Util.Ensure.ensureNumber(value.month);
						Jsonix.Util.Ensure.ensureNumber(value.day);
						if (Jsonix.Util.Type.exists(value.timezone) && !Jsonix.Util.Type.isNaN(value.timezone)) {
							Jsonix.Util.Ensure.ensureInteger(value.timezone);
						}
						var result = this.printDateString(value);
						if (Jsonix.Util.Type.exists(value.timezone)) {
							result = result + this.printTimeZoneString(value.timezone);
						}
						return result;
					},
					printTime : function(value) {
						Jsonix.Util.Ensure.ensureObject(value);
						Jsonix.Util.Ensure.ensureNumber(value.hour);
						Jsonix.Util.Ensure.ensureNumber(value.minute);
						Jsonix.Util.Ensure.ensureNumber(value.second);
						if (Jsonix.Util.Type.exists(value.fractionalString)) {
							Jsonix.Util.Ensure.ensureNumber(value.fractionalString);
						}
						if (Jsonix.Util.Type.exists(value.timezone) && !Jsonix.Util.Type.isNaN(value.timezone)) {
							Jsonix.Util.Ensure.ensureInteger(value.timezone);
						}

						var result = this.printTimeString(value);
						if (Jsonix.Util.Type.exists(value.timezone)) {
							result = result + this.printTimeZoneString(value.timezone);
						}
						return result;
					},
					printDateString : function(value) {
						Jsonix.Util.Ensure.ensureObject(value);
						Jsonix.Util.Ensure.ensureInteger(value.year);
						Jsonix.Util.Ensure.ensureInteger(value.month);
						Jsonix.Util.Ensure.ensureInteger(value.day);
						return (value.year < 0 ? ('-' + this.printYear(-value.year)) : this.printYear(value.year)) + '-' + this.printMonth(value.month) + '-' + this.printDay(value.day);
					},
					printTimeString : function(value) {
						Jsonix.Util.Ensure.ensureObject(value);
						Jsonix.Util.Ensure.ensureInteger(value.hour);
						Jsonix.Util.Ensure.ensureInteger(value.minute);
						Jsonix.Util.Ensure.ensureInteger(value.second);
						if (Jsonix.Util.Type.exists(value.fractionalSecond)) {
							Jsonix.Util.Ensure.ensureNumber(value.fractionalSecond);
						}
						var result = this.printHour(value.hour);
						result = result + ':';
						result = result + this.printMinute(value.minute);
						result = result + ':';
						result = result + this.printSecond(value.second);
						if (Jsonix.Util.Type.exists(value.fractionalSecond)) {
							result = result + this.printFractionalSecond(value.fractionalSecond);
						}
						return result;
					},
					printTimeZoneString : function(value) {
						if (!Jsonix.Util.Type.exists(value) || Jsonix.Util.Type.isNaN(value)) {
							return '';
						} else {
							Jsonix.Util.Ensure.ensureInteger(value);

							var sign = value < 0 ? -1 : (value > 0 ? 1 : 0);
							var data = value * sign;
							var minute = data % 60;
							var hour = Math.floor(data / 60);

							var result;
							if (sign === 0) {
								return 'Z';
							} else {
								if (sign > 0) {
									result = '-';
								} else if (sign < 0) {
									result = '+';
								}
								result = result + this.printHour(hour);
								result = result + ':';
								result = result + this.printMinute(minute);
								return result;
							}
						}
					},
					printYear : function(value) {
						return this.printInteger(value, 4);
					},
					printMonth : function(value) {
						return this.printInteger(value, 2);
					},
					printDay : function(value) {
						return this.printInteger(value, 2);
					},
					printHour : function(value) {
						return this.printInteger(value, 2);
					},
					printMinute : function(value) {
						return this.printInteger(value, 2);
					},
					printSecond : function(value) {
						return this.printInteger(value, 2);
					},
					printFractionalSecond : function(value) {
						Jsonix.Util.Ensure.ensureNumber(value);
						if (value < 0 || value >= 1) {
							throw new Error('Fractional second [' + value + '] must be between 0 and 1.');
						} else if (value === 0) {
							return '';
						} else {
							var string = String(value);
							var dotIndex = string.indexOf('.');
							if (dotIndex < 0) {
								return '';
							} else {
								return string.substring(dotIndex);
							}
						}
					},
					printInteger : function(value, length) {
						Jsonix.Util.Ensure.ensureInteger(value);
						Jsonix.Util.Ensure.ensureInteger(length);
						if (length <= 0) {
							throw new Error('Length [' + value + '] must be positive.');
						}
						if (value < 0) {
							throw new Error('Value [' + value + '] must not be negative.');
						}
						if (value >= Math.pow(10, length)) {
							throw new Error('Value [' + value + '] must be less than [' + Math.pow(10, length) + '].');
						}
						var result = String(value);
						for ( var i = result.length; i < length; i++) {
							result = '0' + result;
						}
						return result;
					},
					isInstance : function(value, context, scope) {
						return Jsonix.Util.Type.isObject(value) && ((Jsonix.Util.NumberUtils.isInteger(value.year) && Jsonix.Util.NumberUtils.isInteger(value.month) && Jsonix.Util.NumberUtils.isInteger(value.day)) || (Jsonix.Util.NumberUtils.isInteger(value.hour) && Jsonix.Util.NumberUtils.isInteger(value.minute) && Jsonix.Util.NumberUtils
								.isInteger(value.second)));
					},
					CLASS_NAME : 'Jsonix.Schema.XSD.Calendar'
				});
Jsonix.Schema.XSD.Calendar.INSTANCE = new Jsonix.Schema.XSD.Calendar();
Jsonix.Schema.XSD.Calendar.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Calendar.INSTANCE);
Jsonix.Schema.XSD.Duration = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'Duration',
	typeName : Jsonix.Schema.XSD.qname('duration'),
	CLASS_NAME : 'Jsonix.Schema.XSD.Duration'
});
Jsonix.Schema.XSD.Duration.INSTANCE = new Jsonix.Schema.XSD.Duration();
Jsonix.Schema.XSD.Duration.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.Duration.INSTANCE);
Jsonix.Schema.XSD.DateTime = Jsonix.Class(Jsonix.Schema.XSD.Calendar, {
	name : 'DateTime',
	typeName : Jsonix.Schema.XSD.qname('dateTime'),
	parse : function(value, context, input, scope) {
		var calendar = this.parseDateTime(value);
		var date = new Date();
		date.setFullYear(calendar.year);
		date.setMonth(calendar.month - 1);
		date.setDate(calendar.day);
		date.setHours(calendar.hour);
		date.setMinutes(calendar.minute);
		date.setSeconds(calendar.second);
		if (Jsonix.Util.Type.isNumber(calendar.fractionalSecond)) {
			date.setMilliseconds(Math.floor(1000 * calendar.fractionalSecond));
		}
		var timezoneOffset;
		var unknownTimezone;
		var localTimezoneOffset = date.getTimezoneOffset();
		if (Jsonix.Util.NumberUtils.isInteger(calendar.timezone))
		{
			timezoneOffset = calendar.timezone;
			unknownTimezone = false;
		}
		else
		{
			// Unknown timezone
			timezoneOffset = localTimezoneOffset;
			unknownTimezone = true;
		}
		//
		var result = new Date(date.getTime() + (60000 * (timezoneOffset - localTimezoneOffset)));
		if (unknownTimezone)
		{
			// null denotes "unknown timezone"
			result.originalTimezoneOffset = null;
		}
		else
		{
			result.originalTimezoneOffset = timezoneOffset;
		}
		return result;
	},
	print : function(value, context, output, scope) {
		Jsonix.Util.Ensure.ensureDate(value);
		var timezoneOffset;
		var localTimezoneOffset = value.getTimezoneOffset();
		var correctedValue;
		// If original time zone was unknown, print the given value without
		// the timezone
		if (value.originalTimezoneOffset === null)
		{
			return this.printDateTime(new Jsonix.XML.Calendar({
				year : value.getFullYear(),
				month : value.getMonth() + 1,
				day : value.getDate(),
				hour : value.getHours(),
				minute : value.getMinutes(),
				second : value.getSeconds(),
				fractionalSecond : (value.getMilliseconds() / 1000)
			}));
		}
		else
		{
			// If original timezone was known, correct and print the value with the timezone
			if (Jsonix.Util.NumberUtils.isInteger(value.originalTimezoneOffset))
			{
				timezoneOffset = value.originalTimezoneOffset;
				correctedValue = new Date(value.getTime() - (60000 * (timezoneOffset - localTimezoneOffset)));
			}
			// If original timezone was not specified, do not correct and use the local time zone
			else
			{
				timezoneOffset = localTimezoneOffset;
				correctedValue = value;
			}
			return this.printDateTime(new Jsonix.XML.Calendar({
				year : correctedValue.getFullYear(),
				month : correctedValue.getMonth() + 1,
				day : correctedValue.getDate(),
				hour : correctedValue.getHours(),
				minute : correctedValue.getMinutes(),
				second : correctedValue.getSeconds(),
				fractionalSecond : (correctedValue.getMilliseconds() / 1000),
				timezone: timezoneOffset
			}));
		}
	},
	isInstance : function(value, context, scope) {
		return Jsonix.Util.Type.isDate(value);
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.DateTime'
});
Jsonix.Schema.XSD.DateTime.INSTANCE = new Jsonix.Schema.XSD.DateTime();
Jsonix.Schema.XSD.DateTime.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.DateTime.INSTANCE);

Jsonix.Schema.XSD.Time = Jsonix.Class(Jsonix.Schema.XSD.Calendar, {
	name : 'Time',
	typeName : Jsonix.Schema.XSD.qname('time'),
	parse : function(value, context, input, scope) {
		var calendar = this.parseTime(value);
		var date = new Date();
		date.setFullYear(1970);
		date.setMonth(0);
		date.setDate(1);
		date.setHours(calendar.hour);
		date.setMinutes(calendar.minute);
		date.setSeconds(calendar.second);
		if (Jsonix.Util.Type.isNumber(calendar.fractionalSecond)) {
			date.setMilliseconds(Math.floor(1000 * calendar.fractionalSecond));
		}
		var timezoneOffset;
		var unknownTimezone;
		var localTimezoneOffset = date.getTimezoneOffset();
		if (Jsonix.Util.NumberUtils.isInteger(calendar.timezone))
		{
			timezoneOffset = calendar.timezone;
			unknownTimezone = false;
		}
		else
		{
			// Unknown timezone
			timezoneOffset = localTimezoneOffset;
			unknownTimezone = true;
		}
		//
		var result = new Date(date.getTime() + (60000 * (timezoneOffset - localTimezoneOffset)));
		if (unknownTimezone)
		{
			// null denotes "unknown timezone"
			result.originalTimezoneOffset = null;
		}
		else
		{
			result.originalTimezoneOffset = timezoneOffset;
		}
		return result;
	},
	print : function(value, context, output, scope) {
		Jsonix.Util.Ensure.ensureDate(value);
		var time = value.getTime();
		if (time <= -86400000 && time >= 86400000) {
			throw new Error('Invalid time [' + value + '].');
		}
		// Original timezone was unknown, just use current time, no timezone
		if (value.originalTimezoneOffset === null)
		{
			return this.printTime(new Jsonix.XML.Calendar({
				hour : value.getHours(),
				minute : value.getMinutes(),
				second : value.getSeconds(),
				fractionalSecond : (value.getMilliseconds() / 1000)
			}));
		}
		else
		{
			var correctedValue;
			var timezoneOffset;
			var localTimezoneOffset = value.getTimezoneOffset();
			if (Jsonix.Util.NumberUtils.isInteger(value.originalTimezoneOffset))
			{
				timezoneOffset = value.originalTimezoneOffset;
				correctedValue = new Date(value.getTime() - (60000 * (timezoneOffset - localTimezoneOffset)));
			}
			else
			{
				timezoneOffset = localTimezoneOffset;
				correctedValue = value;
			}
			var correctedTime = correctedValue.getTime();
			if (correctedTime >= 0) {
				return this.printTime(new Jsonix.XML.Calendar({
					hour : correctedValue.getHours(),
					minute : correctedValue.getMinutes(),
					second : correctedValue.getSeconds(),
					fractionalSecond : (correctedValue.getMilliseconds() / 1000),
					timezone: timezoneOffset
				}));
			} else {
				var timezoneOffsetHours = Math.ceil(-correctedTime / 3600000);
				return this.printTime(new Jsonix.XML.Calendar({
					hour : (correctedValue.getHours() + timezoneOffsetHours + timezoneOffset / 60 ) % 24,
					minute : correctedValue.getMinutes(),
					second : correctedValue.getSeconds(),
					fractionalSecond : (correctedValue.getMilliseconds() / 1000),
					timezone : - timezoneOffsetHours * 60
				}));
			}
		}
	},
	isInstance : function(value, context, scope) {
		return Jsonix.Util.Type.isDate(value) && value.getTime() > -86400000 && value.getTime() < 86400000;
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.Time'
});
Jsonix.Schema.XSD.Time.INSTANCE = new Jsonix.Schema.XSD.Time();
Jsonix.Schema.XSD.Time.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Time.INSTANCE);
Jsonix.Schema.XSD.Date = Jsonix.Class(Jsonix.Schema.XSD.Calendar, {
	name : 'Date',
	typeName : Jsonix.Schema.XSD.qname('date'),
	parse : function(value, context, input, scope) {
		var calendar = this.parseDate(value);
		var date = new Date();
		date.setFullYear(calendar.year);
		date.setMonth(calendar.month - 1);
		date.setDate(calendar.day);
		date.setHours(0);
		date.setMinutes(0);
		date.setSeconds(0);
		date.setMilliseconds(0);
		if (Jsonix.Util.Type.isNumber(calendar.fractionalSecond)) {
			date.setMilliseconds(Math.floor(1000 * calendar.fractionalSecond));
		}
		var timezoneOffset;
		var unknownTimezone;
		var localTimezoneOffset = date.getTimezoneOffset();
		if (Jsonix.Util.NumberUtils.isInteger(calendar.timezone))
		{
			timezoneOffset = calendar.timezone;
			unknownTimezone = false;
		}
		else
		{
			// Unknown timezone
			timezoneOffset = localTimezoneOffset;
			unknownTimezone = true;
		}
		//
		var result = new Date(date.getTime() + (60000 * (timezoneOffset - localTimezoneOffset)));
		if (unknownTimezone)
		{
			// null denotes "unknown timezone"
			result.originalTimezoneOffset = null;
		}
		else
		{
			result.originalTimezoneOffset = timezoneOffset;
		}
		return result;
	},
	print : function(value, context, output, scope) {
		Jsonix.Util.Ensure.ensureDate(value);
		var localDate = new Date(value.getTime());
		localDate.setHours(0);
		localDate.setMinutes(0);
		localDate.setSeconds(0);
		localDate.setMilliseconds(0);
		
		// Original timezone is unknown
		if (value.originalTimezoneOffset === null)
		{
			return this.printDate(new Jsonix.XML.Calendar({
				year : value.getFullYear(),
				month : value.getMonth() + 1,
				day : value.getDate()
			}));
		}
		else
		{
			// If original timezone was known, correct and print the value with the timezone
			if (Jsonix.Util.NumberUtils.isInteger(value.originalTimezoneOffset))
			{
				var correctedValue = new Date(value.getTime() - (60000 * (value.originalTimezoneOffset - value.getTimezoneOffset())));
				return this.printDate(new Jsonix.XML.Calendar({
					year : correctedValue.getFullYear(),
					month : correctedValue.getMonth() + 1,
					day : correctedValue.getDate(),
					timezone : value.originalTimezoneOffset
				}));
			}
			// If original timezone was not specified, do not correct and use the local time zone
			else
			{
				// We assume that the difference between the date value and local midnight
				// should be interpreted as a timezone offset.
				// In case there's no difference, we assume default/unknown timezone
				var localTimezoneOffset = value.getTime() - localDate.getTime();
				if (localTimezoneOffset === 0) {
					return this.printDate(new Jsonix.XML.Calendar({
						year : value.getFullYear(),
						month : value.getMonth() + 1,
						day : value.getDate()
					}));
				} else {
					var timezoneOffset = localTimezoneOffset + (60000 * value.getTimezoneOffset());
					if (timezoneOffset <= 43200000) {
						return this.printDate(new Jsonix.XML.Calendar({
							year : value.getFullYear(),
							month : value.getMonth() + 1,
							day : value.getDate(),
							timezone : Math.floor(timezoneOffset / 60000)
						}));
					} else {
						var nextDay = new Date(value.getTime() + 86400000);
						return this.printDate(new Jsonix.XML.Calendar({
							year : nextDay.getFullYear(),
							month : nextDay.getMonth() + 1,
							day : nextDay.getDate(),
							timezone : (Math.floor(timezoneOffset / 60000) - 1440)
						}));
					}
				}
			}
		}
	},
	isInstance : function(value, context, scope) {
		return Jsonix.Util.Type.isDate(value);
	},
	CLASS_NAME : 'Jsonix.Schema.XSD.Date'
});
Jsonix.Schema.XSD.Date.INSTANCE = new Jsonix.Schema.XSD.Date();
Jsonix.Schema.XSD.Date.INSTANCE.LIST = new Jsonix.Schema.XSD.List(Jsonix.Schema.XSD.Date.INSTANCE);
Jsonix.Schema.XSD.GYearMonth = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'GYearMonth',
	typeName : Jsonix.Schema.XSD.qname('gYearMonth'),
	CLASS_NAME : 'Jsonix.Schema.XSD.GYearMonth'
});
Jsonix.Schema.XSD.GYearMonth.INSTANCE = new Jsonix.Schema.XSD.GYearMonth();
Jsonix.Schema.XSD.GYearMonth.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.GYearMonth.INSTANCE);
Jsonix.Schema.XSD.GYear = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'GYear',
	typeName : Jsonix.Schema.XSD.qname('gYear'),
	CLASS_NAME : 'Jsonix.Schema.XSD.GYear'
});
Jsonix.Schema.XSD.GYear.INSTANCE = new Jsonix.Schema.XSD.GYear();
Jsonix.Schema.XSD.GYear.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.GYear.INSTANCE);
Jsonix.Schema.XSD.GMonthDay = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'GMonthDay',
	typeName : Jsonix.Schema.XSD.qname('gMonthDay'),
	CLASS_NAME : 'Jsonix.Schema.XSD.GMonthDay'
});
Jsonix.Schema.XSD.GMonthDay.INSTANCE = new Jsonix.Schema.XSD.GMonthDay();
Jsonix.Schema.XSD.GMonthDay.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.GMonthDay.INSTANCE);
Jsonix.Schema.XSD.GDay = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'GDay',
	typeName : Jsonix.Schema.XSD.qname('gDay'),
	CLASS_NAME : 'Jsonix.Schema.XSD.GDay'
});
Jsonix.Schema.XSD.GDay.INSTANCE = new Jsonix.Schema.XSD.GDay();
Jsonix.Schema.XSD.GDay.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.GDay.INSTANCE);
Jsonix.Schema.XSD.GMonth = Jsonix.Class(Jsonix.Schema.XSD.AnySimpleType, {
	name : 'GMonth',
	typeName : Jsonix.Schema.XSD.qname('gMonth'),
	CLASS_NAME : 'Jsonix.Schema.XSD.GMonth'
});
Jsonix.Schema.XSD.GMonth.INSTANCE = new Jsonix.Schema.XSD.GMonth();
Jsonix.Schema.XSD.GMonth.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.GMonth.INSTANCE);
Jsonix.Schema.XSD.ID = Jsonix.Class(Jsonix.Schema.XSD.String, {
	name : 'ID',
	typeName : Jsonix.Schema.XSD.qname('ID'),
	CLASS_NAME : 'Jsonix.Schema.XSD.ID'
});
Jsonix.Schema.XSD.ID.INSTANCE = new Jsonix.Schema.XSD.ID();
Jsonix.Schema.XSD.ID.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.ID.INSTANCE);
Jsonix.Schema.XSD.IDREF = Jsonix.Class(Jsonix.Schema.XSD.String, {
	name : 'IDREF',
	typeName : Jsonix.Schema.XSD.qname('IDREF'),
	CLASS_NAME : 'Jsonix.Schema.XSD.IDREF'
});
Jsonix.Schema.XSD.IDREF.INSTANCE = new Jsonix.Schema.XSD.IDREF();
Jsonix.Schema.XSD.IDREF.INSTANCE.LIST = new Jsonix.Schema.XSD.List(
		Jsonix.Schema.XSD.IDREF.INSTANCE);
Jsonix.Schema.XSD.IDREFS = Jsonix.Class(Jsonix.Schema.XSD.List, {
	name : 'IDREFS',
	initialize : function() {
		Jsonix.Schema.XSD.List.prototype.initialize.apply(this, [ Jsonix.Schema.XSD.IDREF.INSTANCE, Jsonix.Schema.XSD.qname('IDREFS'), ' ' ]);
	},
	// TODO Constraints
	CLASS_NAME : 'Jsonix.Schema.XSD.IDREFS'
});
Jsonix.Schema.XSD.IDREFS.INSTANCE = new Jsonix.Schema.XSD.IDREFS();
Jsonix.Context = Jsonix
		.Class({
			modules : [],
			typeInfos : null,
			elementInfos : null,
			properties : null,
			substitutionMembersMap : null,
			scopedElementInfosMap : null,
			initialize : function(mappings, properties) {
				this.modules = [];
				this.elementInfos = [];
				this.typeInfos = {};
				this.registerBuiltinTypeInfos();
				this.properties = {
					namespacePrefixes : {}
				};
				this.substitutionMembersMap = {};
				this.scopedElementInfosMap = {};


				// Initialize properties
				if (Jsonix.Util.Type.exists(properties)) {
					Jsonix.Util.Ensure.ensureObject(properties);
					if (Jsonix.Util.Type
							.isObject(properties.namespacePrefixes)) {
						this.properties.namespacePrefixes = 
							Jsonix.Util.Type.cloneObject(properties.namespacePrefixes, {});
					}
				}
				// Initialize modules
				if (Jsonix.Util.Type.exists(mappings)) {
					Jsonix.Util.Ensure.ensureArray(mappings);
					// Initialize modules
					var index, mapping, module;
					for (index = 0; index < mappings.length; index++) {
						mapping = mappings[index];
						module = this.createModule(mapping);
						this.modules[index] = module;
					}
				}
				this.processModules();
			},
			createModule : function(mapping) {
				var module;
				if (mapping instanceof Jsonix.Model.Module) {
					module = mapping;
				} else {
					module = new Jsonix.Model.Module(mapping);
				}
				return module;
			},
			registerBuiltinTypeInfos : function() {
				for ( var index = 0; index < this.builtinTypeInfos.length; index++) {
					this.registerTypeInfo(this.builtinTypeInfos[index]);
				}
			},
			processModules : function() {
				var index, module;
				for (index = 0; index < this.modules.length; index++) {
					module = this.modules[index];
					module.registerTypeInfos(this);
				}
				for (index = 0; index < this.modules.length; index++) {
					module = this.modules[index];
					module.buildTypeInfos(this);
				}
				for (index = 0; index < this.modules.length; index++) {
					module = this.modules[index];
					module.registerElementInfos(this);
				}
				for (index = 0; index < this.modules.length; index++) {
					module = this.modules[index];
					module.buildElementInfos(this);
				}
			},
			registerTypeInfo : function(typeInfo) {
				Jsonix.Util.Ensure.ensureObject(typeInfo);
				var n = typeInfo.name||typeInfo.n||null;
				Jsonix.Util.Ensure.ensureString(n);
				this.typeInfos[n] = typeInfo;
			},
			resolveTypeInfo : function(mapping, module) {
				if (!Jsonix.Util.Type.exists(mapping)) {
					return null;
				} else if (mapping instanceof Jsonix.Model.TypeInfo) {
					return mapping;
				} else if (Jsonix.Util.Type.isString(mapping)) {
					var typeInfoName;
					// If mapping starts with '.' consider it to be a local type name in this module
					if (mapping.length > 0 && mapping.charAt(0) === '.')
					{
						var n = module.name || module.n || undefined;
						Jsonix.Util.Ensure.ensureObject(module, 'Type info mapping can only be resolved if module is provided.');
						Jsonix.Util.Ensure.ensureString(n, 'Type info mapping can only be resolved if module name is provided.');
						typeInfoName = n + mapping;
					}
					else
					{
						typeInfoName = mapping;
					}
					if (!this.typeInfos[typeInfoName]) {
						throw new Error('Type info [' + typeInfoName + '] is not known in this context.');
					} else {
						return this.typeInfos[typeInfoName];
					}
				} else {
					Jsonix.Util.Ensure.ensureObject(module, 'Type info mapping can only be resolved if module is provided.');
					var typeInfo = module.createTypeInfo(mapping);
					typeInfo.build(this, module);
					return typeInfo;
				}
			},
			registerElementInfo : function(elementInfo, module) {
				Jsonix.Util.Ensure.ensureObject(elementInfo);
				this.elementInfos.push(elementInfo);

				if (Jsonix.Util.Type.exists(elementInfo.substitutionHead)) {
					var substitutionHead = elementInfo.substitutionHead;
					var substitutionHeadKey = substitutionHead.key;
					var substitutionMembers = this.substitutionMembersMap[substitutionHeadKey];

					if (!Jsonix.Util.Type.isArray(substitutionMembers)) {
						substitutionMembers = [];
						this.substitutionMembersMap[substitutionHeadKey] = substitutionMembers;
					}
					substitutionMembers.push(elementInfo);
				}

				var scopeKey;
				if (Jsonix.Util.Type.exists(elementInfo.scope)) {
					scopeKey = this.resolveTypeInfo(elementInfo.scope, module).name;
				} else {
					scopeKey = '##global';
				}

				var scopedElementInfos = this.scopedElementInfosMap[scopeKey];

				if (!Jsonix.Util.Type.isObject(scopedElementInfos)) {
					scopedElementInfos = {};
					this.scopedElementInfosMap[scopeKey] = scopedElementInfos;
				}
				scopedElementInfos[elementInfo.elementName.key] = elementInfo;

			},
			getElementInfo : function(name, scope) {
				if (Jsonix.Util.Type.exists(scope)) {
					var scopeKey = scope.name;
					var scopedElementInfos = this.scopedElementInfosMap[scopeKey];
					if (Jsonix.Util.Type.exists(scopedElementInfos)) {
						var scopedElementInfo = scopedElementInfos[name.key];
						if (Jsonix.Util.Type.exists(scopedElementInfo)) {
							return scopedElementInfo;
						}
					}
				}

				var globalScopeKey = '##global';
				var globalScopedElementInfos = this.scopedElementInfosMap[globalScopeKey];
				if (Jsonix.Util.Type.exists(globalScopedElementInfos)) {
					var globalScopedElementInfo = globalScopedElementInfos[name.key];
					if (Jsonix.Util.Type.exists(globalScopedElementInfo)) {
						return globalScopedElementInfo;
					}
				}
				return null;
				//
				// throw new Error("Element [" + name.key
				// + "] could not be found in the given context.");
			},
			getSubstitutionMembers : function(name) {
				return this.substitutionMembersMap[Jsonix.XML.QName
						.fromObject(name).key];
			},
			createMarshaller : function() {
				return new Jsonix.Context.Marshaller(this);
			},
			createUnmarshaller : function() {
				return new Jsonix.Context.Unmarshaller(this);
			},
			getNamespaceURI : function(prefix) {
				Jsonix.Util.Ensure.ensureString(prefix);
				return this.properties.namespacePrefixes[prefix];
			},
			/**
			 * Builtin type infos.
			 */
			builtinTypeInfos : [
			        Jsonix.Schema.XSD.AnyType.INSTANCE,
					Jsonix.Schema.XSD.AnyURI.INSTANCE,
					Jsonix.Schema.XSD.Base64Binary.INSTANCE,
					Jsonix.Schema.XSD.Boolean.INSTANCE,
					Jsonix.Schema.XSD.Byte.INSTANCE,
					Jsonix.Schema.XSD.Calendar.INSTANCE,
					Jsonix.Schema.XSD.Date.INSTANCE,
					Jsonix.Schema.XSD.DateTime.INSTANCE,
					Jsonix.Schema.XSD.Decimal.INSTANCE,
					Jsonix.Schema.XSD.Double.INSTANCE,
					Jsonix.Schema.XSD.Duration.INSTANCE,
					Jsonix.Schema.XSD.Float.INSTANCE,
					Jsonix.Schema.XSD.GDay.INSTANCE,
					Jsonix.Schema.XSD.GMonth.INSTANCE,
					Jsonix.Schema.XSD.GMonthDay.INSTANCE,
					Jsonix.Schema.XSD.GYear.INSTANCE,
					Jsonix.Schema.XSD.GYearMonth.INSTANCE,
					Jsonix.Schema.XSD.HexBinary.INSTANCE,
					Jsonix.Schema.XSD.ID.INSTANCE,
					Jsonix.Schema.XSD.IDREF.INSTANCE,
					Jsonix.Schema.XSD.IDREFS.INSTANCE,
					Jsonix.Schema.XSD.Int.INSTANCE,
					Jsonix.Schema.XSD.Integer.INSTANCE,
					Jsonix.Schema.XSD.Language.INSTANCE,
					Jsonix.Schema.XSD.Long.INSTANCE,
					Jsonix.Schema.XSD.Name.INSTANCE,
					Jsonix.Schema.XSD.NCName.INSTANCE,
					Jsonix.Schema.XSD.NegativeInteger.INSTANCE,
					Jsonix.Schema.XSD.NMToken.INSTANCE,
					Jsonix.Schema.XSD.NMTokens.INSTANCE,
					Jsonix.Schema.XSD.NonNegativeInteger.INSTANCE,
					Jsonix.Schema.XSD.NonPositiveInteger.INSTANCE,
					Jsonix.Schema.XSD.NormalizedString.INSTANCE,
					Jsonix.Schema.XSD.Number.INSTANCE,
					Jsonix.Schema.XSD.PositiveInteger.INSTANCE,
					Jsonix.Schema.XSD.QName.INSTANCE,
					Jsonix.Schema.XSD.Short.INSTANCE,
					Jsonix.Schema.XSD.String.INSTANCE,
					Jsonix.Schema.XSD.Strings.INSTANCE,
					Jsonix.Schema.XSD.Time.INSTANCE,
					Jsonix.Schema.XSD.Token.INSTANCE,
					Jsonix.Schema.XSD.UnsignedByte.INSTANCE,
					Jsonix.Schema.XSD.UnsignedInt.INSTANCE,
					Jsonix.Schema.XSD.UnsignedLong.INSTANCE,
					Jsonix.Schema.XSD.UnsignedShort.INSTANCE ],
			CLASS_NAME : 'Jsonix.Context'
		});
Jsonix.Context.Marshaller = Jsonix.Class({
	context : null,
	initialize : function(context) {
		Jsonix.Util.Ensure.ensureObject(context);
		this.context = context;
	},
	marshalString : function(value) {
		var doc = this.marshalDocument(value);
		var text = Jsonix.DOM.serialize(doc);
		return text;
	},
	marshalDocument : function(value) {
		var output = new Jsonix.XML.Output({
			namespacePrefixes : this.context.properties.namespacePrefixes
		});

		var doc = output.writeStartDocument();

		this.marshalElementNode(value, output);

		output.writeEndDocument();

		return doc;

	},
	marshalElementNode : function(value, output, scope) {

		Jsonix.Util.Ensure.ensureObject(value);
		Jsonix.Util.Ensure.ensureObject(value.name);
		Jsonix.Util.Ensure.ensureExists(value.value);

		var name = Jsonix.XML.QName.fromObject(value.name);

		var elementDeclaration = this.context.getElementInfo(name, scope);
		if (!Jsonix.Util.Type.exists(elementDeclaration)) {
			throw new Error("Could not find element declaration for the element [" + name.key + "].");
		}
		Jsonix.Util.Ensure.ensureObject(elementDeclaration.typeInfo);
		var typeInfo = elementDeclaration.typeInfo;
		var element = output.writeStartElement(value.name);
		var adapter = Jsonix.Model.Adapter.getAdapter(elementDeclaration);
		adapter.marshal(typeInfo, value.value, this.context, output, scope);
		output.writeEndElement();
		return element;

	},
	CLASS_NAME : 'Jsonix.Context.Marshaller'
});
Jsonix.Context.Unmarshaller = Jsonix.Class({
	context : null,
	initialize : function(context) {
		Jsonix.Util.Ensure.ensureObject(context);
		this.context = context;
	},
	unmarshalString : function(text) {
		Jsonix.Util.Ensure.ensureString(text);
		var doc = Jsonix.DOM.parse(text);
		return this.unmarshalDocument(doc);
	},
	unmarshalURL : function(url, callback, options) {
		Jsonix.Util.Ensure.ensureString(url);
		Jsonix.Util.Ensure.ensureFunction(callback);
		if (Jsonix.Util.Type.exists(options)) {
			Jsonix.Util.Ensure.ensureObject(options);
		}
		that = this;
		Jsonix.DOM.load(url, function(doc) {
			callback(that.unmarshalDocument(doc));
		}, options);
	},
	unmarshalFile : function(fileName, callback, options) {
		if (typeof _jsonix_fs === 'undefined')
		{
			throw new Error("File unmarshalling is only available in environments which support file systems.");
		}
		Jsonix.Util.Ensure.ensureString(fileName);
		Jsonix.Util.Ensure.ensureFunction(callback);
		if (Jsonix.Util.Type.exists(options)) {
			Jsonix.Util.Ensure.ensureObject(options);
		}
		that = this;
		var fs =_jsonix_fs;
		fs.readFile(fileName, options, function(err, data) {
			if (err)
			{
				throw err;
			}
			else
			{
				var text = data.toString();
				var doc = Jsonix.DOM.parse(text);
				callback(that.unmarshalDocument(doc));
			}
		});
	},
	unmarshalDocument : function(doc) {
		var input = new Jsonix.XML.Input(doc);

		var result = null;
		input.nextTag();
		return this.unmarshalElementNode(input);

	},
	unmarshalElementNode : function(input, scope) {
		if (input.eventType != 1) {
			throw new Error("Parser must be on START_ELEMENT to read next text.");
		}

		var result = null;
		var name = Jsonix.XML.QName.fromObject(input.getName());

		var elementDeclaration = this.context.getElementInfo(name, scope);
		if (!Jsonix.Util.Type.exists(elementDeclaration)) {
			throw new Error("Could not find element declaration for the element [" + name.key + "].");
		}
		Jsonix.Util.Ensure.ensureObject(elementDeclaration.typeInfo);
		var typeInfo = elementDeclaration.typeInfo;
		var adapter = Jsonix.Model.Adapter.getAdapter(elementDeclaration);
		var value = adapter.unmarshal(typeInfo, this.context, input, scope);
		result = {
			name : name,
			value : value
		};

		return result;

	},
	CLASS_NAME : 'Jsonix.Context.Unmarshaller'
});
	// Complete Jsonix script is included above
	return { Jsonix: Jsonix };
};

// If the require function exists ...
if (typeof require === 'function') {
	// ... but the define function does not exists
	if (typeof define !== 'function') {
		// Load the define function via amdefine
		var define = require('amdefine')(module);
		// If we're not in browser
		if (typeof window === 'undefined')
		{
			// Require xmldom, xmlhttprequest and fs
			define(["xmldom", "xmlhttprequest", "fs"], _jsonix_factory);
		}
		else
		{
			// We're probably in browser, maybe browserify
			// Do not require xmldom, xmlhttprequest as they'r provided by the browser
			// Do not require fs since file system is not available anyway
			define([], _jsonix_factory);
		}
	}
	else {
		// Otherwise assume we're in the browser/RequireJS environment
		// Load the module without xmldom and xmlhttprequests dependencies
		define([], _jsonix_factory);
	}
}
// If the require function does not exists, we're not in Node.js and therefore in browser environment
else
{
	// Just call the factory and set Jsonix as global.
	var Jsonix = _jsonix_factory().Jsonix;
}

},{"amdefine":19}],3:[function(require,module,exports){
var Filter_1_0_0_Module_Factory = function () {
  var Filter_1_0_0 = {
    n: 'Filter_1_0_0',
    dens: 'http:\/\/www.opengis.net\/ogc',
    deps: ['GML_2_1_2'],
    tis: [{
        ln: 'PropertyNameType',
        bti: '.ExpressionType',
        ps: [{
            n: 'content',
            col: true,
            dom: false,
            t: 'ae'
          }]
      }, {
        ln: 'SpatialOperatorsType.Intersect',
        tn: null
      }, {
        ln: 'UpperBoundaryType',
        ps: [{
            n: 'expression',
            rq: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }]
      }, {
        ln: 'SpatialOperatorsType.Crosses',
        tn: null
      }, {
        ln: 'SimpleComparisons',
        tn: null
      }, {
        ln: 'SpatialOperatorsType.Within',
        tn: null
      }, {
        ln: 'ExpressionType'
      }, {
        ln: 'SpatialOperatorsType.Equals',
        tn: null
      }, {
        ln: 'SimpleArithmetic',
        tn: null
      }, {
        ln: 'SortPropertyType',
        ps: [{
            n: 'propertyName',
            rq: true,
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }, {
            n: 'sortOrder',
            en: 'SortOrder'
          }]
      }, {
        ln: 'SpatialOpsType'
      }, {
        ln: 'LiteralType',
        bti: '.ExpressionType',
        ps: [{
            n: 'content',
            col: true,
            dom: false,
            t: 'ae'
          }]
      }, {
        ln: 'DistanceType',
        ps: [{
            n: 'content',
            t: 'v'
          }, {
            n: 'units',
            rq: true,
            an: {
              lp: 'units'
            },
            t: 'a'
          }]
      }, {
        ln: 'FunctionType',
        bti: '.ExpressionType',
        ps: [{
            n: 'expression',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }, {
            n: 'name',
            rq: true,
            an: {
              lp: 'name'
            },
            t: 'a'
          }]
      }, {
        ln: 'BinaryOperatorType',
        bti: '.ExpressionType',
        ps: [{
            n: 'expression',
            rq: true,
            mno: 2,
            mxo: 2,
            col: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }]
      }, {
        ln: 'ComparisonOperatorsType',
        tn: 'Comparison_OperatorsType',
        ps: [{
            n: 'simpleComparisonsOrLikeOrBetween',
            rq: true,
            col: true,
            etis: [{
                en: 'Simple_Comparisons',
                ti: '.SimpleComparisons'
              }, {
                en: 'Like',
                ti: '.Like'
              }, {
                en: 'Between',
                ti: '.Between'
              }, {
                en: 'NullCheck',
                ti: '.NullCheck'
              }],
            t: 'es'
          }]
      }, {
        ln: 'SortByType',
        ps: [{
            n: 'sortProperty',
            rq: true,
            col: true,
            en: 'SortProperty',
            ti: '.SortPropertyType'
          }]
      }, {
        ln: 'SpatialOperatorsType.Overlaps',
        tn: null
      }, {
        ln: 'ArithmeticOperatorsType',
        tn: 'Arithmetic_OperatorsType',
        ps: [{
            n: 'simpleArithmeticOrFunctions',
            rq: true,
            col: true,
            etis: [{
                en: 'Simple_Arithmetic',
                ti: '.SimpleArithmetic'
              }, {
                en: 'Functions',
                ti: '.FunctionsType'
              }],
            t: 'es'
          }]
      }, {
        ln: 'BinaryLogicOpType',
        bti: '.LogicOpsType',
        ps: [{
            n: 'ops',
            rq: true,
            mno: 2,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'spatialOps',
                ti: '.SpatialOpsType'
              }, {
                en: 'comparisonOps',
                ti: '.ComparisonOpsType'
              }, {
                en: 'logicOps',
                ti: '.LogicOpsType'
              }],
            t: 'ers'
          }]
      }, {
        ln: 'FunctionNamesType',
        tn: 'Function_NamesType',
        ps: [{
            n: 'functionName',
            rq: true,
            col: true,
            en: 'Function_Name',
            ti: '.FunctionNameType'
          }]
      }, {
        ln: 'LogicalOperators',
        tn: null
      }, {
        ln: 'PropertyIsNullType',
        bti: '.ComparisonOpsType',
        ps: [{
            n: 'propertyName',
            rq: true,
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }, {
            n: 'literal',
            rq: true,
            en: 'Literal',
            ti: '.LiteralType'
          }]
      }, {
        ln: 'PropertyIsBetweenType',
        bti: '.ComparisonOpsType',
        ps: [{
            n: 'expression',
            rq: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }, {
            n: 'lowerBoundary',
            rq: true,
            en: 'LowerBoundary',
            ti: '.LowerBoundaryType'
          }, {
            n: 'upperBoundary',
            rq: true,
            en: 'UpperBoundary',
            ti: '.UpperBoundaryType'
          }]
      }, {
        ln: 'FilterType',
        ps: [{
            n: 'spatialOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.SpatialOpsType',
            t: 'er'
          }, {
            n: 'comparisonOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.ComparisonOpsType',
            t: 'er'
          }, {
            n: 'logicOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.LogicOpsType',
            t: 'er'
          }, {
            n: 'featureId',
            rq: true,
            col: true,
            en: 'FeatureId',
            ti: '.FeatureIdType'
          }]
      }, {
        ln: 'BinaryComparisonOpType',
        bti: '.ComparisonOpsType',
        ps: [{
            n: 'expression',
            rq: true,
            mno: 2,
            mxo: 2,
            col: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }]
      }, {
        ln: 'LogicOpsType'
      }, {
        ln: 'Between',
        tn: null
      }, {
        ln: 'SpatialOperatorsType.Touches',
        tn: null
      }, {
        ln: 'SpatialOperatorsType.DWithin',
        tn: null
      }, {
        ln: 'FunctionsType',
        ps: [{
            n: 'functionNames',
            rq: true,
            en: 'Function_Names',
            ti: '.FunctionNamesType'
          }]
      }, {
        ln: 'FunctionNameType',
        tn: 'Function_NameType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'nArgs',
            rq: true,
            an: {
              lp: 'nArgs'
            },
            t: 'a'
          }]
      }, {
        ln: 'FilterCapabilities',
        tn: null,
        ps: [{
            n: 'spatialCapabilities',
            rq: true,
            en: 'Spatial_Capabilities',
            ti: '.SpatialCapabilitiesType'
          }, {
            n: 'scalarCapabilities',
            rq: true,
            en: 'Scalar_Capabilities',
            ti: '.ScalarCapabilitiesType'
          }]
      }, {
        ln: 'UnaryLogicOpType',
        bti: '.LogicOpsType',
        ps: [{
            n: 'comparisonOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.ComparisonOpsType',
            t: 'er'
          }, {
            n: 'spatialOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.SpatialOpsType',
            t: 'er'
          }, {
            n: 'logicOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.LogicOpsType',
            t: 'er'
          }]
      }, {
        ln: 'ScalarCapabilitiesType',
        tn: 'Scalar_CapabilitiesType',
        ps: [{
            n: 'logicalOperatorsOrComparisonOperatorsOrArithmeticOperators',
            rq: true,
            col: true,
            etis: [{
                en: 'Logical_Operators',
                ti: '.LogicalOperators'
              }, {
                en: 'Comparison_Operators',
                ti: '.ComparisonOperatorsType'
              }, {
                en: 'Arithmetic_Operators',
                ti: '.ArithmeticOperatorsType'
              }],
            t: 'es'
          }]
      }, {
        ln: 'Like',
        tn: null
      }, {
        ln: 'SpatialCapabilitiesType',
        tn: 'Spatial_CapabilitiesType',
        ps: [{
            n: 'spatialOperators',
            rq: true,
            en: 'Spatial_Operators',
            ti: '.SpatialOperatorsType'
          }]
      }, {
        ln: 'FeatureIdType',
        ps: [{
            n: 'fid',
            rq: true,
            an: {
              lp: 'fid'
            },
            t: 'a'
          }]
      }, {
        ln: 'SpatialOperatorsType.BBOX',
        tn: null
      }, {
        ln: 'SpatialOperatorsType.Disjoint',
        tn: null
      }, {
        ln: 'SpatialOperatorsType.Beyond',
        tn: null
      }, {
        ln: 'ComparisonOpsType'
      }, {
        ln: 'BBOXType',
        bti: '.SpatialOpsType',
        ps: [{
            n: 'propertyName',
            rq: true,
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }, {
            n: 'box',
            rq: true,
            en: {
              lp: 'Box',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            ti: 'GML_2_1_2.BoxType'
          }]
      }, {
        ln: 'NullCheck',
        tn: null
      }, {
        ln: 'LowerBoundaryType',
        ps: [{
            n: 'expression',
            rq: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }]
      }, {
        ln: 'DistanceBufferType',
        bti: '.SpatialOpsType',
        ps: [{
            n: 'propertyName',
            rq: true,
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }, {
            n: 'geometry',
            rq: true,
            mx: false,
            dom: false,
            en: {
              lp: '_Geometry',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            ti: 'GML_2_1_2.AbstractGeometryType',
            t: 'er'
          }, {
            n: 'distance',
            rq: true,
            en: 'Distance',
            ti: '.DistanceType'
          }]
      }, {
        ln: 'PropertyIsLikeType',
        bti: '.ComparisonOpsType',
        ps: [{
            n: 'propertyName',
            rq: true,
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }, {
            n: 'literal',
            rq: true,
            en: 'Literal',
            ti: '.LiteralType'
          }, {
            n: 'wildCard',
            rq: true,
            an: {
              lp: 'wildCard'
            },
            t: 'a'
          }, {
            n: 'singleChar',
            rq: true,
            an: {
              lp: 'singleChar'
            },
            t: 'a'
          }, {
            n: 'escape',
            rq: true,
            an: {
              lp: 'escape'
            },
            t: 'a'
          }]
      }, {
        ln: 'SpatialOperatorsType',
        tn: 'Spatial_OperatorsType',
        ps: [{
            n: 'bboxOrEqualsOrDisjoint',
            rq: true,
            col: true,
            etis: [{
                en: 'BBOX',
                ti: '.SpatialOperatorsType.BBOX'
              }, {
                en: 'Equals',
                ti: '.SpatialOperatorsType.Equals'
              }, {
                en: 'Disjoint',
                ti: '.SpatialOperatorsType.Disjoint'
              }, {
                en: 'Intersect',
                ti: '.SpatialOperatorsType.Intersect'
              }, {
                en: 'Touches',
                ti: '.SpatialOperatorsType.Touches'
              }, {
                en: 'Crosses',
                ti: '.SpatialOperatorsType.Crosses'
              }, {
                en: 'Within',
                ti: '.SpatialOperatorsType.Within'
              }, {
                en: 'Contains',
                ti: '.SpatialOperatorsType.Contains'
              }, {
                en: 'Overlaps',
                ti: '.SpatialOperatorsType.Overlaps'
              }, {
                en: 'Beyond',
                ti: '.SpatialOperatorsType.Beyond'
              }, {
                en: 'DWithin',
                ti: '.SpatialOperatorsType.DWithin'
              }],
            t: 'es'
          }]
      }, {
        ln: 'SpatialOperatorsType.Contains',
        tn: null
      }, {
        ln: 'BinarySpatialOpType',
        bti: '.SpatialOpsType',
        ps: [{
            n: 'propertyName',
            rq: true,
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }, {
            n: 'geometry',
            rq: true,
            mx: false,
            dom: false,
            en: {
              lp: '_Geometry',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            ti: 'GML_2_1_2.AbstractGeometryType',
            t: 'er'
          }, {
            n: 'box',
            rq: true,
            en: {
              lp: 'Box',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            ti: 'GML_2_1_2.BoxType'
          }]
      }, {
        t: 'enum',
        ln: 'SortOrderType',
        vs: ['DESC', 'ASC']
      }],
    eis: [{
        en: 'Div',
        ti: '.BinaryOperatorType',
        sh: 'expression'
      }, {
        en: 'comparisonOps',
        ti: '.ComparisonOpsType'
      }, {
        en: 'Simple_Comparisons',
        ti: '.SimpleComparisons'
      }, {
        en: 'PropertyIsLike',
        ti: '.PropertyIsLikeType',
        sh: 'comparisonOps'
      }, {
        en: 'Disjoint',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'Filter',
        ti: '.FilterType'
      }, {
        en: 'expression',
        ti: '.ExpressionType'
      }, {
        en: 'Beyond',
        ti: '.DistanceBufferType',
        sh: 'spatialOps'
      }, {
        en: 'BBOX',
        ti: '.BBOXType',
        sh: 'spatialOps'
      }, {
        en: 'Function',
        ti: '.FunctionType',
        sh: 'expression'
      }, {
        en: 'Overlaps',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'Mul',
        ti: '.BinaryOperatorType',
        sh: 'expression'
      }, {
        en: 'Sub',
        ti: '.BinaryOperatorType',
        sh: 'expression'
      }, {
        en: 'PropertyIsGreaterThanOrEqualTo',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'NullCheck',
        ti: '.NullCheck'
      }, {
        en: 'Literal',
        ti: '.LiteralType',
        sh: 'expression'
      }, {
        en: 'DWithin',
        ti: '.DistanceBufferType',
        sh: 'spatialOps'
      }, {
        en: 'Logical_Operators',
        ti: '.LogicalOperators'
      }, {
        en: 'FeatureId',
        ti: '.FeatureIdType'
      }, {
        en: 'PropertyIsEqualTo',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'SortBy',
        ti: '.SortByType'
      }, {
        en: 'Intersects',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'Add',
        ti: '.BinaryOperatorType',
        sh: 'expression'
      }, {
        en: 'PropertyIsGreaterThan',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'Like',
        ti: '.Like'
      }, {
        en: 'And',
        ti: '.BinaryLogicOpType',
        sh: 'logicOps'
      }, {
        en: 'PropertyIsBetween',
        ti: '.PropertyIsBetweenType',
        sh: 'comparisonOps'
      }, {
        en: 'Contains',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'PropertyIsLessThan',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'Filter_Capabilities',
        ti: '.FilterCapabilities'
      }, {
        en: 'Simple_Arithmetic',
        ti: '.SimpleArithmetic'
      }, {
        en: 'Or',
        ti: '.BinaryLogicOpType',
        sh: 'logicOps'
      }, {
        en: 'Equals',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'PropertyIsLessThanOrEqualTo',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'PropertyIsNotEqualTo',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'Not',
        ti: '.UnaryLogicOpType',
        sh: 'logicOps'
      }, {
        en: 'Crosses',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'PropertyIsNull',
        ti: '.PropertyIsNullType',
        sh: 'comparisonOps'
      }, {
        en: 'logicOps',
        ti: '.LogicOpsType'
      }, {
        en: 'Touches',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'Within',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'PropertyName',
        ti: '.PropertyNameType',
        sh: 'expression'
      }, {
        en: 'spatialOps',
        ti: '.SpatialOpsType'
      }, {
        en: 'Between',
        ti: '.Between'
      }]
  };
  return {
    Filter_1_0_0: Filter_1_0_0
  };
};
if (typeof define === 'function' && define.amd) {
  define([], Filter_1_0_0_Module_Factory);
}
else {
  var Filter_1_0_0_Module = Filter_1_0_0_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.Filter_1_0_0 = Filter_1_0_0_Module.Filter_1_0_0;
  }
  else {
    var Filter_1_0_0 = Filter_1_0_0_Module.Filter_1_0_0;
  }
}
},{}],4:[function(require,module,exports){
var Filter_1_1_0_Module_Factory = function () {
  var Filter_1_1_0 = {
    n: 'Filter_1_1_0',
    dens: 'http:\/\/www.opengis.net\/ogc',
    deps: ['GML_3_1_1'],
    tis: [{
        ln: 'ArithmeticOperatorsType',
        ps: [{
            n: 'ops',
            rq: true,
            col: true,
            etis: [{
                en: 'SimpleArithmetic',
                ti: '.SimpleArithmetic'
              }, {
                en: 'Functions',
                ti: '.FunctionsType'
              }],
            t: 'es'
          }]
      }, {
        ln: 'BinaryComparisonOpType',
        bti: '.ComparisonOpsType',
        ps: [{
            n: 'expression',
            rq: true,
            mno: 2,
            mxo: 2,
            col: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }, {
            n: 'matchCase',
            ti: 'Boolean',
            an: {
              lp: 'matchCase'
            },
            t: 'a'
          }]
      }, {
        ln: 'FilterCapabilities',
        tn: null,
        ps: [{
            n: 'spatialCapabilities',
            rq: true,
            en: 'Spatial_Capabilities',
            ti: '.SpatialCapabilitiesType'
          }, {
            n: 'scalarCapabilities',
            rq: true,
            en: 'Scalar_Capabilities',
            ti: '.ScalarCapabilitiesType'
          }, {
            n: 'idCapabilities',
            rq: true,
            en: 'Id_Capabilities',
            ti: '.IdCapabilitiesType'
          }]
      }, {
        ln: 'LiteralType',
        bti: '.ExpressionType',
        ps: [{
            n: 'content',
            col: true,
            dom: false,
            t: 'ae'
          }]
      }, {
        ln: 'ComparisonOpsType'
      }, {
        ln: 'FunctionNamesType',
        ps: [{
            n: 'functionName',
            rq: true,
            col: true,
            en: 'FunctionName',
            ti: '.FunctionNameType'
          }]
      }, {
        ln: 'BinaryLogicOpType',
        bti: '.LogicOpsType',
        ps: [{
            n: 'ops',
            rq: true,
            mno: 2,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'spatialOps',
                ti: '.SpatialOpsType'
              }, {
                en: 'Function',
                ti: '.FunctionType'
              }, {
                en: 'comparisonOps',
                ti: '.ComparisonOpsType'
              }, {
                en: 'logicOps',
                ti: '.LogicOpsType'
              }],
            t: 'ers'
          }]
      }, {
        ln: 'PropertyIsLikeType',
        bti: '.ComparisonOpsType',
        ps: [{
            n: 'propertyName',
            rq: true,
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }, {
            n: 'literal',
            rq: true,
            en: 'Literal',
            ti: '.LiteralType'
          }, {
            n: 'wildCard',
            rq: true,
            an: {
              lp: 'wildCard'
            },
            t: 'a'
          }, {
            n: 'singleChar',
            rq: true,
            an: {
              lp: 'singleChar'
            },
            t: 'a'
          }, {
            n: 'escapeChar',
            rq: true,
            an: {
              lp: 'escapeChar'
            },
            t: 'a'
          }, {
            n: 'matchCase',
            ti: 'Boolean',
            an: {
              lp: 'matchCase'
            },
            t: 'a'
          }]
      }, {
        ln: 'FunctionNameType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'nArgs',
            rq: true,
            an: {
              lp: 'nArgs'
            },
            t: 'a'
          }]
      }, {
        ln: 'ScalarCapabilitiesType',
        tn: 'Scalar_CapabilitiesType',
        ps: [{
            n: 'logicalOperators',
            en: 'LogicalOperators',
            ti: '.LogicalOperators'
          }, {
            n: 'comparisonOperators',
            en: 'ComparisonOperators',
            ti: '.ComparisonOperatorsType'
          }, {
            n: 'arithmeticOperators',
            en: 'ArithmeticOperators',
            ti: '.ArithmeticOperatorsType'
          }]
      }, {
        ln: 'LogicOpsType'
      }, {
        ln: 'UnaryLogicOpType',
        bti: '.LogicOpsType',
        ps: [{
            n: 'comparisonOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.ComparisonOpsType',
            t: 'er'
          }, {
            n: 'spatialOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.SpatialOpsType',
            t: 'er'
          }, {
            n: 'logicOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.LogicOpsType',
            t: 'er'
          }, {
            n: 'function',
            rq: true,
            en: 'Function',
            ti: '.FunctionType'
          }]
      }, {
        ln: 'PropertyIsNullType',
        bti: '.ComparisonOpsType',
        ps: [{
            n: 'propertyName',
            rq: true,
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }]
      }, {
        ln: 'SpatialOperatorsType',
        ps: [{
            n: 'spatialOperator',
            rq: true,
            col: true,
            en: 'SpatialOperator',
            ti: '.SpatialOperatorType'
          }]
      }, {
        ln: 'FeatureIdType',
        bti: '.AbstractIdType',
        ps: [{
            n: 'fid',
            rq: true,
            ti: 'ID',
            an: {
              lp: 'fid'
            },
            t: 'a'
          }]
      }, {
        ln: 'SortPropertyType',
        ps: [{
            n: 'propertyName',
            rq: true,
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }, {
            n: 'sortOrder',
            en: 'SortOrder'
          }]
      }, {
        ln: 'SimpleArithmetic',
        tn: null
      }, {
        ln: 'FID',
        tn: null
      }, {
        ln: 'ExpressionType'
      }, {
        ln: 'AbstractIdType'
      }, {
        ln: 'FilterType',
        ps: [{
            n: 'spatialOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.SpatialOpsType',
            t: 'er'
          }, {
            n: 'comparisonOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.ComparisonOpsType',
            t: 'er'
          }, {
            n: 'logicOps',
            rq: true,
            mx: false,
            dom: false,
            ti: '.LogicOpsType',
            t: 'er'
          }, {
            n: 'id',
            rq: true,
            col: true,
            mx: false,
            dom: false,
            en: '_Id',
            ti: '.AbstractIdType',
            t: 'er'
          }]
      }, {
        ln: 'GmlObjectIdType',
        bti: '.AbstractIdType',
        ps: [{
            n: 'id',
            rq: true,
            ti: 'ID',
            an: {
              lp: 'id',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }]
      }, {
        ln: 'PropertyNameType',
        bti: '.ExpressionType',
        ps: [{
            n: 'content',
            col: true,
            dom: false,
            t: 'ae'
          }]
      }, {
        ln: 'UpperBoundaryType',
        ps: [{
            n: 'expression',
            rq: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }]
      }, {
        ln: 'EID',
        tn: null
      }, {
        ln: 'BinarySpatialOpType',
        bti: '.SpatialOpsType',
        ps: [{
            n: 'propertyName',
            rq: true,
            mxo: 2,
            col: true,
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }, {
            n: 'geometry',
            rq: true,
            mx: false,
            dom: false,
            en: {
              lp: '_Geometry',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            ti: 'GML_3_1_1.AbstractGeometryType',
            t: 'er'
          }, {
            n: 'envelope',
            rq: true,
            mx: false,
            dom: false,
            en: {
              lp: 'Envelope',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            ti: 'GML_3_1_1.EnvelopeType',
            t: 'er'
          }]
      }, {
        ln: 'ComparisonOperatorsType',
        ps: [{
            n: 'comparisonOperator',
            rq: true,
            col: true,
            en: 'ComparisonOperator'
          }]
      }, {
        ln: 'SpatialOpsType'
      }, {
        ln: 'FunctionType',
        bti: '.ExpressionType',
        ps: [{
            n: 'expression',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }, {
            n: 'name',
            rq: true,
            an: {
              lp: 'name'
            },
            t: 'a'
          }]
      }, {
        ln: 'DistanceBufferType',
        bti: '.SpatialOpsType',
        ps: [{
            n: 'propertyName',
            rq: true,
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }, {
            n: 'geometry',
            rq: true,
            mx: false,
            dom: false,
            en: {
              lp: '_Geometry',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            ti: 'GML_3_1_1.AbstractGeometryType',
            t: 'er'
          }, {
            n: 'distance',
            rq: true,
            en: 'Distance',
            ti: '.DistanceType'
          }]
      }, {
        ln: 'LogicalOperators',
        tn: null
      }, {
        ln: 'LowerBoundaryType',
        ps: [{
            n: 'expression',
            rq: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }]
      }, {
        ln: 'BBOXType',
        bti: '.SpatialOpsType',
        ps: [{
            n: 'propertyName',
            en: 'PropertyName',
            ti: '.PropertyNameType'
          }, {
            n: 'envelope',
            rq: true,
            mx: false,
            dom: false,
            en: {
              lp: 'Envelope',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            ti: 'GML_3_1_1.EnvelopeType',
            t: 'er'
          }]
      }, {
        ln: 'SpatialCapabilitiesType',
        tn: 'Spatial_CapabilitiesType',
        ps: [{
            n: 'geometryOperands',
            rq: true,
            en: 'GeometryOperands',
            ti: '.GeometryOperandsType'
          }, {
            n: 'spatialOperators',
            rq: true,
            en: 'SpatialOperators',
            ti: '.SpatialOperatorsType'
          }]
      }, {
        ln: 'IdCapabilitiesType',
        tn: 'Id_CapabilitiesType',
        ps: [{
            n: 'ids',
            rq: true,
            col: true,
            etis: [{
                en: 'EID',
                ti: '.EID'
              }, {
                en: 'FID',
                ti: '.FID'
              }],
            t: 'es'
          }]
      }, {
        ln: 'DistanceType',
        ps: [{
            n: 'value',
            ti: 'Double',
            t: 'v'
          }, {
            n: 'units',
            rq: true,
            an: {
              lp: 'units'
            },
            t: 'a'
          }]
      }, {
        ln: 'SpatialOperatorType',
        ps: [{
            n: 'geometryOperands',
            en: 'GeometryOperands',
            ti: '.GeometryOperandsType'
          }, {
            n: 'name',
            an: {
              lp: 'name'
            },
            t: 'a'
          }]
      }, {
        ln: 'FunctionsType',
        ps: [{
            n: 'functionNames',
            rq: true,
            en: 'FunctionNames',
            ti: '.FunctionNamesType'
          }]
      }, {
        ln: 'PropertyIsBetweenType',
        bti: '.ComparisonOpsType',
        ps: [{
            n: 'expression',
            rq: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }, {
            n: 'lowerBoundary',
            rq: true,
            en: 'LowerBoundary',
            ti: '.LowerBoundaryType'
          }, {
            n: 'upperBoundary',
            rq: true,
            en: 'UpperBoundary',
            ti: '.UpperBoundaryType'
          }]
      }, {
        ln: 'BinaryOperatorType',
        bti: '.ExpressionType',
        ps: [{
            n: 'expression',
            rq: true,
            mno: 2,
            mxo: 2,
            col: true,
            mx: false,
            dom: false,
            ti: '.ExpressionType',
            t: 'er'
          }]
      }, {
        ln: 'SortByType',
        ps: [{
            n: 'sortProperty',
            rq: true,
            col: true,
            en: 'SortProperty',
            ti: '.SortPropertyType'
          }]
      }, {
        ln: 'GeometryOperandsType',
        ps: [{
            n: 'geometryOperand',
            rq: true,
            col: true,
            en: 'GeometryOperand',
            ti: 'QName'
          }]
      }, {
        t: 'enum',
        ln: 'SortOrderType',
        vs: ['DESC', 'ASC']
      }, {
        t: 'enum',
        ln: 'SpatialOperatorNameType',
        vs: ['BBOX', 'Equals', 'Disjoint', 'Intersects', 'Touches', 'Crosses', 'Within', 'Contains', 'Overlaps', 'Beyond', 'DWithin']
      }, {
        t: 'enum',
        ln: 'ComparisonOperatorType',
        vs: ['LessThan', 'GreaterThan', 'LessThanEqualTo', 'GreaterThanEqualTo', 'EqualTo', 'NotEqualTo', 'Like', 'Between', 'NullCheck']
      }],
    eis: [{
        en: 'SimpleArithmetic',
        ti: '.SimpleArithmetic'
      }, {
        en: 'EID',
        ti: '.EID'
      }, {
        en: 'PropertyName',
        ti: '.PropertyNameType',
        sh: 'expression'
      }, {
        en: 'PropertyIsEqualTo',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'Equals',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'Filter_Capabilities',
        ti: '.FilterCapabilities'
      }, {
        en: 'Overlaps',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'Crosses',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'FID',
        ti: '.FID'
      }, {
        en: 'Mul',
        ti: '.BinaryOperatorType',
        sh: 'expression'
      }, {
        en: 'FeatureId',
        ti: '.FeatureIdType',
        sh: '_Id'
      }, {
        en: 'Div',
        ti: '.BinaryOperatorType',
        sh: 'expression'
      }, {
        en: 'Intersects',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: '_Id',
        ti: '.AbstractIdType'
      }, {
        en: 'Within',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'Sub',
        ti: '.BinaryOperatorType',
        sh: 'expression'
      }, {
        en: 'PropertyIsNull',
        ti: '.PropertyIsNullType',
        sh: 'comparisonOps'
      }, {
        en: 'Not',
        ti: '.UnaryLogicOpType',
        sh: 'logicOps'
      }, {
        en: 'PropertyIsNotEqualTo',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'logicOps',
        ti: '.LogicOpsType'
      }, {
        en: 'Add',
        ti: '.BinaryOperatorType',
        sh: 'expression'
      }, {
        en: 'Touches',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'PropertyIsGreaterThan',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'PropertyIsGreaterThanOrEqualTo',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'comparisonOps',
        ti: '.ComparisonOpsType'
      }, {
        en: 'PropertyIsLessThanOrEqualTo',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'PropertyIsBetween',
        ti: '.PropertyIsBetweenType',
        sh: 'comparisonOps'
      }, {
        en: 'PropertyIsLessThan',
        ti: '.BinaryComparisonOpType',
        sh: 'comparisonOps'
      }, {
        en: 'Filter',
        ti: '.FilterType'
      }, {
        en: 'Beyond',
        ti: '.DistanceBufferType',
        sh: 'spatialOps'
      }, {
        en: 'PropertyIsLike',
        ti: '.PropertyIsLikeType',
        sh: 'comparisonOps'
      }, {
        en: 'Or',
        ti: '.BinaryLogicOpType',
        sh: 'logicOps'
      }, {
        en: 'DWithin',
        ti: '.DistanceBufferType',
        sh: 'spatialOps'
      }, {
        en: 'expression',
        ti: '.ExpressionType'
      }, {
        en: 'GmlObjectId',
        ti: '.GmlObjectIdType',
        sh: '_Id'
      }, {
        en: 'BBOX',
        ti: '.BBOXType',
        sh: 'spatialOps'
      }, {
        en: 'LogicalOperators',
        ti: '.LogicalOperators'
      }, {
        en: 'Function',
        ti: '.FunctionType',
        sh: 'expression'
      }, {
        en: 'And',
        ti: '.BinaryLogicOpType',
        sh: 'logicOps'
      }, {
        en: 'spatialOps',
        ti: '.SpatialOpsType'
      }, {
        en: 'SortBy',
        ti: '.SortByType'
      }, {
        en: 'Disjoint',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'Contains',
        ti: '.BinarySpatialOpType',
        sh: 'spatialOps'
      }, {
        en: 'Literal',
        ti: '.LiteralType',
        sh: 'expression'
      }]
  };
  return {
    Filter_1_1_0: Filter_1_1_0
  };
};
if (typeof define === 'function' && define.amd) {
  define([], Filter_1_1_0_Module_Factory);
}
else {
  var Filter_1_1_0_Module = Filter_1_1_0_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.Filter_1_1_0 = Filter_1_1_0_Module.Filter_1_1_0;
  }
  else {
    var Filter_1_1_0 = Filter_1_1_0_Module.Filter_1_1_0;
  }
}
},{}],5:[function(require,module,exports){
var GML_2_1_2_Module_Factory = function () {
  var GML_2_1_2 = {
    n: 'GML_2_1_2',
    dens: 'http:\/\/www.opengis.net\/gml',
    dans: 'http:\/\/www.w3.org\/1999\/xlink',
    deps: ['XLink_1_0'],
    tis: [{
        ln: 'MultiPolygonPropertyType',
        bti: '.GeometryAssociationType'
      }, {
        ln: 'LineStringType',
        bti: '.AbstractGeometryType',
        ps: [{
            n: 'coord',
            rq: true,
            mno: 2,
            col: true,
            ti: '.CoordType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }]
      }, {
        ln: 'AbstractFeatureType',
        ps: [{
            n: 'description'
          }, {
            n: 'name'
          }, {
            n: 'boundedBy',
            ti: '.BoundingShapeType'
          }, {
            n: 'fid',
            ti: 'ID',
            an: {
              lp: 'fid'
            },
            t: 'a'
          }]
      }, {
        ln: 'MultiPointPropertyType',
        bti: '.GeometryAssociationType'
      }, {
        ln: 'LinearRingMemberType',
        bti: '.GeometryAssociationType'
      }, {
        ln: 'MultiGeometryPropertyType',
        bti: '.GeometryAssociationType'
      }, {
        ln: 'CoordType',
        ps: [{
            n: 'x',
            rq: true,
            en: 'X',
            ti: 'Decimal'
          }, {
            n: 'y',
            en: 'Y',
            ti: 'Decimal'
          }, {
            n: 'z',
            en: 'Z',
            ti: 'Decimal'
          }]
      }, {
        ln: 'CoordinatesType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'decimal',
            an: {
              lp: 'decimal'
            },
            t: 'a'
          }, {
            n: 'cs',
            an: {
              lp: 'cs'
            },
            t: 'a'
          }, {
            n: 'ts',
            an: {
              lp: 'ts'
            },
            t: 'a'
          }]
      }, {
        ln: 'LineStringMemberType',
        bti: '.GeometryAssociationType'
      }, {
        ln: 'MultiPolygonType',
        bti: '.GeometryCollectionType'
      }, {
        ln: 'AbstractFeatureCollectionType',
        bti: '.AbstractFeatureCollectionBaseType',
        ps: [{
            n: 'featureMember',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            ti: '.FeatureAssociationType',
            t: 'er'
          }]
      }, {
        ln: 'GeometryCollectionType',
        bti: '.AbstractGeometryCollectionBaseType',
        ps: [{
            n: 'geometryMember',
            rq: true,
            col: true,
            mx: false,
            dom: false,
            ti: '.GeometryAssociationType',
            t: 'er'
          }]
      }, {
        ln: 'PolygonType',
        bti: '.AbstractGeometryType',
        ps: [{
            n: 'outerBoundaryIs',
            rq: true,
            ti: '.LinearRingMemberType'
          }, {
            n: 'innerBoundaryIs',
            mno: 0,
            col: true,
            ti: '.LinearRingMemberType'
          }]
      }, {
        ln: 'PolygonPropertyType',
        bti: '.GeometryAssociationType'
      }, {
        ln: 'PointPropertyType',
        bti: '.GeometryAssociationType'
      }, {
        ln: 'AbstractFeatureCollectionBaseType',
        bti: '.AbstractFeatureType'
      }, {
        ln: 'LinearRingType',
        bti: '.AbstractGeometryType',
        ps: [{
            n: 'coord',
            rq: true,
            mno: 4,
            col: true,
            ti: '.CoordType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }]
      }, {
        ln: 'GeometryPropertyType',
        ps: [{
            n: 'geometry',
            rq: true,
            mx: false,
            dom: false,
            en: '_Geometry',
            ti: '.AbstractGeometryType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'BoxType',
        bti: '.AbstractGeometryType',
        ps: [{
            n: 'coord',
            rq: true,
            mno: 2,
            mxo: 2,
            col: true,
            ti: '.CoordType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }]
      }, {
        ln: 'LineStringPropertyType',
        bti: '.GeometryAssociationType'
      }, {
        ln: 'AbstractGeometryType',
        ps: [{
            n: 'gid',
            ti: 'ID',
            an: {
              lp: 'gid'
            },
            t: 'a'
          }, {
            n: 'srsName',
            an: {
              lp: 'srsName'
            },
            t: 'a'
          }]
      }, {
        ln: 'MultiLineStringPropertyType',
        bti: '.GeometryAssociationType'
      }, {
        ln: 'GeometryAssociationType',
        ps: [{
            n: 'geometry',
            rq: true,
            mx: false,
            dom: false,
            en: '_Geometry',
            ti: '.AbstractGeometryType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'PointMemberType',
        bti: '.GeometryAssociationType'
      }, {
        ln: 'PolygonMemberType',
        bti: '.GeometryAssociationType'
      }, {
        ln: 'MultiLineStringType',
        bti: '.GeometryCollectionType'
      }, {
        ln: 'MultiPointType',
        bti: '.GeometryCollectionType'
      }, {
        ln: 'BoundingShapeType',
        ps: [{
            n: 'box',
            rq: true,
            en: 'Box',
            ti: '.BoxType'
          }, {
            n: '_null',
            rq: true,
            en: 'null'
          }]
      }, {
        ln: 'AbstractGeometryCollectionBaseType',
        bti: '.AbstractGeometryType'
      }, {
        ln: 'PointType',
        bti: '.AbstractGeometryType',
        ps: [{
            n: 'coord',
            rq: true,
            ti: '.CoordType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }]
      }, {
        ln: 'FeatureAssociationType',
        ps: [{
            n: 'feature',
            rq: true,
            mx: false,
            dom: false,
            en: '_Feature',
            ti: '.AbstractFeatureType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        t: 'enum',
        ln: 'NullType',
        vs: ['inapplicable', 'unknown', 'unavailable', 'missing']
      }],
    eis: [{
        en: 'location',
        ti: '.PointPropertyType',
        sh: 'pointProperty'
      }, {
        en: 'polygonProperty',
        ti: '.PolygonPropertyType',
        sh: '_geometryProperty'
      }, {
        en: 'lineStringProperty',
        ti: '.LineStringPropertyType',
        sh: '_geometryProperty'
      }, {
        en: 'pointMember',
        ti: '.PointMemberType',
        sh: 'geometryMember'
      }, {
        en: 'boundedBy',
        ti: '.BoundingShapeType'
      }, {
        en: 'multiCenterOf',
        ti: '.MultiPointPropertyType',
        sh: 'multiPointProperty'
      }, {
        en: 'multiGeometryProperty',
        ti: '.MultiGeometryPropertyType',
        sh: '_geometryProperty'
      }, {
        en: 'multiCenterLineOf',
        ti: '.MultiLineStringPropertyType',
        sh: 'multiLineStringProperty'
      }, {
        en: 'multiCoverage',
        ti: '.MultiPolygonPropertyType',
        sh: 'multiPolygonProperty'
      }, {
        en: 'multiEdgeOf',
        ti: '.MultiLineStringPropertyType',
        sh: 'multiLineStringProperty'
      }, {
        en: '_Feature',
        ti: '.AbstractFeatureType'
      }, {
        en: 'multiLineStringProperty',
        ti: '.MultiLineStringPropertyType',
        sh: '_geometryProperty'
      }, {
        en: 'position',
        ti: '.PointPropertyType',
        sh: 'pointProperty'
      }, {
        en: 'innerBoundaryIs',
        ti: '.LinearRingMemberType'
      }, {
        en: 'pointProperty',
        ti: '.PointPropertyType',
        sh: '_geometryProperty'
      }, {
        en: 'multiPolygonProperty',
        ti: '.MultiPolygonPropertyType',
        sh: '_geometryProperty'
      }, {
        en: 'multiExtentOf',
        ti: '.MultiPolygonPropertyType',
        sh: 'multiPolygonProperty'
      }, {
        en: 'geometryMember',
        ti: '.GeometryAssociationType'
      }, {
        en: 'name'
      }, {
        en: 'coord',
        ti: '.CoordType'
      }, {
        en: 'edgeOf',
        ti: '.LineStringPropertyType',
        sh: 'lineStringProperty'
      }, {
        en: 'MultiPoint',
        ti: '.MultiPointType',
        sh: '_Geometry'
      }, {
        en: 'centerOf',
        ti: '.PointPropertyType',
        sh: 'pointProperty'
      }, {
        en: 'multiLocation',
        ti: '.MultiPointPropertyType',
        sh: 'multiPointProperty'
      }, {
        en: '_Geometry',
        ti: '.AbstractGeometryType'
      }, {
        en: 'featureMember',
        ti: '.FeatureAssociationType'
      }, {
        en: 'extentOf',
        ti: '.PolygonPropertyType',
        sh: 'polygonProperty'
      }, {
        en: 'Point',
        ti: '.PointType',
        sh: '_Geometry'
      }, {
        en: 'Box',
        ti: '.BoxType'
      }, {
        en: 'coverage',
        ti: '.PolygonPropertyType',
        sh: 'polygonProperty'
      }, {
        en: 'description'
      }, {
        en: 'Polygon',
        ti: '.PolygonType',
        sh: '_Geometry'
      }, {
        en: 'MultiGeometry',
        ti: '.GeometryCollectionType',
        sh: '_Geometry'
      }, {
        en: 'geometryProperty',
        ti: '.GeometryAssociationType'
      }, {
        en: '_FeatureCollection',
        ti: '.AbstractFeatureCollectionType',
        sh: '_Feature'
      }, {
        en: 'coordinates',
        ti: '.CoordinatesType'
      }, {
        en: 'outerBoundaryIs',
        ti: '.LinearRingMemberType'
      }, {
        en: 'multiPosition',
        ti: '.MultiPointPropertyType',
        sh: 'multiPointProperty'
      }, {
        en: 'LinearRing',
        ti: '.LinearRingType',
        sh: '_Geometry'
      }, {
        en: 'multiPointProperty',
        ti: '.MultiPointPropertyType',
        sh: '_geometryProperty'
      }, {
        en: 'lineStringMember',
        ti: '.LineStringMemberType',
        sh: 'geometryMember'
      }, {
        en: 'LineString',
        ti: '.LineStringType',
        sh: '_Geometry'
      }, {
        en: 'otherFeatureMember',
        ti: '.FeatureAssociationType',
        sh: 'featureMember'
      }, {
        en: '_GeometryCollection',
        ti: '.GeometryCollectionType',
        sh: '_Geometry'
      }, {
        en: 'MultiPolygon',
        ti: '.MultiPolygonType',
        sh: '_Geometry'
      }, {
        en: 'MultiLineString',
        ti: '.MultiLineStringType',
        sh: '_Geometry'
      }, {
        en: 'centerLineOf',
        ti: '.LineStringPropertyType',
        sh: 'lineStringProperty'
      }, {
        en: '_geometryProperty',
        ti: '.GeometryAssociationType'
      }, {
        en: 'polygonMember',
        ti: '.PolygonMemberType',
        sh: 'geometryMember'
      }]
  };
  return {
    GML_2_1_2: GML_2_1_2
  };
};
if (typeof define === 'function' && define.amd) {
  define([], GML_2_1_2_Module_Factory);
}
else {
  var GML_2_1_2_Module = GML_2_1_2_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.GML_2_1_2 = GML_2_1_2_Module.GML_2_1_2;
  }
  else {
    var GML_2_1_2 = GML_2_1_2_Module.GML_2_1_2;
  }
}
},{}],6:[function(require,module,exports){
var GML_3_1_1_Module_Factory = function () {
  var GML_3_1_1 = {
    n: 'GML_3_1_1',
    dens: 'http:\/\/www.opengis.net\/gml',
    dans: 'http:\/\/www.w3.org\/1999\/xlink',
    deps: ['XLink_1_0', 'SMIL_2_0_Language'],
    tis: [{
        ln: 'EngineeringCRSType',
        bti: '.AbstractReferenceSystemType',
        ps: [{
            n: 'usesCS',
            rq: true,
            ti: '.CoordinateSystemRefType'
          }, {
            n: 'usesEngineeringDatum',
            rq: true,
            ti: '.EngineeringDatumRefType'
          }]
      }, {
        ln: 'FileType',
        ps: [{
            n: 'rangeParameters',
            rq: true,
            ti: '.RangeParametersType'
          }, {
            n: 'fileName',
            rq: true
          }, {
            n: 'fileStructure',
            rq: true
          }, {
            n: 'mimeType'
          }, {
            n: 'compression'
          }]
      }, {
        ln: 'CylinderType',
        bti: '.AbstractGriddedSurfaceType',
        ps: [{
            n: 'horizontalCURVETYPE',
            an: {
              lp: 'horizontalCurveType'
            },
            t: 'a'
          }, {
            n: 'verticalCURVETYPE',
            an: {
              lp: 'verticalCurveType'
            },
            t: 'a'
          }]
      }, {
        ln: 'LinearRingType',
        bti: '.AbstractRingType',
        ps: [{
            n: 'posOrPointPropertyOrPointRep',
            rq: true,
            mno: 4,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'pos',
                ti: '.DirectPositionType'
              }, {
                en: 'pointProperty',
                ti: '.PointPropertyType'
              }, {
                en: 'pointRep',
                ti: '.PointPropertyType'
              }],
            t: 'ers'
          }, {
            n: 'posList',
            rq: true,
            ti: '.DirectPositionListType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }, {
            n: 'coord',
            rq: true,
            mno: 4,
            col: true,
            ti: '.CoordType'
          }]
      }, {
        ln: 'AbstractCurveType',
        bti: '.AbstractGeometricPrimitiveType'
      }, {
        ln: 'MultiCurvePropertyType',
        ps: [{
            n: 'multiCurve',
            rq: true,
            en: 'MultiCurve',
            ti: '.MultiCurveType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CoordinateSystemAxisRefType',
        ps: [{
            n: 'coordinateSystemAxis',
            rq: true,
            en: 'CoordinateSystemAxis',
            ti: '.CoordinateSystemAxisType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'EllipsoidType',
        bti: '.EllipsoidBaseType',
        ps: [{
            n: 'ellipsoidID',
            mno: 0,
            col: true,
            ti: '.IdentifierType'
          }, {
            n: 'remarks',
            ti: '.StringOrRefType'
          }, {
            n: 'semiMajorAxis',
            rq: true,
            ti: '.MeasureType'
          }, {
            n: 'secondDefiningParameter',
            rq: true,
            ti: '.SecondDefiningParameterType'
          }]
      }, {
        ln: 'SurfacePropertyType',
        ps: [{
            n: 'surface',
            rq: true,
            mx: false,
            dom: false,
            en: '_Surface',
            ti: '.AbstractSurfaceType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'ProjectedCRSType',
        bti: '.AbstractGeneralDerivedCRSType',
        ps: [{
            n: 'usesCartesianCS',
            rq: true,
            ti: '.CartesianCSRefType'
          }]
      }, {
        ln: 'CodeType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'codeSpace',
            an: {
              lp: 'codeSpace'
            },
            t: 'a'
          }]
      }, {
        ln: 'GeneralConversionRefType',
        ps: [{
            n: 'generalConversion',
            rq: true,
            mx: false,
            dom: false,
            en: '_GeneralConversion',
            ti: '.AbstractGeneralConversionType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CompositeCurvePropertyType',
        ps: [{
            n: 'compositeCurve',
            rq: true,
            en: 'CompositeCurve',
            ti: '.CompositeCurveType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TopoPointType',
        bti: '.AbstractTopologyType',
        ps: [{
            n: 'directedNode',
            rq: true,
            ti: '.DirectedNodePropertyType'
          }]
      }, {
        ln: 'TimeInstantType',
        bti: '.AbstractTimeGeometricPrimitiveType',
        ps: [{
            n: 'timePosition',
            rq: true,
            ti: '.TimePositionType'
          }]
      }, {
        ln: 'EnvelopeType',
        ps: [{
            n: 'lowerCorner',
            rq: true,
            ti: '.DirectPositionType'
          }, {
            n: 'upperCorner',
            rq: true,
            ti: '.DirectPositionType'
          }, {
            n: 'coord',
            rq: true,
            mno: 2,
            mxo: 2,
            col: true,
            ti: '.CoordType'
          }, {
            n: 'pos',
            rq: true,
            mno: 2,
            mxo: 2,
            col: true,
            ti: '.DirectPositionType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }, {
            n: 'srsName',
            an: {
              lp: 'srsName'
            },
            t: 'a'
          }, {
            n: 'srsDimension',
            ti: 'PositiveInteger',
            an: {
              lp: 'srsDimension'
            },
            t: 'a'
          }, {
            n: 'axisLabels',
            ti: {
              t: 'l',
              bti: 'NCName'
            },
            an: {
              lp: 'axisLabels'
            },
            t: 'a'
          }, {
            n: 'uomLabels',
            ti: {
              t: 'l',
              bti: 'NCName'
            },
            an: {
              lp: 'uomLabels'
            },
            t: 'a'
          }]
      }, {
        ln: 'GeographicCRSType',
        bti: '.AbstractReferenceSystemType',
        ps: [{
            n: 'usesEllipsoidalCS',
            rq: true,
            ti: '.EllipsoidalCSRefType'
          }, {
            n: 'usesGeodeticDatum',
            rq: true,
            ti: '.GeodeticDatumRefType'
          }]
      }, {
        ln: 'GeometricComplexPropertyType',
        ps: [{
            n: 'geometricComplex',
            rq: true,
            en: 'GeometricComplex',
            ti: '.GeometricComplexType'
          }, {
            n: 'compositeCurve',
            rq: true,
            en: 'CompositeCurve',
            ti: '.CompositeCurveType'
          }, {
            n: 'compositeSurface',
            rq: true,
            en: 'CompositeSurface',
            ti: '.CompositeSurfaceType'
          }, {
            n: 'compositeSolid',
            rq: true,
            en: 'CompositeSolid',
            ti: '.CompositeSolidType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'IdentifierType',
        ps: [{
            n: 'name',
            rq: true,
            mx: false,
            dom: false,
            ti: '.CodeType',
            t: 'er'
          }, {
            n: 'version'
          }, {
            n: 'remarks',
            ti: '.StringOrRefType'
          }]
      }, {
        ln: 'TopoVolumeType',
        bti: '.AbstractTopologyType',
        ps: [{
            n: 'directedTopoSolid',
            rq: true,
            col: true,
            ti: '.DirectedTopoSolidPropertyType'
          }]
      }, {
        ln: 'AbstractGeneralOperationParameterType',
        bti: '.DefinitionType',
        ps: [{
            n: 'minimumOccurs',
            ti: 'NonNegativeInteger'
          }]
      }, {
        ln: 'OperationParameterType',
        bti: '.OperationParameterBaseType',
        ps: [{
            n: 'parameterID',
            mno: 0,
            col: true,
            ti: '.IdentifierType'
          }, {
            n: 'remarks',
            ti: '.StringOrRefType'
          }]
      }, {
        ln: 'StyleVariationType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'styleProperty',
            rq: true,
            an: {
              lp: 'styleProperty'
            },
            t: 'a'
          }, {
            n: 'featurePropertyRange',
            an: {
              lp: 'featurePropertyRange'
            },
            t: 'a'
          }]
      }, {
        ln: 'AbstractTimeTopologyPrimitiveType',
        bti: '.AbstractTimePrimitiveType',
        ps: [{
            n: 'complex',
            ti: '.ReferenceType'
          }]
      }, {
        ln: 'TimeEdgePropertyType',
        ps: [{
            n: 'timeEdge',
            rq: true,
            en: 'TimeEdge',
            ti: '.TimeEdgeType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'EllipsoidalCSRefType',
        ps: [{
            n: 'ellipsoidalCS',
            rq: true,
            en: 'EllipsoidalCS',
            ti: '.EllipsoidalCSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'ArcByCenterPointType',
        bti: '.AbstractCurveSegmentType',
        ps: [{
            n: 'pos',
            rq: true,
            ti: '.DirectPositionType'
          }, {
            n: 'pointProperty',
            rq: true,
            ti: '.PointPropertyType'
          }, {
            n: 'pointRep',
            rq: true,
            ti: '.PointPropertyType'
          }, {
            n: 'posList',
            rq: true,
            ti: '.DirectPositionListType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }, {
            n: 'radius',
            rq: true,
            ti: '.LengthType'
          }, {
            n: 'startAngle',
            ti: '.AngleType'
          }, {
            n: 'endAngle',
            ti: '.AngleType'
          }, {
            n: 'interpolation',
            an: {
              lp: 'interpolation'
            },
            t: 'a'
          }, {
            n: 'numARC',
            rq: true,
            ti: 'Integer',
            an: {
              lp: 'numArc'
            },
            t: 'a'
          }]
      }, {
        ln: 'VolumeType',
        bti: '.MeasureType'
      }, {
        ln: 'AbstractTimeReferenceSystemType',
        bti: '.DefinitionType',
        ps: [{
            n: 'domainOfValidity'
          }]
      }, {
        ln: 'MultiSurfaceCoverageType',
        bti: '.AbstractDiscreteCoverageType'
      }, {
        ln: 'GeocentricCRSRefType',
        ps: [{
            n: 'geocentricCRS',
            rq: true,
            en: 'GeocentricCRS',
            ti: '.GeocentricCRSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CurveSegmentArrayPropertyType',
        ps: [{
            n: 'curveSegment',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: '_CurveSegment',
            ti: '.AbstractCurveSegmentType',
            t: 'er'
          }]
      }, {
        ln: 'TopoCurvePropertyType',
        ps: [{
            n: 'topoCurve',
            rq: true,
            en: 'TopoCurve',
            ti: '.TopoCurveType'
          }]
      }, {
        ln: 'SecondDefiningParameterType',
        ps: [{
            n: 'inverseFlattening',
            rq: true,
            ti: '.MeasureType'
          }, {
            n: 'semiMinorAxis',
            rq: true,
            ti: '.MeasureType'
          }, {
            n: 'isSphere',
            rq: true
          }]
      }, {
        ln: 'MultiCurveCoverageType',
        bti: '.AbstractDiscreteCoverageType'
      }, {
        ln: 'DerivedCRSTypeType',
        bti: '.CodeType'
      }, {
        ln: 'ProjectedCRSRefType',
        ps: [{
            n: 'projectedCRS',
            rq: true,
            en: 'ProjectedCRS',
            ti: '.ProjectedCRSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AngleType',
        bti: '.MeasureType'
      }, {
        ln: 'DirectionVectorType',
        ps: [{
            n: 'vector',
            rq: true,
            ti: '.VectorType'
          }, {
            n: 'horizontalAngle',
            rq: true,
            ti: '.AngleType'
          }, {
            n: 'verticalAngle',
            rq: true,
            ti: '.AngleType'
          }]
      }, {
        ln: 'DerivationUnitTermType',
        bti: '.UnitOfMeasureType',
        ps: [{
            n: 'exponent',
            ti: 'Integer',
            an: {
              lp: 'exponent'
            },
            t: 'a'
          }]
      }, {
        ln: 'ConversionType',
        bti: '.AbstractGeneralConversionType',
        ps: [{
            n: 'usesMethod',
            rq: true,
            ti: '.OperationMethodRefType'
          }, {
            n: 'usesValue',
            mno: 0,
            col: true,
            ti: '.ParameterValueType'
          }]
      }, {
        ln: 'ScaleType',
        bti: '.MeasureType'
      }, {
        ln: 'TimePeriodType',
        bti: '.AbstractTimeGeometricPrimitiveType',
        ps: [{
            n: 'beginPosition',
            rq: true,
            ti: '.TimePositionType'
          }, {
            n: 'begin',
            rq: true,
            ti: '.TimeInstantPropertyType'
          }, {
            n: 'endPosition',
            rq: true,
            ti: '.TimePositionType'
          }, {
            n: 'end',
            rq: true,
            ti: '.TimeInstantPropertyType'
          }, {
            n: 'duration',
            rq: true,
            ti: 'Duration'
          }, {
            n: 'timeInterval',
            rq: true,
            ti: '.TimeIntervalLengthType'
          }]
      }, {
        ln: 'LabelType',
        ps: [{
            n: 'content',
            col: true,
            dom: false,
            en: 'LabelExpression',
            t: 'er'
          }, {
            n: 'transform',
            an: {
              lp: 'transform',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }]
      }, {
        ln: 'PixelInCellType',
        bti: '.CodeType'
      }, {
        ln: 'PolarCSRefType',
        ps: [{
            n: 'polarCS',
            rq: true,
            en: 'PolarCS',
            ti: '.PolarCSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AbstractGeneralParameterValueType'
      }, {
        ln: 'GeodeticDatumRefType',
        ps: [{
            n: 'geodeticDatum',
            rq: true,
            en: 'GeodeticDatum',
            ti: '.GeodeticDatumType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'VerticalCRSRefType',
        ps: [{
            n: 'verticalCRS',
            rq: true,
            en: 'VerticalCRS',
            ti: '.VerticalCRSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CylindricalCSRefType',
        ps: [{
            n: 'cylindricalCS',
            rq: true,
            en: 'CylindricalCS',
            ti: '.CylindricalCSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'MultiSolidDomainType',
        bti: '.DomainSetType'
      }, {
        ln: 'TemporalCRSType',
        bti: '.AbstractReferenceSystemType',
        ps: [{
            n: 'usesTemporalCS',
            rq: true,
            ti: '.TemporalCSRefType'
          }, {
            n: 'usesTemporalDatum',
            rq: true,
            ti: '.TemporalDatumRefType'
          }]
      }, {
        ln: 'AbstractGMLType',
        ps: [{
            n: 'metaDataProperty',
            mno: 0,
            col: true,
            ti: '.MetaDataPropertyType'
          }, {
            n: 'description',
            ti: '.StringOrRefType'
          }, {
            n: 'name',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            ti: '.CodeType',
            t: 'er'
          }, {
            n: 'id',
            ti: 'ID',
            an: {
              lp: 'id',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }]
      }, {
        ln: 'RingType',
        bti: '.AbstractRingType',
        ps: [{
            n: 'curveMember',
            rq: true,
            col: true,
            ti: '.CurvePropertyType'
          }]
      }, {
        ln: 'KnotType',
        ps: [{
            n: 'value',
            rq: true,
            ti: 'Double'
          }, {
            n: 'multiplicity',
            rq: true,
            ti: 'NonNegativeInteger'
          }, {
            n: 'weight',
            rq: true,
            ti: 'Double'
          }]
      }, {
        ln: 'PointType',
        bti: '.AbstractGeometricPrimitiveType',
        ps: [{
            n: 'pos',
            rq: true,
            ti: '.DirectPositionType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }, {
            n: 'coord',
            rq: true,
            ti: '.CoordType'
          }]
      }, {
        ln: 'MeasureOrNullListType',
        ps: [{
            n: 'value',
            ti: {
              t: 'l'
            },
            t: 'v'
          }, {
            n: 'uom',
            rq: true,
            an: {
              lp: 'uom'
            },
            t: 'a'
          }]
      }, {
        ln: 'CurveArrayPropertyType',
        ps: [{
            n: 'curve',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: '_Curve',
            ti: '.AbstractCurveType',
            t: 'er'
          }]
      }, {
        ln: 'AbstractTimeSliceType',
        bti: '.AbstractGMLType',
        ps: [{
            n: 'validTime',
            rq: true,
            ti: '.TimePrimitivePropertyType'
          }, {
            n: 'dataSource',
            ti: '.StringOrRefType'
          }]
      }, {
        ln: 'TransformationRefType',
        ps: [{
            n: 'transformation',
            rq: true,
            en: 'Transformation',
            ti: '.TransformationType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'OrientableCurveType',
        bti: '.AbstractCurveType',
        ps: [{
            n: 'baseCurve',
            rq: true,
            ti: '.CurvePropertyType'
          }, {
            n: 'orientation',
            an: {
              lp: 'orientation'
            },
            t: 'a'
          }]
      }, {
        ln: 'GridCoverageType',
        bti: '.AbstractDiscreteCoverageType'
      }, {
        ln: 'CoordinateSystemAxisBaseType',
        bti: '.DefinitionType'
      }, {
        ln: 'SurfaceArrayPropertyType',
        ps: [{
            n: 'surface',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: '_Surface',
            ti: '.AbstractSurfaceType',
            t: 'er'
          }]
      }, {
        ln: 'TopoVolumePropertyType',
        ps: [{
            n: 'topoVolume',
            rq: true,
            en: 'TopoVolume',
            ti: '.TopoVolumeType'
          }]
      }, {
        ln: 'TopoComplexMemberType',
        ps: [{
            n: 'topoComplex',
            en: 'TopoComplex',
            ti: '.TopoComplexType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'GeometryStylePropertyType',
        ps: [{
            n: 'geometryStyle',
            en: 'GeometryStyle',
            ti: '.GeometryStyleType'
          }, {
            n: 'about',
            an: {
              lp: 'about'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'ArrayType',
        bti: '.AbstractGMLType',
        ps: [{
            n: 'members',
            ti: '.ArrayAssociationType'
          }]
      }, {
        ln: 'GeodeticDatumType',
        bti: '.AbstractDatumType',
        ps: [{
            n: 'usesPrimeMeridian',
            rq: true,
            ti: '.PrimeMeridianRefType'
          }, {
            n: 'usesEllipsoid',
            rq: true,
            ti: '.EllipsoidRefType'
          }]
      }, {
        ln: 'TinType.ControlPoint',
        tn: null,
        ps: [{
            n: 'posList',
            rq: true,
            ti: '.DirectPositionListType'
          }, {
            n: 'geometricPositionGroup',
            rq: true,
            mno: 3,
            col: true,
            etis: [{
                en: 'pos',
                ti: '.DirectPositionType'
              }, {
                en: 'pointProperty',
                ti: '.PointPropertyType'
              }],
            t: 'es'
          }]
      }, {
        ln: 'ImageDatumType',
        bti: '.AbstractDatumType',
        ps: [{
            n: 'pixelInCell',
            rq: true,
            ti: '.PixelInCellType'
          }]
      }, {
        ln: 'AbstractReferenceSystemBaseType',
        bti: '.DefinitionType'
      }, {
        ln: 'AbstractGeneralTransformationType',
        bti: '.AbstractCoordinateOperationType'
      }, {
        ln: 'ObservationType',
        bti: '.AbstractFeatureType',
        ps: [{
            n: 'validTime',
            rq: true,
            ti: '.TimePrimitivePropertyType'
          }, {
            n: 'using',
            ti: '.FeaturePropertyType'
          }, {
            n: 'target',
            mx: false,
            dom: false,
            ti: '.TargetPropertyType',
            t: 'er'
          }, {
            n: 'resultOf',
            rq: true,
            ti: '.AssociationType'
          }]
      }, {
        ln: 'ArrayAssociationType',
        ps: [{
            n: 'object',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: '_Object',
            ti: 'AnyType',
            t: 'er'
          }]
      }, {
        ln: 'TimeCoordinateSystemType',
        bti: '.AbstractTimeReferenceSystemType',
        ps: [{
            n: 'originPosition',
            rq: true,
            ti: '.TimePositionType'
          }, {
            n: 'origin',
            rq: true,
            ti: '.TimeInstantPropertyType'
          }, {
            n: 'interval',
            rq: true,
            ti: '.TimeIntervalLengthType'
          }]
      }, {
        ln: 'CoverageFunctionType',
        ps: [{
            n: 'mappingRule',
            rq: true,
            en: 'MappingRule',
            ti: '.StringOrRefType'
          }, {
            n: 'gridFunction',
            rq: true,
            mx: false,
            dom: false,
            en: 'GridFunction',
            ti: '.GridFunctionType',
            t: 'er'
          }]
      }, {
        ln: 'DefaultStylePropertyType',
        ps: [{
            n: 'style',
            mx: false,
            dom: false,
            en: '_Style',
            ti: '.AbstractStyleType',
            t: 'er'
          }, {
            n: 'about',
            an: {
              lp: 'about'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'SphericalCSType',
        bti: '.AbstractCoordinateSystemType'
      }, {
        ln: 'TimeCalendarEraPropertyType',
        ps: [{
            n: 'timeCalendarEra',
            rq: true,
            en: 'TimeCalendarEra',
            ti: '.TimeCalendarEraType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AbstractDatumBaseType',
        bti: '.DefinitionType'
      }, {
        ln: 'UnitOfMeasureType',
        ps: [{
            n: 'uom',
            rq: true,
            an: {
              lp: 'uom'
            },
            t: 'a'
          }]
      }, {
        ln: 'AbstractTopoPrimitiveType',
        bti: '.AbstractTopologyType',
        ps: [{
            n: 'isolated',
            mno: 0,
            col: true,
            ti: '.IsolatedPropertyType'
          }, {
            n: 'container',
            ti: '.ContainerPropertyType'
          }]
      }, {
        ln: 'ConventionalUnitType',
        bti: '.UnitDefinitionType',
        ps: [{
            n: 'conversionToPreferredUnit',
            rq: true,
            ti: '.ConversionToPreferredUnitType'
          }, {
            n: 'roughConversionToPreferredUnit',
            rq: true,
            ti: '.ConversionToPreferredUnitType'
          }, {
            n: 'derivationUnitTerm',
            mno: 0,
            col: true,
            ti: '.DerivationUnitTermType'
          }]
      }, {
        ln: 'ExtentType',
        ps: [{
            n: 'description',
            ti: '.StringOrRefType'
          }, {
            n: 'boundingBox',
            mno: 0,
            col: true,
            ti: '.EnvelopeType'
          }, {
            n: 'boundingPolygon',
            mno: 0,
            col: true,
            ti: '.PolygonType'
          }, {
            n: 'verticalExtent',
            mno: 0,
            col: true,
            ti: '.EnvelopeType'
          }, {
            n: 'temporalExtent',
            mno: 0,
            col: true,
            ti: '.TimePeriodType'
          }]
      }, {
        ln: 'AbsoluteExternalPositionalAccuracyType',
        bti: '.AbstractPositionalAccuracyType',
        ps: [{
            n: 'result',
            rq: true,
            ti: '.MeasureType'
          }]
      }, {
        ln: 'CoordinateSystemRefType',
        ps: [{
            n: 'coordinateSystem',
            rq: true,
            mx: false,
            dom: false,
            en: '_CoordinateSystem',
            ti: '.AbstractCoordinateSystemType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'BaseStyleDescriptorType',
        bti: '.AbstractGMLType',
        ps: [{
            n: 'spatialResolution',
            ti: '.ScaleType'
          }, {
            n: 'styleVariation',
            mno: 0,
            col: true,
            ti: '.StyleVariationType'
          }, {
            n: 'animate',
            mno: 0,
            col: true,
            en: {
              lp: 'animate',
              ns: 'http:\/\/www.w3.org\/2001\/SMIL20\/'
            },
            ti: 'SMIL_2_0_Language.AnimateType'
          }, {
            n: 'animateMotion',
            mno: 0,
            col: true,
            en: {
              lp: 'animateMotion',
              ns: 'http:\/\/www.w3.org\/2001\/SMIL20\/'
            },
            ti: 'SMIL_2_0_Language.AnimateMotionType'
          }, {
            n: 'animateColor',
            mno: 0,
            col: true,
            en: {
              lp: 'animateColor',
              ns: 'http:\/\/www.w3.org\/2001\/SMIL20\/'
            },
            ti: 'SMIL_2_0_Language.AnimateColorType'
          }, {
            n: 'set',
            mno: 0,
            col: true,
            en: {
              lp: 'set',
              ns: 'http:\/\/www.w3.org\/2001\/SMIL20\/'
            },
            ti: 'SMIL_2_0_Language.SetType'
          }]
      }, {
        ln: 'AssociationType',
        ps: [{
            n: 'object',
            rq: true,
            mx: false,
            dom: false,
            en: '_Object',
            ti: 'AnyType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'MultiCurveDomainType',
        bti: '.DomainSetType'
      }, {
        ln: 'LinearCSType',
        bti: '.AbstractCoordinateSystemType'
      }, {
        ln: 'MeasureType',
        ps: [{
            n: 'value',
            ti: 'Double',
            t: 'v'
          }, {
            n: 'uom',
            rq: true,
            an: {
              lp: 'uom'
            },
            t: 'a'
          }]
      }, {
        ln: 'AbstractGeometryType',
        bti: '.AbstractGMLType',
        ps: [{
            n: 'gid',
            an: {
              lp: 'gid'
            },
            t: 'a'
          }, {
            n: 'srsName',
            an: {
              lp: 'srsName'
            },
            t: 'a'
          }, {
            n: 'srsDimension',
            ti: 'PositiveInteger',
            an: {
              lp: 'srsDimension'
            },
            t: 'a'
          }, {
            n: 'axisLabels',
            ti: {
              t: 'l',
              bti: 'NCName'
            },
            an: {
              lp: 'axisLabels'
            },
            t: 'a'
          }, {
            n: 'uomLabels',
            ti: {
              t: 'l',
              bti: 'NCName'
            },
            an: {
              lp: 'uomLabels'
            },
            t: 'a'
          }]
      }, {
        ln: 'TopoPointPropertyType',
        ps: [{
            n: 'topoPoint',
            rq: true,
            en: 'TopoPoint',
            ti: '.TopoPointType'
          }]
      }, {
        ln: 'DerivedUnitType',
        bti: '.UnitDefinitionType',
        ps: [{
            n: 'derivationUnitTerm',
            rq: true,
            col: true,
            ti: '.DerivationUnitTermType'
          }]
      }, {
        ln: 'MultiPointCoverageType',
        bti: '.AbstractDiscreteCoverageType'
      }, {
        ln: 'AbstractTimeComplexType',
        bti: '.AbstractTimeObjectType'
      }, {
        ln: 'SequenceRuleType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'order',
            an: {
              lp: 'order'
            },
            t: 'a'
          }]
      }, {
        ln: 'DirectedObservationAtDistanceType',
        bti: '.DirectedObservationType',
        ps: [{
            n: 'distance',
            rq: true,
            ti: '.MeasureType'
          }]
      }, {
        ln: 'GeographicCRSRefType',
        ps: [{
            n: 'geographicCRS',
            rq: true,
            en: 'GeographicCRS',
            ti: '.GeographicCRSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AbstractFeatureCollectionType',
        bti: '.AbstractFeatureType',
        ps: [{
            n: 'featureMember',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            ti: '.FeaturePropertyType',
            t: 'er'
          }, {
            n: 'featureMembers',
            mx: false,
            dom: false,
            ti: '.FeatureArrayPropertyType',
            t: 'er'
          }]
      }, {
        ln: 'MultiPointType',
        bti: '.AbstractGeometricAggregateType',
        ps: [{
            n: 'pointMember',
            mno: 0,
            col: true,
            ti: '.PointPropertyType'
          }, {
            n: 'pointMembers',
            ti: '.PointArrayPropertyType'
          }]
      }, {
        ln: 'VerticalDatumTypeType',
        bti: '.CodeType'
      }, {
        ln: 'BaseUnitType',
        bti: '.UnitDefinitionType',
        ps: [{
            n: 'unitsSystem',
            rq: true,
            ti: '.ReferenceType'
          }]
      }, {
        ln: 'MultiLineStringPropertyType',
        ps: [{
            n: 'multiLineString',
            rq: true,
            en: 'MultiLineString',
            ti: '.MultiLineStringType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TimeGeometricPrimitivePropertyType',
        ps: [{
            n: 'timeGeometricPrimitive',
            rq: true,
            mx: false,
            dom: false,
            en: '_TimeGeometricPrimitive',
            ti: '.AbstractTimeGeometricPrimitiveType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TriangulatedSurfaceType',
        bti: '.SurfaceType'
      }, {
        ln: 'RangeParametersType',
        ps: [{
            n: '_boolean',
            rq: true,
            en: 'Boolean',
            ti: 'Boolean'
          }, {
            n: 'category',
            rq: true,
            en: 'Category',
            ti: '.CodeType'
          }, {
            n: 'quantity',
            rq: true,
            en: 'Quantity',
            ti: '.MeasureType'
          }, {
            n: 'count',
            rq: true,
            en: 'Count',
            ti: 'Integer'
          }, {
            n: 'booleanList',
            rq: true,
            en: 'BooleanList',
            ti: {
              t: 'l'
            }
          }, {
            n: 'categoryList',
            rq: true,
            en: 'CategoryList',
            ti: '.CodeOrNullListType'
          }, {
            n: 'quantityList',
            rq: true,
            en: 'QuantityList',
            ti: '.MeasureOrNullListType'
          }, {
            n: 'countList',
            rq: true,
            en: 'CountList',
            ti: {
              t: 'l'
            }
          }, {
            n: 'categoryExtent',
            rq: true,
            en: 'CategoryExtent',
            ti: '.CategoryExtentType'
          }, {
            n: 'quantityExtent',
            rq: true,
            en: 'QuantityExtent',
            ti: '.QuantityExtentType'
          }, {
            n: 'countExtent',
            rq: true,
            en: 'CountExtent',
            ti: {
              t: 'l'
            }
          }, {
            n: 'compositeValue',
            rq: true,
            mx: false,
            dom: false,
            en: 'CompositeValue',
            ti: '.CompositeValueType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TriangleType',
        bti: '.AbstractSurfacePatchType',
        ps: [{
            n: 'exterior',
            rq: true,
            mx: false,
            dom: false,
            ti: '.AbstractRingPropertyType',
            t: 'er'
          }, {
            n: 'interpolation',
            an: {
              lp: 'interpolation'
            },
            t: 'a'
          }]
      }, {
        ln: 'AbstractReferenceSystemType',
        bti: '.AbstractReferenceSystemBaseType',
        ps: [{
            n: 'srsID',
            mno: 0,
            col: true,
            ti: '.IdentifierType'
          }, {
            n: 'remarks',
            ti: '.StringOrRefType'
          }, {
            n: 'validArea',
            ti: '.ExtentType'
          }, {
            n: 'scope'
          }]
      }, {
        ln: 'TimePositionType',
        ps: [{
            n: 'value',
            ti: {
              t: 'l'
            },
            t: 'v'
          }, {
            n: 'frame',
            an: {
              lp: 'frame'
            },
            t: 'a'
          }, {
            n: 'calendarEraName',
            an: {
              lp: 'calendarEraName'
            },
            t: 'a'
          }, {
            n: 'indeterminatePosition',
            an: {
              lp: 'indeterminatePosition'
            },
            t: 'a'
          }]
      }, {
        ln: 'FeaturePropertyType',
        ps: [{
            n: 'feature',
            rq: true,
            mx: false,
            en: '_Feature',
            ti: '.AbstractFeatureType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TimeOrdinalEraType',
        bti: '.DefinitionType',
        ps: [{
            n: 'relatedTime',
            mno: 0,
            col: true,
            ti: '.RelatedTimeType'
          }, {
            n: 'start',
            rq: true,
            ti: '.TimeNodePropertyType'
          }, {
            n: 'end',
            rq: true,
            ti: '.TimeNodePropertyType'
          }, {
            n: 'extent',
            ti: '.TimePeriodPropertyType'
          }, {
            n: 'member',
            mno: 0,
            col: true,
            ti: '.TimeOrdinalEraPropertyType'
          }, {
            n: 'group',
            ti: '.ReferenceType'
          }]
      }, {
        ln: 'RelativeInternalPositionalAccuracyType',
        bti: '.AbstractPositionalAccuracyType',
        ps: [{
            n: 'result',
            rq: true,
            ti: '.MeasureType'
          }]
      }, {
        ln: 'CurvePropertyType',
        ps: [{
            n: 'curve',
            rq: true,
            mx: false,
            dom: false,
            en: '_Curve',
            ti: '.AbstractCurveType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'OperationParameterGroupType',
        bti: '.OperationParameterGroupBaseType',
        ps: [{
            n: 'groupID',
            mno: 0,
            col: true,
            ti: '.IdentifierType'
          }, {
            n: 'remarks',
            ti: '.StringOrRefType'
          }, {
            n: 'maximumOccurs',
            ti: 'PositiveInteger'
          }, {
            n: 'includesParameter',
            rq: true,
            mno: 2,
            col: true,
            ti: '.AbstractGeneralOperationParameterRefType'
          }]
      }, {
        ln: 'LineStringSegmentType',
        bti: '.AbstractCurveSegmentType',
        ps: [{
            n: 'posOrPointPropertyOrPointRep',
            rq: true,
            mno: 2,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'pos',
                ti: '.DirectPositionType'
              }, {
                en: 'pointProperty',
                ti: '.PointPropertyType'
              }, {
                en: 'pointRep',
                ti: '.PointPropertyType'
              }],
            t: 'ers'
          }, {
            n: 'posList',
            rq: true,
            ti: '.DirectPositionListType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }, {
            n: 'interpolation',
            an: {
              lp: 'interpolation'
            },
            t: 'a'
          }]
      }, {
        ln: 'TimeCalendarEraType',
        bti: '.DefinitionType',
        ps: [{
            n: 'referenceEvent',
            rq: true,
            ti: '.StringOrRefType'
          }, {
            n: 'referenceDate',
            ti: 'Date'
          }, {
            n: 'julianReference',
            rq: true,
            ti: 'Decimal'
          }, {
            n: 'epochOfUse',
            rq: true,
            ti: '.TimePeriodPropertyType'
          }]
      }, {
        ln: 'EdgeType',
        bti: '.AbstractTopoPrimitiveType',
        ps: [{
            n: 'directedNode',
            rq: true,
            mno: 2,
            mxo: 2,
            col: true,
            ti: '.DirectedNodePropertyType'
          }, {
            n: 'directedFace',
            mno: 0,
            col: true,
            ti: '.DirectedFacePropertyType'
          }, {
            n: 'curveProperty',
            ti: '.CurvePropertyType'
          }]
      }, {
        ln: 'TinType',
        bti: '.TriangulatedSurfaceType',
        ps: [{
            n: 'stopLines',
            mno: 0,
            col: true,
            ti: '.LineStringSegmentArrayPropertyType'
          }, {
            n: 'breakLines',
            mno: 0,
            col: true,
            ti: '.LineStringSegmentArrayPropertyType'
          }, {
            n: 'maxLength',
            rq: true,
            ti: '.LengthType'
          }, {
            n: 'controlPoint',
            rq: true,
            ti: '.TinType.ControlPoint'
          }]
      }, {
        ln: 'NodeType',
        bti: '.AbstractTopoPrimitiveType',
        ps: [{
            n: 'directedEdge',
            mno: 0,
            col: true,
            ti: '.DirectedEdgePropertyType'
          }, {
            n: 'pointProperty',
            ti: '.PointPropertyType'
          }]
      }, {
        ln: 'LineStringSegmentArrayPropertyType',
        ps: [{
            n: 'lineStringSegment',
            mno: 0,
            col: true,
            en: 'LineStringSegment',
            ti: '.LineStringSegmentType'
          }]
      }, {
        ln: 'DirectedFacePropertyType',
        ps: [{
            n: 'face',
            rq: true,
            en: 'Face',
            ti: '.FaceType'
          }, {
            n: 'orientation',
            an: {
              lp: 'orientation'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'StringOrRefType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CoordinateSystemAxisType',
        bti: '.CoordinateSystemAxisBaseType',
        ps: [{
            n: 'axisID',
            mno: 0,
            col: true,
            ti: '.IdentifierType'
          }, {
            n: 'remarks',
            ti: '.StringOrRefType'
          }, {
            n: 'axisAbbrev',
            rq: true,
            ti: '.CodeType'
          }, {
            n: 'axisDirection',
            rq: true,
            ti: '.CodeType'
          }, {
            n: 'uom',
            rq: true,
            an: {
              lp: 'uom',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }]
      }, {
        ln: 'BagType',
        bti: '.AbstractGMLType',
        ps: [{
            n: 'member',
            mno: 0,
            col: true,
            ti: '.AssociationType'
          }, {
            n: 'members',
            ti: '.ArrayAssociationType'
          }]
      }, {
        ln: 'AbstractRingType',
        bti: '.AbstractGeometryType'
      }, {
        ln: 'ParameterValueType',
        bti: '.AbstractGeneralParameterValueType',
        ps: [{
            n: 'value',
            rq: true,
            ti: '.MeasureType'
          }, {
            n: 'dmsAngleValue',
            rq: true,
            ti: '.DMSAngleType'
          }, {
            n: 'stringValue',
            rq: true
          }, {
            n: 'integerValue',
            rq: true,
            ti: 'PositiveInteger'
          }, {
            n: 'booleanValue',
            rq: true,
            ti: 'Boolean'
          }, {
            n: 'valueList',
            rq: true,
            ti: '.MeasureListType'
          }, {
            n: 'integerValueList',
            rq: true,
            ti: {
              t: 'l',
              bti: 'Integer'
            }
          }, {
            n: 'valueFile',
            rq: true
          }, {
            n: 'valueOfParameter',
            rq: true,
            ti: '.OperationParameterRefType'
          }]
      }, {
        ln: 'LabelStyleType',
        bti: '.BaseStyleDescriptorType',
        ps: [{
            n: 'style',
            rq: true
          }, {
            n: 'label',
            rq: true,
            ti: '.LabelType'
          }]
      }, {
        ln: 'DerivedCRSRefType',
        ps: [{
            n: 'derivedCRS',
            rq: true,
            en: 'DerivedCRS',
            ti: '.DerivedCRSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'ConversionRefType',
        ps: [{
            n: 'conversion',
            rq: true,
            en: 'Conversion',
            ti: '.ConversionType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'EngineeringCRSRefType',
        ps: [{
            n: 'engineeringCRS',
            rq: true,
            en: 'EngineeringCRS',
            ti: '.EngineeringCRSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CovarianceMatrixType',
        bti: '.AbstractPositionalAccuracyType',
        ps: [{
            n: 'unitOfMeasure',
            rq: true,
            col: true,
            ti: '.UnitOfMeasureType'
          }, {
            n: 'includesElement',
            rq: true,
            col: true,
            ti: '.CovarianceElementType'
          }]
      }, {
        ln: 'GeocentricCRSType',
        bti: '.AbstractReferenceSystemType',
        ps: [{
            n: 'usesCartesianCS',
            rq: true,
            ti: '.CartesianCSRefType'
          }, {
            n: 'usesSphericalCS',
            rq: true,
            ti: '.SphericalCSRefType'
          }, {
            n: 'usesGeodeticDatum',
            rq: true,
            ti: '.GeodeticDatumRefType'
          }]
      }, {
        ln: 'OperationMethodType',
        bti: '.OperationMethodBaseType',
        ps: [{
            n: 'methodID',
            mno: 0,
            col: true,
            ti: '.IdentifierType'
          }, {
            n: 'remarks',
            ti: '.StringOrRefType'
          }, {
            n: 'methodFormula',
            rq: true,
            ti: '.CodeType'
          }, {
            n: 'sourceDimensions',
            rq: true,
            ti: 'PositiveInteger'
          }, {
            n: 'targetDimensions',
            rq: true,
            ti: 'PositiveInteger'
          }, {
            n: 'usesParameter',
            mno: 0,
            col: true,
            ti: '.AbstractGeneralOperationParameterRefType'
          }]
      }, {
        ln: 'CompositeValueType',
        bti: '.AbstractGMLType',
        ps: [{
            n: 'valueComponent',
            mno: 0,
            col: true,
            ti: '.ValuePropertyType'
          }, {
            n: 'valueComponents',
            ti: '.ValueArrayPropertyType'
          }]
      }, {
        ln: 'PrimeMeridianType',
        bti: '.PrimeMeridianBaseType',
        ps: [{
            n: 'meridianID',
            mno: 0,
            col: true,
            ti: '.IdentifierType'
          }, {
            n: 'remarks',
            ti: '.StringOrRefType'
          }, {
            n: 'greenwichLongitude',
            rq: true,
            ti: '.AngleChoiceType'
          }]
      }, {
        ln: 'AbstractFeatureType',
        bti: '.AbstractGMLType',
        ps: [{
            n: 'boundedBy',
            ti: '.BoundingShapeType'
          }, {
            n: 'location',
            mx: false,
            dom: false,
            ti: '.LocationPropertyType',
            t: 'er'
          }]
      }, {
        ln: 'MultiPolygonPropertyType',
        ps: [{
            n: 'multiPolygon',
            rq: true,
            en: 'MultiPolygon',
            ti: '.MultiPolygonType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TimeClockType',
        bti: '.AbstractTimeReferenceSystemType',
        ps: [{
            n: 'referenceEvent',
            rq: true,
            ti: '.StringOrRefType'
          }, {
            n: 'referenceTime',
            rq: true,
            ti: 'Time'
          }, {
            n: 'utcReference',
            rq: true,
            ti: 'Time'
          }, {
            n: 'dateBasis',
            mno: 0,
            col: true,
            ti: '.TimeCalendarPropertyType'
          }]
      }, {
        ln: 'GridLimitsType',
        ps: [{
            n: 'gridEnvelope',
            rq: true,
            en: 'GridEnvelope',
            ti: '.GridEnvelopeType'
          }]
      }, {
        ln: 'DMSAngleType',
        ps: [{
            n: 'degrees',
            rq: true,
            ti: '.DegreesType'
          }, {
            n: 'decimalMinutes',
            rq: true,
            ti: 'Decimal'
          }, {
            n: 'minutes',
            rq: true,
            ti: 'NonNegativeInteger'
          }, {
            n: 'seconds',
            ti: 'Decimal'
          }]
      }, {
        ln: 'CoordinateReferenceSystemRefType',
        ps: [{
            n: 'coordinateReferenceSystem',
            rq: true,
            mx: false,
            dom: false,
            en: '_CoordinateReferenceSystem',
            ti: '.AbstractReferenceSystemType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AbstractContinuousCoverageType',
        bti: '.AbstractCoverageType',
        ps: [{
            n: 'coverageFunction',
            ti: '.CoverageFunctionType'
          }]
      }, {
        ln: 'UnitDefinitionType',
        bti: '.DefinitionType',
        ps: [{
            n: 'quantityType',
            rq: true,
            ti: '.StringOrRefType'
          }, {
            n: 'catalogSymbol',
            ti: '.CodeType'
          }]
      }, {
        ln: 'ReferenceSystemRefType',
        ps: [{
            n: 'referenceSystem',
            rq: true,
            mx: false,
            dom: false,
            en: '_ReferenceSystem',
            ti: '.AbstractReferenceSystemType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'ArcStringType',
        bti: '.AbstractCurveSegmentType',
        ps: [{
            n: 'posOrPointPropertyOrPointRep',
            rq: true,
            mno: 3,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'pos',
                ti: '.DirectPositionType'
              }, {
                en: 'pointProperty',
                ti: '.PointPropertyType'
              }, {
                en: 'pointRep',
                ti: '.PointPropertyType'
              }],
            t: 'ers'
          }, {
            n: 'posList',
            rq: true,
            ti: '.DirectPositionListType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }, {
            n: 'interpolation',
            an: {
              lp: 'interpolation'
            },
            t: 'a'
          }, {
            n: 'numArc',
            ti: 'Integer',
            an: {
              lp: 'numArc'
            },
            t: 'a'
          }]
      }, {
        ln: 'LinearRingPropertyType',
        ps: [{
            n: 'linearRing',
            rq: true,
            en: 'LinearRing',
            ti: '.LinearRingType'
          }]
      }, {
        ln: 'TimeCalendarType',
        bti: '.AbstractTimeReferenceSystemType',
        ps: [{
            n: 'referenceFrame',
            rq: true,
            col: true,
            ti: '.TimeCalendarEraPropertyType'
          }]
      }, {
        ln: 'PrimeMeridianBaseType',
        bti: '.DefinitionType'
      }, {
        ln: 'RingPropertyType',
        ps: [{
            n: 'ring',
            rq: true,
            en: 'Ring',
            ti: '.RingType'
          }]
      }, {
        ln: 'MultiSurfaceType',
        bti: '.AbstractGeometricAggregateType',
        ps: [{
            n: 'surfaceMember',
            mno: 0,
            col: true,
            ti: '.SurfacePropertyType'
          }, {
            n: 'surfaceMembers',
            ti: '.SurfaceArrayPropertyType'
          }]
      }, {
        ln: 'StyleType',
        bti: '.AbstractStyleType',
        ps: [{
            n: 'featureStyle',
            rq: true,
            col: true,
            ti: '.FeatureStylePropertyType'
          }, {
            n: 'graphStyle',
            ti: '.GraphStylePropertyType'
          }]
      }, {
        ln: 'FeatureStyleType',
        bti: '.AbstractGMLType',
        ps: [{
            n: 'featureConstraint'
          }, {
            n: 'geometryStyle',
            mno: 0,
            col: true,
            ti: '.GeometryStylePropertyType'
          }, {
            n: 'topologyStyle',
            mno: 0,
            col: true,
            ti: '.TopologyStylePropertyType'
          }, {
            n: 'labelStyle',
            ti: '.LabelStylePropertyType'
          }, {
            n: 'featureType',
            an: {
              lp: 'featureType'
            },
            t: 'a'
          }, {
            n: 'baseType',
            an: {
              lp: 'baseType'
            },
            t: 'a'
          }, {
            n: 'queryGrammar',
            an: {
              lp: 'queryGrammar'
            },
            t: 'a'
          }]
      }, {
        ln: 'MultiSolidType',
        bti: '.AbstractGeometricAggregateType',
        ps: [{
            n: 'solidMember',
            mno: 0,
            col: true,
            ti: '.SolidPropertyType'
          }, {
            n: 'solidMembers',
            ti: '.SolidArrayPropertyType'
          }]
      }, {
        ln: 'PolygonPropertyType',
        ps: [{
            n: 'polygon',
            rq: true,
            en: 'Polygon',
            ti: '.PolygonType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CategoryPropertyType',
        bti: '.ValuePropertyType'
      }, {
        ln: 'DataBlockType',
        ps: [{
            n: 'rangeParameters',
            rq: true,
            ti: '.RangeParametersType'
          }, {
            n: 'tupleList',
            rq: true,
            ti: '.CoordinatesType'
          }, {
            n: 'doubleOrNullTupleList',
            rq: true,
            ti: {
              t: 'l'
            }
          }]
      }, {
        ln: 'EnvelopeWithTimePeriodType',
        bti: '.EnvelopeType',
        ps: [{
            n: 'timePosition',
            rq: true,
            mno: 2,
            mxo: 2,
            col: true,
            ti: '.TimePositionType'
          }, {
            n: 'frame',
            an: {
              lp: 'frame'
            },
            t: 'a'
          }]
      }, {
        ln: 'OperationMethodRefType',
        ps: [{
            n: 'operationMethod',
            rq: true,
            en: 'OperationMethod',
            ti: '.OperationMethodType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'MultiPointDomainType',
        bti: '.DomainSetType'
      }, {
        ln: 'AbstractCoverageType',
        bti: '.AbstractFeatureType',
        ps: [{
            n: 'domainSet',
            rq: true,
            mx: false,
            dom: false,
            ti: '.DomainSetType',
            t: 'er'
          }, {
            n: 'rangeSet',
            rq: true,
            ti: '.RangeSetType'
          }, {
            n: 'dimension',
            ti: 'PositiveInteger',
            an: {
              lp: 'dimension'
            },
            t: 'a'
          }]
      }, {
        ln: 'GridEnvelopeType',
        ps: [{
            n: 'low',
            rq: true,
            ti: {
              t: 'l',
              bti: 'Integer'
            }
          }, {
            n: 'high',
            rq: true,
            ti: {
              t: 'l',
              bti: 'Integer'
            }
          }]
      }, {
        ln: 'PolarCSType',
        bti: '.AbstractCoordinateSystemType'
      }, {
        ln: 'GeometricComplexType',
        bti: '.AbstractGeometryType',
        ps: [{
            n: 'element',
            rq: true,
            col: true,
            ti: '.GeometricPrimitivePropertyType'
          }]
      }, {
        ln: 'LineStringType',
        bti: '.AbstractCurveType',
        ps: [{
            n: 'posOrPointPropertyOrPointRep',
            rq: true,
            mno: 2,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'coord',
                ti: '.CoordType'
              }, {
                en: 'pos',
                ti: '.DirectPositionType'
              }, {
                en: 'pointProperty',
                ti: '.PointPropertyType'
              }, {
                en: 'pointRep',
                ti: '.PointPropertyType'
              }],
            t: 'ers'
          }, {
            n: 'posList',
            rq: true,
            ti: '.DirectPositionListType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }]
      }, {
        ln: 'ContainerPropertyType',
        ps: [{
            n: 'face',
            rq: true,
            en: 'Face',
            ti: '.FaceType'
          }, {
            n: 'topoSolid',
            rq: true,
            en: 'TopoSolid',
            ti: '.TopoSolidType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'GridType',
        bti: '.AbstractGeometryType',
        ps: [{
            n: 'limits',
            rq: true,
            ti: '.GridLimitsType'
          }, {
            n: 'axisName',
            rq: true,
            col: true
          }, {
            n: 'dimension',
            rq: true,
            ti: 'PositiveInteger',
            an: {
              lp: 'dimension'
            },
            t: 'a'
          }]
      }, {
        ln: 'ScalarValuePropertyType',
        bti: '.ValuePropertyType'
      }, {
        ln: 'AbstractGriddedSurfaceType',
        bti: '.AbstractParametricCurveSurfaceType',
        ps: [{
            n: 'row',
            rq: true,
            col: true,
            ti: '.AbstractGriddedSurfaceType.Row'
          }, {
            n: 'rows',
            ti: 'Integer'
          }, {
            n: 'columns',
            ti: 'Integer'
          }]
      }, {
        ln: 'TemporalCSType',
        bti: '.AbstractCoordinateSystemType'
      }, {
        ln: 'VerticalCRSType',
        bti: '.AbstractReferenceSystemType',
        ps: [{
            n: 'usesVerticalCS',
            rq: true,
            ti: '.VerticalCSRefType'
          }, {
            n: 'usesVerticalDatum',
            rq: true,
            ti: '.VerticalDatumRefType'
          }]
      }, {
        ln: 'CurveType',
        bti: '.AbstractCurveType',
        ps: [{
            n: 'segments',
            rq: true,
            ti: '.CurveSegmentArrayPropertyType'
          }]
      }, {
        ln: 'MultiGeometryPropertyType',
        ps: [{
            n: 'geometricAggregate',
            rq: true,
            mx: false,
            dom: false,
            en: '_GeometricAggregate',
            ti: '.AbstractGeometricAggregateType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TimeInstantPropertyType',
        ps: [{
            n: 'timeInstant',
            rq: true,
            en: 'TimeInstant',
            ti: '.TimeInstantType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'PriorityLocationPropertyType',
        bti: '.LocationPropertyType',
        ps: [{
            n: 'priority',
            an: {
              lp: 'priority'
            },
            t: 'a'
          }]
      }, {
        ln: 'FormulaType',
        ps: [{
            n: 'a',
            ti: 'Double'
          }, {
            n: 'b',
            rq: true,
            ti: 'Double'
          }, {
            n: 'c',
            rq: true,
            ti: 'Double'
          }, {
            n: 'd',
            ti: 'Double'
          }]
      }, {
        ln: 'CylindricalCSType',
        bti: '.AbstractCoordinateSystemType'
      }, {
        ln: 'DirectedEdgePropertyType',
        ps: [{
            n: 'edge',
            rq: true,
            en: 'Edge',
            ti: '.EdgeType'
          }, {
            n: 'orientation',
            an: {
              lp: 'orientation'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AbstractGeometricPrimitiveType',
        bti: '.AbstractGeometryType'
      }, {
        ln: 'PassThroughOperationType',
        bti: '.AbstractCoordinateOperationType',
        ps: [{
            n: 'modifiedCoordinate',
            rq: true,
            col: true,
            ti: 'PositiveInteger'
          }, {
            n: 'usesOperation',
            rq: true,
            ti: '.OperationRefType'
          }]
      }, {
        ln: 'ArcType',
        bti: '.ArcStringType'
      }, {
        ln: 'OrientableSurfaceType',
        bti: '.AbstractSurfaceType',
        ps: [{
            n: 'baseSurface',
            rq: true,
            ti: '.SurfacePropertyType'
          }, {
            n: 'orientation',
            an: {
              lp: 'orientation'
            },
            t: 'a'
          }]
      }, {
        ln: 'UserDefinedCSRefType',
        ps: [{
            n: 'userDefinedCS',
            rq: true,
            en: 'UserDefinedCS',
            ti: '.UserDefinedCSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'ReferenceType',
        ps: [{
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'BooleanPropertyType',
        bti: '.ValuePropertyType'
      }, {
        ln: 'MultiSolidPropertyType',
        ps: [{
            n: 'multiSolid',
            rq: true,
            en: 'MultiSolid',
            ti: '.MultiSolidType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'MultiSurfacePropertyType',
        ps: [{
            n: 'multiSurface',
            rq: true,
            en: 'MultiSurface',
            ti: '.MultiSurfaceType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'ConcatenatedOperationRefType',
        ps: [{
            n: 'concatenatedOperation',
            rq: true,
            en: 'ConcatenatedOperation',
            ti: '.ConcatenatedOperationType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'OffsetCurveType',
        bti: '.AbstractCurveSegmentType',
        ps: [{
            n: 'offsetBase',
            rq: true,
            ti: '.CurvePropertyType'
          }, {
            n: 'distance',
            rq: true,
            ti: '.LengthType'
          }, {
            n: 'refDirection',
            ti: '.VectorType'
          }]
      }, {
        ln: 'TimeOrdinalEraPropertyType',
        ps: [{
            n: 'timeOrdinalEra',
            rq: true,
            en: 'TimeOrdinalEra',
            ti: '.TimeOrdinalEraType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AngleChoiceType',
        ps: [{
            n: 'angle',
            rq: true,
            ti: '.MeasureType'
          }, {
            n: 'dmsAngle',
            rq: true,
            ti: '.DMSAngleType'
          }]
      }, {
        ln: 'MultiGeometryType',
        bti: '.AbstractGeometricAggregateType',
        ps: [{
            n: 'geometryMember',
            mno: 0,
            col: true,
            ti: '.GeometryPropertyType'
          }, {
            n: 'geometryMembers',
            ti: '.GeometryArrayPropertyType'
          }]
      }, {
        ln: 'GridFunctionType',
        ps: [{
            n: 'sequenceRule',
            ti: '.SequenceRuleType'
          }, {
            n: 'startPoint',
            ti: {
              t: 'l',
              bti: 'Integer'
            }
          }]
      }, {
        ln: 'DictionaryEntryType',
        ps: [{
            n: 'definition',
            rq: true,
            mx: false,
            dom: false,
            en: 'Definition',
            ti: '.DefinitionType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'RelatedTimeType',
        bti: '.TimePrimitivePropertyType',
        ps: [{
            n: 'relativePosition',
            an: {
              lp: 'relativePosition'
            },
            t: 'a'
          }]
      }, {
        ln: 'IndirectEntryType',
        ps: [{
            n: 'definitionProxy',
            rq: true,
            en: 'DefinitionProxy',
            ti: '.DefinitionProxyType'
          }]
      }, {
        ln: 'ValuePropertyType',
        ps: [{
            n: '_boolean',
            rq: true,
            en: 'Boolean',
            ti: 'Boolean'
          }, {
            n: 'category',
            rq: true,
            en: 'Category',
            ti: '.CodeType'
          }, {
            n: 'quantity',
            rq: true,
            en: 'Quantity',
            ti: '.MeasureType'
          }, {
            n: 'count',
            rq: true,
            en: 'Count',
            ti: 'Integer'
          }, {
            n: 'booleanList',
            rq: true,
            en: 'BooleanList',
            ti: {
              t: 'l'
            }
          }, {
            n: 'categoryList',
            rq: true,
            en: 'CategoryList',
            ti: '.CodeOrNullListType'
          }, {
            n: 'quantityList',
            rq: true,
            en: 'QuantityList',
            ti: '.MeasureOrNullListType'
          }, {
            n: 'countList',
            rq: true,
            en: 'CountList',
            ti: {
              t: 'l'
            }
          }, {
            n: 'categoryExtent',
            rq: true,
            en: 'CategoryExtent',
            ti: '.CategoryExtentType'
          }, {
            n: 'quantityExtent',
            rq: true,
            en: 'QuantityExtent',
            ti: '.QuantityExtentType'
          }, {
            n: 'countExtent',
            rq: true,
            en: 'CountExtent',
            ti: {
              t: 'l'
            }
          }, {
            n: 'compositeValue',
            rq: true,
            mx: false,
            dom: false,
            en: 'CompositeValue',
            ti: '.CompositeValueType',
            t: 'er'
          }, {
            n: 'object',
            rq: true,
            mx: false,
            dom: false,
            en: '_Object',
            ti: 'AnyType',
            t: 'er'
          }, {
            n: '_null',
            rq: true,
            en: 'Null',
            ti: {
              t: 'l'
            }
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AbstractCoordinateSystemType',
        bti: '.AbstractCoordinateSystemBaseType',
        ps: [{
            n: 'csID',
            mno: 0,
            col: true,
            ti: '.IdentifierType'
          }, {
            n: 'remarks',
            ti: '.StringOrRefType'
          }, {
            n: 'usesAxis',
            rq: true,
            col: true,
            ti: '.CoordinateSystemAxisRefType'
          }]
      }, {
        ln: 'RectifiedGridType',
        bti: '.GridType',
        ps: [{
            n: 'origin',
            rq: true,
            ti: '.PointPropertyType'
          }, {
            n: 'offsetVector',
            rq: true,
            col: true,
            ti: '.VectorType'
          }]
      }, {
        ln: 'CompositeSolidType',
        bti: '.AbstractSolidType',
        ps: [{
            n: 'solidMember',
            rq: true,
            col: true,
            ti: '.SolidPropertyType'
          }]
      }, {
        ln: 'AbstractPositionalAccuracyType',
        ps: [{
            n: 'measureDescription',
            ti: '.CodeType'
          }]
      }, {
        ln: 'MultiPolygonType',
        bti: '.AbstractGeometricAggregateType',
        ps: [{
            n: 'polygonMember',
            mno: 0,
            col: true,
            ti: '.PolygonPropertyType'
          }]
      }, {
        ln: 'CovarianceElementType',
        ps: [{
            n: 'rowIndex',
            rq: true,
            ti: 'PositiveInteger'
          }, {
            n: 'columnIndex',
            rq: true,
            ti: 'PositiveInteger'
          }, {
            n: 'covariance',
            rq: true,
            ti: 'Double'
          }]
      }, {
        ln: 'DirectPositionListType',
        ps: [{
            n: 'value',
            ti: {
              t: 'l',
              bti: 'Double'
            },
            t: 'v'
          }, {
            n: 'count',
            ti: 'PositiveInteger',
            an: {
              lp: 'count'
            },
            t: 'a'
          }, {
            n: 'srsName',
            an: {
              lp: 'srsName'
            },
            t: 'a'
          }, {
            n: 'srsDimension',
            ti: 'PositiveInteger',
            an: {
              lp: 'srsDimension'
            },
            t: 'a'
          }, {
            n: 'axisLabels',
            ti: {
              t: 'l',
              bti: 'NCName'
            },
            an: {
              lp: 'axisLabels'
            },
            t: 'a'
          }, {
            n: 'uomLabels',
            ti: {
              t: 'l',
              bti: 'NCName'
            },
            an: {
              lp: 'uomLabels'
            },
            t: 'a'
          }]
      }, {
        ln: 'ObliqueCartesianCSRefType',
        ps: [{
            n: 'obliqueCartesianCS',
            rq: true,
            en: 'ObliqueCartesianCS',
            ti: '.ObliqueCartesianCSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CartesianCSType',
        bti: '.AbstractCoordinateSystemType'
      }, {
        ln: 'ObliqueCartesianCSType',
        bti: '.AbstractCoordinateSystemType'
      }, {
        ln: 'DynamicFeatureCollectionType',
        bti: '.FeatureCollectionType',
        ps: [{
            n: 'validTime',
            ti: '.TimePrimitivePropertyType'
          }, {
            n: 'history',
            mx: false,
            dom: false,
            ti: '.HistoryPropertyType',
            t: 'er'
          }, {
            n: 'dataSource',
            ti: '.StringOrRefType'
          }]
      }, {
        ln: 'ImageDatumRefType',
        ps: [{
            n: 'imageDatum',
            rq: true,
            en: 'ImageDatum',
            ti: '.ImageDatumType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'OperationParameterBaseType',
        bti: '.AbstractGeneralOperationParameterType'
      }, {
        ln: 'UserDefinedCSType',
        bti: '.AbstractCoordinateSystemType'
      }, {
        ln: 'PolygonPatchArrayPropertyType',
        bti: '.SurfacePatchArrayPropertyType'
      }, {
        ln: 'TemporalDatumType',
        bti: '.TemporalDatumBaseType',
        ps: [{
            n: 'origin',
            rq: true,
            ti: 'DateTime'
          }]
      }, {
        ln: 'QuantityPropertyType',
        bti: '.ValuePropertyType'
      }, {
        ln: 'DirectionPropertyType',
        ps: [{
            n: 'directionVector',
            rq: true,
            en: 'DirectionVector',
            ti: '.DirectionVectorType'
          }, {
            n: 'compassPoint',
            rq: true,
            en: 'CompassPoint'
          }, {
            n: 'directionKeyword',
            rq: true,
            en: 'DirectionKeyword',
            ti: '.CodeType'
          }, {
            n: 'directionString',
            rq: true,
            en: 'DirectionString',
            ti: '.StringOrRefType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'PolyhedralSurfaceType',
        bti: '.SurfaceType'
      }, {
        ln: 'CompositeCurveType',
        bti: '.AbstractCurveType',
        ps: [{
            n: 'curveMember',
            rq: true,
            col: true,
            ti: '.CurvePropertyType'
          }]
      }, {
        ln: 'TemporalDatumRefType',
        ps: [{
            n: 'temporalDatum',
            rq: true,
            en: 'TemporalDatum',
            ti: '.TemporalDatumType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TransformationType',
        bti: '.AbstractGeneralTransformationType',
        ps: [{
            n: 'usesMethod',
            rq: true,
            ti: '.OperationMethodRefType'
          }, {
            n: 'usesValue',
            mno: 0,
            col: true,
            ti: '.ParameterValueType'
          }]
      }, {
        ln: 'AbstractDiscreteCoverageType',
        bti: '.AbstractCoverageType',
        ps: [{
            n: 'coverageFunction',
            ti: '.CoverageFunctionType'
          }]
      }, {
        ln: 'MetaDataPropertyType',
        ps: [{
            n: 'any',
            rq: true,
            mx: false,
            t: 'ae'
          }, {
            n: 'about',
            an: {
              lp: 'about'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AbstractDatumType',
        bti: '.AbstractDatumBaseType',
        ps: [{
            n: 'datumID',
            mno: 0,
            col: true,
            ti: '.IdentifierType'
          }, {
            n: 'remarks',
            ti: '.StringOrRefType'
          }, {
            n: 'anchorPoint',
            ti: '.CodeType'
          }, {
            n: 'realizationEpoch',
            ti: 'Date'
          }, {
            n: 'validArea',
            ti: '.ExtentType'
          }, {
            n: 'scope'
          }]
      }, {
        ln: 'FeatureArrayPropertyType',
        ps: [{
            n: 'feature',
            mno: 0,
            col: true,
            mx: false,
            en: '_Feature',
            ti: '.AbstractFeatureType',
            t: 'er'
          }]
      }, {
        ln: 'AbstractCurveSegmentType',
        ps: [{
            n: 'numDerivativesAtStart',
            ti: 'Integer',
            an: {
              lp: 'numDerivativesAtStart'
            },
            t: 'a'
          }, {
            n: 'numDerivativesAtEnd',
            ti: 'Integer',
            an: {
              lp: 'numDerivativesAtEnd'
            },
            t: 'a'
          }, {
            n: 'numDerivativeInterior',
            ti: 'Integer',
            an: {
              lp: 'numDerivativeInterior'
            },
            t: 'a'
          }]
      }, {
        ln: 'EngineeringDatumRefType',
        ps: [{
            n: 'engineeringDatum',
            rq: true,
            en: 'EngineeringDatum',
            ti: '.EngineeringDatumType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'EllipsoidBaseType',
        bti: '.DefinitionType'
      }, {
        ln: 'CompoundCRSRefType',
        ps: [{
            n: 'compoundCRS',
            rq: true,
            en: 'CompoundCRS',
            ti: '.CompoundCRSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TimeTopologyComplexType',
        bti: '.AbstractTimeComplexType',
        ps: [{
            n: 'primitive',
            rq: true,
            col: true,
            ti: '.TimeTopologyPrimitivePropertyType'
          }]
      }, {
        ln: 'AbstractCoordinateOperationType',
        bti: '.AbstractCoordinateOperationBaseType',
        ps: [{
            n: 'coordinateOperationID',
            mno: 0,
            col: true,
            ti: '.IdentifierType'
          }, {
            n: 'remarks',
            ti: '.StringOrRefType'
          }, {
            n: 'operationVersion'
          }, {
            n: 'validArea',
            ti: '.ExtentType'
          }, {
            n: 'scope'
          }, {
            n: 'positionalAccuracy',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: '_positionalAccuracy',
            ti: '.AbstractPositionalAccuracyType',
            t: 'er'
          }, {
            n: 'sourceCRS',
            ti: '.CRSRefType'
          }, {
            n: 'targetCRS',
            ti: '.CRSRefType'
          }]
      }, {
        ln: 'AbstractCoordinateSystemBaseType',
        bti: '.DefinitionType'
      }, {
        ln: 'BezierType',
        bti: '.BSplineType'
      }, {
        ln: 'GraphStylePropertyType',
        ps: [{
            n: 'graphStyle',
            en: 'GraphStyle',
            ti: '.GraphStyleType'
          }, {
            n: 'about',
            an: {
              lp: 'about'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CountPropertyType',
        bti: '.ValuePropertyType'
      }, {
        ln: 'ClothoidType.RefLocation',
        tn: null,
        ps: [{
            n: 'affinePlacement',
            rq: true,
            en: 'AffinePlacement',
            ti: '.AffinePlacementType'
          }]
      }, {
        ln: 'TargetPropertyType',
        ps: [{
            n: 'feature',
            rq: true,
            mx: false,
            en: '_Feature',
            ti: '.AbstractFeatureType',
            t: 'er'
          }, {
            n: 'geometry',
            rq: true,
            mx: false,
            dom: false,
            en: '_Geometry',
            ti: '.AbstractGeometryType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CircleByCenterPointType',
        bti: '.ArcByCenterPointType'
      }, {
        ln: 'TimeType',
        bti: '.MeasureType'
      }, {
        ln: 'CartesianCSRefType',
        ps: [{
            n: 'cartesianCS',
            rq: true,
            en: 'CartesianCS',
            ti: '.CartesianCSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'DerivedCRSType',
        bti: '.AbstractGeneralDerivedCRSType',
        ps: [{
            n: 'derivedCRSType',
            rq: true,
            ti: '.DerivedCRSTypeType'
          }, {
            n: 'usesCS',
            rq: true,
            ti: '.CoordinateSystemRefType'
          }]
      }, {
        ln: 'TemporalCSRefType',
        ps: [{
            n: 'temporalCS',
            rq: true,
            en: 'TemporalCS',
            ti: '.TemporalCSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'OperationParameterRefType',
        ps: [{
            n: 'operationParameter',
            rq: true,
            en: 'OperationParameter',
            ti: '.OperationParameterType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'QuantityExtentType',
        bti: '.MeasureOrNullListType'
      }, {
        ln: 'AbstractGeneralDerivedCRSType',
        bti: '.AbstractReferenceSystemType',
        ps: [{
            n: 'baseCRS',
            rq: true,
            ti: '.CoordinateReferenceSystemRefType'
          }, {
            n: 'definedByConversion',
            rq: true,
            ti: '.GeneralConversionRefType'
          }]
      }, {
        ln: 'MultiSurfaceDomainType',
        bti: '.DomainSetType'
      }, {
        ln: 'GeometryPropertyType',
        ps: [{
            n: 'geometry',
            rq: true,
            mx: false,
            dom: false,
            en: '_Geometry',
            ti: '.AbstractGeometryType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'OperationParameterGroupRefType',
        ps: [{
            n: 'operationParameterGroup',
            rq: true,
            en: 'OperationParameterGroup',
            ti: '.OperationParameterGroupType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CubicSplineType',
        bti: '.AbstractCurveSegmentType',
        ps: [{
            n: 'posOrPointPropertyOrPointRep',
            rq: true,
            mno: 2,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'pos',
                ti: '.DirectPositionType'
              }, {
                en: 'pointProperty',
                ti: '.PointPropertyType'
              }, {
                en: 'pointRep',
                ti: '.PointPropertyType'
              }],
            t: 'ers'
          }, {
            n: 'posList',
            rq: true,
            ti: '.DirectPositionListType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }, {
            n: 'vectorAtStart',
            rq: true,
            ti: '.VectorType'
          }, {
            n: 'vectorAtEnd',
            rq: true,
            ti: '.VectorType'
          }, {
            n: 'interpolation',
            an: {
              lp: 'interpolation'
            },
            t: 'a'
          }, {
            n: 'degree',
            ti: 'Integer',
            an: {
              lp: 'degree'
            },
            t: 'a'
          }]
      }, {
        ln: 'AbstractGeometricAggregateType',
        bti: '.AbstractGeometryType'
      }, {
        ln: 'PassThroughOperationRefType',
        ps: [{
            n: 'passThroughOperation',
            rq: true,
            en: 'PassThroughOperation',
            ti: '.PassThroughOperationType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'IndexMapType',
        bti: '.GridFunctionType',
        ps: [{
            n: 'lookUpTable',
            rq: true,
            ti: {
              t: 'l',
              bti: 'Integer'
            }
          }]
      }, {
        ln: 'VerticalDatumType',
        bti: '.AbstractDatumType',
        ps: [{
            n: 'verticalDatumType',
            ti: '.VerticalDatumTypeType'
          }]
      }, {
        ln: 'TimeEdgeType',
        bti: '.AbstractTimeTopologyPrimitiveType',
        ps: [{
            n: 'start',
            rq: true,
            ti: '.TimeNodePropertyType'
          }, {
            n: 'end',
            rq: true,
            ti: '.TimeNodePropertyType'
          }, {
            n: 'extent',
            ti: '.TimePeriodPropertyType'
          }]
      }, {
        ln: 'AbstractSurfacePatchType'
      }, {
        ln: 'LineStringPropertyType',
        ps: [{
            n: 'lineString',
            rq: true,
            en: 'LineString',
            ti: '.LineStringType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'DirectedTopoSolidPropertyType',
        ps: [{
            n: 'topoSolid',
            rq: true,
            en: 'TopoSolid',
            ti: '.TopoSolidType'
          }, {
            n: 'orientation',
            an: {
              lp: 'orientation'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'OperationRefType',
        ps: [{
            n: 'operation',
            rq: true,
            mx: false,
            dom: false,
            en: '_Operation',
            ti: '.AbstractCoordinateOperationType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TopoComplexType',
        bti: '.AbstractTopologyType',
        ps: [{
            n: 'maximalComplex',
            rq: true,
            ti: '.TopoComplexMemberType'
          }, {
            n: 'superComplex',
            mno: 0,
            col: true,
            ti: '.TopoComplexMemberType'
          }, {
            n: 'subComplex',
            mno: 0,
            col: true,
            ti: '.TopoComplexMemberType'
          }, {
            n: 'topoPrimitiveMember',
            mno: 0,
            col: true,
            ti: '.TopoPrimitiveMemberType'
          }, {
            n: 'topoPrimitiveMembers',
            ti: '.TopoPrimitiveArrayAssociationType'
          }, {
            n: 'isMaximal',
            ti: 'Boolean',
            an: {
              lp: 'isMaximal'
            },
            t: 'a'
          }]
      }, {
        ln: 'TimeIntervalLengthType',
        ps: [{
            n: 'value',
            ti: 'Decimal',
            t: 'v'
          }, {
            n: 'unit',
            rq: true,
            an: {
              lp: 'unit'
            },
            t: 'a'
          }, {
            n: 'radix',
            ti: 'PositiveInteger',
            an: {
              lp: 'radix'
            },
            t: 'a'
          }, {
            n: 'factor',
            ti: 'Integer',
            an: {
              lp: 'factor'
            },
            t: 'a'
          }]
      }, {
        ln: 'MeasureListType',
        ps: [{
            n: 'value',
            ti: {
              t: 'l',
              bti: 'Double'
            },
            t: 'v'
          }, {
            n: 'uom',
            rq: true,
            an: {
              lp: 'uom'
            },
            t: 'a'
          }]
      }, {
        ln: 'CoordinatesType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'decimal',
            an: {
              lp: 'decimal'
            },
            t: 'a'
          }, {
            n: 'cs',
            an: {
              lp: 'cs'
            },
            t: 'a'
          }, {
            n: 'ts',
            an: {
              lp: 'ts'
            },
            t: 'a'
          }]
      }, {
        ln: 'SingleOperationRefType',
        ps: [{
            n: 'singleOperation',
            rq: true,
            mx: false,
            dom: false,
            en: '_SingleOperation',
            ti: '.AbstractCoordinateOperationType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AreaType',
        bti: '.MeasureType'
      }, {
        ln: 'DatumRefType',
        ps: [{
            n: 'datum',
            rq: true,
            mx: false,
            dom: false,
            en: '_Datum',
            ti: '.AbstractDatumType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'KnotPropertyType',
        ps: [{
            n: 'knot',
            rq: true,
            en: 'Knot',
            ti: '.KnotType'
          }]
      }, {
        ln: 'ClothoidType',
        bti: '.AbstractCurveSegmentType',
        ps: [{
            n: 'refLocation',
            rq: true,
            ti: '.ClothoidType.RefLocation'
          }, {
            n: 'scaleFactor',
            rq: true,
            ti: 'Decimal'
          }, {
            n: 'startParameter',
            rq: true,
            ti: 'Double'
          }, {
            n: 'endParameter',
            rq: true,
            ti: 'Double'
          }]
      }, {
        ln: 'AffinePlacementType',
        ps: [{
            n: 'location',
            rq: true,
            ti: '.DirectPositionType'
          }, {
            n: 'refDirection',
            rq: true,
            col: true,
            ti: '.VectorType'
          }, {
            n: 'inDimension',
            rq: true,
            ti: 'PositiveInteger'
          }, {
            n: 'outDimension',
            rq: true,
            ti: 'PositiveInteger'
          }]
      }, {
        ln: 'CompoundCRSType',
        bti: '.AbstractReferenceSystemType',
        ps: [{
            n: 'includesCRS',
            rq: true,
            mno: 2,
            col: true,
            ti: '.CoordinateReferenceSystemRefType'
          }]
      }, {
        ln: 'CoordinateOperationRefType',
        ps: [{
            n: 'coordinateOperation',
            rq: true,
            mx: false,
            dom: false,
            en: '_CoordinateOperation',
            ti: '.AbstractCoordinateOperationType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'DomainSetType',
        ps: [{
            n: 'geometry',
            rq: true,
            mx: false,
            dom: false,
            en: '_Geometry',
            ti: '.AbstractGeometryType',
            t: 'er'
          }, {
            n: 'timeObject',
            rq: true,
            mx: false,
            dom: false,
            en: '_TimeObject',
            ti: '.AbstractTimeObjectType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'EllipsoidRefType',
        ps: [{
            n: 'ellipsoid',
            rq: true,
            en: 'Ellipsoid',
            ti: '.EllipsoidType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TimeClockPropertyType',
        ps: [{
            n: 'timeClock',
            rq: true,
            en: 'TimeClock',
            ti: '.TimeClockType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AbstractCoordinateOperationBaseType',
        bti: '.DefinitionType'
      }, {
        ln: 'RectangleType',
        bti: '.AbstractSurfacePatchType',
        ps: [{
            n: 'exterior',
            rq: true,
            mx: false,
            dom: false,
            ti: '.AbstractRingPropertyType',
            t: 'er'
          }, {
            n: 'interpolation',
            an: {
              lp: 'interpolation'
            },
            t: 'a'
          }]
      }, {
        ln: 'RangeSetType',
        ps: [{
            n: 'valueArray',
            rq: true,
            col: true,
            en: 'ValueArray',
            ti: '.ValueArrayType'
          }, {
            n: 'scalarValueList',
            rq: true,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'CategoryList',
                ti: '.CodeOrNullListType'
              }, {
                en: 'CountList',
                ti: {
                  t: 'l'
                }
              }, {
                en: 'QuantityList',
                ti: '.MeasureOrNullListType'
              }, {
                en: 'BooleanList',
                ti: {
                  t: 'l'
                }
              }],
            t: 'ers'
          }, {
            n: 'dataBlock',
            rq: true,
            en: 'DataBlock',
            ti: '.DataBlockType'
          }, {
            n: 'file',
            rq: true,
            en: 'File',
            ti: '.FileType'
          }]
      }, {
        ln: 'AbstractSurfaceType',
        bti: '.AbstractGeometricPrimitiveType'
      }, {
        ln: 'VerticalDatumRefType',
        ps: [{
            n: 'verticalDatum',
            rq: true,
            en: 'VerticalDatum',
            ti: '.VerticalDatumType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'RectifiedGridDomainType',
        bti: '.DomainSetType'
      }, {
        ln: 'SymbolType',
        ps: [{
            n: 'any',
            mno: 0,
            col: true,
            typed: false,
            mx: false,
            t: 'ae'
          }, {
            n: 'symbolType',
            rq: true,
            an: {
              lp: 'symbolType'
            },
            t: 'a'
          }, {
            n: 'transform',
            an: {
              lp: 'transform',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'about',
            an: {
              lp: 'about'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'GenericMetaDataType',
        bti: '.AbstractMetaDataType',
        ps: [{
            n: 'contentOverrideForGenericMetaDataType',
            t: 'ae'
          }]
      }, {
        ln: 'VerticalCSRefType',
        ps: [{
            n: 'verticalCS',
            rq: true,
            en: 'VerticalCS',
            ti: '.VerticalCSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TopoSurfaceType',
        bti: '.AbstractTopologyType',
        ps: [{
            n: 'directedFace',
            rq: true,
            col: true,
            ti: '.DirectedFacePropertyType'
          }]
      }, {
        ln: 'LocationPropertyType',
        ps: [{
            n: 'geometry',
            rq: true,
            mx: false,
            dom: false,
            en: '_Geometry',
            ti: '.AbstractGeometryType',
            t: 'er'
          }, {
            n: 'locationKeyWord',
            rq: true,
            en: 'LocationKeyWord',
            ti: '.CodeType'
          }, {
            n: 'locationString',
            rq: true,
            en: 'LocationString',
            ti: '.StringOrRefType'
          }, {
            n: '_null',
            rq: true,
            en: 'Null',
            ti: {
              t: 'l'
            }
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TopoCurveType',
        bti: '.AbstractTopologyType',
        ps: [{
            n: 'directedEdge',
            rq: true,
            col: true,
            ti: '.DirectedEdgePropertyType'
          }]
      }, {
        ln: 'AbstractParametricCurveSurfaceType',
        bti: '.AbstractSurfacePatchType'
      }, {
        ln: 'LengthType',
        bti: '.MeasureType'
      }, {
        ln: 'GeometricPrimitivePropertyType',
        ps: [{
            n: 'geometricPrimitive',
            rq: true,
            mx: false,
            dom: false,
            en: '_GeometricPrimitive',
            ti: '.AbstractGeometricPrimitiveType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'GeodesicType',
        bti: '.GeodesicStringType'
      }, {
        ln: 'CompositeSolidPropertyType',
        ps: [{
            n: 'compositeSolid',
            rq: true,
            en: 'CompositeSolid',
            ti: '.CompositeSolidType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'OperationMethodBaseType',
        bti: '.DefinitionType'
      }, {
        ln: 'CompositeSurfacePropertyType',
        ps: [{
            n: 'compositeSurface',
            rq: true,
            en: 'CompositeSurface',
            ti: '.CompositeSurfaceType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TimePrimitivePropertyType',
        ps: [{
            n: 'timePrimitive',
            rq: true,
            mx: false,
            dom: false,
            en: '_TimePrimitive',
            ti: '.AbstractTimePrimitiveType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TrianglePatchArrayPropertyType',
        bti: '.SurfacePatchArrayPropertyType'
      }, {
        ln: 'MovingObjectStatusType',
        bti: '.AbstractTimeSliceType',
        ps: [{
            n: 'location',
            rq: true,
            mx: false,
            dom: false,
            ti: '.LocationPropertyType',
            t: 'er'
          }, {
            n: 'speed',
            ti: '.MeasureType'
          }, {
            n: 'bearing',
            ti: '.DirectionPropertyType'
          }, {
            n: 'acceleration',
            ti: '.MeasureType'
          }, {
            n: 'elevation',
            ti: '.MeasureType'
          }, {
            n: 'status',
            ti: '.StringOrRefType'
          }]
      }, {
        ln: 'PrimeMeridianRefType',
        ps: [{
            n: 'primeMeridian',
            rq: true,
            en: 'PrimeMeridian',
            ti: '.PrimeMeridianType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TopologyStylePropertyType',
        ps: [{
            n: 'topologyStyle',
            en: 'TopologyStyle',
            ti: '.TopologyStyleType'
          }, {
            n: 'about',
            an: {
              lp: 'about'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AbstractTopologyType',
        bti: '.AbstractGMLType'
      }, {
        ln: 'PolygonPatchType',
        bti: '.AbstractSurfacePatchType',
        ps: [{
            n: 'exterior',
            mx: false,
            dom: false,
            ti: '.AbstractRingPropertyType',
            t: 'er'
          }, {
            n: 'interior',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            ti: '.AbstractRingPropertyType',
            t: 'er'
          }, {
            n: 'interpolation',
            an: {
              lp: 'interpolation'
            },
            t: 'a'
          }]
      }, {
        ln: 'GeometryStyleType',
        bti: '.BaseStyleDescriptorType',
        ps: [{
            n: 'symbol',
            rq: true,
            ti: '.SymbolType'
          }, {
            n: 'style',
            rq: true
          }, {
            n: 'labelStyle',
            ti: '.LabelStylePropertyType'
          }, {
            n: 'geometryProperty',
            an: {
              lp: 'geometryProperty'
            },
            t: 'a'
          }, {
            n: 'geometryType',
            an: {
              lp: 'geometryType'
            },
            t: 'a'
          }]
      }, {
        ln: 'DirectedNodePropertyType',
        ps: [{
            n: 'node',
            rq: true,
            en: 'Node',
            ti: '.NodeType'
          }, {
            n: 'orientation',
            an: {
              lp: 'orientation'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'GeodesicStringType',
        bti: '.AbstractCurveSegmentType',
        ps: [{
            n: 'posList',
            rq: true,
            ti: '.DirectPositionListType'
          }, {
            n: 'geometricPositionGroup',
            rq: true,
            mno: 2,
            col: true,
            etis: [{
                en: 'pos',
                ti: '.DirectPositionType'
              }, {
                en: 'pointProperty',
                ti: '.PointPropertyType'
              }],
            t: 'es'
          }, {
            n: 'interpolation',
            an: {
              lp: 'interpolation'
            },
            t: 'a'
          }]
      }, {
        ln: 'BSplineType',
        bti: '.AbstractCurveSegmentType',
        ps: [{
            n: 'posOrPointPropertyOrPointRep',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'pos',
                ti: '.DirectPositionType'
              }, {
                en: 'pointProperty',
                ti: '.PointPropertyType'
              }, {
                en: 'pointRep',
                ti: '.PointPropertyType'
              }],
            t: 'ers'
          }, {
            n: 'posList',
            rq: true,
            ti: '.DirectPositionListType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }, {
            n: 'degree',
            rq: true,
            ti: 'NonNegativeInteger'
          }, {
            n: 'knot',
            rq: true,
            mno: 2,
            col: true,
            ti: '.KnotPropertyType'
          }, {
            n: 'interpolation',
            an: {
              lp: 'interpolation'
            },
            t: 'a'
          }, {
            n: 'isPolynomial',
            ti: 'Boolean',
            an: {
              lp: 'isPolynomial'
            },
            t: 'a'
          }, {
            n: 'knotType',
            an: {
              lp: 'knotType'
            },
            t: 'a'
          }]
      }, {
        ln: 'HistoryPropertyType',
        ps: [{
            n: 'timeSlice',
            rq: true,
            col: true,
            mx: false,
            dom: false,
            en: '_TimeSlice',
            ti: '.AbstractTimeSliceType',
            t: 'er'
          }]
      }, {
        ln: 'DirectPositionType',
        ps: [{
            n: 'value',
            ti: {
              t: 'l',
              bti: 'Double'
            },
            t: 'v'
          }, {
            n: 'srsName',
            an: {
              lp: 'srsName'
            },
            t: 'a'
          }, {
            n: 'srsDimension',
            ti: 'PositiveInteger',
            an: {
              lp: 'srsDimension'
            },
            t: 'a'
          }, {
            n: 'axisLabels',
            ti: {
              t: 'l',
              bti: 'NCName'
            },
            an: {
              lp: 'axisLabels'
            },
            t: 'a'
          }, {
            n: 'uomLabels',
            ti: {
              t: 'l',
              bti: 'NCName'
            },
            an: {
              lp: 'uomLabels'
            },
            t: 'a'
          }]
      }, {
        ln: 'SphericalCSRefType',
        ps: [{
            n: 'sphericalCS',
            rq: true,
            en: 'SphericalCS',
            ti: '.SphericalCSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AbstractSolidType',
        bti: '.AbstractGeometricPrimitiveType'
      }, {
        ln: 'MultiPointPropertyType',
        ps: [{
            n: 'multiPoint',
            rq: true,
            en: 'MultiPoint',
            ti: '.MultiPointType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'GeneralTransformationRefType',
        ps: [{
            n: 'generalTransformation',
            rq: true,
            mx: false,
            dom: false,
            en: '_GeneralTransformation',
            ti: '.AbstractGeneralTransformationType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'DefinitionType',
        bti: '.AbstractGMLType'
      }, {
        ln: 'SpeedType',
        bti: '.MeasureType'
      }, {
        ln: 'VectorType',
        ps: [{
            n: 'value',
            ti: {
              t: 'l',
              bti: 'Double'
            },
            t: 'v'
          }, {
            n: 'srsName',
            an: {
              lp: 'srsName'
            },
            t: 'a'
          }, {
            n: 'srsDimension',
            ti: 'PositiveInteger',
            an: {
              lp: 'srsDimension'
            },
            t: 'a'
          }, {
            n: 'axisLabels',
            ti: {
              t: 'l',
              bti: 'NCName'
            },
            an: {
              lp: 'axisLabels'
            },
            t: 'a'
          }, {
            n: 'uomLabels',
            ti: {
              t: 'l',
              bti: 'NCName'
            },
            an: {
              lp: 'uomLabels'
            },
            t: 'a'
          }]
      }, {
        ln: 'ArcByBulgeType',
        bti: '.ArcStringByBulgeType'
      }, {
        ln: 'DirectedObservationType',
        bti: '.ObservationType',
        ps: [{
            n: 'direction',
            rq: true,
            ti: '.DirectionPropertyType'
          }]
      }, {
        ln: 'ConcatenatedOperationType',
        bti: '.AbstractCoordinateOperationType',
        ps: [{
            n: 'usesSingleOperation',
            rq: true,
            mno: 2,
            col: true,
            ti: '.SingleOperationRefType'
          }]
      }, {
        ln: 'RectifiedGridCoverageType',
        bti: '.AbstractDiscreteCoverageType'
      }, {
        ln: 'SolidArrayPropertyType',
        ps: [{
            n: 'solid',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: '_Solid',
            ti: '.AbstractSolidType',
            t: 'er'
          }]
      }, {
        ln: 'SurfacePatchArrayPropertyType',
        ps: [{
            n: 'surfacePatch',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: '_SurfacePatch',
            ti: '.AbstractSurfacePatchType',
            t: 'er'
          }]
      }, {
        ln: 'TimeTopologyPrimitivePropertyType',
        ps: [{
            n: 'timeTopologyPrimitive',
            rq: true,
            mx: false,
            dom: false,
            en: '_TimeTopologyPrimitive',
            ti: '.AbstractTimeTopologyPrimitiveType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'MultiSolidCoverageType',
        bti: '.AbstractDiscreteCoverageType'
      }, {
        ln: 'LinearCSRefType',
        ps: [{
            n: 'linearCS',
            rq: true,
            en: 'LinearCS',
            ti: '.LinearCSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'ImageCRSRefType',
        ps: [{
            n: 'imageCRS',
            rq: true,
            en: 'ImageCRS',
            ti: '.ImageCRSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'GridDomainType',
        bti: '.DomainSetType'
      }, {
        ln: 'TopoPrimitiveArrayAssociationType',
        ps: [{
            n: 'topoPrimitive',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: '_TopoPrimitive',
            ti: '.AbstractTopoPrimitiveType',
            t: 'er'
          }]
      }, {
        ln: 'TimeNodeType',
        bti: '.AbstractTimeTopologyPrimitiveType',
        ps: [{
            n: 'previousEdge',
            mno: 0,
            col: true,
            ti: '.TimeEdgePropertyType'
          }, {
            n: 'nextEdge',
            mno: 0,
            col: true,
            ti: '.TimeEdgePropertyType'
          }, {
            n: 'position',
            ti: '.TimeInstantPropertyType'
          }]
      }, {
        ln: 'ArcStringByBulgeType',
        bti: '.AbstractCurveSegmentType',
        ps: [{
            n: 'posOrPointPropertyOrPointRep',
            rq: true,
            mno: 2,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'pos',
                ti: '.DirectPositionType'
              }, {
                en: 'pointProperty',
                ti: '.PointPropertyType'
              }, {
                en: 'pointRep',
                ti: '.PointPropertyType'
              }],
            t: 'ers'
          }, {
            n: 'posList',
            rq: true,
            ti: '.DirectPositionListType'
          }, {
            n: 'coordinates',
            rq: true,
            ti: '.CoordinatesType'
          }, {
            n: 'bulge',
            rq: true,
            col: true,
            ti: 'Double'
          }, {
            n: 'normal',
            rq: true,
            col: true,
            ti: '.VectorType'
          }, {
            n: 'interpolation',
            an: {
              lp: 'interpolation'
            },
            t: 'a'
          }, {
            n: 'numArc',
            ti: 'Integer',
            an: {
              lp: 'numArc'
            },
            t: 'a'
          }]
      }, {
        ln: 'ParameterValueGroupType',
        bti: '.AbstractGeneralParameterValueType',
        ps: [{
            n: 'includesValue',
            rq: true,
            mno: 2,
            col: true,
            ti: '.AbstractGeneralParameterValueType'
          }, {
            n: 'valuesOfGroup',
            rq: true,
            ti: '.OperationParameterGroupRefType'
          }]
      }, {
        ln: 'CodeListType',
        ps: [{
            n: 'value',
            ti: {
              t: 'l',
              bti: 'Name'
            },
            t: 'v'
          }, {
            n: 'codeSpace',
            an: {
              lp: 'codeSpace'
            },
            t: 'a'
          }]
      }, {
        ln: 'FaceType',
        bti: '.AbstractTopoPrimitiveType',
        ps: [{
            n: 'directedEdge',
            rq: true,
            col: true,
            ti: '.DirectedEdgePropertyType'
          }, {
            n: 'directedTopoSolid',
            mno: 0,
            mxo: 2,
            col: true,
            ti: '.DirectedTopoSolidPropertyType'
          }, {
            n: 'surfaceProperty',
            ti: '.SurfacePropertyType'
          }]
      }, {
        ln: 'DynamicFeatureType',
        bti: '.AbstractFeatureType',
        ps: [{
            n: 'validTime',
            ti: '.TimePrimitivePropertyType'
          }, {
            n: 'history',
            mx: false,
            dom: false,
            ti: '.HistoryPropertyType',
            t: 'er'
          }, {
            n: 'dataSource',
            ti: '.StringOrRefType'
          }]
      }, {
        ln: 'DictionaryType',
        bti: '.DefinitionType',
        ps: [{
            n: 'dictionaryEntryOrIndirectEntry',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'dictionaryEntry',
                ti: '.DictionaryEntryType'
              }, {
                en: 'indirectEntry',
                ti: '.IndirectEntryType'
              }],
            t: 'ers'
          }]
      }, {
        ln: 'SolidPropertyType',
        ps: [{
            n: 'solid',
            rq: true,
            mx: false,
            dom: false,
            en: '_Solid',
            ti: '.AbstractSolidType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'GeometryArrayPropertyType',
        ps: [{
            n: 'geometry',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: '_Geometry',
            ti: '.AbstractGeometryType',
            t: 'er'
          }]
      }, {
        ln: 'ConversionToPreferredUnitType',
        bti: '.UnitOfMeasureType',
        ps: [{
            n: 'factor',
            rq: true,
            ti: 'Double'
          }, {
            n: 'formula',
            rq: true,
            ti: '.FormulaType'
          }]
      }, {
        ln: 'GraphStyleType',
        bti: '.BaseStyleDescriptorType',
        ps: [{
            n: 'planar',
            ti: 'Boolean'
          }, {
            n: 'directed',
            ti: 'Boolean'
          }, {
            n: 'grid',
            ti: 'Boolean'
          }, {
            n: 'minDistance',
            ti: 'Double'
          }, {
            n: 'minAngle',
            ti: 'Double'
          }, {
            n: 'graphType'
          }, {
            n: 'drawingType'
          }, {
            n: 'lineType'
          }, {
            n: 'aestheticCriteria',
            mno: 0,
            col: true
          }]
      }, {
        ln: 'TemporalDatumBaseType',
        bti: '.AbstractDatumType'
      }, {
        ln: 'ValueArrayType',
        bti: '.CompositeValueType',
        ps: [{
            n: 'codeSpace',
            an: {
              lp: 'codeSpace'
            },
            t: 'a'
          }, {
            n: 'uom',
            an: {
              lp: 'uom'
            },
            t: 'a'
          }]
      }, {
        ln: 'AbstractStyleType',
        bti: '.AbstractGMLType'
      }, {
        ln: 'AbstractMetaDataType',
        ps: [{
            n: 'content',
            col: true,
            dom: false,
            t: 'ers'
          }, {
            n: 'id',
            ti: 'ID',
            an: {
              lp: 'id',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }]
      }, {
        ln: 'AbstractTimeGeometricPrimitiveType',
        bti: '.AbstractTimePrimitiveType',
        ps: [{
            n: 'frame',
            an: {
              lp: 'frame'
            },
            t: 'a'
          }]
      }, {
        ln: 'CRSRefType',
        ps: [{
            n: 'crs',
            rq: true,
            mx: false,
            dom: false,
            en: '_CRS',
            ti: '.AbstractReferenceSystemType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'MultiCurveType',
        bti: '.AbstractGeometricAggregateType',
        ps: [{
            n: 'curveMember',
            mno: 0,
            col: true,
            ti: '.CurvePropertyType'
          }, {
            n: 'curveMembers',
            ti: '.CurveArrayPropertyType'
          }]
      }, {
        ln: 'BoundedFeatureType',
        bti: '.AbstractFeatureType'
      }, {
        ln: 'AbstractTimeObjectType',
        bti: '.AbstractGMLType'
      }, {
        ln: 'TimeNodePropertyType',
        ps: [{
            n: 'timeNode',
            rq: true,
            en: 'TimeNode',
            ti: '.TimeNodeType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'FeatureCollectionType',
        bti: '.AbstractFeatureCollectionType'
      }, {
        ln: 'OperationParameterGroupBaseType',
        bti: '.AbstractGeneralOperationParameterType'
      }, {
        ln: 'VerticalCSType',
        bti: '.AbstractCoordinateSystemType'
      }, {
        ln: 'AbstractTimePrimitiveType',
        bti: '.AbstractTimeObjectType',
        ps: [{
            n: 'relatedTime',
            mno: 0,
            col: true,
            ti: '.RelatedTimeType'
          }]
      }, {
        ln: 'ImageCRSType',
        bti: '.AbstractReferenceSystemType',
        ps: [{
            n: 'usesCartesianCS',
            rq: true,
            ti: '.CartesianCSRefType'
          }, {
            n: 'usesObliqueCartesianCS',
            rq: true,
            ti: '.ObliqueCartesianCSRefType'
          }, {
            n: 'usesImageDatum',
            rq: true,
            ti: '.ImageDatumRefType'
          }]
      }, {
        ln: 'SphereType',
        bti: '.AbstractGriddedSurfaceType',
        ps: [{
            n: 'horizontalCURVETYPE',
            an: {
              lp: 'horizontalCurveType'
            },
            t: 'a'
          }, {
            n: 'verticalCURVETYPE',
            an: {
              lp: 'verticalCurveType'
            },
            t: 'a'
          }]
      }, {
        ln: 'PolygonType',
        bti: '.AbstractSurfaceType',
        ps: [{
            n: 'exterior',
            mx: false,
            dom: false,
            ti: '.AbstractRingPropertyType',
            t: 'er'
          }, {
            n: 'interior',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            ti: '.AbstractRingPropertyType',
            t: 'er'
          }]
      }, {
        ln: 'SolidType',
        bti: '.AbstractSolidType',
        ps: [{
            n: 'exterior',
            ti: '.SurfacePropertyType'
          }, {
            n: 'interior',
            mno: 0,
            col: true,
            ti: '.SurfacePropertyType'
          }]
      }, {
        ln: 'TopoPrimitiveMemberType',
        ps: [{
            n: 'topoPrimitive',
            mx: false,
            dom: false,
            en: '_TopoPrimitive',
            ti: '.AbstractTopoPrimitiveType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'GridLengthType',
        bti: '.MeasureType'
      }, {
        ln: 'DefinitionProxyType',
        bti: '.DefinitionType',
        ps: [{
            n: 'definitionRef',
            rq: true,
            ti: '.ReferenceType'
          }]
      }, {
        ln: 'MultiLineStringType',
        bti: '.AbstractGeometricAggregateType',
        ps: [{
            n: 'lineStringMember',
            mno: 0,
            col: true,
            ti: '.LineStringPropertyType'
          }]
      }, {
        ln: 'SurfaceType',
        bti: '.AbstractSurfaceType',
        ps: [{
            n: 'patches',
            rq: true,
            mx: false,
            dom: false,
            ti: '.SurfacePatchArrayPropertyType',
            t: 'er'
          }]
      }, {
        ln: 'LabelStylePropertyType',
        ps: [{
            n: 'labelStyle',
            en: 'LabelStyle',
            ti: '.LabelStyleType'
          }, {
            n: 'about',
            an: {
              lp: 'about'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'ValueArrayPropertyType',
        ps: [{
            n: 'value',
            rq: true,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'CategoryList',
                ti: '.CodeOrNullListType'
              }, {
                en: 'Count',
                ti: 'Integer'
              }, {
                en: 'QuantityList',
                ti: '.MeasureOrNullListType'
              }, {
                en: '_Object',
                ti: 'AnyType'
              }, {
                en: 'Boolean',
                ti: 'Boolean'
              }, {
                en: 'Category',
                ti: '.CodeType'
              }, {
                en: 'Quantity',
                ti: '.MeasureType'
              }, {
                en: 'Null',
                ti: {
                  t: 'l'
                }
              }, {
                en: 'QuantityExtent',
                ti: '.QuantityExtentType'
              }, {
                en: 'CountList',
                ti: {
                  t: 'l'
                }
              }, {
                en: 'CategoryExtent',
                ti: '.CategoryExtentType'
              }, {
                en: 'BooleanList',
                ti: {
                  t: 'l'
                }
              }, {
                en: 'CountExtent',
                ti: {
                  t: 'l'
                }
              }, {
                en: 'CompositeValue',
                ti: '.CompositeValueType'
              }],
            t: 'ers'
          }]
      }, {
        ln: 'TimePeriodPropertyType',
        ps: [{
            n: 'timePeriod',
            rq: true,
            en: 'TimePeriod',
            ti: '.TimePeriodType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TimeOrdinalReferenceSystemType',
        bti: '.AbstractTimeReferenceSystemType',
        ps: [{
            n: 'component',
            rq: true,
            col: true,
            ti: '.TimeOrdinalEraPropertyType'
          }]
      }, {
        ln: 'FeatureStylePropertyType',
        ps: [{
            n: 'featureStyle',
            en: 'FeatureStyle',
            ti: '.FeatureStyleType'
          }, {
            n: 'about',
            an: {
              lp: 'about'
            },
            t: 'a'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CompositeSurfaceType',
        bti: '.AbstractSurfaceType',
        ps: [{
            n: 'surfaceMember',
            rq: true,
            col: true,
            ti: '.SurfacePropertyType'
          }]
      }, {
        ln: 'PointPropertyType',
        ps: [{
            n: 'point',
            rq: true,
            en: 'Point',
            ti: '.PointType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CoordType',
        ps: [{
            n: 'x',
            rq: true,
            en: 'X',
            ti: 'Decimal'
          }, {
            n: 'y',
            en: 'Y',
            ti: 'Decimal'
          }, {
            n: 'z',
            en: 'Z',
            ti: 'Decimal'
          }]
      }, {
        ln: 'PointArrayPropertyType',
        ps: [{
            n: 'point',
            mno: 0,
            col: true,
            en: 'Point',
            ti: '.PointType'
          }]
      }, {
        ln: 'AbstractGriddedSurfaceType.Row',
        tn: null,
        ps: [{
            n: 'posList',
            rq: true,
            ti: '.DirectPositionListType'
          }, {
            n: 'geometricPositionGroup',
            rq: true,
            col: true,
            etis: [{
                en: 'pos',
                ti: '.DirectPositionType'
              }, {
                en: 'pointProperty',
                ti: '.PointPropertyType'
              }],
            t: 'es'
          }]
      }, {
        ln: 'AbstractRingPropertyType',
        ps: [{
            n: 'ring',
            rq: true,
            mx: false,
            dom: false,
            en: '_Ring',
            ti: '.AbstractRingType',
            t: 'er'
          }]
      }, {
        ln: 'DegreesType',
        ps: [{
            n: 'value',
            ti: 'NonNegativeInteger',
            t: 'v'
          }, {
            n: 'direction',
            an: {
              lp: 'direction'
            },
            t: 'a'
          }]
      }, {
        ln: 'EllipsoidalCSType',
        bti: '.AbstractCoordinateSystemType'
      }, {
        ln: 'TopologyStyleType',
        bti: '.BaseStyleDescriptorType',
        ps: [{
            n: 'symbol',
            rq: true,
            ti: '.SymbolType'
          }, {
            n: 'style',
            rq: true
          }, {
            n: 'labelStyle',
            ti: '.LabelStylePropertyType'
          }, {
            n: 'topologyProperty',
            an: {
              lp: 'topologyProperty'
            },
            t: 'a'
          }, {
            n: 'topologyType',
            an: {
              lp: 'topologyType'
            },
            t: 'a'
          }]
      }, {
        ln: 'AbstractGeneralConversionType',
        bti: '.AbstractCoordinateOperationType'
      }, {
        ln: 'ConeType',
        bti: '.AbstractGriddedSurfaceType',
        ps: [{
            n: 'horizontalCURVETYPE',
            an: {
              lp: 'horizontalCurveType'
            },
            t: 'a'
          }, {
            n: 'verticalCURVETYPE',
            an: {
              lp: 'verticalCurveType'
            },
            t: 'a'
          }]
      }, {
        ln: 'TimeTopologyComplexPropertyType',
        ps: [{
            n: 'timeTopologyComplex',
            rq: true,
            en: 'TimeTopologyComplex',
            ti: '.TimeTopologyComplexType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CategoryExtentType',
        bti: '.CodeOrNullListType'
      }, {
        ln: 'CodeOrNullListType',
        ps: [{
            n: 'value',
            ti: {
              t: 'l'
            },
            t: 'v'
          }, {
            n: 'codeSpace',
            an: {
              lp: 'codeSpace'
            },
            t: 'a'
          }]
      }, {
        ln: 'TimeCalendarPropertyType',
        ps: [{
            n: 'timeCalendar',
            rq: true,
            en: 'TimeCalendar',
            ti: '.TimeCalendarType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TopoSolidType',
        bti: '.AbstractTopoPrimitiveType',
        ps: [{
            n: 'directedFace',
            rq: true,
            col: true,
            ti: '.DirectedFacePropertyType'
          }]
      }, {
        ln: 'EngineeringDatumType',
        bti: '.AbstractDatumType'
      }, {
        ln: 'TopoSurfacePropertyType',
        ps: [{
            n: 'topoSurface',
            rq: true,
            en: 'TopoSurface',
            ti: '.TopoSurfaceType'
          }]
      }, {
        ln: 'BoundingShapeType',
        ps: [{
            n: 'envelope',
            rq: true,
            mx: false,
            dom: false,
            en: 'Envelope',
            ti: '.EnvelopeType',
            t: 'er'
          }, {
            n: '_null',
            rq: true,
            en: 'Null',
            ti: {
              t: 'l'
            }
          }]
      }, {
        ln: 'CircleType',
        bti: '.ArcType'
      }, {
        ln: 'TrackType',
        bti: '.HistoryPropertyType'
      }, {
        ln: 'IsolatedPropertyType',
        ps: [{
            n: 'node',
            rq: true,
            en: 'Node',
            ti: '.NodeType'
          }, {
            n: 'edge',
            rq: true,
            en: 'Edge',
            ti: '.EdgeType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AbstractGeneralOperationParameterRefType',
        ps: [{
            n: 'generalOperationParameter',
            rq: true,
            mx: false,
            dom: false,
            en: '_GeneralOperationParameter',
            ti: '.AbstractGeneralOperationParameterType',
            t: 'er'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'TemporalCRSRefType',
        ps: [{
            n: 'temporalCRS',
            rq: true,
            en: 'TemporalCRS',
            ti: '.TemporalCRSType'
          }, {
            n: 'remoteSchema',
            an: {
              lp: 'remoteSchema',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        t: 'enum',
        ln: 'KnotTypesType',
        vs: ['uniform', 'quasiUniform', 'piecewiseBezier']
      }, {
        t: 'enum',
        ln: 'SurfaceInterpolationType',
        vs: ['none', 'planar', 'spherical', 'elliptical', 'conic', 'tin', 'parametricCurve', 'polynomialSpline', 'rationalSpline', 'triangulatedSpline']
      }, {
        t: 'enum',
        ln: 'IncrementOrder',
        vs: ['+x+y', '+y+x', '+x-y', '-x-y']
      }, {
        t: 'enum',
        ln: 'FileValueModelType',
        vs: ['Record Interleaved']
      }, {
        t: 'enum',
        ln: 'CurveInterpolationType',
        vs: ['linear', 'geodesic', 'circularArc3Points', 'circularArc2PointWithBulge', 'circularArcCenterPointWithRadius', 'elliptical', 'clothoid', 'conic', 'polynomialSpline', 'cubicSpline', 'rationalSpline']
      }, {
        t: 'enum',
        ln: 'TimeIndeterminateValueType',
        vs: ['after', 'before', 'now', 'unknown']
      }, {
        t: 'enum',
        ln: 'SymbolTypeEnumeration',
        vs: ['svg', 'xpath', 'other']
      }, {
        t: 'enum',
        ln: 'SignType',
        vs: ['-', '+']
      }, {
        t: 'enum',
        ln: 'SuccessionType',
        vs: ['substitution', 'division', 'fusion', 'initiation']
      }, {
        t: 'enum',
        ln: 'CompassPointEnumeration',
        vs: ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW']
      }, {
        t: 'enum',
        ln: 'GraphTypeType',
        vs: ['TREE', 'BICONNECTED']
      }, {
        t: 'enum',
        ln: 'SequenceRuleNames',
        vs: ['Linear', 'Boustrophedonic', 'Cantor-diagonal', 'Spiral', 'Morton', 'Hilbert']
      }, {
        t: 'enum',
        ln: 'DrawingTypeType',
        vs: ['POLYLINE', 'ORTHOGONAL']
      }, {
        t: 'enum',
        ln: 'LineTypeType',
        vs: ['STRAIGHT', 'BENT']
      }, {
        t: 'enum',
        ln: 'QueryGrammarEnumeration',
        vs: ['xpath', 'xquery', 'other']
      }, {
        t: 'enum',
        ln: 'AesheticCriteriaType',
        vs: ['MIN_CROSSINGS', 'MIN_AREA', 'MIN_BENDS', 'MAX_BENDS', 'UNIFORM_BENDS', 'MIN_SLOPES', 'MIN_EDGE_LENGTH', 'MAX_EDGE_LENGTH', 'UNIFORM_EDGE_LENGTH', 'MAX_ANGULAR_RESOLUTION', 'MIN_ASPECT_RATIO', 'MAX_SYMMETRIES']
      }],
    eis: [{
        en: 'validTime',
        ti: '.TimePrimitivePropertyType'
      }, {
        en: 'MultiSolidCoverage',
        ti: '.MultiSolidCoverageType',
        sh: '_DiscreteCoverage'
      }, {
        en: 'Clothoid',
        ti: '.ClothoidType',
        sh: '_CurveSegment'
      }, {
        en: 'priorityLocation',
        ti: '.PriorityLocationPropertyType',
        sh: 'location'
      }, {
        en: 'multiExtentOf',
        ti: '.MultiSurfacePropertyType'
      }, {
        en: '_GeometricAggregate',
        ti: '.AbstractGeometricAggregateType',
        sh: '_Geometry'
      }, {
        en: 'srsID',
        ti: '.IdentifierType'
      }, {
        en: 'TimeEdge',
        ti: '.TimeEdgeType',
        sh: '_TimeTopologyPrimitive'
      }, {
        en: 'roughConversionToPreferredUnit',
        ti: '.ConversionToPreferredUnitType'
      }, {
        en: 'LabelStyle',
        ti: '.LabelStyleType',
        sh: '_GML'
      }, {
        en: 'patches',
        ti: '.SurfacePatchArrayPropertyType'
      }, {
        en: 'container',
        ti: '.ContainerPropertyType'
      }, {
        en: 'passThroughOperationRef',
        ti: '.PassThroughOperationRefType'
      }, {
        en: 'featureMembers',
        ti: '.FeatureArrayPropertyType'
      }, {
        en: 'TriangulatedSurface',
        ti: '.TriangulatedSurfaceType',
        sh: 'Surface'
      }, {
        en: 'datumID',
        ti: '.IdentifierType'
      }, {
        en: 'EllipsoidalCS',
        ti: '.EllipsoidalCSType',
        sh: '_CoordinateSystem'
      }, {
        en: 'File',
        ti: '.FileType'
      }, {
        en: 'booleanValue',
        ti: 'Boolean'
      }, {
        en: 'GeodesicString',
        ti: '.GeodesicStringType',
        sh: '_CurveSegment'
      }, {
        en: '_Geometry',
        ti: '.AbstractGeometryType',
        sh: '_GML'
      }, {
        en: 'pointProperty',
        ti: '.PointPropertyType'
      }, {
        en: 'valueProperty',
        ti: '.ValuePropertyType'
      }, {
        en: 'coordinates',
        ti: '.CoordinatesType'
      }, {
        en: 'otherFeatureMembers',
        ti: '.FeatureArrayPropertyType',
        sh: 'featureMembers'
      }, {
        en: 'CompositeValue',
        ti: '.CompositeValueType'
      }, {
        en: 'polygonProperty',
        ti: '.PolygonPropertyType'
      }, {
        en: 'dataSource',
        ti: '.StringOrRefType'
      }, {
        en: 'measureDescription',
        ti: '.CodeType'
      }, {
        en: 'doubleOrNullTupleList',
        ti: {
          t: 'l'
        }
      }, {
        en: '_GriddedSurface',
        ti: '.AbstractGriddedSurfaceType',
        sh: '_ParametricCurveSurface'
      }, {
        en: 'LinearCS',
        ti: '.LinearCSType',
        sh: '_CoordinateSystem'
      }, {
        en: 'usesAxis',
        ti: '.CoordinateSystemAxisRefType'
      }, {
        en: 'verticalDatumType',
        ti: '.VerticalDatumTypeType'
      }, {
        en: 'CompassPoint'
      }, {
        en: 'gridDomain',
        ti: '.GridDomainType',
        sh: 'domainSet'
      }, {
        en: '_TimeGeometricPrimitive',
        ti: '.AbstractTimeGeometricPrimitiveType',
        sh: '_TimePrimitive'
      }, {
        en: 'ObliqueCartesianCS',
        ti: '.ObliqueCartesianCSType',
        sh: '_CoordinateSystem'
      }, {
        en: 'geometryMembers',
        ti: '.GeometryArrayPropertyType'
      }, {
        en: 'Quantity',
        ti: '.MeasureType'
      }, {
        en: 'MultiPolygon',
        ti: '.MultiPolygonType',
        sh: '_GeometricAggregate'
      }, {
        en: 'Ellipsoid',
        ti: '.EllipsoidType',
        sh: 'Definition'
      }, {
        en: 'Definition',
        ti: '.DefinitionType',
        sh: '_GML'
      }, {
        en: 'Ring',
        ti: '.RingType',
        sh: '_Ring'
      }, {
        en: 'OrientableSurface',
        ti: '.OrientableSurfaceType',
        sh: '_Surface'
      }, {
        en: 'lineStringMember',
        ti: '.LineStringPropertyType'
      }, {
        en: 'ArcString',
        ti: '.ArcStringType',
        sh: '_CurveSegment'
      }, {
        en: 'directedNode',
        ti: '.DirectedNodePropertyType'
      }, {
        en: 'MultiSurfaceCoverage',
        ti: '.MultiSurfaceCoverageType',
        sh: '_DiscreteCoverage'
      }, {
        en: '_positionalAccuracy',
        ti: '.AbstractPositionalAccuracyType'
      }, {
        en: 'multiGeometryProperty',
        ti: '.MultiGeometryPropertyType'
      }, {
        en: 'absoluteExternalPositionalAccuracy',
        ti: '.AbsoluteExternalPositionalAccuracyType',
        sh: '_positionalAccuracy'
      }, {
        en: 'GeocentricCRS',
        ti: '.GeocentricCRSType',
        sh: '_CoordinateReferenceSystem'
      }, {
        en: 'TimeNode',
        ti: '.TimeNodeType',
        sh: '_TimeTopologyPrimitive'
      }, {
        en: 'valueComponents',
        ti: '.ValueArrayPropertyType'
      }, {
        en: 'GenericMetaData',
        ti: '.GenericMetaDataType',
        sh: '_MetaData'
      }, {
        en: 'topoPrimitiveMembers',
        ti: '.TopoPrimitiveArrayAssociationType'
      }, {
        en: 'timePosition',
        ti: '.TimePositionType'
      }, {
        en: 'Bag',
        ti: '.BagType',
        sh: '_GML'
      }, {
        en: 'ellipsoidName',
        ti: '.CodeType',
        sh: 'name'
      }, {
        en: 'unitOfMeasure',
        ti: '.UnitOfMeasureType'
      }, {
        en: 'Geodesic',
        ti: '.GeodesicType',
        sh: 'GeodesicString'
      }, {
        en: 'definedByConversion',
        ti: '.GeneralConversionRefType'
      }, {
        en: 'scope'
      }, {
        en: 'PolarCS',
        ti: '.PolarCSType',
        sh: '_CoordinateSystem'
      }, {
        en: 'Solid',
        ti: '.SolidType',
        sh: '_Solid'
      }, {
        en: 'surfaceMember',
        ti: '.SurfacePropertyType'
      }, {
        en: 'TopoSurface',
        ti: '.TopoSurfaceType'
      }, {
        en: '_Solid',
        ti: '.AbstractSolidType',
        sh: '_GeometricPrimitive'
      }, {
        en: 'CountList',
        ti: {
          t: 'l'
        }
      }, {
        en: 'CubicSpline',
        ti: '.CubicSplineType',
        sh: '_CurveSegment'
      }, {
        en: 'GeographicCRS',
        ti: '.GeographicCRSType',
        sh: '_CoordinateReferenceSystem'
      }, {
        en: 'Grid',
        ti: '.GridType',
        sh: '_ImplicitGeometry'
      }, {
        en: '_ContinuousCoverage',
        ti: '.AbstractContinuousCoverageType',
        sh: '_Coverage'
      }, {
        en: 'PassThroughOperation',
        ti: '.PassThroughOperationType',
        sh: '_SingleOperation'
      }, {
        en: 'rangeParameters',
        ti: '.RangeParametersType'
      }, {
        en: 'definitionRef',
        ti: '.ReferenceType'
      }, {
        en: 'baseSurface',
        ti: '.SurfacePropertyType'
      }, {
        en: '_GeometricPrimitive',
        ti: '.AbstractGeometricPrimitiveType',
        sh: '_Geometry'
      }, {
        en: 'verticalCSRef',
        ti: '.VerticalCSRefType'
      }, {
        en: 'TimeCalendar',
        ti: '.TimeCalendarType',
        sh: '_TimeReferenceSystem'
      }, {
        en: 'TopoCurve',
        ti: '.TopoCurveType'
      }, {
        en: 'subject',
        ti: '.TargetPropertyType',
        sh: 'target'
      }, {
        en: 'TemporalCS',
        ti: '.TemporalCSType',
        sh: '_CoordinateSystem'
      }, {
        en: 'isSphere'
      }, {
        en: 'RectifiedGridCoverage',
        ti: '.RectifiedGridCoverageType',
        sh: '_DiscreteCoverage'
      }, {
        en: 'sourceDimensions',
        ti: 'PositiveInteger'
      }, {
        en: '_MetaData',
        ti: '.AbstractMetaDataType',
        sh: '_Object'
      }, {
        en: 'BSpline',
        ti: '.BSplineType',
        sh: '_CurveSegment'
      }, {
        en: '_CoordinateOperation',
        ti: '.AbstractCoordinateOperationType',
        sh: 'Definition'
      }, {
        en: '_association',
        ti: '.AssociationType'
      }, {
        en: 'definitionMember',
        ti: '.DictionaryEntryType',
        sh: 'dictionaryEntry'
      }, {
        en: 'LineStringSegment',
        ti: '.LineStringSegmentType',
        sh: '_CurveSegment'
      }, {
        en: '_CRS',
        ti: '.AbstractReferenceSystemType',
        sh: '_ReferenceSystem'
      }, {
        en: 'result',
        ti: '.MeasureType'
      }, {
        en: 'Circle',
        ti: '.CircleType',
        sh: 'Arc'
      }, {
        en: '_DiscreteCoverage',
        ti: '.AbstractDiscreteCoverageType',
        sh: '_Coverage'
      }, {
        en: '_Surface',
        ti: '.AbstractSurfaceType',
        sh: '_GeometricPrimitive'
      }, {
        en: 'verticalCRSRef',
        ti: '.VerticalCRSRefType'
      }, {
        en: 'concatenatedOperationRef',
        ti: '.ConcatenatedOperationRefType'
      }, {
        en: 'operationParameterRef',
        ti: '.OperationParameterRefType'
      }, {
        en: 'meridianID',
        ti: '.IdentifierType'
      }, {
        en: 'usesEngineeringDatum',
        ti: '.EngineeringDatumRefType'
      }, {
        en: 'CompositeSolid',
        ti: '.CompositeSolidType',
        sh: '_Solid'
      }, {
        en: 'curveProperty',
        ti: '.CurvePropertyType'
      }, {
        en: '_CoordinateReferenceSystem',
        ti: '.AbstractReferenceSystemType',
        sh: '_CRS'
      }, {
        en: 'greenwichLongitude',
        ti: '.AngleChoiceType'
      }, {
        en: 'Envelope',
        ti: '.EnvelopeType'
      }, {
        en: 'usesVerticalCS',
        ti: '.VerticalCSRefType'
      }, {
        en: 'degrees',
        ti: '.DegreesType'
      }, {
        en: 'location',
        ti: '.LocationPropertyType'
      }, {
        en: 'geometryMember',
        ti: '.GeometryPropertyType'
      }, {
        en: 'topoCurveProperty',
        ti: '.TopoCurvePropertyType'
      }, {
        en: '_TimeObject',
        ti: '.AbstractTimeObjectType',
        sh: '_GML'
      }, {
        en: 'coordinateSystemAxisRef',
        ti: '.CoordinateSystemAxisRefType'
      }, {
        en: 'surfaceArrayProperty',
        ti: '.SurfaceArrayPropertyType'
      }, {
        en: 'labelStyle',
        ti: '.LabelStylePropertyType'
      }, {
        en: 'otherFeatureMember',
        ti: '.FeaturePropertyType',
        sh: 'featureMember'
      }, {
        en: 'IndexMap',
        ti: '.IndexMapType',
        sh: 'GridFunction'
      }, {
        en: '_Feature',
        ti: '.AbstractFeatureType',
        sh: '_GML'
      }, {
        en: 'direction',
        ti: '.DirectionPropertyType'
      }, {
        en: 'parameterValue',
        ti: '.ParameterValueType',
        sh: '_generalParameterValue'
      }, {
        en: 'duration',
        ti: 'Duration'
      }, {
        en: 'boundedBy',
        ti: '.BoundingShapeType'
      }, {
        en: 'secondDefiningParameter',
        ti: '.SecondDefiningParameterType'
      }, {
        en: 'Rectangle',
        ti: '.RectangleType',
        sh: '_SurfacePatch'
      }, {
        en: 'Sphere',
        ti: '.SphereType',
        sh: '_GriddedSurface'
      }, {
        en: '_Coverage',
        ti: '.AbstractCoverageType',
        sh: '_Feature'
      }, {
        en: 'member',
        ti: '.AssociationType'
      }, {
        en: 'multiCoverage',
        ti: '.MultiSurfacePropertyType'
      }, {
        en: 'imageCRSRef',
        ti: '.ImageCRSRefType'
      }, {
        en: '_FeatureCollection',
        ti: '.AbstractFeatureCollectionType',
        sh: '_Feature'
      }, {
        en: 'usesParameter',
        ti: '.AbstractGeneralOperationParameterRefType'
      }, {
        en: 'coordinateSystemRef',
        ti: '.CoordinateSystemRefType'
      }, {
        en: 'posList',
        ti: '.DirectPositionListType'
      }, {
        en: 'csID',
        ti: '.IdentifierType'
      }, {
        en: 'featureMember',
        ti: '.FeaturePropertyType'
      }, {
        en: 'centerLineOf',
        ti: '.CurvePropertyType'
      }, {
        en: 'isolated',
        ti: '.IsolatedPropertyType'
      }, {
        en: 'TimePeriod',
        ti: '.TimePeriodType',
        sh: '_TimeGeometricPrimitive'
      }, {
        en: 'multiSurfaceProperty',
        ti: '.MultiSurfacePropertyType'
      }, {
        en: '_Operation',
        ti: '.AbstractCoordinateOperationType',
        sh: '_SingleOperation'
      }, {
        en: 'symbol',
        ti: '.SymbolType'
      }, {
        en: 'LocationString',
        ti: '.StringOrRefType'
      }, {
        en: 'subComplex',
        ti: '.TopoComplexMemberType'
      }, {
        en: 'csName',
        ti: '.CodeType',
        sh: 'name'
      }, {
        en: 'axisAbbrev',
        ti: '.CodeType'
      }, {
        en: '_TimePrimitive',
        ti: '.AbstractTimePrimitiveType',
        sh: '_TimeObject'
      }, {
        en: 'usesGeodeticDatum',
        ti: '.GeodeticDatumRefType'
      }, {
        en: '_CurveSegment',
        ti: '.AbstractCurveSegmentType'
      }, {
        en: 'Boolean',
        ti: 'Boolean'
      }, {
        en: 'resultOf',
        ti: '.AssociationType'
      }, {
        en: 'usesValue',
        ti: '.ParameterValueType'
      }, {
        en: 'usesEllipsoid',
        ti: '.EllipsoidRefType'
      }, {
        en: '_GML',
        ti: '.AbstractGMLType',
        sh: '_Object'
      }, {
        en: 'Conversion',
        ti: '.ConversionType',
        sh: '_GeneralConversion'
      }, {
        en: 'derivedCRSType',
        ti: '.DerivedCRSTypeType'
      }, {
        en: 'Dictionary',
        ti: '.DictionaryType',
        sh: 'Definition'
      }, {
        en: 'exterior',
        ti: '.AbstractRingPropertyType'
      }, {
        en: 'methodID',
        ti: '.IdentifierType'
      }, {
        en: 'TopologyStyle',
        ti: '.TopologyStyleType',
        sh: '_GML'
      }, {
        en: 'defaultStyle',
        ti: '.DefaultStylePropertyType'
      }, {
        en: 'featureStyle',
        ti: '.FeatureStylePropertyType'
      }, {
        en: 'TopoVolume',
        ti: '.TopoVolumeType'
      }, {
        en: 'ArcByBulge',
        ti: '.ArcByBulgeType',
        sh: 'ArcStringByBulge'
      }, {
        en: 'geographicCRSRef',
        ti: '.GeographicCRSRefType'
      }, {
        en: 'GeometricComplex',
        ti: '.GeometricComplexType',
        sh: '_Geometry'
      }, {
        en: 'vector',
        ti: '.VectorType'
      }, {
        en: 'polygonPatches',
        ti: '.PolygonPatchArrayPropertyType',
        sh: 'patches'
      }, {
        en: 'centerOf',
        ti: '.PointPropertyType'
      }, {
        en: 'usesVerticalDatum',
        ti: '.VerticalDatumRefType'
      }, {
        en: 'VerticalCRS',
        ti: '.VerticalCRSType',
        sh: '_CoordinateReferenceSystem'
      }, {
        en: 'angle',
        ti: '.MeasureType'
      }, {
        en: 'CategoryExtent',
        ti: '.CategoryExtentType'
      }, {
        en: 'sphericalCSRef',
        ti: '.SphericalCSRefType'
      }, {
        en: 'QuantityExtent',
        ti: '.QuantityExtentType'
      }, {
        en: 'multiCenterLineOf',
        ti: '.MultiCurvePropertyType'
      }, {
        en: 'CompositeSurface',
        ti: '.CompositeSurfaceType',
        sh: '_Surface'
      }, {
        en: 'derivedCRSRef',
        ti: '.DerivedCRSRefType'
      }, {
        en: 'coordinateOperationName',
        ti: '.CodeType',
        sh: 'name'
      }, {
        en: '_TopoPrimitive',
        ti: '.AbstractTopoPrimitiveType',
        sh: '_Topology'
      }, {
        en: '_TimeSlice',
        ti: '.AbstractTimeSliceType',
        sh: '_GML'
      }, {
        en: 'temporalDatumRef',
        ti: '.TemporalDatumRefType'
      }, {
        en: 'stringValue'
      }, {
        en: 'name',
        ti: '.CodeType'
      }, {
        en: 'surfaceMembers',
        ti: '.SurfaceArrayPropertyType'
      }, {
        en: 'derivationUnitTerm',
        ti: '.DerivationUnitTermType'
      }, {
        en: 'DefinitionCollection',
        ti: '.DictionaryType',
        sh: 'Definition'
      }, {
        en: 'GraphStyle',
        ti: '.GraphStyleType',
        sh: '_GML'
      }, {
        en: 'semiMajorAxis',
        ti: '.MeasureType'
      }, {
        en: 'LinearRing',
        ti: '.LinearRingType',
        sh: '_Ring'
      }, {
        en: 'domainSet',
        ti: '.DomainSetType'
      }, {
        en: 'userDefinedCSRef',
        ti: '.UserDefinedCSRefType'
      }, {
        en: 'geocentricCRSRef',
        ti: '.GeocentricCRSRefType'
      }, {
        en: 'operationVersion'
      }, {
        en: 'dmsAngle',
        ti: '.DMSAngleType'
      }, {
        en: 'OffsetCurve',
        ti: '.OffsetCurveType',
        sh: '_CurveSegment'
      }, {
        en: 'PrimeMeridian',
        ti: '.PrimeMeridianType',
        sh: 'Definition'
      }, {
        en: 'TimeCoordinateSystem',
        ti: '.TimeCoordinateSystemType',
        sh: '_TimeReferenceSystem'
      }, {
        en: '_generalParameterValue',
        ti: '.AbstractGeneralParameterValueType'
      }, {
        en: 'meridianName',
        ti: '.CodeType',
        sh: 'name'
      }, {
        en: 'ImageCRS',
        ti: '.ImageCRSType',
        sh: '_CoordinateReferenceSystem'
      }, {
        en: '_GeneralTransformation',
        ti: '.AbstractGeneralTransformationType',
        sh: '_Operation'
      }, {
        en: 'realizationEpoch',
        ti: 'Date'
      }, {
        en: 'Null',
        ti: {
          t: 'l'
        }
      }, {
        en: 'crsRef',
        ti: '.CRSRefType'
      }, {
        en: 'ArcStringByBulge',
        ti: '.ArcStringByBulgeType',
        sh: '_CurveSegment'
      }, {
        en: 'MultiCurve',
        ti: '.MultiCurveType',
        sh: '_GeometricAggregate'
      }, {
        en: 'DerivedUnit',
        ti: '.DerivedUnitType',
        sh: 'UnitDefinition'
      }, {
        en: 'geodeticDatumRef',
        ti: '.GeodeticDatumRefType'
      }, {
        en: 'topoPointProperty',
        ti: '.TopoPointPropertyType'
      }, {
        en: 'solidProperty',
        ti: '.SolidPropertyType'
      }, {
        en: 'Transformation',
        ti: '.TransformationType',
        sh: '_GeneralTransformation'
      }, {
        en: 'multiCurveProperty',
        ti: '.MultiCurvePropertyType'
      }, {
        en: 'curveArrayProperty',
        ti: '.CurveArrayPropertyType'
      }, {
        en: 'ellipsoidalCSRef',
        ti: '.EllipsoidalCSRefType'
      }, {
        en: 'usesObliqueCartesianCS',
        ti: '.ObliqueCartesianCSRefType'
      }, {
        en: 'datumName',
        ti: '.CodeType',
        sh: 'name'
      }, {
        en: 'covarianceMatrix',
        ti: '.CovarianceMatrixType',
        sh: '_positionalAccuracy'
      }, {
        en: 'interior',
        ti: '.AbstractRingPropertyType'
      }, {
        en: 'OrientableCurve',
        ti: '.OrientableCurveType',
        sh: '_Curve'
      }, {
        en: 'Observation',
        ti: '.ObservationType',
        sh: '_Feature'
      }, {
        en: 'BaseUnit',
        ti: '.BaseUnitType',
        sh: 'UnitDefinition'
      }, {
        en: 'DirectedObservationAtDistance',
        ti: '.DirectedObservationAtDistanceType',
        sh: 'DirectedObservation'
      }, {
        en: 'LineString',
        ti: '.LineStringType',
        sh: '_Curve'
      }, {
        en: 'CompoundCRS',
        ti: '.CompoundCRSType',
        sh: '_CRS'
      }, {
        en: 'baseCurve',
        ti: '.CurvePropertyType'
      }, {
        en: 'CategoryList',
        ti: '.CodeOrNullListType'
      }, {
        en: '_SingleOperation',
        ti: '.AbstractCoordinateOperationType',
        sh: '_CoordinateOperation'
      }, {
        en: 'history',
        ti: '.HistoryPropertyType'
      }, {
        en: 'status',
        ti: '.StringOrRefType'
      }, {
        en: 'multiPointProperty',
        ti: '.MultiPointPropertyType'
      }, {
        en: 'ConcatenatedOperation',
        ti: '.ConcatenatedOperationType',
        sh: '_CoordinateOperation'
      }, {
        en: 'extentOf',
        ti: '.SurfacePropertyType'
      }, {
        en: 'DataBlock',
        ti: '.DataBlockType'
      }, {
        en: 'imageDatumRef',
        ti: '.ImageDatumRefType'
      }, {
        en: 'rowIndex',
        ti: 'PositiveInteger'
      }, {
        en: 'TimeOrdinalReferenceSystem',
        ti: '.TimeOrdinalReferenceSystemType',
        sh: '_TimeReferenceSystem'
      }, {
        en: 'metaDataProperty',
        ti: '.MetaDataPropertyType'
      }, {
        en: 'minimumOccurs',
        ti: 'NonNegativeInteger'
      }, {
        en: 'semiMinorAxis',
        ti: '.MeasureType'
      }, {
        en: 'usesImageDatum',
        ti: '.ImageDatumRefType'
      }, {
        en: 'DefinitionProxy',
        ti: '.DefinitionProxyType',
        sh: 'Definition'
      }, {
        en: 'segments',
        ti: '.CurveSegmentArrayPropertyType'
      }, {
        en: 'Polygon',
        ti: '.PolygonType',
        sh: '_Surface'
      }, {
        en: 'directedEdge',
        ti: '.DirectedEdgePropertyType'
      }, {
        en: 'decimalMinutes',
        ti: 'Decimal'
      }, {
        en: 'catalogSymbol',
        ti: '.CodeType'
      }, {
        en: 'directedFace',
        ti: '.DirectedFacePropertyType'
      }, {
        en: 'rangeSet',
        ti: '.RangeSetType'
      }, {
        en: 'targetDimensions',
        ti: 'PositiveInteger'
      }, {
        en: 'ConventionalUnit',
        ti: '.ConventionalUnitType',
        sh: 'UnitDefinition'
      }, {
        en: 'polygonMember',
        ti: '.PolygonPropertyType'
      }, {
        en: 'Bezier',
        ti: '.BezierType',
        sh: 'BSpline'
      }, {
        en: '_TimeReferenceSystem',
        ti: '.AbstractTimeReferenceSystemType',
        sh: 'Definition'
      }, {
        en: 'OperationParameter',
        ti: '.OperationParameterType',
        sh: '_GeneralOperationParameter'
      }, {
        en: 'TopoPoint',
        ti: '.TopoPointType'
      }, {
        en: '_Style',
        ti: '.AbstractStyleType',
        sh: '_GML'
      }, {
        en: 'Category',
        ti: '.CodeType'
      }, {
        en: 'primeMeridianRef',
        ti: '.PrimeMeridianRefType'
      }, {
        en: 'LocationKeyWord',
        ti: '.CodeType'
      }, {
        en: 'VerticalCS',
        ti: '.VerticalCSType',
        sh: '_CoordinateSystem'
      }, {
        en: 'boundingBox',
        ti: '.EnvelopeType'
      }, {
        en: 'pointMember',
        ti: '.PointPropertyType'
      }, {
        en: 'PolyhedralSurface',
        ti: '.PolyhedralSurfaceType',
        sh: 'Surface'
      }, {
        en: 'verticalExtent',
        ti: '.EnvelopeType'
      }, {
        en: 'obliqueCartesianCSRef',
        ti: '.ObliqueCartesianCSRefType'
      }, {
        en: 'targetCRS',
        ti: '.CRSRefType'
      }, {
        en: 'referenceSystemRef',
        ti: '.ReferenceSystemRefType'
      }, {
        en: 'axisDirection',
        ti: '.CodeType'
      }, {
        en: 'parameterName',
        ti: '.CodeType',
        sh: 'name'
      }, {
        en: 'multiPosition',
        ti: '.MultiPointPropertyType'
      }, {
        en: 'Arc',
        ti: '.ArcType',
        sh: 'ArcString'
      }, {
        en: 'singleOperationRef',
        ti: '.SingleOperationRefType'
      }, {
        en: 'usesSphericalCS',
        ti: '.SphericalCSRefType'
      }, {
        en: 'includesValue',
        ti: '.AbstractGeneralParameterValueType',
        sh: '_generalParameterValue'
      }, {
        en: 'temporalCSRef',
        ti: '.TemporalCSRefType'
      }, {
        en: 'origin',
        ti: 'DateTime'
      }, {
        en: 'Point',
        ti: '.PointType',
        sh: '_GeometricPrimitive'
      }, {
        en: 'CylindricalCS',
        ti: '.CylindricalCSType',
        sh: '_CoordinateSystem'
      }, {
        en: 'MultiSolid',
        ti: '.MultiSolidType',
        sh: '_GeometricAggregate'
      }, {
        en: '_Curve',
        ti: '.AbstractCurveType',
        sh: '_GeometricPrimitive'
      }, {
        en: 'usesTemporalCS',
        ti: '.TemporalCSRefType'
      }, {
        en: 'rectifiedGridDomain',
        ti: '.RectifiedGridDomainType',
        sh: 'domainSet'
      }, {
        en: 'TimeClock',
        ti: '.TimeClockType',
        sh: '_TimeReferenceSystem'
      }, {
        en: 'usesSingleOperation',
        ti: '.SingleOperationRefType'
      }, {
        en: 'pixelInCell',
        ti: '.PixelInCellType'
      }, {
        en: 'ProjectedCRS',
        ti: '.ProjectedCRSType',
        sh: '_GeneralDerivedCRS'
      }, {
        en: '_Topology',
        ti: '.AbstractTopologyType',
        sh: '_GML'
      }, {
        en: 'modifiedCoordinate',
        ti: 'PositiveInteger'
      }, {
        en: 'relativeInternalPositionalAccuracy',
        ti: '.RelativeInternalPositionalAccuracyType',
        sh: '_positionalAccuracy'
      }, {
        en: '_GeneralOperationParameter',
        ti: '.AbstractGeneralOperationParameterType',
        sh: 'Definition'
      }, {
        en: 'EnvelopeWithTimePeriod',
        ti: '.EnvelopeWithTimePeriodType',
        sh: 'Envelope'
      }, {
        en: 'covariance',
        ti: 'Double'
      }, {
        en: 'outerBoundaryIs',
        ti: '.AbstractRingPropertyType',
        sh: 'exterior'
      }, {
        en: 'Edge',
        ti: '.EdgeType',
        sh: '_TopoPrimitive'
      }, {
        en: 'operationParameterGroupRef',
        ti: '.OperationParameterRefType'
      }, {
        en: 'includesElement',
        ti: '.CovarianceElementType'
      }, {
        en: '_ImplicitGeometry',
        ti: '.AbstractGeometryType',
        sh: '_Geometry'
      }, {
        en: 'dmsAngleValue',
        ti: '.DMSAngleType'
      }, {
        en: 'geometryStyle',
        ti: '.GeometryStylePropertyType'
      }, {
        en: 'usesTemporalDatum',
        ti: '.TemporalDatumRefType'
      }, {
        en: 'Tin',
        ti: '.TinType',
        sh: 'TriangulatedSurface'
      }, {
        en: 'trianglePatches',
        ti: '.TrianglePatchArrayPropertyType',
        sh: 'patches'
      }, {
        en: 'RectifiedGrid',
        ti: '.RectifiedGridType',
        sh: '_ImplicitGeometry'
      }, {
        en: 'inverseFlattening',
        ti: '.MeasureType'
      }, {
        en: 'FeatureStyle',
        ti: '.FeatureStyleType',
        sh: '_GML'
      }, {
        en: 'CompositeCurve',
        ti: '.CompositeCurveType',
        sh: '_Curve'
      }, {
        en: '_Datum',
        ti: '.AbstractDatumType',
        sh: 'Definition'
      }, {
        en: 'position',
        ti: '.PointPropertyType'
      }, {
        en: 'GridCoverage',
        ti: '.GridCoverageType',
        sh: '_DiscreteCoverage'
      }, {
        en: 'dictionaryEntry',
        ti: '.DictionaryEntryType'
      }, {
        en: 'includesCRS',
        ti: '.CoordinateReferenceSystemRefType'
      }, {
        en: 'methodFormula',
        ti: '.CodeType'
      }, {
        en: 'Array',
        ti: '.ArrayType',
        sh: '_GML'
      }, {
        en: 'topoComplexProperty',
        ti: '.TopoComplexMemberType'
      }, {
        en: 'BooleanList',
        ti: {
          t: 'l'
        }
      }, {
        en: 'temporalExtent',
        ti: '.TimePeriodType'
      }, {
        en: 'linearCSRef',
        ti: '.LinearCSRefType'
      }, {
        en: 'coordinateOperationID',
        ti: '.IdentifierType'
      }, {
        en: 'MultiPointCoverage',
        ti: '.MultiPointCoverageType',
        sh: '_DiscreteCoverage'
      }, {
        en: 'multiCenterOf',
        ti: '.MultiPointPropertyType'
      }, {
        en: 'EngineeringDatum',
        ti: '.EngineeringDatumType',
        sh: '_Datum'
      }, {
        en: 'validArea',
        ti: '.ExtentType'
      }, {
        en: 'minutes',
        ti: 'NonNegativeInteger'
      }, {
        en: 'innerBoundaryIs',
        ti: '.AbstractRingPropertyType',
        sh: 'interior'
      }, {
        en: 'CircleByCenterPoint',
        ti: '.CircleByCenterPointType',
        sh: 'ArcByCenterPoint'
      }, {
        en: 'OperationMethod',
        ti: '.OperationMethodType',
        sh: 'Definition'
      }, {
        en: 'Node',
        ti: '.NodeType',
        sh: '_TopoPrimitive'
      }, {
        en: 'multiPointDomain',
        ti: '.MultiPointDomainType',
        sh: 'domainSet'
      }, {
        en: 'topologyStyle',
        ti: '.TopologyStylePropertyType'
      }, {
        en: 'topoPrimitiveMember',
        ti: '.TopoPrimitiveMemberType'
      }, {
        en: 'usesPrimeMeridian',
        ti: '.PrimeMeridianRefType'
      }, {
        en: 'remarks',
        ti: '.StringOrRefType'
      }, {
        en: '_TimeTopologyPrimitive',
        ti: '.AbstractTimeTopologyPrimitiveType',
        sh: '_TimePrimitive'
      }, {
        en: 'temporalCRSRef',
        ti: '.TemporalCRSRefType'
      }, {
        en: 'UnitDefinition',
        ti: '.UnitDefinitionType',
        sh: 'Definition'
      }, {
        en: 'generalTransformationRef',
        ti: '.GeneralTransformationRefType'
      }, {
        en: 'multiSurfaceDomain',
        ti: '.MultiSurfaceDomainType',
        sh: 'domainSet'
      }, {
        en: 'topoSurfaceProperty',
        ti: '.TopoSurfacePropertyType'
      }, {
        en: 'MultiGeometry',
        ti: '.MultiGeometryType',
        sh: '_GeometricAggregate'
      }, {
        en: 'pointRep',
        ti: '.PointPropertyType'
      }, {
        en: 'solidMembers',
        ti: '.SolidArrayPropertyType'
      }, {
        en: '_SurfacePatch',
        ti: '.AbstractSurfacePatchType'
      }, {
        en: 'directedTopoSolid',
        ti: '.DirectedTopoSolidPropertyType'
      }, {
        en: 'coordinateOperationRef',
        ti: '.CoordinateOperationRefType'
      }, {
        en: 'boundingPolygon',
        ti: '.PolygonType'
      }, {
        en: 'solidArrayProperty',
        ti: '.SolidArrayPropertyType'
      }, {
        en: '_strictAssociation',
        ti: '.AssociationType'
      }, {
        en: 'DerivedCRS',
        ti: '.DerivedCRSType',
        sh: '_GeneralDerivedCRS'
      }, {
        en: '_CoordinateSystem',
        ti: '.AbstractCoordinateSystemType',
        sh: 'Definition'
      }, {
        en: 'Face',
        ti: '.FaceType',
        sh: '_TopoPrimitive'
      }, {
        en: 'integerValue',
        ti: 'PositiveInteger'
      }, {
        en: 'parameterID',
        ti: '.IdentifierType'
      }, {
        en: 'usesOperation',
        ti: '.OperationRefType'
      }, {
        en: 'multiSolidDomain',
        ti: '.MultiSolidDomainType',
        sh: 'domainSet'
      }, {
        en: 'datumRef',
        ti: '.DatumRefType'
      }, {
        en: 'methodName',
        ti: '.CodeType',
        sh: 'name'
      }, {
        en: 'verticalDatumRef',
        ti: '.VerticalDatumRefType'
      }, {
        en: 'Cone',
        ti: '.ConeType',
        sh: '_GriddedSurface'
      }, {
        en: 'usesMethod',
        ti: '.OperationMethodRefType'
      }, {
        en: 'surfaceProperty',
        ti: '.SurfacePropertyType'
      }, {
        en: 'abstractGeneralOperationParameterRef',
        ti: '.AbstractGeneralOperationParameterRefType'
      }, {
        en: 'ArcByCenterPoint',
        ti: '.ArcByCenterPointType',
        sh: '_CurveSegment'
      }, {
        en: '_GeneralConversion',
        ti: '.AbstractGeneralConversionType',
        sh: '_Operation'
      }, {
        en: '_TimeComplex',
        ti: '.AbstractTimeComplexType',
        sh: '_TimeObject'
      }, {
        en: 'engineeringDatumRef',
        ti: '.EngineeringDatumRefType'
      }, {
        en: 'multiEdgeOf',
        ti: '.MultiCurvePropertyType'
      }, {
        en: 'coord',
        ti: '.CoordType'
      }, {
        en: 'generalConversionRef',
        ti: '.GeneralConversionRefType'
      }, {
        en: 'CartesianCS',
        ti: '.CartesianCSType',
        sh: '_CoordinateSystem'
      }, {
        en: 'value',
        ti: '.MeasureType'
      }, {
        en: 'QuantityList',
        ti: '.MeasureOrNullListType'
      }, {
        en: 'transformationRef',
        ti: '.TransformationRefType'
      }, {
        en: 'valueFile'
      }, {
        en: '_Ring',
        ti: '.AbstractRingType',
        sh: '_Geometry'
      }, {
        en: 'Surface',
        ti: '.SurfaceType',
        sh: '_Surface'
      }, {
        en: 'ValueArray',
        ti: '.ValueArrayType',
        sh: 'CompositeValue'
      }, {
        en: 'maximumOccurs',
        ti: 'PositiveInteger'
      }, {
        en: 'TemporalDatum',
        ti: '.TemporalDatumType',
        sh: '_Datum'
      }, {
        en: 'usesEllipsoidalCS',
        ti: '.EllipsoidalCSRefType'
      }, {
        en: 'MultiCurveCoverage',
        ti: '.MultiCurveCoverageType',
        sh: '_DiscreteCoverage'
      }, {
        en: 'ellipsoidID',
        ti: '.IdentifierType'
      }, {
        en: '_GeneralDerivedCRS',
        ti: '.AbstractGeneralDerivedCRSType',
        sh: '_CoordinateReferenceSystem'
      }, {
        en: 'CountExtent',
        ti: {
          t: 'l'
        }
      }, {
        en: 'coordinateReferenceSystemRef',
        ti: '.CoordinateReferenceSystemRefType'
      }, {
        en: 'pos',
        ti: '.DirectPositionType'
      }, {
        en: 'maximalComplex',
        ti: '.TopoComplexMemberType'
      }, {
        en: '_ReferenceSystem',
        ti: '.AbstractReferenceSystemType',
        sh: 'Definition'
      }, {
        en: 'description',
        ti: '.StringOrRefType'
      }, {
        en: 'pointMembers',
        ti: '.PointArrayPropertyType'
      }, {
        en: 'curveMembers',
        ti: '.CurveArrayPropertyType'
      }, {
        en: 'coverageFunction',
        ti: '.CoverageFunctionType'
      }, {
        en: 'includesParameter',
        ti: '.AbstractGeneralOperationParameterRefType'
      }, {
        en: 'seconds',
        ti: 'Decimal'
      }, {
        en: 'TemporalCRS',
        ti: '.TemporalCRSType',
        sh: '_CoordinateReferenceSystem'
      }, {
        en: 'TimeCalendarEra',
        ti: '.TimeCalendarEraType',
        sh: 'Definition'
      }, {
        en: 'TimeTopologyComplex',
        ti: '.TimeTopologyComplexType',
        sh: '_TimeComplex'
      }, {
        en: 'FeatureCollection',
        ti: '.FeatureCollectionType',
        sh: '_Feature'
      }, {
        en: 'DirectedObservation',
        ti: '.DirectedObservationType',
        sh: 'Observation'
      }, {
        en: 'TimeInstant',
        ti: '.TimeInstantType',
        sh: '_TimeGeometricPrimitive'
      }, {
        en: 'using',
        ti: '.FeaturePropertyType'
      }, {
        en: 'superComplex',
        ti: '.TopoComplexMemberType'
      }, {
        en: 'integerValueList',
        ti: {
          t: 'l',
          bti: 'Integer'
        }
      }, {
        en: 'groupID',
        ti: '.IdentifierType'
      }, {
        en: '_Object',
        ti: 'AnyType'
      }, {
        en: 'usesCS',
        ti: '.CoordinateSystemRefType'
      }, {
        en: 'track',
        ti: '.TrackType',
        sh: 'history'
      }, {
        en: 'operationRef',
        ti: '.OperationRefType'
      }, {
        en: 'MultiLineString',
        ti: '.MultiLineStringType',
        sh: '_GeometricAggregate'
      }, {
        en: 'Triangle',
        ti: '.TriangleType',
        sh: '_SurfacePatch'
      }, {
        en: 'edgeOf',
        ti: '.CurvePropertyType'
      }, {
        en: 'valuesOfGroup',
        ti: '.OperationParameterGroupRefType'
      }, {
        en: 'EngineeringCRS',
        ti: '.EngineeringCRSType',
        sh: '_CoordinateReferenceSystem'
      }, {
        en: 'MovingObjectStatus',
        ti: '.MovingObjectStatusType',
        sh: '_TimeSlice'
      }, {
        en: 'featureProperty',
        ti: '.FeaturePropertyType'
      }, {
        en: 'groupName',
        ti: '.CodeType',
        sh: 'name'
      }, {
        en: 'GeodeticDatum',
        ti: '.GeodeticDatumType',
        sh: '_Datum'
      }, {
        en: 'tupleList',
        ti: '.CoordinatesType'
      }, {
        en: 'projectedCRSRef',
        ti: '.ProjectedCRSRefType'
      }, {
        en: 'Curve',
        ti: '.CurveType',
        sh: '_Curve'
      }, {
        en: 'indirectEntry',
        ti: '.IndirectEntryType'
      }, {
        en: '_ParametricCurveSurface',
        ti: '.AbstractParametricCurveSurfaceType',
        sh: '_SurfacePatch'
      }, {
        en: 'Cylinder',
        ti: '.CylinderType',
        sh: '_GriddedSurface'
      }, {
        en: 'SphericalCS',
        ti: '.SphericalCSType',
        sh: '_CoordinateSystem'
      }, {
        en: 'UserDefinedCS',
        ti: '.UserDefinedCSType',
        sh: '_CoordinateSystem'
      }, {
        en: 'cartesianCSRef',
        ti: '.CartesianCSRefType'
      }, {
        en: 'usesCartesianCS',
        ti: '.CartesianCSRefType'
      }, {
        en: 'AffinePlacement',
        ti: '.AffinePlacementType'
      }, {
        en: 'PolygonPatch',
        ti: '.PolygonPatchType',
        sh: '_SurfacePatch'
      }, {
        en: 'LabelExpression',
        sc: '.LabelType'
      }, {
        en: 'multiSolidProperty',
        ti: '.MultiSolidPropertyType'
      }, {
        en: 'MultiPoint',
        ti: '.MultiPointType',
        sh: '_GeometricAggregate'
      }, {
        en: 'TopoSolid',
        ti: '.TopoSolidType',
        sh: '_TopoPrimitive'
      }, {
        en: 'multiCurveDomain',
        ti: '.MultiCurveDomainType',
        sh: 'domainSet'
      }, {
        en: 'MappingRule',
        ti: '.StringOrRefType'
      }, {
        en: 'valueOfParameter',
        ti: '.OperationParameterRefType'
      }, {
        en: 'cylindricalCSRef',
        ti: '.CylindricalCSRefType'
      }, {
        en: 'ImageDatum',
        ti: '.ImageDatumType',
        sh: '_Datum'
      }, {
        en: 'VerticalDatum',
        ti: '.VerticalDatumType',
        sh: '_Datum'
      }, {
        en: 'pointArrayProperty',
        ti: '.PointArrayPropertyType'
      }, {
        en: 'lineStringProperty',
        ti: '.LineStringPropertyType'
      }, {
        en: '_reference',
        ti: '.ReferenceType'
      }, {
        en: 'srsName',
        ti: '.CodeType',
        sh: 'name'
      }, {
        en: 'OperationParameterGroup',
        ti: '.OperationParameterGroupType',
        sh: '_GeneralOperationParameter'
      }, {
        en: 'operationMethodRef',
        ti: '.OperationMethodRefType'
      }, {
        en: 'timeInterval',
        ti: '.TimeIntervalLengthType'
      }, {
        en: 'parameterValueGroup',
        ti: '.ParameterValueGroupType',
        sh: '_generalParameterValue'
      }, {
        en: 'conversionToPreferredUnit',
        ti: '.ConversionToPreferredUnitType'
      }, {
        en: 'TimeOrdinalEra',
        ti: '.TimeOrdinalEraType'
      }, {
        en: 'MultiSurface',
        ti: '.MultiSurfaceType',
        sh: '_GeometricAggregate'
      }, {
        en: 'solidMember',
        ti: '.SolidPropertyType'
      }, {
        en: 'quantityType',
        ti: '.StringOrRefType'
      }, {
        en: 'Style',
        ti: '.StyleType',
        sh: '_Style'
      }, {
        en: 'members',
        ti: '.ArrayAssociationType'
      }, {
        en: 'columnIndex',
        ti: 'PositiveInteger'
      }, {
        en: 'sourceCRS',
        ti: '.CRSRefType'
      }, {
        en: 'conversionRef',
        ti: '.ConversionRefType'
      }, {
        en: 'GeometryStyle',
        ti: '.GeometryStyleType',
        sh: '_GML'
      }, {
        en: 'measure',
        ti: '.MeasureType'
      }, {
        en: 'axisID',
        ti: '.IdentifierType'
      }, {
        en: 'compoundCRSRef',
        ti: '.CompoundCRSRefType'
      }, {
        en: 'multiLocation',
        ti: '.MultiPointPropertyType'
      }, {
        en: 'DirectionVector',
        ti: '.DirectionVectorType'
      }, {
        en: 'version'
      }, {
        en: 'topoVolumeProperty',
        ti: '.TopoVolumePropertyType'
      }, {
        en: 'engineeringCRSRef',
        ti: '.EngineeringCRSRefType'
      }, {
        en: 'curveMember',
        ti: '.CurvePropertyType'
      }, {
        en: 'valueComponent',
        ti: '.ValuePropertyType'
      }, {
        en: 'CoordinateSystemAxis',
        ti: '.CoordinateSystemAxisType',
        sh: 'Definition'
      }, {
        en: 'anchorPoint',
        ti: '.CodeType'
      }, {
        en: 'TopoComplex',
        ti: '.TopoComplexType',
        sh: '_Topology'
      }, {
        en: 'GridFunction',
        ti: '.GridFunctionType'
      }, {
        en: 'baseCRS',
        ti: '.CoordinateReferenceSystemRefType'
      }, {
        en: 'Count',
        ti: 'Integer'
      }, {
        en: 'polarCSRef',
        ti: '.PolarCSRefType'
      }, {
        en: 'target',
        ti: '.TargetPropertyType'
      }, {
        en: 'graphStyle',
        ti: '.GraphStylePropertyType'
      }, {
        en: 'ellipsoidRef',
        ti: '.EllipsoidRefType'
      }, {
        en: 'valueList',
        ti: '.MeasureListType'
      }]
  };
  return {
    GML_3_1_1: GML_3_1_1
  };
};
if (typeof define === 'function' && define.amd) {
  define([], GML_3_1_1_Module_Factory);
}
else {
  var GML_3_1_1_Module = GML_3_1_1_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.GML_3_1_1 = GML_3_1_1_Module.GML_3_1_1;
  }
  else {
    var GML_3_1_1 = GML_3_1_1_Module.GML_3_1_1;
  }
}
},{}],7:[function(require,module,exports){
var OWS_1_0_0_Module_Factory = function () {
  var OWS_1_0_0 = {
    n: 'OWS_1_0_0',
    dens: 'http:\/\/www.opengis.net\/ows',
    dans: 'http:\/\/www.w3.org\/1999\/xlink',
    deps: ['XLink_1_0'],
    tis: [{
        ln: 'ResponsiblePartyType',
        ps: [{
            n: 'individualName',
            en: 'IndividualName'
          }, {
            n: 'organisationName',
            en: 'OrganisationName'
          }, {
            n: 'positionName',
            en: 'PositionName'
          }, {
            n: 'contactInfo',
            en: 'ContactInfo',
            ti: '.ContactType'
          }, {
            n: 'role',
            rq: true,
            en: 'Role',
            ti: '.CodeType'
          }]
      }, {
        ln: 'ServiceProvider',
        tn: null,
        ps: [{
            n: 'providerName',
            rq: true,
            en: 'ProviderName'
          }, {
            n: 'providerSite',
            en: 'ProviderSite',
            ti: '.OnlineResourceType'
          }, {
            n: 'serviceContact',
            rq: true,
            en: 'ServiceContact',
            ti: '.ResponsiblePartySubsetType'
          }]
      }, {
        ln: 'WGS84BoundingBoxType',
        bti: '.BoundingBoxType'
      }, {
        ln: 'Operation',
        tn: null,
        ps: [{
            n: 'dcp',
            rq: true,
            col: true,
            en: 'DCP',
            ti: '.DCP'
          }, {
            n: 'parameter',
            mno: 0,
            col: true,
            en: 'Parameter',
            ti: '.DomainType'
          }, {
            n: 'constraint',
            mno: 0,
            col: true,
            en: 'Constraint',
            ti: '.DomainType'
          }, {
            n: 'metadata',
            mno: 0,
            col: true,
            en: 'Metadata',
            ti: '.MetadataType'
          }, {
            n: 'name',
            rq: true,
            an: {
              lp: 'name'
            },
            t: 'a'
          }]
      }, {
        ln: 'AcceptVersionsType',
        ps: [{
            n: 'version',
            rq: true,
            col: true,
            en: 'Version'
          }]
      }, {
        ln: 'OperationsMetadata',
        tn: null,
        ps: [{
            n: 'operation',
            rq: true,
            mno: 2,
            col: true,
            en: 'Operation',
            ti: '.Operation'
          }, {
            n: 'parameter',
            mno: 0,
            col: true,
            en: 'Parameter',
            ti: '.DomainType'
          }, {
            n: 'constraint',
            mno: 0,
            col: true,
            en: 'Constraint',
            ti: '.DomainType'
          }, {
            n: 'extendedCapabilities',
            en: 'ExtendedCapabilities',
            ti: 'AnyType'
          }]
      }, {
        ln: 'SectionsType',
        ps: [{
            n: 'section',
            mno: 0,
            col: true,
            en: 'Section'
          }]
      }, {
        ln: 'CapabilitiesBaseType',
        ps: [{
            n: 'serviceIdentification',
            en: 'ServiceIdentification',
            ti: '.ServiceIdentification'
          }, {
            n: 'serviceProvider',
            en: 'ServiceProvider',
            ti: '.ServiceProvider'
          }, {
            n: 'operationsMetadata',
            en: 'OperationsMetadata',
            ti: '.OperationsMetadata'
          }, {
            n: 'version',
            rq: true,
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'updateSequence',
            an: {
              lp: 'updateSequence'
            },
            t: 'a'
          }]
      }, {
        ln: 'GetCapabilitiesType',
        ps: [{
            n: 'acceptVersions',
            en: 'AcceptVersions',
            ti: '.AcceptVersionsType'
          }, {
            n: 'sections',
            en: 'Sections',
            ti: '.SectionsType'
          }, {
            n: 'acceptFormats',
            en: 'AcceptFormats',
            ti: '.AcceptFormatsType'
          }, {
            n: 'updateSequence',
            an: {
              lp: 'updateSequence'
            },
            t: 'a'
          }]
      }, {
        ln: 'DomainType',
        ps: [{
            n: 'value',
            rq: true,
            col: true,
            en: 'Value'
          }, {
            n: 'metadata',
            mno: 0,
            col: true,
            en: 'Metadata',
            ti: '.MetadataType'
          }, {
            n: 'name',
            rq: true,
            an: {
              lp: 'name'
            },
            t: 'a'
          }]
      }, {
        ln: 'RequestMethodType',
        bti: '.OnlineResourceType',
        ps: [{
            n: 'constraint',
            mno: 0,
            col: true,
            en: 'Constraint',
            ti: '.DomainType'
          }]
      }, {
        ln: 'IdentificationType',
        bti: '.DescriptionType',
        ps: [{
            n: 'identifier',
            en: 'Identifier',
            ti: '.CodeType'
          }, {
            n: 'boundingBox',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: 'BoundingBox',
            ti: '.BoundingBoxType',
            t: 'er'
          }, {
            n: 'outputFormat',
            mno: 0,
            col: true,
            en: 'OutputFormat'
          }, {
            n: 'availableCRS',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: 'AvailableCRS',
            t: 'er'
          }, {
            n: 'metadata',
            mno: 0,
            col: true,
            en: 'Metadata',
            ti: '.MetadataType'
          }]
      }, {
        ln: 'MetadataType',
        ps: [{
            n: 'abstractMetaData',
            en: 'AbstractMetaData',
            ti: 'AnyType'
          }, {
            n: 'about',
            an: {
              lp: 'about'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'AcceptFormatsType',
        ps: [{
            n: 'outputFormat',
            mno: 0,
            col: true,
            en: 'OutputFormat'
          }]
      }, {
        ln: 'CodeType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'codeSpace',
            an: {
              lp: 'codeSpace'
            },
            t: 'a'
          }]
      }, {
        ln: 'AddressType',
        ps: [{
            n: 'deliveryPoint',
            mno: 0,
            col: true,
            en: 'DeliveryPoint'
          }, {
            n: 'city',
            en: 'City'
          }, {
            n: 'administrativeArea',
            en: 'AdministrativeArea'
          }, {
            n: 'postalCode',
            en: 'PostalCode'
          }, {
            n: 'country',
            en: 'Country'
          }, {
            n: 'electronicMailAddress',
            mno: 0,
            col: true,
            en: 'ElectronicMailAddress'
          }]
      }, {
        ln: 'BoundingBoxType',
        ps: [{
            n: 'lowerCorner',
            rq: true,
            en: 'LowerCorner',
            ti: {
              t: 'l',
              bti: 'Double'
            }
          }, {
            n: 'upperCorner',
            rq: true,
            en: 'UpperCorner',
            ti: {
              t: 'l',
              bti: 'Double'
            }
          }, {
            n: 'crs',
            an: {
              lp: 'crs'
            },
            t: 'a'
          }, {
            n: 'dimensions',
            ti: 'PositiveInteger',
            an: {
              lp: 'dimensions'
            },
            t: 'a'
          }]
      }, {
        ln: 'KeywordsType',
        ps: [{
            n: 'keyword',
            rq: true,
            col: true,
            en: 'Keyword'
          }, {
            n: 'type',
            en: 'Type',
            ti: '.CodeType'
          }]
      }, {
        ln: 'DescriptionType',
        ps: [{
            n: 'title',
            en: 'Title'
          }, {
            n: '_abstract',
            en: 'Abstract'
          }, {
            n: 'keywords',
            mno: 0,
            col: true,
            en: 'Keywords',
            ti: '.KeywordsType'
          }]
      }, {
        ln: 'ContactType',
        ps: [{
            n: 'phone',
            en: 'Phone',
            ti: '.TelephoneType'
          }, {
            n: 'address',
            en: 'Address',
            ti: '.AddressType'
          }, {
            n: 'onlineResource',
            en: 'OnlineResource',
            ti: '.OnlineResourceType'
          }, {
            n: 'hoursOfService',
            en: 'HoursOfService'
          }, {
            n: 'contactInstructions',
            en: 'ContactInstructions'
          }]
      }, {
        ln: 'ExceptionReport',
        tn: null,
        ps: [{
            n: 'exception',
            rq: true,
            col: true,
            en: 'Exception',
            ti: '.ExceptionType'
          }, {
            n: 'version',
            rq: true,
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'language',
            ti: 'Language',
            an: {
              lp: 'language'
            },
            t: 'a'
          }]
      }, {
        ln: 'ResponsiblePartySubsetType',
        ps: [{
            n: 'individualName',
            en: 'IndividualName'
          }, {
            n: 'positionName',
            en: 'PositionName'
          }, {
            n: 'contactInfo',
            en: 'ContactInfo',
            ti: '.ContactType'
          }, {
            n: 'role',
            en: 'Role',
            ti: '.CodeType'
          }]
      }, {
        ln: 'DCP',
        tn: null,
        ps: [{
            n: 'http',
            rq: true,
            en: 'HTTP',
            ti: '.HTTP'
          }]
      }, {
        ln: 'HTTP',
        tn: null,
        ps: [{
            n: 'getOrPost',
            rq: true,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'Post',
                ti: '.RequestMethodType'
              }, {
                en: 'Get',
                ti: '.RequestMethodType'
              }],
            t: 'ers'
          }]
      }, {
        ln: 'TelephoneType',
        ps: [{
            n: 'voice',
            mno: 0,
            col: true,
            en: 'Voice'
          }, {
            n: 'facsimile',
            mno: 0,
            col: true,
            en: 'Facsimile'
          }]
      }, {
        ln: 'ServiceIdentification',
        tn: null,
        bti: '.DescriptionType',
        ps: [{
            n: 'serviceType',
            rq: true,
            en: 'ServiceType',
            ti: '.CodeType'
          }, {
            n: 'serviceTypeVersion',
            rq: true,
            col: true,
            en: 'ServiceTypeVersion'
          }, {
            n: 'fees',
            en: 'Fees'
          }, {
            n: 'accessConstraints',
            mno: 0,
            col: true,
            en: 'AccessConstraints'
          }]
      }, {
        ln: 'ExceptionType',
        ps: [{
            n: 'exceptionText',
            mno: 0,
            col: true,
            en: 'ExceptionText'
          }, {
            n: 'exceptionCode',
            rq: true,
            an: {
              lp: 'exceptionCode'
            },
            t: 'a'
          }, {
            n: 'locator',
            an: {
              lp: 'locator'
            },
            t: 'a'
          }]
      }, {
        ln: 'OnlineResourceType',
        ps: [{
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }],
    eis: [{
        en: 'GetCapabilities',
        ti: '.GetCapabilitiesType'
      }, {
        en: 'ServiceProvider',
        ti: '.ServiceProvider'
      }, {
        en: 'PointOfContact',
        ti: '.ResponsiblePartyType'
      }, {
        en: 'ContactInfo',
        ti: '.ContactType'
      }, {
        en: 'OrganisationName'
      }, {
        en: 'HTTP',
        ti: '.HTTP'
      }, {
        en: 'Title'
      }, {
        en: 'Language',
        ti: 'Language'
      }, {
        en: 'DCP',
        ti: '.DCP'
      }, {
        en: 'AvailableCRS'
      }, {
        en: 'AbstractMetaData',
        ti: 'AnyType'
      }, {
        en: 'PositionName'
      }, {
        en: 'SupportedCRS',
        sh: 'AvailableCRS'
      }, {
        en: 'AccessConstraints'
      }, {
        en: 'OperationsMetadata',
        ti: '.OperationsMetadata'
      }, {
        en: 'ExtendedCapabilities',
        ti: 'AnyType'
      }, {
        en: 'Operation',
        ti: '.Operation'
      }, {
        en: 'Fees'
      }, {
        en: 'IndividualName'
      }, {
        en: 'Role',
        ti: '.CodeType'
      }, {
        en: 'Abstract'
      }, {
        en: 'Identifier',
        ti: '.CodeType'
      }, {
        en: 'OutputFormat'
      }, {
        en: 'WGS84BoundingBox',
        ti: '.WGS84BoundingBoxType',
        sh: 'BoundingBox'
      }, {
        en: 'Metadata',
        ti: '.MetadataType'
      }, {
        en: 'Post',
        ti: '.RequestMethodType',
        sc: '.HTTP'
      }, {
        en: 'ServiceIdentification',
        ti: '.ServiceIdentification'
      }, {
        en: 'ExceptionReport',
        ti: '.ExceptionReport'
      }, {
        en: 'BoundingBox',
        ti: '.BoundingBoxType'
      }, {
        en: 'Keywords',
        ti: '.KeywordsType'
      }, {
        en: 'Exception',
        ti: '.ExceptionType'
      }, {
        en: 'Get',
        ti: '.RequestMethodType',
        sc: '.HTTP'
      }]
  };
  return {
    OWS_1_0_0: OWS_1_0_0
  };
};
if (typeof define === 'function' && define.amd) {
  define([], OWS_1_0_0_Module_Factory);
}
else {
  var OWS_1_0_0_Module = OWS_1_0_0_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.OWS_1_0_0 = OWS_1_0_0_Module.OWS_1_0_0;
  }
  else {
    var OWS_1_0_0 = OWS_1_0_0_Module.OWS_1_0_0;
  }
}
},{}],8:[function(require,module,exports){
var OWS_1_1_0_Module_Factory = function () {
  var OWS_1_1_0 = {
    n: 'OWS_1_1_0',
    dens: 'http:\/\/www.opengis.net\/ows\/1.1',
    dans: 'http:\/\/www.w3.org\/1999\/xlink',
    deps: ['XLink_1_0'],
    tis: [{
        ln: 'ReferenceGroupType',
        bti: '.BasicIdentificationType',
        ps: [{
            n: 'abstractReferenceBase',
            rq: true,
            col: true,
            mx: false,
            dom: false,
            en: 'AbstractReferenceBase',
            ti: '.AbstractReferenceBaseType',
            t: 'er'
          }]
      }, {
        ln: 'GetCapabilitiesType',
        ps: [{
            n: 'acceptVersions',
            en: 'AcceptVersions',
            ti: '.AcceptVersionsType'
          }, {
            n: 'sections',
            en: 'Sections',
            ti: '.SectionsType'
          }, {
            n: 'acceptFormats',
            en: 'AcceptFormats',
            ti: '.AcceptFormatsType'
          }, {
            n: 'updateSequence',
            an: {
              lp: 'updateSequence'
            },
            t: 'a'
          }]
      }, {
        ln: 'GetResourceByIdType',
        ps: [{
            n: 'resourceID',
            mno: 0,
            col: true,
            en: 'ResourceID'
          }, {
            n: 'outputFormat',
            en: 'OutputFormat'
          }, {
            n: 'service',
            rq: true,
            an: {
              lp: 'service'
            },
            t: 'a'
          }, {
            n: 'version',
            rq: true,
            an: {
              lp: 'version'
            },
            t: 'a'
          }]
      }, {
        ln: 'ValuesReference',
        tn: null,
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'reference',
            rq: true,
            an: {
              lp: 'reference',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            t: 'a'
          }]
      }, {
        ln: 'MetadataType',
        ps: [{
            n: 'abstractMetaData',
            en: 'AbstractMetaData',
            ti: 'AnyType'
          }, {
            n: 'about',
            an: {
              lp: 'about'
            },
            t: 'a'
          }, {
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'DescriptionType',
        ps: [{
            n: 'title',
            mno: 0,
            col: true,
            en: 'Title',
            ti: '.LanguageStringType'
          }, {
            n: '_abstract',
            mno: 0,
            col: true,
            en: 'Abstract',
            ti: '.LanguageStringType'
          }, {
            n: 'keywords',
            mno: 0,
            col: true,
            en: 'Keywords',
            ti: '.KeywordsType'
          }]
      }, {
        ln: 'ServiceReferenceType',
        bti: '.ReferenceType',
        ps: [{
            n: 'requestMessage',
            rq: true,
            en: 'RequestMessage',
            ti: 'AnyType'
          }, {
            n: 'requestMessageReference',
            rq: true,
            en: 'RequestMessageReference'
          }]
      }, {
        ln: 'LanguageStringType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'lang',
            an: {
              lp: 'lang',
              ns: 'http:\/\/www.w3.org\/XML\/1998\/namespace'
            },
            t: 'a'
          }]
      }, {
        ln: 'HTTP',
        tn: null,
        ps: [{
            n: 'getOrPost',
            rq: true,
            col: true,
            mx: false,
            dom: false,
            etis: [{
                en: 'Get',
                ti: '.RequestMethodType'
              }, {
                en: 'Post',
                ti: '.RequestMethodType'
              }],
            t: 'ers'
          }]
      }, {
        ln: 'AllowedValues',
        tn: null,
        ps: [{
            n: 'valueOrRange',
            rq: true,
            col: true,
            etis: [{
                en: 'Value',
                ti: '.ValueType'
              }, {
                en: 'Range',
                ti: '.RangeType'
              }],
            t: 'es'
          }]
      }, {
        ln: 'KeywordsType',
        ps: [{
            n: 'keyword',
            rq: true,
            col: true,
            en: 'Keyword',
            ti: '.LanguageStringType'
          }, {
            n: 'type',
            en: 'Type',
            ti: '.CodeType'
          }]
      }, {
        ln: 'UnNamedDomainType',
        ps: [{
            n: 'allowedValues',
            rq: true,
            en: 'AllowedValues',
            ti: '.AllowedValues'
          }, {
            n: 'anyValue',
            rq: true,
            en: 'AnyValue',
            ti: '.AnyValue'
          }, {
            n: 'noValues',
            rq: true,
            en: 'NoValues',
            ti: '.NoValues'
          }, {
            n: 'valuesReference',
            rq: true,
            en: 'ValuesReference',
            ti: '.ValuesReference'
          }, {
            n: 'defaultValue',
            en: 'DefaultValue',
            ti: '.ValueType'
          }, {
            n: 'meaning',
            en: 'Meaning',
            ti: '.DomainMetadataType'
          }, {
            n: 'dataType',
            en: 'DataType',
            ti: '.DomainMetadataType'
          }, {
            n: 'uom',
            rq: true,
            en: 'UOM',
            ti: '.DomainMetadataType'
          }, {
            n: 'referenceSystem',
            rq: true,
            en: 'ReferenceSystem',
            ti: '.DomainMetadataType'
          }, {
            n: 'metadata',
            mno: 0,
            col: true,
            en: 'Metadata',
            ti: '.MetadataType'
          }]
      }, {
        ln: 'TelephoneType',
        ps: [{
            n: 'voice',
            mno: 0,
            col: true,
            en: 'Voice'
          }, {
            n: 'facsimile',
            mno: 0,
            col: true,
            en: 'Facsimile'
          }]
      }, {
        ln: 'ResponsiblePartyType',
        ps: [{
            n: 'individualName',
            en: 'IndividualName'
          }, {
            n: 'organisationName',
            en: 'OrganisationName'
          }, {
            n: 'positionName',
            en: 'PositionName'
          }, {
            n: 'contactInfo',
            en: 'ContactInfo',
            ti: '.ContactType'
          }, {
            n: 'role',
            rq: true,
            en: 'Role',
            ti: '.CodeType'
          }]
      }, {
        ln: 'ResponsiblePartySubsetType',
        ps: [{
            n: 'individualName',
            en: 'IndividualName'
          }, {
            n: 'positionName',
            en: 'PositionName'
          }, {
            n: 'contactInfo',
            en: 'ContactInfo',
            ti: '.ContactType'
          }, {
            n: 'role',
            en: 'Role',
            ti: '.CodeType'
          }]
      }, {
        ln: 'AddressType',
        ps: [{
            n: 'deliveryPoint',
            mno: 0,
            col: true,
            en: 'DeliveryPoint'
          }, {
            n: 'city',
            en: 'City'
          }, {
            n: 'administrativeArea',
            en: 'AdministrativeArea'
          }, {
            n: 'postalCode',
            en: 'PostalCode'
          }, {
            n: 'country',
            en: 'Country'
          }, {
            n: 'electronicMailAddress',
            mno: 0,
            col: true,
            en: 'ElectronicMailAddress'
          }]
      }, {
        ln: 'ValueType',
        ps: [{
            n: 'value',
            t: 'v'
          }]
      }, {
        ln: 'ExceptionType',
        ps: [{
            n: 'exceptionText',
            mno: 0,
            col: true,
            en: 'ExceptionText'
          }, {
            n: 'exceptionCode',
            rq: true,
            an: {
              lp: 'exceptionCode'
            },
            t: 'a'
          }, {
            n: 'locator',
            an: {
              lp: 'locator'
            },
            t: 'a'
          }]
      }, {
        ln: 'NoValues',
        tn: null
      }, {
        ln: 'WGS84BoundingBoxType',
        bti: '.BoundingBoxType'
      }, {
        ln: 'ServiceIdentification',
        tn: null,
        bti: '.DescriptionType',
        ps: [{
            n: 'serviceType',
            rq: true,
            en: 'ServiceType',
            ti: '.CodeType'
          }, {
            n: 'serviceTypeVersion',
            rq: true,
            col: true,
            en: 'ServiceTypeVersion'
          }, {
            n: 'profile',
            mno: 0,
            col: true,
            en: 'Profile'
          }, {
            n: 'fees',
            en: 'Fees'
          }, {
            n: 'accessConstraints',
            mno: 0,
            col: true,
            en: 'AccessConstraints'
          }]
      }, {
        ln: 'AcceptVersionsType',
        ps: [{
            n: 'version',
            rq: true,
            col: true,
            en: 'Version'
          }]
      }, {
        ln: 'SectionsType',
        ps: [{
            n: 'section',
            mno: 0,
            col: true,
            en: 'Section'
          }]
      }, {
        ln: 'ContactType',
        ps: [{
            n: 'phone',
            en: 'Phone',
            ti: '.TelephoneType'
          }, {
            n: 'address',
            en: 'Address',
            ti: '.AddressType'
          }, {
            n: 'onlineResource',
            en: 'OnlineResource',
            ti: '.OnlineResourceType'
          }, {
            n: 'hoursOfService',
            en: 'HoursOfService'
          }, {
            n: 'contactInstructions',
            en: 'ContactInstructions'
          }]
      }, {
        ln: 'RangeType',
        ps: [{
            n: 'minimumValue',
            en: 'MinimumValue',
            ti: '.ValueType'
          }, {
            n: 'maximumValue',
            en: 'MaximumValue',
            ti: '.ValueType'
          }, {
            n: 'spacing',
            en: 'Spacing',
            ti: '.ValueType'
          }, {
            n: 'rangeClosure',
            ti: {
              t: 'l'
            },
            an: {
              lp: 'rangeClosure',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            t: 'a'
          }]
      }, {
        ln: 'ExceptionReport',
        tn: null,
        ps: [{
            n: 'exception',
            rq: true,
            col: true,
            en: 'Exception',
            ti: '.ExceptionType'
          }, {
            n: 'version',
            rq: true,
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'lang',
            an: {
              lp: 'lang',
              ns: 'http:\/\/www.w3.org\/XML\/1998\/namespace'
            },
            t: 'a'
          }]
      }, {
        ln: 'DatasetDescriptionSummaryBaseType',
        bti: '.DescriptionType',
        ps: [{
            n: 'wgs84BoundingBox',
            mno: 0,
            col: true,
            en: 'WGS84BoundingBox',
            ti: '.WGS84BoundingBoxType'
          }, {
            n: 'identifier',
            rq: true,
            en: 'Identifier',
            ti: '.CodeType'
          }, {
            n: 'boundingBox',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: 'BoundingBox',
            ti: '.BoundingBoxType',
            t: 'er'
          }, {
            n: 'metadata',
            mno: 0,
            col: true,
            en: 'Metadata',
            ti: '.MetadataType'
          }, {
            n: 'datasetDescriptionSummary',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: 'DatasetDescriptionSummary',
            ti: '.DatasetDescriptionSummaryBaseType',
            t: 'er'
          }]
      }, {
        ln: 'OperationsMetadata',
        tn: null,
        ps: [{
            n: 'operation',
            rq: true,
            mno: 2,
            col: true,
            en: 'Operation',
            ti: '.Operation'
          }, {
            n: 'parameter',
            mno: 0,
            col: true,
            en: 'Parameter',
            ti: '.DomainType'
          }, {
            n: 'constraint',
            mno: 0,
            col: true,
            en: 'Constraint',
            ti: '.DomainType'
          }, {
            n: 'extendedCapabilities',
            en: 'ExtendedCapabilities',
            ti: 'AnyType'
          }]
      }, {
        ln: 'IdentificationType',
        bti: '.BasicIdentificationType',
        ps: [{
            n: 'boundingBox',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: 'BoundingBox',
            ti: '.BoundingBoxType',
            t: 'er'
          }, {
            n: 'outputFormat',
            mno: 0,
            col: true,
            en: 'OutputFormat'
          }, {
            n: 'availableCRS',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: 'AvailableCRS',
            t: 'er'
          }]
      }, {
        ln: 'CodeType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'codeSpace',
            an: {
              lp: 'codeSpace'
            },
            t: 'a'
          }]
      }, {
        ln: 'ManifestType',
        bti: '.BasicIdentificationType',
        ps: [{
            n: 'referenceGroup',
            rq: true,
            col: true,
            en: 'ReferenceGroup',
            ti: '.ReferenceGroupType'
          }]
      }, {
        ln: 'Operation',
        tn: null,
        ps: [{
            n: 'dcp',
            rq: true,
            col: true,
            en: 'DCP',
            ti: '.DCP'
          }, {
            n: 'parameter',
            mno: 0,
            col: true,
            en: 'Parameter',
            ti: '.DomainType'
          }, {
            n: 'constraint',
            mno: 0,
            col: true,
            en: 'Constraint',
            ti: '.DomainType'
          }, {
            n: 'metadata',
            mno: 0,
            col: true,
            en: 'Metadata',
            ti: '.MetadataType'
          }, {
            n: 'name',
            rq: true,
            an: {
              lp: 'name'
            },
            t: 'a'
          }]
      }, {
        ln: 'ContentsBaseType',
        ps: [{
            n: 'datasetDescriptionSummary',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: 'DatasetDescriptionSummary',
            ti: '.DatasetDescriptionSummaryBaseType',
            t: 'er'
          }, {
            n: 'otherSource',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: 'OtherSource',
            ti: '.MetadataType',
            t: 'er'
          }]
      }, {
        ln: 'DomainType',
        bti: '.UnNamedDomainType',
        ps: [{
            n: 'name',
            rq: true,
            an: {
              lp: 'name'
            },
            t: 'a'
          }]
      }, {
        ln: 'BasicIdentificationType',
        bti: '.DescriptionType',
        ps: [{
            n: 'identifier',
            en: 'Identifier',
            ti: '.CodeType'
          }, {
            n: 'metadata',
            mno: 0,
            col: true,
            en: 'Metadata',
            ti: '.MetadataType'
          }]
      }, {
        ln: 'OnlineResourceType',
        ps: [{
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'ServiceProvider',
        tn: null,
        ps: [{
            n: 'providerName',
            rq: true,
            en: 'ProviderName'
          }, {
            n: 'providerSite',
            en: 'ProviderSite',
            ti: '.OnlineResourceType'
          }, {
            n: 'serviceContact',
            rq: true,
            en: 'ServiceContact',
            ti: '.ResponsiblePartySubsetType'
          }]
      }, {
        ln: 'DomainMetadataType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'reference',
            an: {
              lp: 'reference',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            t: 'a'
          }]
      }, {
        ln: 'AcceptFormatsType',
        ps: [{
            n: 'outputFormat',
            mno: 0,
            col: true,
            en: 'OutputFormat'
          }]
      }, {
        ln: 'DCP',
        tn: null,
        ps: [{
            n: 'http',
            rq: true,
            en: 'HTTP',
            ti: '.HTTP'
          }]
      }, {
        ln: 'BoundingBoxType',
        ps: [{
            n: 'lowerCorner',
            rq: true,
            en: 'LowerCorner',
            ti: {
              t: 'l',
              bti: 'Double'
            }
          }, {
            n: 'upperCorner',
            rq: true,
            en: 'UpperCorner',
            ti: {
              t: 'l',
              bti: 'Double'
            }
          }, {
            n: 'crs',
            an: {
              lp: 'crs'
            },
            t: 'a'
          }, {
            n: 'dimensions',
            ti: 'PositiveInteger',
            an: {
              lp: 'dimensions'
            },
            t: 'a'
          }]
      }, {
        ln: 'ReferenceType',
        bti: '.AbstractReferenceBaseType',
        ps: [{
            n: 'identifier',
            en: 'Identifier',
            ti: '.CodeType'
          }, {
            n: '_abstract',
            mno: 0,
            col: true,
            en: 'Abstract',
            ti: '.LanguageStringType'
          }, {
            n: 'format',
            en: 'Format'
          }, {
            n: 'metadata',
            mno: 0,
            col: true,
            en: 'Metadata',
            ti: '.MetadataType'
          }]
      }, {
        ln: 'AbstractReferenceBaseType',
        ps: [{
            n: 'type',
            an: {
              lp: 'type',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            t: 'a'
          }, {
            n: 'href',
            rq: true,
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'CapabilitiesBaseType',
        ps: [{
            n: 'serviceIdentification',
            en: 'ServiceIdentification',
            ti: '.ServiceIdentification'
          }, {
            n: 'serviceProvider',
            en: 'ServiceProvider',
            ti: '.ServiceProvider'
          }, {
            n: 'operationsMetadata',
            en: 'OperationsMetadata',
            ti: '.OperationsMetadata'
          }, {
            n: 'version',
            rq: true,
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'updateSequence',
            an: {
              lp: 'updateSequence'
            },
            t: 'a'
          }]
      }, {
        ln: 'RequestMethodType',
        bti: '.OnlineResourceType',
        ps: [{
            n: 'constraint',
            mno: 0,
            col: true,
            en: 'Constraint',
            ti: '.DomainType'
          }]
      }, {
        ln: 'AnyValue',
        tn: null
      }],
    eis: [{
        en: 'OtherSourceExtension',
        ti: '.MetadataType',
        sh: 'OtherSource'
      }, {
        en: 'Operation',
        ti: '.Operation'
      }, {
        en: 'Value',
        ti: '.ValueType'
      }, {
        en: 'ContactInfo',
        ti: '.ContactType'
      }, {
        en: 'DatasetDescriptionSummaryExtension',
        ti: '.DatasetDescriptionSummaryBaseType',
        sh: 'DatasetDescriptionSummary'
      }, {
        en: 'AnyValue',
        ti: '.AnyValue'
      }, {
        en: 'OrganisationName'
      }, {
        en: 'OtherSource',
        ti: '.MetadataType'
      }, {
        en: 'DefaultValue',
        ti: '.ValueType'
      }, {
        en: 'Spacing',
        ti: '.ValueType'
      }, {
        en: 'InputData',
        ti: '.ManifestType'
      }, {
        en: 'PointOfContact',
        ti: '.ResponsiblePartyType'
      }, {
        en: 'Meaning',
        ti: '.DomainMetadataType'
      }, {
        en: 'WGS84BoundingBox',
        ti: '.WGS84BoundingBoxType',
        sh: 'BoundingBox'
      }, {
        en: 'UOM',
        ti: '.DomainMetadataType'
      }, {
        en: 'Abstract',
        ti: '.LanguageStringType'
      }, {
        en: 'Fees'
      }, {
        en: 'ServiceReference',
        ti: '.ServiceReferenceType',
        sh: 'Reference'
      }, {
        en: 'AbstractReferenceBase',
        ti: '.AbstractReferenceBaseType'
      }, {
        en: 'Title',
        ti: '.LanguageStringType'
      }, {
        en: 'Resource',
        ti: 'AnyType'
      }, {
        en: 'AccessConstraints'
      }, {
        en: 'OperationsMetadata',
        ti: '.OperationsMetadata'
      }, {
        en: 'ExtendedCapabilities',
        ti: 'AnyType'
      }, {
        en: 'AbstractMetaData',
        ti: 'AnyType'
      }, {
        en: 'Metadata',
        ti: '.MetadataType'
      }, {
        en: 'NoValues',
        ti: '.NoValues'
      }, {
        en: 'ValuesReference',
        ti: '.ValuesReference'
      }, {
        en: 'ExceptionReport',
        ti: '.ExceptionReport'
      }, {
        en: 'Identifier',
        ti: '.CodeType'
      }, {
        en: 'SupportedCRS',
        sh: 'AvailableCRS'
      }, {
        en: 'ServiceIdentification',
        ti: '.ServiceIdentification'
      }, {
        en: 'AllowedValues',
        ti: '.AllowedValues'
      }, {
        en: 'IndividualName'
      }, {
        en: 'Language',
        ti: 'Language'
      }, {
        en: 'OperationResponse',
        ti: '.ManifestType'
      }, {
        en: 'HTTP',
        ti: '.HTTP'
      }, {
        en: 'GetResourceByID',
        ti: '.GetResourceByIdType'
      }, {
        en: 'Manifest',
        ti: '.ManifestType'
      }, {
        en: 'Role',
        ti: '.CodeType'
      }, {
        en: 'ReferenceGroup',
        ti: '.ReferenceGroupType'
      }, {
        en: 'DatasetDescriptionSummary',
        ti: '.DatasetDescriptionSummaryBaseType'
      }, {
        en: 'Get',
        ti: '.RequestMethodType',
        sc: '.HTTP'
      }, {
        en: 'DCP',
        ti: '.DCP'
      }, {
        en: 'OutputFormat'
      }, {
        en: 'DataType',
        ti: '.DomainMetadataType'
      }, {
        en: 'ReferenceSystem',
        ti: '.DomainMetadataType'
      }, {
        en: 'GetCapabilities',
        ti: '.GetCapabilitiesType'
      }, {
        en: 'ServiceProvider',
        ti: '.ServiceProvider'
      }, {
        en: 'Range',
        ti: '.RangeType'
      }, {
        en: 'PositionName'
      }, {
        en: 'Exception',
        ti: '.ExceptionType'
      }, {
        en: 'Post',
        ti: '.RequestMethodType',
        sc: '.HTTP'
      }, {
        en: 'Keywords',
        ti: '.KeywordsType'
      }, {
        en: 'MinimumValue',
        ti: '.ValueType'
      }, {
        en: 'AvailableCRS'
      }, {
        en: 'MaximumValue',
        ti: '.ValueType'
      }, {
        en: 'Reference',
        ti: '.ReferenceType',
        sh: 'AbstractReferenceBase'
      }, {
        en: 'BoundingBox',
        ti: '.BoundingBoxType'
      }]
  };
  return {
    OWS_1_1_0: OWS_1_1_0
  };
};
if (typeof define === 'function' && define.amd) {
  define([], OWS_1_1_0_Module_Factory);
}
else {
  var OWS_1_1_0_Module = OWS_1_1_0_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.OWS_1_1_0 = OWS_1_1_0_Module.OWS_1_1_0;
  }
  else {
    var OWS_1_1_0 = OWS_1_1_0_Module.OWS_1_1_0;
  }
}
},{}],9:[function(require,module,exports){
var SLD_1_0_0_Module_Factory = function () {
  var SLD_1_0_0 = {
    n: 'SLD_1_0_0',
    dens: 'http:\/\/www.opengis.net\/sld',
    dans: 'http:\/\/www.w3.org\/1999\/xlink',
    deps: ['XLink_1_0', 'Filter_1_0_0'],
    tis: [{
        ln: 'RasterSymbolizer',
        tn: null,
        bti: '.SymbolizerType',
        ps: [{
            n: 'geometry',
            en: 'Geometry',
            ti: '.Geometry'
          }, {
            n: 'opacity',
            en: 'Opacity',
            ti: '.ParameterValueType'
          }, {
            n: 'channelSelection',
            en: 'ChannelSelection',
            ti: '.ChannelSelection'
          }, {
            n: 'overlapBehavior',
            en: 'OverlapBehavior',
            ti: '.OverlapBehavior'
          }, {
            n: 'colorMap',
            en: 'ColorMap',
            ti: '.ColorMap'
          }, {
            n: 'contrastEnhancement',
            en: 'ContrastEnhancement',
            ti: '.ContrastEnhancement'
          }, {
            n: 'shadedRelief',
            en: 'ShadedRelief',
            ti: '.ShadedRelief'
          }, {
            n: 'imageOutline',
            en: 'ImageOutline',
            ti: '.ImageOutline'
          }]
      }, {
        ln: 'LayerFeatureConstraints',
        tn: null,
        ps: [{
            n: 'featureTypeConstraint',
            rq: true,
            col: true,
            en: 'FeatureTypeConstraint',
            ti: '.FeatureTypeConstraint'
          }]
      }, {
        ln: 'FeatureTypeStyle',
        tn: null,
        ps: [{
            n: 'name',
            en: 'Name'
          }, {
            n: 'title',
            en: 'Title'
          }, {
            n: '_abstract',
            en: 'Abstract'
          }, {
            n: 'featureTypeName',
            en: 'FeatureTypeName'
          }, {
            n: 'semanticTypeIdentifier',
            mno: 0,
            col: true,
            en: 'SemanticTypeIdentifier'
          }, {
            n: 'rule',
            rq: true,
            col: true,
            en: 'Rule',
            ti: '.Rule'
          }]
      }, {
        ln: 'LabelPlacement',
        tn: null,
        ps: [{
            n: 'pointPlacement',
            rq: true,
            en: 'PointPlacement',
            ti: '.PointPlacement'
          }, {
            n: 'linePlacement',
            rq: true,
            en: 'LinePlacement',
            ti: '.LinePlacement'
          }]
      }, {
        ln: 'LegendGraphic',
        tn: null,
        ps: [{
            n: 'graphic',
            rq: true,
            en: 'Graphic',
            ti: '.Graphic'
          }]
      }, {
        ln: 'EARLIESTONTOP',
        tn: null
      }, {
        ln: 'LATESTONTOP',
        tn: null
      }, {
        ln: 'GraphicFill',
        tn: null,
        ps: [{
            n: 'graphic',
            rq: true,
            en: 'Graphic',
            ti: '.Graphic'
          }]
      }, {
        ln: 'Histogram',
        tn: null
      }, {
        ln: 'OverlapBehavior',
        tn: null,
        ps: [{
            n: 'latestontop',
            rq: true,
            en: 'LATEST_ON_TOP',
            ti: '.LATESTONTOP'
          }, {
            n: 'earliestontop',
            rq: true,
            en: 'EARLIEST_ON_TOP',
            ti: '.EARLIESTONTOP'
          }, {
            n: 'average',
            rq: true,
            en: 'AVERAGE',
            ti: '.AVERAGE'
          }, {
            n: 'random',
            rq: true,
            en: 'RANDOM',
            ti: '.RANDOM'
          }]
      }, {
        ln: 'Geometry',
        tn: null,
        ps: [{
            n: 'propertyName',
            rq: true,
            en: {
              lp: 'PropertyName',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_0_0.PropertyNameType'
          }]
      }, {
        ln: 'CssParameter',
        tn: null,
        bti: '.ParameterValueType',
        ps: [{
            n: 'name',
            rq: true,
            an: {
              lp: 'name'
            },
            t: 'a'
          }]
      }, {
        ln: 'NamedStyle',
        tn: null,
        ps: [{
            n: 'name',
            rq: true,
            en: 'Name'
          }]
      }, {
        ln: 'PointPlacement',
        tn: null,
        ps: [{
            n: 'anchorPoint',
            en: 'AnchorPoint',
            ti: '.AnchorPoint'
          }, {
            n: 'displacement',
            en: 'Displacement',
            ti: '.Displacement'
          }, {
            n: 'rotation',
            en: 'Rotation',
            ti: '.ParameterValueType'
          }]
      }, {
        ln: 'UserStyle',
        tn: null,
        ps: [{
            n: 'name',
            en: 'Name'
          }, {
            n: 'title',
            en: 'Title'
          }, {
            n: '_abstract',
            en: 'Abstract'
          }, {
            n: 'isDefault',
            en: 'IsDefault',
            ti: 'Boolean'
          }, {
            n: 'featureTypeStyle',
            rq: true,
            col: true,
            en: 'FeatureTypeStyle',
            ti: '.FeatureTypeStyle'
          }]
      }, {
        ln: 'ExternalGraphic',
        tn: null,
        ps: [{
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }, {
            n: 'format',
            rq: true,
            en: 'Format'
          }]
      }, {
        ln: 'ParameterValueType',
        ps: [{
            n: 'content',
            col: true,
            dom: false,
            en: {
              lp: 'expression',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_0_0.ExpressionType',
            t: 'er'
          }]
      }, {
        ln: 'ElseFilter',
        tn: null
      }, {
        ln: 'Halo',
        tn: null,
        ps: [{
            n: 'radius',
            en: 'Radius',
            ti: '.ParameterValueType'
          }, {
            n: 'fill',
            en: 'Fill',
            ti: '.Fill'
          }]
      }, {
        ln: 'TextSymbolizer',
        tn: null,
        bti: '.SymbolizerType',
        ps: [{
            n: 'geometry',
            en: 'Geometry',
            ti: '.Geometry'
          }, {
            n: 'label',
            en: 'Label',
            ti: '.ParameterValueType'
          }, {
            n: 'font',
            en: 'Font',
            ti: '.Font'
          }, {
            n: 'labelPlacement',
            en: 'LabelPlacement',
            ti: '.LabelPlacement'
          }, {
            n: 'halo',
            en: 'Halo',
            ti: '.Halo'
          }, {
            n: 'fill',
            en: 'Fill',
            ti: '.Fill'
          }]
      }, {
        ln: 'Extent',
        tn: null,
        ps: [{
            n: 'name',
            rq: true,
            en: 'Name'
          }, {
            n: 'value',
            rq: true,
            en: 'Value'
          }]
      }, {
        ln: 'StyledLayerDescriptor',
        tn: null,
        ps: [{
            n: 'name',
            en: 'Name'
          }, {
            n: 'title',
            en: 'Title'
          }, {
            n: '_abstract',
            en: 'Abstract'
          }, {
            n: 'namedLayerOrUserLayer',
            mno: 0,
            col: true,
            etis: [{
                en: 'NamedLayer',
                ti: '.NamedLayer'
              }, {
                en: 'UserLayer',
                ti: '.UserLayer'
              }],
            t: 'es'
          }, {
            n: 'version',
            rq: true,
            an: {
              lp: 'version'
            },
            t: 'a'
          }]
      }, {
        ln: 'RemoteOWS',
        tn: null,
        ps: [{
            n: 'service',
            rq: true,
            en: 'Service'
          }, {
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'ImageOutline',
        tn: null,
        ps: [{
            n: 'lineSymbolizer',
            rq: true,
            en: 'LineSymbolizer',
            ti: '.LineSymbolizer'
          }, {
            n: 'polygonSymbolizer',
            rq: true,
            en: 'PolygonSymbolizer',
            ti: '.PolygonSymbolizer'
          }]
      }, {
        ln: 'LineSymbolizer',
        tn: null,
        bti: '.SymbolizerType',
        ps: [{
            n: 'geometry',
            en: 'Geometry',
            ti: '.Geometry'
          }, {
            n: 'stroke',
            en: 'Stroke',
            ti: '.Stroke'
          }]
      }, {
        ln: 'FeatureTypeConstraint',
        tn: null,
        ps: [{
            n: 'featureTypeName',
            en: 'FeatureTypeName'
          }, {
            n: 'filter',
            en: {
              lp: 'Filter',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_0_0.FilterType'
          }, {
            n: 'extent',
            mno: 0,
            col: true,
            en: 'Extent',
            ti: '.Extent'
          }]
      }, {
        ln: 'Graphic',
        tn: null,
        ps: [{
            n: 'externalGraphicOrMark',
            mno: 0,
            col: true,
            etis: [{
                en: 'ExternalGraphic',
                ti: '.ExternalGraphic'
              }, {
                en: 'Mark',
                ti: '.Mark'
              }],
            t: 'es'
          }, {
            n: 'opacity',
            en: 'Opacity',
            ti: '.ParameterValueType'
          }, {
            n: 'size',
            en: 'Size',
            ti: '.ParameterValueType'
          }, {
            n: 'rotation',
            en: 'Rotation',
            ti: '.ParameterValueType'
          }]
      }, {
        ln: 'AVERAGE',
        tn: null
      }, {
        ln: 'ShadedRelief',
        tn: null,
        ps: [{
            n: 'brightnessOnly',
            en: 'BrightnessOnly',
            ti: 'Boolean'
          }, {
            n: 'reliefFactor',
            en: 'ReliefFactor',
            ti: 'Double'
          }]
      }, {
        ln: 'RANDOM',
        tn: null
      }, {
        ln: 'PointSymbolizer',
        tn: null,
        bti: '.SymbolizerType',
        ps: [{
            n: 'geometry',
            en: 'Geometry',
            ti: '.Geometry'
          }, {
            n: 'graphic',
            en: 'Graphic',
            ti: '.Graphic'
          }]
      }, {
        ln: 'ChannelSelection',
        tn: null,
        ps: [{
            n: 'redChannel',
            rq: true,
            en: 'RedChannel',
            ti: '.SelectedChannelType'
          }, {
            n: 'greenChannel',
            rq: true,
            en: 'GreenChannel',
            ti: '.SelectedChannelType'
          }, {
            n: 'blueChannel',
            rq: true,
            en: 'BlueChannel',
            ti: '.SelectedChannelType'
          }, {
            n: 'grayChannel',
            rq: true,
            en: 'GrayChannel',
            ti: '.SelectedChannelType'
          }]
      }, {
        ln: 'Rule',
        tn: null,
        ps: [{
            n: 'name',
            en: 'Name'
          }, {
            n: 'title',
            en: 'Title'
          }, {
            n: '_abstract',
            en: 'Abstract'
          }, {
            n: 'legendGraphic',
            en: 'LegendGraphic',
            ti: '.LegendGraphic'
          }, {
            n: 'filter',
            rq: true,
            en: {
              lp: 'Filter',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_0_0.FilterType'
          }, {
            n: 'elseFilter',
            rq: true,
            en: 'ElseFilter',
            ti: '.ElseFilter'
          }, {
            n: 'minScaleDenominator',
            en: 'MinScaleDenominator',
            ti: 'Double'
          }, {
            n: 'maxScaleDenominator',
            en: 'MaxScaleDenominator',
            ti: 'Double'
          }, {
            n: 'symbolizer',
            rq: true,
            col: true,
            mx: false,
            dom: false,
            en: 'Symbolizer',
            ti: '.SymbolizerType',
            t: 'er'
          }]
      }, {
        ln: 'UserLayer',
        tn: null,
        ps: [{
            n: 'name',
            en: 'Name'
          }, {
            n: 'remoteOWS',
            en: 'RemoteOWS',
            ti: '.RemoteOWS'
          }, {
            n: 'layerFeatureConstraints',
            rq: true,
            en: 'LayerFeatureConstraints',
            ti: '.LayerFeatureConstraints'
          }, {
            n: 'userStyle',
            rq: true,
            col: true,
            en: 'UserStyle',
            ti: '.UserStyle'
          }]
      }, {
        ln: 'AnchorPoint',
        tn: null,
        ps: [{
            n: 'anchorPointX',
            rq: true,
            en: 'AnchorPointX',
            ti: '.ParameterValueType'
          }, {
            n: 'anchorPointY',
            rq: true,
            en: 'AnchorPointY',
            ti: '.ParameterValueType'
          }]
      }, {
        ln: 'Stroke',
        tn: null,
        ps: [{
            n: 'graphicFill',
            rq: true,
            en: 'GraphicFill',
            ti: '.GraphicFill'
          }, {
            n: 'graphicStroke',
            rq: true,
            en: 'GraphicStroke',
            ti: '.GraphicStroke'
          }, {
            n: 'cssParameter',
            mno: 0,
            col: true,
            en: 'CssParameter',
            ti: '.CssParameter'
          }]
      }, {
        ln: 'ContrastEnhancement',
        tn: null,
        ps: [{
            n: 'normalize',
            rq: true,
            en: 'Normalize',
            ti: '.Normalize'
          }, {
            n: 'histogram',
            rq: true,
            en: 'Histogram',
            ti: '.Histogram'
          }, {
            n: 'gammaValue',
            en: 'GammaValue',
            ti: 'Double'
          }]
      }, {
        ln: 'SymbolizerType'
      }, {
        ln: 'Fill',
        tn: null,
        ps: [{
            n: 'graphicFill',
            en: 'GraphicFill',
            ti: '.GraphicFill'
          }, {
            n: 'cssParameter',
            mno: 0,
            col: true,
            en: 'CssParameter',
            ti: '.CssParameter'
          }]
      }, {
        ln: 'NamedLayer',
        tn: null,
        ps: [{
            n: 'name',
            rq: true,
            en: 'Name'
          }, {
            n: 'layerFeatureConstraints',
            en: 'LayerFeatureConstraints',
            ti: '.LayerFeatureConstraints'
          }, {
            n: 'namedStyleOrUserStyle',
            mno: 0,
            col: true,
            etis: [{
                en: 'NamedStyle',
                ti: '.NamedStyle'
              }, {
                en: 'UserStyle',
                ti: '.UserStyle'
              }],
            t: 'es'
          }]
      }, {
        ln: 'PolygonSymbolizer',
        tn: null,
        bti: '.SymbolizerType',
        ps: [{
            n: 'geometry',
            en: 'Geometry',
            ti: '.Geometry'
          }, {
            n: 'fill',
            en: 'Fill',
            ti: '.Fill'
          }, {
            n: 'stroke',
            en: 'Stroke',
            ti: '.Stroke'
          }]
      }, {
        ln: 'Displacement',
        tn: null,
        ps: [{
            n: 'displacementX',
            rq: true,
            en: 'DisplacementX',
            ti: '.ParameterValueType'
          }, {
            n: 'displacementY',
            rq: true,
            en: 'DisplacementY',
            ti: '.ParameterValueType'
          }]
      }, {
        ln: 'Font',
        tn: null,
        ps: [{
            n: 'cssParameter',
            mno: 0,
            col: true,
            en: 'CssParameter',
            ti: '.CssParameter'
          }]
      }, {
        ln: 'Normalize',
        tn: null
      }, {
        ln: 'ColorMapEntry',
        tn: null,
        ps: [{
            n: 'color',
            rq: true,
            an: {
              lp: 'color'
            },
            t: 'a'
          }, {
            n: 'opacity',
            ti: 'Double',
            an: {
              lp: 'opacity'
            },
            t: 'a'
          }, {
            n: 'quantity',
            ti: 'Double',
            an: {
              lp: 'quantity'
            },
            t: 'a'
          }, {
            n: 'label',
            an: {
              lp: 'label'
            },
            t: 'a'
          }]
      }, {
        ln: 'OnlineResource',
        tn: null,
        ps: [{
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            t: 'a'
          }]
      }, {
        ln: 'GraphicStroke',
        tn: null,
        ps: [{
            n: 'graphic',
            rq: true,
            en: 'Graphic',
            ti: '.Graphic'
          }]
      }, {
        ln: 'SelectedChannelType',
        ps: [{
            n: 'sourceChannelName',
            rq: true,
            en: 'SourceChannelName'
          }, {
            n: 'contrastEnhancement',
            en: 'ContrastEnhancement',
            ti: '.ContrastEnhancement'
          }]
      }, {
        ln: 'ColorMap',
        tn: null,
        ps: [{
            n: 'colorMapEntry',
            mno: 0,
            col: true,
            en: 'ColorMapEntry',
            ti: '.ColorMapEntry'
          }]
      }, {
        ln: 'Mark',
        tn: null,
        ps: [{
            n: 'wellKnownName',
            en: 'WellKnownName'
          }, {
            n: 'fill',
            en: 'Fill',
            ti: '.Fill'
          }, {
            n: 'stroke',
            en: 'Stroke',
            ti: '.Stroke'
          }]
      }, {
        ln: 'LinePlacement',
        tn: null,
        ps: [{
            n: 'perpendicularOffset',
            en: 'PerpendicularOffset',
            ti: '.ParameterValueType'
          }]
      }],
    eis: [{
        en: 'Format'
      }, {
        en: 'Radius',
        ti: '.ParameterValueType'
      }, {
        en: 'GrayChannel',
        ti: '.SelectedChannelType'
      }, {
        en: 'Mark',
        ti: '.Mark'
      }, {
        en: 'ColorMapEntry',
        ti: '.ColorMapEntry'
      }, {
        en: 'LATEST_ON_TOP',
        ti: '.LATESTONTOP'
      }, {
        en: 'RANDOM',
        ti: '.RANDOM'
      }, {
        en: 'TextSymbolizer',
        ti: '.TextSymbolizer',
        sh: 'Symbolizer'
      }, {
        en: 'RedChannel',
        ti: '.SelectedChannelType'
      }, {
        en: 'LineSymbolizer',
        ti: '.LineSymbolizer',
        sh: 'Symbolizer'
      }, {
        en: 'ReliefFactor',
        ti: 'Double'
      }, {
        en: 'EARLIEST_ON_TOP',
        ti: '.EARLIESTONTOP'
      }, {
        en: 'Graphic',
        ti: '.Graphic'
      }, {
        en: 'UserLayer',
        ti: '.UserLayer'
      }, {
        en: 'PolygonSymbolizer',
        ti: '.PolygonSymbolizer',
        sh: 'Symbolizer'
      }, {
        en: 'Value'
      }, {
        en: 'WellKnownName'
      }, {
        en: 'LayerFeatureConstraints',
        ti: '.LayerFeatureConstraints'
      }, {
        en: 'Halo',
        ti: '.Halo'
      }, {
        en: 'PointSymbolizer',
        ti: '.PointSymbolizer',
        sh: 'Symbolizer'
      }, {
        en: 'Label',
        ti: '.ParameterValueType'
      }, {
        en: 'LinePlacement',
        ti: '.LinePlacement'
      }, {
        en: 'ContrastEnhancement',
        ti: '.ContrastEnhancement'
      }, {
        en: 'Opacity',
        ti: '.ParameterValueType'
      }, {
        en: 'GraphicStroke',
        ti: '.GraphicStroke'
      }, {
        en: 'Geometry',
        ti: '.Geometry'
      }, {
        en: 'GraphicFill',
        ti: '.GraphicFill'
      }, {
        en: 'ColorMap',
        ti: '.ColorMap'
      }, {
        en: 'Normalize',
        ti: '.Normalize'
      }, {
        en: 'RemoteOWS',
        ti: '.RemoteOWS'
      }, {
        en: 'DisplacementY',
        ti: '.ParameterValueType'
      }, {
        en: 'Histogram',
        ti: '.Histogram'
      }, {
        en: 'FeatureTypeStyle',
        ti: '.FeatureTypeStyle'
      }, {
        en: 'ExternalGraphic',
        ti: '.ExternalGraphic'
      }, {
        en: 'LabelPlacement',
        ti: '.LabelPlacement'
      }, {
        en: 'FeatureTypeConstraint',
        ti: '.FeatureTypeConstraint'
      }, {
        en: 'NamedLayer',
        ti: '.NamedLayer'
      }, {
        en: 'ElseFilter',
        ti: '.ElseFilter'
      }, {
        en: 'Displacement',
        ti: '.Displacement'
      }, {
        en: 'Title'
      }, {
        en: 'SemanticTypeIdentifier'
      }, {
        en: 'MaxScaleDenominator',
        ti: 'Double'
      }, {
        en: 'OnlineResource',
        ti: '.OnlineResource'
      }, {
        en: 'AVERAGE',
        ti: '.AVERAGE'
      }, {
        en: 'Font',
        ti: '.Font'
      }, {
        en: 'MinScaleDenominator',
        ti: 'Double'
      }, {
        en: 'RasterSymbolizer',
        ti: '.RasterSymbolizer',
        sh: 'Symbolizer'
      }, {
        en: 'AnchorPointY',
        ti: '.ParameterValueType'
      }, {
        en: 'DisplacementX',
        ti: '.ParameterValueType'
      }, {
        en: 'BlueChannel',
        ti: '.SelectedChannelType'
      }, {
        en: 'GammaValue',
        ti: 'Double'
      }, {
        en: 'ImageOutline',
        ti: '.ImageOutline'
      }, {
        en: 'GreenChannel',
        ti: '.SelectedChannelType'
      }, {
        en: 'UserStyle',
        ti: '.UserStyle'
      }, {
        en: 'CssParameter',
        ti: '.CssParameter'
      }, {
        en: 'ShadedRelief',
        ti: '.ShadedRelief'
      }, {
        en: 'Abstract'
      }, {
        en: 'PointPlacement',
        ti: '.PointPlacement'
      }, {
        en: 'Rule',
        ti: '.Rule'
      }, {
        en: 'FeatureTypeName'
      }, {
        en: 'AnchorPoint',
        ti: '.AnchorPoint'
      }, {
        en: 'IsDefault',
        ti: 'Boolean'
      }, {
        en: 'AnchorPointX',
        ti: '.ParameterValueType'
      }, {
        en: 'PerpendicularOffset',
        ti: '.ParameterValueType'
      }, {
        en: 'SourceChannelName'
      }, {
        en: 'Extent',
        ti: '.Extent'
      }, {
        en: 'Name'
      }, {
        en: 'Stroke',
        ti: '.Stroke'
      }, {
        en: 'Symbolizer',
        ti: '.SymbolizerType'
      }, {
        en: 'NamedStyle',
        ti: '.NamedStyle'
      }, {
        en: 'LegendGraphic',
        ti: '.LegendGraphic'
      }, {
        en: 'Fill',
        ti: '.Fill'
      }, {
        en: 'Size',
        ti: '.ParameterValueType'
      }, {
        en: 'Service'
      }, {
        en: 'OverlapBehavior',
        ti: '.OverlapBehavior'
      }, {
        en: 'ChannelSelection',
        ti: '.ChannelSelection'
      }, {
        en: 'BrightnessOnly',
        ti: 'Boolean'
      }, {
        en: 'Rotation',
        ti: '.ParameterValueType'
      }, {
        en: 'StyledLayerDescriptor',
        ti: '.StyledLayerDescriptor'
      }]
  };
  return {
    SLD_1_0_0: SLD_1_0_0
  };
};
if (typeof define === 'function' && define.amd) {
  define([], SLD_1_0_0_Module_Factory);
}
else {
  var SLD_1_0_0_Module = SLD_1_0_0_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.SLD_1_0_0 = SLD_1_0_0_Module.SLD_1_0_0;
  }
  else {
    var SLD_1_0_0 = SLD_1_0_0_Module.SLD_1_0_0;
  }
}
},{}],10:[function(require,module,exports){
var SMIL_2_0_Module_Factory = function () {
  var SMIL_2_0 = {
    n: 'SMIL_2_0',
    dens: 'http:\/\/www.w3.org\/2001\/SMIL20\/',
    deps: ['SMIL_2_0_Language'],
    tis: [{
        ln: 'AnimateMotionPrototype',
        tn: 'animateMotionPrototype',
        ps: [{
            n: 'origin',
            an: {
              lp: 'origin'
            },
            t: 'a'
          }, {
            n: 'from',
            an: {
              lp: 'from'
            },
            t: 'a'
          }, {
            n: 'by',
            an: {
              lp: 'by'
            },
            t: 'a'
          }, {
            n: 'values',
            an: {
              lp: 'values'
            },
            t: 'a'
          }, {
            n: 'to',
            an: {
              lp: 'to'
            },
            t: 'a'
          }, {
            n: 'additive',
            an: {
              lp: 'additive'
            },
            t: 'a'
          }, {
            n: 'accumulate',
            an: {
              lp: 'accumulate'
            },
            t: 'a'
          }]
      }, {
        ln: 'SetPrototype',
        tn: 'setPrototype',
        ps: [{
            n: 'to',
            an: {
              lp: 'to'
            },
            t: 'a'
          }, {
            n: 'attributeName',
            rq: true,
            an: {
              lp: 'attributeName'
            },
            t: 'a'
          }, {
            n: 'attributeType',
            an: {
              lp: 'attributeType'
            },
            t: 'a'
          }]
      }, {
        ln: 'AnimateColorPrototype',
        tn: 'animateColorPrototype',
        ps: [{
            n: 'additive',
            an: {
              lp: 'additive'
            },
            t: 'a'
          }, {
            n: 'accumulate',
            an: {
              lp: 'accumulate'
            },
            t: 'a'
          }, {
            n: 'attributeName',
            rq: true,
            an: {
              lp: 'attributeName'
            },
            t: 'a'
          }, {
            n: 'attributeType',
            an: {
              lp: 'attributeType'
            },
            t: 'a'
          }, {
            n: 'from',
            an: {
              lp: 'from'
            },
            t: 'a'
          }, {
            n: 'by',
            an: {
              lp: 'by'
            },
            t: 'a'
          }, {
            n: 'values',
            an: {
              lp: 'values'
            },
            t: 'a'
          }, {
            n: 'to',
            an: {
              lp: 'to'
            },
            t: 'a'
          }]
      }, {
        ln: 'AnimatePrototype',
        tn: 'animatePrototype',
        ps: [{
            n: 'from',
            an: {
              lp: 'from'
            },
            t: 'a'
          }, {
            n: 'by',
            an: {
              lp: 'by'
            },
            t: 'a'
          }, {
            n: 'values',
            an: {
              lp: 'values'
            },
            t: 'a'
          }, {
            n: 'to',
            an: {
              lp: 'to'
            },
            t: 'a'
          }, {
            n: 'attributeName',
            rq: true,
            an: {
              lp: 'attributeName'
            },
            t: 'a'
          }, {
            n: 'attributeType',
            an: {
              lp: 'attributeType'
            },
            t: 'a'
          }, {
            n: 'additive',
            an: {
              lp: 'additive'
            },
            t: 'a'
          }, {
            n: 'accumulate',
            an: {
              lp: 'accumulate'
            },
            t: 'a'
          }]
      }, {
        t: 'enum',
        ln: 'SyncBehaviorDefaultType',
        vs: ['canSlip', 'locked', 'independent', 'inherit']
      }, {
        t: 'enum',
        ln: 'FillDefaultType',
        vs: ['remove', 'freeze', 'hold', 'auto', 'inherit', 'transition']
      }, {
        t: 'enum',
        ln: 'SyncBehaviorType',
        vs: ['canSlip', 'locked', 'independent', 'default']
      }, {
        t: 'enum',
        ln: 'RestartTimingType',
        vs: ['never', 'always', 'whenNotActive', 'default']
      }, {
        t: 'enum',
        ln: 'FillTimingAttrsType',
        vs: ['remove', 'freeze', 'hold', 'auto', 'default', 'transition']
      }, {
        t: 'enum',
        ln: 'RestartDefaultType',
        vs: ['never', 'always', 'whenNotActive', 'inherit']
      }],
    eis: [{
        en: 'animate',
        ti: 'SMIL_2_0_Language.AnimateType',
        sh: {
          lp: 'animate',
          ns: 'http:\/\/www.w3.org\/2001\/SMIL20\/Language'
        }
      }, {
        en: 'animateColor',
        ti: 'SMIL_2_0_Language.AnimateColorType',
        sh: {
          lp: 'animateColor',
          ns: 'http:\/\/www.w3.org\/2001\/SMIL20\/Language'
        }
      }, {
        en: 'animateMotion',
        ti: 'SMIL_2_0_Language.AnimateMotionType',
        sh: {
          lp: 'animateMotion',
          ns: 'http:\/\/www.w3.org\/2001\/SMIL20\/Language'
        }
      }, {
        en: 'set',
        ti: 'SMIL_2_0_Language.SetType',
        sh: {
          lp: 'set',
          ns: 'http:\/\/www.w3.org\/2001\/SMIL20\/Language'
        }
      }]
  };
  return {
    SMIL_2_0: SMIL_2_0
  };
};
if (typeof define === 'function' && define.amd) {
  define([], SMIL_2_0_Module_Factory);
}
else {
  var SMIL_2_0_Module = SMIL_2_0_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.SMIL_2_0 = SMIL_2_0_Module.SMIL_2_0;
  }
  else {
    var SMIL_2_0 = SMIL_2_0_Module.SMIL_2_0;
  }
}
},{}],11:[function(require,module,exports){
var SMIL_2_0_Language_Module_Factory = function () {
  var SMIL_2_0_Language = {
    n: 'SMIL_2_0_Language',
    dens: 'http:\/\/www.w3.org\/2001\/SMIL20\/Language',
    deps: ['SMIL_2_0'],
    tis: [{
        ln: 'SetType',
        tn: 'setType',
        bti: 'SMIL_2_0.SetPrototype',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'any',
            mno: 0,
            col: true,
            mx: false,
            t: 'ae'
          }, {
            n: 'alt',
            an: {
              lp: 'alt'
            },
            t: 'a'
          }, {
            n: 'longdesc',
            an: {
              lp: 'longdesc'
            },
            t: 'a'
          }, {
            n: 'id',
            ti: 'ID',
            an: {
              lp: 'id'
            },
            t: 'a'
          }, {
            n: 'clazz',
            an: {
              lp: 'class'
            },
            t: 'a'
          }, {
            n: 'lang',
            an: {
              lp: 'lang',
              ns: 'http:\/\/www.w3.org\/XML\/1998\/namespace'
            },
            t: 'a'
          }, {
            n: 'targetElement',
            ti: 'IDREF',
            an: {
              lp: 'targetElement'
            },
            t: 'a'
          }, {
            n: 'restartDefault',
            an: {
              lp: 'restartDefault'
            },
            t: 'a'
          }, {
            n: 'restart',
            an: {
              lp: 'restart'
            },
            t: 'a'
          }, {
            n: 'repeat',
            ti: 'NonNegativeInteger',
            an: {
              lp: 'repeat'
            },
            t: 'a'
          }, {
            n: 'min',
            an: {
              lp: 'min'
            },
            t: 'a'
          }, {
            n: 'max',
            an: {
              lp: 'max'
            },
            t: 'a'
          }, {
            n: 'dur',
            an: {
              lp: 'dur'
            },
            t: 'a'
          }, {
            n: 'begin',
            an: {
              lp: 'begin'
            },
            t: 'a'
          }, {
            n: 'end',
            an: {
              lp: 'end'
            },
            t: 'a'
          }, {
            n: 'repeatDur',
            an: {
              lp: 'repeatDur'
            },
            t: 'a'
          }, {
            n: 'repeatCount',
            ti: 'Decimal',
            an: {
              lp: 'repeatCount'
            },
            t: 'a'
          }, {
            n: 'syncBehaviorDefault',
            an: {
              lp: 'syncBehaviorDefault'
            },
            t: 'a'
          }, {
            n: 'syncToleranceDefault',
            an: {
              lp: 'syncToleranceDefault'
            },
            t: 'a'
          }, {
            n: 'syncBehavior',
            an: {
              lp: 'syncBehavior'
            },
            t: 'a'
          }, {
            n: 'syncTolerance',
            an: {
              lp: 'syncTolerance'
            },
            t: 'a'
          }, {
            n: 'fill',
            an: {
              lp: 'fill'
            },
            t: 'a'
          }, {
            n: 'fillDefault',
            an: {
              lp: 'fillDefault'
            },
            t: 'a'
          }, {
            n: 'skipContent',
            ti: 'Boolean',
            an: {
              lp: 'skip-content'
            },
            t: 'a'
          }]
      }, {
        ln: 'AnimateType',
        tn: 'animateType',
        bti: 'SMIL_2_0.AnimatePrototype',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'any',
            mno: 0,
            col: true,
            mx: false,
            t: 'ae'
          }, {
            n: 'alt',
            an: {
              lp: 'alt'
            },
            t: 'a'
          }, {
            n: 'longdesc',
            an: {
              lp: 'longdesc'
            },
            t: 'a'
          }, {
            n: 'id',
            ti: 'ID',
            an: {
              lp: 'id'
            },
            t: 'a'
          }, {
            n: 'clazz',
            an: {
              lp: 'class'
            },
            t: 'a'
          }, {
            n: 'lang',
            an: {
              lp: 'lang',
              ns: 'http:\/\/www.w3.org\/XML\/1998\/namespace'
            },
            t: 'a'
          }, {
            n: 'skipContent',
            ti: 'Boolean',
            an: {
              lp: 'skip-content'
            },
            t: 'a'
          }, {
            n: 'targetElement',
            ti: 'IDREF',
            an: {
              lp: 'targetElement'
            },
            t: 'a'
          }, {
            n: 'restartDefault',
            an: {
              lp: 'restartDefault'
            },
            t: 'a'
          }, {
            n: 'restart',
            an: {
              lp: 'restart'
            },
            t: 'a'
          }, {
            n: 'repeat',
            ti: 'NonNegativeInteger',
            an: {
              lp: 'repeat'
            },
            t: 'a'
          }, {
            n: 'min',
            an: {
              lp: 'min'
            },
            t: 'a'
          }, {
            n: 'max',
            an: {
              lp: 'max'
            },
            t: 'a'
          }, {
            n: 'dur',
            an: {
              lp: 'dur'
            },
            t: 'a'
          }, {
            n: 'begin',
            an: {
              lp: 'begin'
            },
            t: 'a'
          }, {
            n: 'end',
            an: {
              lp: 'end'
            },
            t: 'a'
          }, {
            n: 'repeatDur',
            an: {
              lp: 'repeatDur'
            },
            t: 'a'
          }, {
            n: 'repeatCount',
            ti: 'Decimal',
            an: {
              lp: 'repeatCount'
            },
            t: 'a'
          }, {
            n: 'syncBehaviorDefault',
            an: {
              lp: 'syncBehaviorDefault'
            },
            t: 'a'
          }, {
            n: 'syncToleranceDefault',
            an: {
              lp: 'syncToleranceDefault'
            },
            t: 'a'
          }, {
            n: 'syncBehavior',
            an: {
              lp: 'syncBehavior'
            },
            t: 'a'
          }, {
            n: 'syncTolerance',
            an: {
              lp: 'syncTolerance'
            },
            t: 'a'
          }, {
            n: 'fill',
            an: {
              lp: 'fill'
            },
            t: 'a'
          }, {
            n: 'fillDefault',
            an: {
              lp: 'fillDefault'
            },
            t: 'a'
          }, {
            n: 'calcMode',
            an: {
              lp: 'calcMode'
            },
            t: 'a'
          }]
      }, {
        ln: 'AnimateColorType',
        tn: 'animateColorType',
        bti: 'SMIL_2_0.AnimateColorPrototype',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'any',
            mno: 0,
            col: true,
            mx: false,
            t: 'ae'
          }, {
            n: 'restartDefault',
            an: {
              lp: 'restartDefault'
            },
            t: 'a'
          }, {
            n: 'restart',
            an: {
              lp: 'restart'
            },
            t: 'a'
          }, {
            n: 'repeat',
            ti: 'NonNegativeInteger',
            an: {
              lp: 'repeat'
            },
            t: 'a'
          }, {
            n: 'min',
            an: {
              lp: 'min'
            },
            t: 'a'
          }, {
            n: 'max',
            an: {
              lp: 'max'
            },
            t: 'a'
          }, {
            n: 'dur',
            an: {
              lp: 'dur'
            },
            t: 'a'
          }, {
            n: 'begin',
            an: {
              lp: 'begin'
            },
            t: 'a'
          }, {
            n: 'end',
            an: {
              lp: 'end'
            },
            t: 'a'
          }, {
            n: 'repeatDur',
            an: {
              lp: 'repeatDur'
            },
            t: 'a'
          }, {
            n: 'repeatCount',
            ti: 'Decimal',
            an: {
              lp: 'repeatCount'
            },
            t: 'a'
          }, {
            n: 'syncBehaviorDefault',
            an: {
              lp: 'syncBehaviorDefault'
            },
            t: 'a'
          }, {
            n: 'syncToleranceDefault',
            an: {
              lp: 'syncToleranceDefault'
            },
            t: 'a'
          }, {
            n: 'syncBehavior',
            an: {
              lp: 'syncBehavior'
            },
            t: 'a'
          }, {
            n: 'syncTolerance',
            an: {
              lp: 'syncTolerance'
            },
            t: 'a'
          }, {
            n: 'fill',
            an: {
              lp: 'fill'
            },
            t: 'a'
          }, {
            n: 'fillDefault',
            an: {
              lp: 'fillDefault'
            },
            t: 'a'
          }, {
            n: 'calcMode',
            an: {
              lp: 'calcMode'
            },
            t: 'a'
          }, {
            n: 'alt',
            an: {
              lp: 'alt'
            },
            t: 'a'
          }, {
            n: 'longdesc',
            an: {
              lp: 'longdesc'
            },
            t: 'a'
          }, {
            n: 'id',
            ti: 'ID',
            an: {
              lp: 'id'
            },
            t: 'a'
          }, {
            n: 'clazz',
            an: {
              lp: 'class'
            },
            t: 'a'
          }, {
            n: 'lang',
            an: {
              lp: 'lang',
              ns: 'http:\/\/www.w3.org\/XML\/1998\/namespace'
            },
            t: 'a'
          }, {
            n: 'targetElement',
            ti: 'IDREF',
            an: {
              lp: 'targetElement'
            },
            t: 'a'
          }, {
            n: 'skipContent',
            ti: 'Boolean',
            an: {
              lp: 'skip-content'
            },
            t: 'a'
          }]
      }, {
        ln: 'AnimateMotionType',
        tn: 'animateMotionType',
        bti: 'SMIL_2_0.AnimateMotionPrototype',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'any',
            mno: 0,
            col: true,
            mx: false,
            t: 'ae'
          }, {
            n: 'alt',
            an: {
              lp: 'alt'
            },
            t: 'a'
          }, {
            n: 'longdesc',
            an: {
              lp: 'longdesc'
            },
            t: 'a'
          }, {
            n: 'id',
            ti: 'ID',
            an: {
              lp: 'id'
            },
            t: 'a'
          }, {
            n: 'clazz',
            an: {
              lp: 'class'
            },
            t: 'a'
          }, {
            n: 'lang',
            an: {
              lp: 'lang',
              ns: 'http:\/\/www.w3.org\/XML\/1998\/namespace'
            },
            t: 'a'
          }, {
            n: 'targetElement',
            ti: 'IDREF',
            an: {
              lp: 'targetElement'
            },
            t: 'a'
          }, {
            n: 'calcMode',
            an: {
              lp: 'calcMode'
            },
            t: 'a'
          }, {
            n: 'restartDefault',
            an: {
              lp: 'restartDefault'
            },
            t: 'a'
          }, {
            n: 'restart',
            an: {
              lp: 'restart'
            },
            t: 'a'
          }, {
            n: 'repeat',
            ti: 'NonNegativeInteger',
            an: {
              lp: 'repeat'
            },
            t: 'a'
          }, {
            n: 'min',
            an: {
              lp: 'min'
            },
            t: 'a'
          }, {
            n: 'max',
            an: {
              lp: 'max'
            },
            t: 'a'
          }, {
            n: 'dur',
            an: {
              lp: 'dur'
            },
            t: 'a'
          }, {
            n: 'begin',
            an: {
              lp: 'begin'
            },
            t: 'a'
          }, {
            n: 'end',
            an: {
              lp: 'end'
            },
            t: 'a'
          }, {
            n: 'repeatDur',
            an: {
              lp: 'repeatDur'
            },
            t: 'a'
          }, {
            n: 'repeatCount',
            ti: 'Decimal',
            an: {
              lp: 'repeatCount'
            },
            t: 'a'
          }, {
            n: 'syncBehaviorDefault',
            an: {
              lp: 'syncBehaviorDefault'
            },
            t: 'a'
          }, {
            n: 'syncToleranceDefault',
            an: {
              lp: 'syncToleranceDefault'
            },
            t: 'a'
          }, {
            n: 'syncBehavior',
            an: {
              lp: 'syncBehavior'
            },
            t: 'a'
          }, {
            n: 'syncTolerance',
            an: {
              lp: 'syncTolerance'
            },
            t: 'a'
          }, {
            n: 'fill',
            an: {
              lp: 'fill'
            },
            t: 'a'
          }, {
            n: 'fillDefault',
            an: {
              lp: 'fillDefault'
            },
            t: 'a'
          }, {
            n: 'skipContent',
            ti: 'Boolean',
            an: {
              lp: 'skip-content'
            },
            t: 'a'
          }]
      }],
    eis: [{
        en: 'set',
        ti: '.SetType'
      }, {
        en: 'animate',
        ti: '.AnimateType'
      }, {
        en: 'animateMotion',
        ti: '.AnimateMotionType'
      }, {
        en: 'animateColor',
        ti: '.AnimateColorType'
      }]
  };
  return {
    SMIL_2_0_Language: SMIL_2_0_Language
  };
};
if (typeof define === 'function' && define.amd) {
  define([], SMIL_2_0_Language_Module_Factory);
}
else {
  var SMIL_2_0_Language_Module = SMIL_2_0_Language_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.SMIL_2_0_Language = SMIL_2_0_Language_Module.SMIL_2_0_Language;
  }
  else {
    var SMIL_2_0_Language = SMIL_2_0_Language_Module.SMIL_2_0_Language;
  }
}
},{}],12:[function(require,module,exports){
var WFS_1_1_0_Module_Factory = function () {
  var WFS_1_1_0 = {
    n: 'WFS_1_1_0',
    dens: 'http:\/\/www.opengis.net\/wfs',
    deps: ['Filter_1_1_0', 'OWS_1_0_0', 'GML_3_1_1'],
    tis: [{
        ln: 'InsertResultsType',
        ps: [{
            n: 'feature',
            rq: true,
            col: true,
            en: 'Feature',
            ti: '.InsertedFeatureType'
          }]
      }, {
        ln: 'TransactionResponseType',
        ps: [{
            n: 'transactionSummary',
            rq: true,
            en: 'TransactionSummary',
            ti: '.TransactionSummaryType'
          }, {
            n: 'transactionResults',
            en: 'TransactionResults',
            ti: '.TransactionResultsType'
          }, {
            n: 'insertResults',
            en: 'InsertResults',
            ti: '.InsertResultsType'
          }, {
            n: 'version',
            rq: true,
            an: {
              lp: 'version'
            },
            t: 'a'
          }]
      }, {
        ln: 'BaseRequestType',
        ps: [{
            n: 'service',
            an: {
              lp: 'service'
            },
            t: 'a'
          }, {
            n: 'version',
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'handle',
            an: {
              lp: 'handle'
            },
            t: 'a'
          }]
      }, {
        ln: 'XlinkPropertyName',
        tn: null,
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'traverseXlinkDepth',
            rq: true,
            an: {
              lp: 'traverseXlinkDepth'
            },
            t: 'a'
          }, {
            n: 'traverseXlinkExpiry',
            ti: 'PositiveInteger',
            an: {
              lp: 'traverseXlinkExpiry'
            },
            t: 'a'
          }]
      }, {
        ln: 'DescribeFeatureTypeType',
        bti: '.BaseRequestType',
        ps: [{
            n: 'typeName',
            mno: 0,
            col: true,
            en: 'TypeName',
            ti: 'QName'
          }, {
            n: 'outputFormat',
            an: {
              lp: 'outputFormat'
            },
            t: 'a'
          }]
      }, {
        ln: 'ActionType',
        ps: [{
            n: 'message',
            en: 'Message'
          }, {
            n: 'locator',
            rq: true,
            an: {
              lp: 'locator'
            },
            t: 'a'
          }, {
            n: 'code',
            an: {
              lp: 'code'
            },
            t: 'a'
          }]
      }, {
        ln: 'LockFeatureType',
        bti: '.BaseRequestType',
        ps: [{
            n: 'lock',
            rq: true,
            col: true,
            en: 'Lock',
            ti: '.LockType'
          }, {
            n: 'expiry',
            ti: 'PositiveInteger',
            an: {
              lp: 'expiry'
            },
            t: 'a'
          }, {
            n: 'lockAction',
            an: {
              lp: 'lockAction'
            },
            t: 'a'
          }]
      }, {
        ln: 'GetGmlObjectType',
        bti: '.BaseRequestType',
        ps: [{
            n: 'gmlObjectId',
            rq: true,
            en: {
              lp: 'GmlObjectId',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_1_0.GmlObjectIdType'
          }, {
            n: 'outputFormat',
            an: {
              lp: 'outputFormat'
            },
            t: 'a'
          }, {
            n: 'traverseXlinkDepth',
            rq: true,
            an: {
              lp: 'traverseXlinkDepth'
            },
            t: 'a'
          }, {
            n: 'traverseXlinkExpiry',
            ti: 'PositiveInteger',
            an: {
              lp: 'traverseXlinkExpiry'
            },
            t: 'a'
          }]
      }, {
        ln: 'OutputFormatListType',
        ps: [{
            n: 'format',
            rq: true,
            col: true,
            en: 'Format'
          }]
      }, {
        ln: 'MetadataURLType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'type',
            rq: true,
            an: {
              lp: 'type'
            },
            t: 'a'
          }, {
            n: 'format',
            rq: true,
            an: {
              lp: 'format'
            },
            t: 'a'
          }]
      }, {
        ln: 'DeleteElementType',
        ps: [{
            n: 'filter',
            rq: true,
            en: {
              lp: 'Filter',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_1_0.FilterType'
          }, {
            n: 'handle',
            an: {
              lp: 'handle'
            },
            t: 'a'
          }, {
            n: 'typeName',
            rq: true,
            ti: 'QName',
            an: {
              lp: 'typeName'
            },
            t: 'a'
          }]
      }, {
        ln: 'GetFeatureWithLockType',
        bti: '.BaseRequestType',
        ps: [{
            n: 'query',
            rq: true,
            col: true,
            en: 'Query',
            ti: '.QueryType'
          }, {
            n: 'expiry',
            ti: 'PositiveInteger',
            an: {
              lp: 'expiry'
            },
            t: 'a'
          }, {
            n: 'resultType',
            an: {
              lp: 'resultType'
            },
            t: 'a'
          }, {
            n: 'outputFormat',
            an: {
              lp: 'outputFormat'
            },
            t: 'a'
          }, {
            n: 'maxFeatures',
            ti: 'PositiveInteger',
            an: {
              lp: 'maxFeatures'
            },
            t: 'a'
          }, {
            n: 'traverseXlinkDepth',
            an: {
              lp: 'traverseXlinkDepth'
            },
            t: 'a'
          }, {
            n: 'traverseXlinkExpiry',
            ti: 'PositiveInteger',
            an: {
              lp: 'traverseXlinkExpiry'
            },
            t: 'a'
          }]
      }, {
        ln: 'GMLObjectTypeType',
        ps: [{
            n: 'name',
            rq: true,
            en: 'Name',
            ti: 'QName'
          }, {
            n: 'title',
            en: 'Title'
          }, {
            n: '_abstract',
            en: 'Abstract'
          }, {
            n: 'keywords',
            mno: 0,
            col: true,
            en: {
              lp: 'Keywords',
              ns: 'http:\/\/www.opengis.net\/ows'
            },
            ti: 'OWS_1_0_0.KeywordsType'
          }, {
            n: 'outputFormats',
            en: 'OutputFormats',
            ti: '.OutputFormatListType'
          }]
      }, {
        ln: 'FeatureTypeType.NoSRS',
        tn: null
      }, {
        ln: 'OperationsType',
        ps: [{
            n: 'operation',
            rq: true,
            col: true,
            en: 'Operation'
          }]
      }, {
        ln: 'GetFeatureType',
        bti: '.BaseRequestType',
        ps: [{
            n: 'query',
            rq: true,
            col: true,
            en: 'Query',
            ti: '.QueryType'
          }, {
            n: 'resultType',
            an: {
              lp: 'resultType'
            },
            t: 'a'
          }, {
            n: 'outputFormat',
            an: {
              lp: 'outputFormat'
            },
            t: 'a'
          }, {
            n: 'maxFeatures',
            ti: 'PositiveInteger',
            an: {
              lp: 'maxFeatures'
            },
            t: 'a'
          }, {
            n: 'traverseXlinkDepth',
            an: {
              lp: 'traverseXlinkDepth'
            },
            t: 'a'
          }, {
            n: 'traverseXlinkExpiry',
            ti: 'PositiveInteger',
            an: {
              lp: 'traverseXlinkExpiry'
            },
            t: 'a'
          }]
      }, {
        ln: 'WFSCapabilitiesType',
        tn: 'WFS_CapabilitiesType',
        bti: 'OWS_1_0_0.CapabilitiesBaseType',
        ps: [{
            n: 'featureTypeList',
            en: 'FeatureTypeList',
            ti: '.FeatureTypeListType'
          }, {
            n: 'servesGMLObjectTypeList',
            en: 'ServesGMLObjectTypeList',
            ti: '.GMLObjectTypeListType'
          }, {
            n: 'supportsGMLObjectTypeList',
            en: 'SupportsGMLObjectTypeList',
            ti: '.GMLObjectTypeListType'
          }, {
            n: 'filterCapabilities',
            rq: true,
            en: {
              lp: 'Filter_Capabilities',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_1_0.FilterCapabilities'
          }]
      }, {
        ln: 'TransactionType',
        bti: '.BaseRequestType',
        ps: [{
            n: 'lockId',
            en: 'LockId'
          }, {
            n: 'insertOrUpdateOrDelete',
            mno: 0,
            col: true,
            etis: [{
                en: 'Insert',
                ti: '.InsertElementType'
              }, {
                en: 'Update',
                ti: '.UpdateElementType'
              }, {
                en: 'Delete',
                ti: '.DeleteElementType'
              }, {
                en: 'Native',
                ti: '.NativeType'
              }],
            t: 'es'
          }, {
            n: 'releaseAction',
            an: {
              lp: 'releaseAction'
            },
            t: 'a'
          }]
      }, {
        ln: 'LockFeatureResponseType',
        ps: [{
            n: 'lockId',
            rq: true,
            en: 'LockId'
          }, {
            n: 'featuresLocked',
            en: 'FeaturesLocked',
            ti: '.FeaturesLockedType'
          }, {
            n: 'featuresNotLocked',
            en: 'FeaturesNotLocked',
            ti: '.FeaturesNotLockedType'
          }]
      }, {
        ln: 'UpdateElementType',
        ps: [{
            n: 'property',
            rq: true,
            col: true,
            en: 'Property',
            ti: '.PropertyType'
          }, {
            n: 'filter',
            en: {
              lp: 'Filter',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_1_0.FilterType'
          }, {
            n: 'handle',
            an: {
              lp: 'handle'
            },
            t: 'a'
          }, {
            n: 'typeName',
            rq: true,
            ti: 'QName',
            an: {
              lp: 'typeName'
            },
            t: 'a'
          }, {
            n: 'inputFormat',
            an: {
              lp: 'inputFormat'
            },
            t: 'a'
          }, {
            n: 'srsName',
            an: {
              lp: 'srsName'
            },
            t: 'a'
          }]
      }, {
        ln: 'FeatureTypeType',
        ps: [{
            n: 'name',
            rq: true,
            en: 'Name',
            ti: 'QName'
          }, {
            n: 'title',
            rq: true,
            en: 'Title'
          }, {
            n: '_abstract',
            en: 'Abstract'
          }, {
            n: 'keywords',
            mno: 0,
            col: true,
            en: {
              lp: 'Keywords',
              ns: 'http:\/\/www.opengis.net\/ows'
            },
            ti: 'OWS_1_0_0.KeywordsType'
          }, {
            n: 'defaultSRS',
            rq: true,
            en: 'DefaultSRS'
          }, {
            n: 'otherSRS',
            mno: 0,
            col: true,
            en: 'OtherSRS'
          }, {
            n: 'noSRS',
            rq: true,
            en: 'NoSRS',
            ti: '.FeatureTypeType.NoSRS'
          }, {
            n: 'operations',
            en: 'Operations',
            ti: '.OperationsType'
          }, {
            n: 'outputFormats',
            en: 'OutputFormats',
            ti: '.OutputFormatListType'
          }, {
            n: 'wgs84BoundingBox',
            mno: 0,
            col: true,
            en: {
              lp: 'WGS84BoundingBox',
              ns: 'http:\/\/www.opengis.net\/ows'
            },
            ti: 'OWS_1_0_0.WGS84BoundingBoxType'
          }, {
            n: 'metadataURL',
            mno: 0,
            col: true,
            en: 'MetadataURL',
            ti: '.MetadataURLType'
          }]
      }, {
        ln: 'FeaturesNotLockedType',
        ps: [{
            n: 'featureId',
            rq: true,
            col: true,
            en: {
              lp: 'FeatureId',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_1_0.FeatureIdType'
          }]
      }, {
        ln: 'TransactionSummaryType',
        ps: [{
            n: 'totalInserted',
            ti: 'NonNegativeInteger'
          }, {
            n: 'totalUpdated',
            ti: 'NonNegativeInteger'
          }, {
            n: 'totalDeleted',
            ti: 'NonNegativeInteger'
          }]
      }, {
        ln: 'NativeType',
        ps: [{
            n: 'vendorId',
            rq: true,
            an: {
              lp: 'vendorId'
            },
            t: 'a'
          }, {
            n: 'safeToIgnore',
            rq: true,
            ti: 'Boolean',
            an: {
              lp: 'safeToIgnore'
            },
            t: 'a'
          }]
      }, {
        ln: 'InsertElementType',
        ps: [{
            n: 'feature',
            rq: true,
            col: true,
            mx: false,
            dom: false,
            en: {
              lp: '_Feature',
              ns: 'http:\/\/www.opengis.net\/gml'
            },
            ti: 'GML_3_1_1.AbstractFeatureType',
            t: 'er'
          }, {
            n: 'idgen',
            an: {
              lp: 'idgen'
            },
            t: 'a'
          }, {
            n: 'handle',
            an: {
              lp: 'handle'
            },
            t: 'a'
          }, {
            n: 'inputFormat',
            an: {
              lp: 'inputFormat'
            },
            t: 'a'
          }, {
            n: 'srsName',
            an: {
              lp: 'srsName'
            },
            t: 'a'
          }]
      }, {
        ln: 'PropertyType',
        ps: [{
            n: 'name',
            rq: true,
            en: 'Name',
            ti: 'QName'
          }, {
            n: 'value',
            en: 'Value',
            ti: 'AnyType'
          }]
      }, {
        ln: 'FeatureTypeListType',
        ps: [{
            n: 'operations',
            en: 'Operations',
            ti: '.OperationsType'
          }, {
            n: 'featureType',
            rq: true,
            col: true,
            en: 'FeatureType',
            ti: '.FeatureTypeType'
          }]
      }, {
        ln: 'InsertedFeatureType',
        ps: [{
            n: 'featureId',
            rq: true,
            col: true,
            en: {
              lp: 'FeatureId',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_1_0.FeatureIdType'
          }, {
            n: 'handle',
            an: {
              lp: 'handle'
            },
            t: 'a'
          }]
      }, {
        ln: 'LockType',
        ps: [{
            n: 'filter',
            en: {
              lp: 'Filter',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_1_0.FilterType'
          }, {
            n: 'handle',
            an: {
              lp: 'handle'
            },
            t: 'a'
          }, {
            n: 'typeName',
            rq: true,
            ti: 'QName',
            an: {
              lp: 'typeName'
            },
            t: 'a'
          }]
      }, {
        ln: 'GetCapabilitiesType',
        bti: 'OWS_1_0_0.GetCapabilitiesType',
        ps: [{
            n: 'service',
            an: {
              lp: 'service'
            },
            t: 'a'
          }]
      }, {
        ln: 'GMLObjectTypeListType',
        ps: [{
            n: 'gmlObjectType',
            rq: true,
            col: true,
            en: 'GMLObjectType',
            ti: '.GMLObjectTypeType'
          }]
      }, {
        ln: 'QueryType',
        ps: [{
            n: 'propertyNameOrXlinkPropertyNameOrFunction',
            mno: 0,
            col: true,
            etis: [{
                en: 'PropertyName'
              }, {
                en: 'XlinkPropertyName',
                ti: '.XlinkPropertyName'
              }, {
                en: {
                  lp: 'Function',
                  ns: 'http:\/\/www.opengis.net\/ogc'
                },
                ti: 'Filter_1_1_0.FunctionType'
              }],
            t: 'es'
          }, {
            n: 'filter',
            en: {
              lp: 'Filter',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_1_0.FilterType'
          }, {
            n: 'sortBy',
            en: {
              lp: 'SortBy',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_1_0.SortByType'
          }, {
            n: 'handle',
            an: {
              lp: 'handle'
            },
            t: 'a'
          }, {
            n: 'typeName',
            rq: true,
            ti: {
              t: 'l',
              bti: 'QName'
            },
            an: {
              lp: 'typeName'
            },
            t: 'a'
          }, {
            n: 'featureVersion',
            an: {
              lp: 'featureVersion'
            },
            t: 'a'
          }, {
            n: 'srsName',
            an: {
              lp: 'srsName'
            },
            t: 'a'
          }]
      }, {
        ln: 'FeaturesLockedType',
        ps: [{
            n: 'featureId',
            rq: true,
            col: true,
            en: {
              lp: 'FeatureId',
              ns: 'http:\/\/www.opengis.net\/ogc'
            },
            ti: 'Filter_1_1_0.FeatureIdType'
          }]
      }, {
        ln: 'TransactionResultsType',
        ps: [{
            n: 'action',
            mno: 0,
            col: true,
            en: 'Action',
            ti: '.ActionType'
          }]
      }, {
        ln: 'FeatureCollectionType',
        bti: 'GML_3_1_1.AbstractFeatureCollectionType',
        ps: [{
            n: 'lockId',
            an: {
              lp: 'lockId'
            },
            t: 'a'
          }, {
            n: 'timeStamp',
            ti: 'DateTime',
            an: {
              lp: 'timeStamp'
            },
            t: 'a'
          }, {
            n: 'numberOfFeatures',
            ti: 'NonNegativeInteger',
            an: {
              lp: 'numberOfFeatures'
            },
            t: 'a'
          }]
      }, {
        t: 'enum',
        ln: 'OperationType',
        vs: ['Insert', 'Update', 'Delete', 'Query', 'Lock', 'GetGmlObject']
      }, {
        t: 'enum',
        ln: 'AllSomeType',
        vs: ['ALL', 'SOME']
      }, {
        t: 'enum',
        ln: 'IdentifierGenerationOptionType',
        vs: ['UseExisting', 'ReplaceDuplicate', 'GenerateNew']
      }, {
        t: 'enum',
        ln: 'ResultTypeType',
        vs: ['results', 'hits']
      }],
    eis: [{
        en: 'GetFeatureWithLock',
        ti: '.GetFeatureWithLockType'
      }, {
        en: 'Delete',
        ti: '.DeleteElementType'
      }, {
        en: 'SupportsGMLObjectTypeList',
        ti: '.GMLObjectTypeListType'
      }, {
        en: 'Query',
        ti: '.QueryType'
      }, {
        en: 'LockId'
      }, {
        en: 'Native',
        ti: '.NativeType'
      }, {
        en: 'GetGmlObject',
        ti: '.GetGmlObjectType'
      }, {
        en: 'XlinkPropertyName',
        ti: '.XlinkPropertyName'
      }, {
        en: 'WFS_Capabilities',
        ti: '.WFSCapabilitiesType'
      }, {
        en: 'Transaction',
        ti: '.TransactionType'
      }, {
        en: 'TransactionResponse',
        ti: '.TransactionResponseType'
      }, {
        en: 'Property',
        ti: '.PropertyType'
      }, {
        en: 'ServesGMLObjectTypeList',
        ti: '.GMLObjectTypeListType'
      }, {
        en: 'LockFeatureResponse',
        ti: '.LockFeatureResponseType'
      }, {
        en: 'Insert',
        ti: '.InsertElementType'
      }, {
        en: 'PropertyName'
      }, {
        en: 'LockFeature',
        ti: '.LockFeatureType'
      }, {
        en: 'FeatureTypeList',
        ti: '.FeatureTypeListType'
      }, {
        en: 'DescribeFeatureType',
        ti: '.DescribeFeatureTypeType'
      }, {
        en: 'GetFeature',
        ti: '.GetFeatureType'
      }, {
        en: 'Update',
        ti: '.UpdateElementType'
      }, {
        en: 'FeatureCollection',
        ti: '.FeatureCollectionType',
        sh: {
          lp: '_FeatureCollection',
          ns: 'http:\/\/www.opengis.net\/gml'
        }
      }, {
        en: 'GetCapabilities',
        ti: '.GetCapabilitiesType'
      }]
  };
  return {
    WFS_1_1_0: WFS_1_1_0
  };
};
if (typeof define === 'function' && define.amd) {
  define([], WFS_1_1_0_Module_Factory);
}
else {
  var WFS_1_1_0_Module = WFS_1_1_0_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.WFS_1_1_0 = WFS_1_1_0_Module.WFS_1_1_0;
  }
  else {
    var WFS_1_1_0 = WFS_1_1_0_Module.WFS_1_1_0;
  }
}
},{}],13:[function(require,module,exports){
var WMSC_1_1_1_Module_Factory = function () {
  var WMSC_1_1_1 = {
    n: 'WMSC_1_1_1',
    tis: [{
        ln: 'Identifier',
        tn: null,
        ps: [{
            n: 'authority',
            an: {
              lp: 'authority'
            },
            t: 'a'
          }, {
            n: 'value',
            t: 'v'
          }]
      }, {
        ln: 'HTTP',
        tn: null,
        ps: [{
            n: 'getOrPost',
            col: true,
            etis: [{
                en: {
                  lp: 'Get'
                },
                ti: '.Get'
              }, {
                en: {
                  lp: 'Post'
                },
                ti: '.Post'
              }],
            t: 'es'
          }]
      }, {
        ln: 'Query',
        tn: null,
        ps: [{
            n: 'typeName',
            an: {
              lp: 'typeName'
            },
            t: 'a'
          }]
      }, {
        ln: 'LayerDescription',
        tn: null,
        ps: [{
            n: 'name',
            an: {
              lp: 'name'
            },
            t: 'a'
          }, {
            n: 'wfs',
            an: {
              lp: 'wfs'
            },
            t: 'a'
          }, {
            n: 'owsType',
            an: {
              lp: 'owsType'
            },
            t: 'a'
          }, {
            n: 'owsURL',
            an: {
              lp: 'owsURL'
            },
            t: 'a'
          }, {
            n: 'query',
            col: true,
            en: {
              lp: 'Query'
            },
            ti: '.Query'
          }]
      }, {
        ln: 'DCPType',
        tn: null,
        ps: [{
            n: 'http',
            en: {
              lp: 'HTTP'
            },
            ti: '.HTTP'
          }]
      }, {
        ln: 'UserDefinedSymbolization',
        tn: null,
        ps: [{
            n: 'supportSLD',
            an: {
              lp: 'SupportSLD'
            },
            t: 'a'
          }, {
            n: 'userLayer',
            an: {
              lp: 'UserLayer'
            },
            t: 'a'
          }, {
            n: 'userStyle',
            an: {
              lp: 'UserStyle'
            },
            t: 'a'
          }, {
            n: 'remoteWFS',
            an: {
              lp: 'RemoteWFS'
            },
            t: 'a'
          }]
      }, {
        ln: 'VendorSpecificCapabilities',
        tn: null,
        ps: [{
            n: 'tileSet',
            col: true,
            en: {
              lp: 'TileSet'
            },
            ti: '.TileSet'
          }]
      }, {
        ln: 'GetLegendGraphic',
        tn: null,
        ps: [{
            n: 'format',
            col: true,
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'dcpType',
            col: true,
            en: {
              lp: 'DCPType'
            },
            ti: '.DCPType'
          }]
      }, {
        ln: 'GetMap',
        tn: null,
        ps: [{
            n: 'format',
            col: true,
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'dcpType',
            col: true,
            en: {
              lp: 'DCPType'
            },
            ti: '.DCPType'
          }]
      }, {
        ln: 'GetCapabilities',
        tn: null,
        ps: [{
            n: 'format',
            col: true,
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'dcpType',
            col: true,
            en: {
              lp: 'DCPType'
            },
            ti: '.DCPType'
          }]
      }, {
        ln: 'OnlineResource',
        tn: null,
        ps: [{
            n: 'xmlnsXlink',
            an: {
              lp: 'xmlns:xlink'
            },
            t: 'a'
          }, {
            n: 'xlinkType',
            an: {
              lp: 'xlink:type'
            },
            t: 'a'
          }, {
            n: 'xlinkHref',
            an: {
              lp: 'xlink:href'
            },
            t: 'a'
          }]
      }, {
        ln: 'ContactPersonPrimary',
        tn: null,
        ps: [{
            n: 'contactPerson',
            en: {
              lp: 'ContactPerson'
            }
          }, {
            n: 'contactOrganization',
            en: {
              lp: 'ContactOrganization'
            }
          }]
      }, {
        ln: 'DataURL',
        tn: null,
        ps: [{
            n: 'format',
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'ScaleHint',
        tn: null,
        ps: [{
            n: 'min',
            an: {
              lp: 'min'
            },
            t: 'a'
          }, {
            n: 'max',
            an: {
              lp: 'max'
            },
            t: 'a'
          }]
      }, {
        ln: 'LogoURL',
        tn: null,
        ps: [{
            n: 'width',
            an: {
              lp: 'width'
            },
            t: 'a'
          }, {
            n: 'height',
            an: {
              lp: 'height'
            },
            t: 'a'
          }, {
            n: 'format',
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'Capability',
        tn: null,
        ps: [{
            n: 'request',
            en: {
              lp: 'Request'
            },
            ti: '.Request'
          }, {
            n: 'exception',
            en: {
              lp: 'Exception'
            },
            ti: '.Exception'
          }, {
            n: 'vendorSpecificCapabilities',
            en: {
              lp: 'VendorSpecificCapabilities'
            },
            ti: '.VendorSpecificCapabilities'
          }, {
            n: 'userDefinedSymbolization',
            en: {
              lp: 'UserDefinedSymbolization'
            },
            ti: '.UserDefinedSymbolization'
          }, {
            n: 'layer',
            en: {
              lp: 'Layer'
            },
            ti: '.Layer'
          }]
      }, {
        ln: 'PutStyles',
        tn: null,
        ps: [{
            n: 'format',
            col: true,
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'dcpType',
            col: true,
            en: {
              lp: 'DCPType'
            },
            ti: '.DCPType'
          }]
      }, {
        ln: 'Get',
        tn: null,
        ps: [{
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'BoundingBox',
        tn: null,
        ps: [{
            n: 'srs',
            an: {
              lp: 'SRS'
            },
            t: 'a'
          }, {
            n: 'minx',
            an: {
              lp: 'minx'
            },
            t: 'a'
          }, {
            n: 'miny',
            an: {
              lp: 'miny'
            },
            t: 'a'
          }, {
            n: 'maxx',
            an: {
              lp: 'maxx'
            },
            t: 'a'
          }, {
            n: 'maxy',
            an: {
              lp: 'maxy'
            },
            t: 'a'
          }, {
            n: 'resx',
            an: {
              lp: 'resx'
            },
            t: 'a'
          }, {
            n: 'resy',
            an: {
              lp: 'resy'
            },
            t: 'a'
          }]
      }, {
        ln: 'Style',
        tn: null,
        ps: [{
            n: 'name',
            en: {
              lp: 'Name'
            }
          }, {
            n: 'title',
            en: {
              lp: 'Title'
            }
          }, {
            n: '_abstract',
            en: {
              lp: 'Abstract'
            }
          }, {
            n: 'legendURL',
            col: true,
            en: {
              lp: 'LegendURL'
            },
            ti: '.LegendURL'
          }, {
            n: 'styleSheetURL',
            en: {
              lp: 'StyleSheetURL'
            },
            ti: '.StyleSheetURL'
          }, {
            n: 'styleURL',
            en: {
              lp: 'StyleURL'
            },
            ti: '.StyleURL'
          }]
      }, {
        ln: 'GetFeatureInfo',
        tn: null,
        ps: [{
            n: 'format',
            col: true,
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'dcpType',
            col: true,
            en: {
              lp: 'DCPType'
            },
            ti: '.DCPType'
          }]
      }, {
        ln: 'ContactInformation',
        tn: null,
        ps: [{
            n: 'contactPersonPrimary',
            en: {
              lp: 'ContactPersonPrimary'
            },
            ti: '.ContactPersonPrimary'
          }, {
            n: 'contactPosition',
            en: {
              lp: 'ContactPosition'
            }
          }, {
            n: 'contactAddress',
            en: {
              lp: 'ContactAddress'
            },
            ti: '.ContactAddress'
          }, {
            n: 'contactVoiceTelephone',
            en: {
              lp: 'ContactVoiceTelephone'
            }
          }, {
            n: 'contactFacsimileTelephone',
            en: {
              lp: 'ContactFacsimileTelephone'
            }
          }, {
            n: 'contactElectronicMailAddress',
            en: {
              lp: 'ContactElectronicMailAddress'
            }
          }]
      }, {
        ln: 'ServiceExceptionReport',
        tn: null,
        ps: [{
            n: 'version',
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'serviceException',
            col: true,
            en: {
              lp: 'ServiceException'
            },
            ti: '.ServiceException'
          }]
      }, {
        ln: 'WMSDescribeLayerResponse',
        tn: null,
        ps: [{
            n: 'version',
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'layerDescription',
            col: true,
            en: {
              lp: 'LayerDescription'
            },
            ti: '.LayerDescription'
          }]
      }, {
        ln: 'Post',
        tn: null,
        ps: [{
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'FeatureListURL',
        tn: null,
        ps: [{
            n: 'format',
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'DescribeLayer',
        tn: null,
        ps: [{
            n: 'format',
            col: true,
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'dcpType',
            col: true,
            en: {
              lp: 'DCPType'
            },
            ti: '.DCPType'
          }]
      }, {
        ln: 'AuthorityURL',
        tn: null,
        ps: [{
            n: 'name',
            an: {
              lp: 'name'
            },
            t: 'a'
          }, {
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'LatLonBoundingBox',
        tn: null,
        ps: [{
            n: 'minx',
            an: {
              lp: 'minx'
            },
            t: 'a'
          }, {
            n: 'miny',
            an: {
              lp: 'miny'
            },
            t: 'a'
          }, {
            n: 'maxx',
            an: {
              lp: 'maxx'
            },
            t: 'a'
          }, {
            n: 'maxy',
            an: {
              lp: 'maxy'
            },
            t: 'a'
          }]
      }, {
        ln: 'Keyword',
        tn: null,
        ps: [{
            n: 'value',
            t: 'v'
          }]
      }, {
        ln: 'Service',
        tn: null,
        ps: [{
            n: 'name',
            en: {
              lp: 'Name'
            }
          }, {
            n: 'title',
            en: {
              lp: 'Title'
            }
          }, {
            n: '_abstract',
            en: {
              lp: 'Abstract'
            }
          }, {
            n: 'keywordList',
            en: {
              lp: 'KeywordList'
            },
            ti: '.KeywordList'
          }, {
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }, {
            n: 'contactInformation',
            en: {
              lp: 'ContactInformation'
            },
            ti: '.ContactInformation'
          }, {
            n: 'fees',
            en: {
              lp: 'Fees'
            }
          }, {
            n: 'accessConstraints',
            en: {
              lp: 'AccessConstraints'
            }
          }]
      }, {
        ln: 'Layers',
        tn: null,
        ps: [{
            n: 'value',
            t: 'v'
          }]
      }, {
        ln: 'WMTMSCapabilities',
        tn: null,
        ps: [{
            n: 'version',
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'updateSequence',
            an: {
              lp: 'updateSequence'
            },
            t: 'a'
          }, {
            n: 'service',
            en: {
              lp: 'Service'
            },
            ti: '.Service'
          }, {
            n: 'capability',
            en: {
              lp: 'Capability'
            },
            ti: '.Capability'
          }]
      }, {
        ln: 'Attribution',
        tn: null,
        ps: [{
            n: 'title',
            en: {
              lp: 'Title'
            }
          }, {
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }, {
            n: 'logoURL',
            en: {
              lp: 'LogoURL'
            },
            ti: '.LogoURL'
          }]
      }, {
        ln: 'StyleURL',
        tn: null,
        ps: [{
            n: 'format',
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'Dimension',
        tn: null,
        ps: [{
            n: 'name',
            an: {
              lp: 'name'
            },
            t: 'a'
          }, {
            n: 'units',
            an: {
              lp: 'units'
            },
            t: 'a'
          }, {
            n: 'unitSymbol',
            an: {
              lp: 'unitSymbol'
            },
            t: 'a'
          }]
      }, {
        ln: 'StyleSheetURL',
        tn: null,
        ps: [{
            n: 'format',
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'Styles',
        tn: null,
        ps: [{
            n: 'value',
            t: 'v'
          }]
      }, {
        ln: 'MetadataURL',
        tn: null,
        ps: [{
            n: 'type',
            an: {
              lp: 'type'
            },
            t: 'a'
          }, {
            n: 'format',
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'TileSet',
        tn: null,
        ps: [{
            n: 'srs',
            en: {
              lp: 'SRS'
            },
            ti: '.SRS'
          }, {
            n: 'boundingBox',
            en: {
              lp: 'BoundingBox'
            },
            ti: '.BoundingBox'
          }, {
            n: 'resolutions',
            en: {
              lp: 'Resolutions'
            }
          }, {
            n: 'width',
            en: {
              lp: 'Width'
            }
          }, {
            n: 'height',
            en: {
              lp: 'Height'
            }
          }, {
            n: 'format',
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'layers',
            col: true,
            en: {
              lp: 'Layers'
            },
            ti: '.Layers'
          }, {
            n: 'styles',
            col: true,
            en: {
              lp: 'Styles'
            },
            ti: '.Styles'
          }]
      }, {
        ln: 'KeywordList',
        tn: null,
        ps: [{
            n: 'keyword',
            col: true,
            en: {
              lp: 'Keyword'
            },
            ti: '.Keyword'
          }]
      }, {
        ln: 'GetStyles',
        tn: null,
        ps: [{
            n: 'format',
            col: true,
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'dcpType',
            col: true,
            en: {
              lp: 'DCPType'
            },
            ti: '.DCPType'
          }]
      }, {
        ln: 'ContactAddress',
        tn: null,
        ps: [{
            n: 'addressType',
            en: {
              lp: 'AddressType'
            }
          }, {
            n: 'address',
            en: {
              lp: 'Address'
            }
          }, {
            n: 'city',
            en: {
              lp: 'City'
            }
          }, {
            n: 'stateOrProvince',
            en: {
              lp: 'StateOrProvince'
            }
          }, {
            n: 'postCode',
            en: {
              lp: 'PostCode'
            }
          }, {
            n: 'country',
            en: {
              lp: 'Country'
            }
          }]
      }, {
        ln: 'Exception',
        tn: null,
        ps: [{
            n: 'format',
            col: true,
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }]
      }, {
        ln: 'ServiceException',
        tn: null,
        ps: [{
            n: 'code',
            an: {
              lp: 'code'
            },
            t: 'a'
          }, {
            n: 'value',
            t: 'v'
          }]
      }, {
        ln: 'LegendURL',
        tn: null,
        ps: [{
            n: 'width',
            an: {
              lp: 'width'
            },
            t: 'a'
          }, {
            n: 'height',
            an: {
              lp: 'height'
            },
            t: 'a'
          }, {
            n: 'format',
            en: {
              lp: 'Format'
            },
            ti: '.Format'
          }, {
            n: 'onlineResource',
            en: {
              lp: 'OnlineResource'
            },
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'Extent',
        tn: null,
        ps: [{
            n: 'name',
            an: {
              lp: 'name'
            },
            t: 'a'
          }, {
            n: '_default',
            an: {
              lp: 'default'
            },
            t: 'a'
          }, {
            n: 'nearestValue',
            an: {
              lp: 'nearestValue'
            },
            t: 'a'
          }, {
            n: 'multipleValues',
            an: {
              lp: 'multipleValues'
            },
            t: 'a'
          }, {
            n: 'current',
            an: {
              lp: 'current'
            },
            t: 'a'
          }, {
            n: 'value',
            t: 'v'
          }]
      }, {
        ln: 'Request',
        tn: null,
        ps: [{
            n: 'getCapabilities',
            en: {
              lp: 'GetCapabilities'
            },
            ti: '.GetCapabilities'
          }, {
            n: 'getMap',
            en: {
              lp: 'GetMap'
            },
            ti: '.GetMap'
          }, {
            n: 'getFeatureInfo',
            en: {
              lp: 'GetFeatureInfo'
            },
            ti: '.GetFeatureInfo'
          }, {
            n: 'describeLayer',
            en: {
              lp: 'DescribeLayer'
            },
            ti: '.DescribeLayer'
          }, {
            n: 'getLegendGraphic',
            en: {
              lp: 'GetLegendGraphic'
            },
            ti: '.GetLegendGraphic'
          }, {
            n: 'getStyles',
            en: {
              lp: 'GetStyles'
            },
            ti: '.GetStyles'
          }, {
            n: 'putStyles',
            en: {
              lp: 'PutStyles'
            },
            ti: '.PutStyles'
          }]
      }, {
        ln: 'SRS',
        tn: null,
        ps: [{
            n: 'value',
            t: 'v'
          }]
      }, {
        ln: 'Format',
        tn: null,
        ps: [{
            n: 'value',
            t: 'v'
          }]
      }, {
        ln: 'Layer',
        tn: null,
        ps: [{
            n: 'queryable',
            an: {
              lp: 'queryable'
            },
            t: 'a'
          }, {
            n: 'cascaded',
            an: {
              lp: 'cascaded'
            },
            t: 'a'
          }, {
            n: 'opaque',
            an: {
              lp: 'opaque'
            },
            t: 'a'
          }, {
            n: 'noSubsets',
            an: {
              lp: 'noSubsets'
            },
            t: 'a'
          }, {
            n: 'fixedWidth',
            an: {
              lp: 'fixedWidth'
            },
            t: 'a'
          }, {
            n: 'fixedHeight',
            an: {
              lp: 'fixedHeight'
            },
            t: 'a'
          }, {
            n: 'name',
            en: {
              lp: 'Name'
            }
          }, {
            n: 'title',
            en: {
              lp: 'Title'
            }
          }, {
            n: '_abstract',
            en: {
              lp: 'Abstract'
            }
          }, {
            n: 'keywordList',
            en: {
              lp: 'KeywordList'
            },
            ti: '.KeywordList'
          }, {
            n: 'srs',
            col: true,
            en: {
              lp: 'SRS'
            },
            ti: '.SRS'
          }, {
            n: 'latLonBoundingBox',
            en: {
              lp: 'LatLonBoundingBox'
            },
            ti: '.LatLonBoundingBox'
          }, {
            n: 'boundingBox',
            col: true,
            en: {
              lp: 'BoundingBox'
            },
            ti: '.BoundingBox'
          }, {
            n: 'dimension',
            col: true,
            en: {
              lp: 'Dimension'
            },
            ti: '.Dimension'
          }, {
            n: 'extent',
            col: true,
            en: {
              lp: 'Extent'
            },
            ti: '.Extent'
          }, {
            n: 'attribution',
            en: {
              lp: 'Attribution'
            },
            ti: '.Attribution'
          }, {
            n: 'authorityURL',
            col: true,
            en: {
              lp: 'AuthorityURL'
            },
            ti: '.AuthorityURL'
          }, {
            n: 'identifier',
            col: true,
            en: {
              lp: 'Identifier'
            },
            ti: '.Identifier'
          }, {
            n: 'metadataURL',
            col: true,
            en: {
              lp: 'MetadataURL'
            },
            ti: '.MetadataURL'
          }, {
            n: 'dataURL',
            col: true,
            en: {
              lp: 'DataURL'
            },
            ti: '.DataURL'
          }, {
            n: 'featureListURL',
            col: true,
            en: {
              lp: 'FeatureListURL'
            },
            ti: '.FeatureListURL'
          }, {
            n: 'style',
            col: true,
            en: {
              lp: 'Style'
            },
            ti: '.Style'
          }, {
            n: 'scaleHint',
            en: {
              lp: 'ScaleHint'
            },
            ti: '.ScaleHint'
          }, {
            n: 'layer',
            col: true,
            en: {
              lp: 'Layer'
            },
            ti: '.Layer'
          }]
      }],
    eis: [{
        en: {
          lp: 'OnlineResource'
        },
        ti: '.OnlineResource'
      }, {
        en: {
          lp: 'ContactPersonPrimary'
        },
        ti: '.ContactPersonPrimary'
      }, {
        en: {
          lp: 'UserDefinedSymbolization'
        },
        ti: '.UserDefinedSymbolization'
      }, {
        en: {
          lp: 'Request'
        },
        ti: '.Request'
      }, {
        en: {
          lp: 'Get'
        },
        ti: '.Get'
      }, {
        en: {
          lp: 'PutStyles'
        },
        ti: '.PutStyles'
      }, {
        en: {
          lp: 'ServiceExceptionReport'
        },
        ti: '.ServiceExceptionReport'
      }, {
        en: {
          lp: 'Identifier'
        },
        ti: '.Identifier'
      }, {
        en: {
          lp: 'Keyword'
        },
        ti: '.Keyword'
      }, {
        en: {
          lp: 'Dimension'
        },
        ti: '.Dimension'
      }, {
        en: {
          lp: 'LayerDescription'
        },
        ti: '.LayerDescription'
      }, {
        en: {
          lp: 'DataURL'
        },
        ti: '.DataURL'
      }, {
        en: {
          lp: 'StyleURL'
        },
        ti: '.StyleURL'
      }, {
        en: {
          lp: 'ServiceException'
        },
        ti: '.ServiceException'
      }, {
        en: {
          lp: 'LegendURL'
        },
        ti: '.LegendURL'
      }, {
        en: {
          lp: 'Extent'
        },
        ti: '.Extent'
      }, {
        en: {
          lp: 'ContactInformation'
        },
        ti: '.ContactInformation'
      }, {
        en: {
          lp: 'LatLonBoundingBox'
        },
        ti: '.LatLonBoundingBox'
      }, {
        en: {
          lp: 'Style'
        },
        ti: '.Style'
      }, {
        en: {
          lp: 'ScaleHint'
        },
        ti: '.ScaleHint'
      }, {
        en: {
          lp: 'DescribeLayer'
        },
        ti: '.DescribeLayer'
      }, {
        en: {
          lp: 'GetMap'
        },
        ti: '.GetMap'
      }, {
        en: {
          lp: 'KeywordList'
        },
        ti: '.KeywordList'
      }, {
        en: {
          lp: 'HTTP'
        },
        ti: '.HTTP'
      }, {
        en: {
          lp: 'ContactAddress'
        },
        ti: '.ContactAddress'
      }, {
        en: {
          lp: 'WMS_DescribeLayerResponse'
        },
        ti: '.WMSDescribeLayerResponse'
      }, {
        en: {
          lp: 'Styles'
        },
        ti: '.Styles'
      }, {
        en: {
          lp: 'Service'
        },
        ti: '.Service'
      }, {
        en: {
          lp: 'Post'
        },
        ti: '.Post'
      }, {
        en: {
          lp: 'GetFeatureInfo'
        },
        ti: '.GetFeatureInfo'
      }, {
        en: {
          lp: 'FeatureListURL'
        },
        ti: '.FeatureListURL'
      }, {
        en: {
          lp: 'AuthorityURL'
        },
        ti: '.AuthorityURL'
      }, {
        en: {
          lp: 'Format'
        },
        ti: '.Format'
      }, {
        en: {
          lp: 'Capability'
        },
        ti: '.Capability'
      }, {
        en: {
          lp: 'MetadataURL'
        },
        ti: '.MetadataURL'
      }, {
        en: {
          lp: 'GetStyles'
        },
        ti: '.GetStyles'
      }, {
        en: {
          lp: 'Exception'
        },
        ti: '.Exception'
      }, {
        en: {
          lp: 'DCPType'
        },
        ti: '.DCPType'
      }, {
        en: {
          lp: 'BoundingBox'
        },
        ti: '.BoundingBox'
      }, {
        en: {
          lp: 'Layer'
        },
        ti: '.Layer'
      }, {
        en: {
          lp: 'GetLegendGraphic'
        },
        ti: '.GetLegendGraphic'
      }, {
        en: {
          lp: 'SRS'
        },
        ti: '.SRS'
      }, {
        en: {
          lp: 'VendorSpecificCapabilities'
        },
        ti: '.VendorSpecificCapabilities'
      }, {
        en: {
          lp: 'TileSet'
        },
        ti: '.TileSet'
      }, {
        en: {
          lp: 'WMT_MS_Capabilities'
        },
        ti: '.WMTMSCapabilities'
      }, {
        en: {
          lp: 'StyleSheetURL'
        },
        ti: '.StyleSheetURL'
      }, {
        en: {
          lp: 'GetCapabilities'
        },
        ti: '.GetCapabilities'
      }, {
        en: {
          lp: 'LogoURL'
        },
        ti: '.LogoURL'
      }, {
        en: {
          lp: 'Layers'
        },
        ti: '.Layers'
      }, {
        en: {
          lp: 'Attribution'
        },
        ti: '.Attribution'
      }, {
        en: {
          lp: 'Query'
        },
        ti: '.Query'
      }]
  };
  return {
    WMSC_1_1_1: WMSC_1_1_1
  };
};
if (typeof define === 'function' && define.amd) {
  define([], WMSC_1_1_1_Module_Factory);
}
else {
  var WMSC_1_1_1_Module = WMSC_1_1_1_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.WMSC_1_1_1 = WMSC_1_1_1_Module.WMSC_1_1_1;
  }
  else {
    var WMSC_1_1_1 = WMSC_1_1_1_Module.WMSC_1_1_1;
  }
}
},{}],14:[function(require,module,exports){
var WMS_1_3_0_Module_Factory = function () {
  var WMS_1_3_0 = {
    n: 'WMS_1_3_0',
    dens: 'http:\/\/www.opengis.net\/wms',
    deps: ['XLink_1_0'],
    tis: [{
        ln: 'Dimension',
        tn: null,
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'name',
            rq: true,
            an: {
              lp: 'name'
            },
            t: 'a'
          }, {
            n: 'units',
            rq: true,
            an: {
              lp: 'units'
            },
            t: 'a'
          }, {
            n: 'unitSymbol',
            an: {
              lp: 'unitSymbol'
            },
            t: 'a'
          }, {
            n: '_default',
            an: {
              lp: 'default'
            },
            t: 'a'
          }, {
            n: 'multipleValues',
            ti: 'Boolean',
            an: {
              lp: 'multipleValues'
            },
            t: 'a'
          }, {
            n: 'nearestValue',
            ti: 'Boolean',
            an: {
              lp: 'nearestValue'
            },
            t: 'a'
          }, {
            n: 'current',
            ti: 'Boolean',
            an: {
              lp: 'current'
            },
            t: 'a'
          }]
      }, {
        ln: 'Capability',
        tn: null,
        ps: [{
            n: 'request',
            rq: true,
            en: 'Request',
            ti: '.Request'
          }, {
            n: 'exception',
            rq: true,
            en: 'Exception',
            ti: '.Exception'
          }, {
            n: 'extendedCapabilities',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: '_ExtendedCapabilities',
            ti: 'AnyType',
            t: 'er'
          }, {
            n: 'layer',
            en: 'Layer',
            ti: '.Layer'
          }]
      }, {
        ln: 'DataURL',
        tn: null,
        ps: [{
            n: 'format',
            rq: true,
            en: 'Format'
          }, {
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'ContactAddress',
        tn: null,
        ps: [{
            n: 'addressType',
            rq: true,
            en: 'AddressType'
          }, {
            n: 'address',
            rq: true,
            en: 'Address'
          }, {
            n: 'city',
            rq: true,
            en: 'City'
          }, {
            n: 'stateOrProvince',
            rq: true,
            en: 'StateOrProvince'
          }, {
            n: 'postCode',
            rq: true,
            en: 'PostCode'
          }, {
            n: 'country',
            rq: true,
            en: 'Country'
          }]
      }, {
        ln: 'KeywordList',
        tn: null,
        ps: [{
            n: 'keyword',
            mno: 0,
            col: true,
            en: 'Keyword',
            ti: '.Keyword'
          }]
      }, {
        ln: 'DCPType',
        tn: null,
        ps: [{
            n: 'http',
            rq: true,
            en: 'HTTP',
            ti: '.HTTP'
          }]
      }, {
        ln: 'Attribution',
        tn: null,
        ps: [{
            n: 'title',
            en: 'Title'
          }, {
            n: 'onlineResource',
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }, {
            n: 'logoURL',
            en: 'LogoURL',
            ti: '.LogoURL'
          }]
      }, {
        ln: 'OnlineResource',
        tn: null,
        ps: [{
            n: 'type',
            ti: 'XLink_1_0.TypeType',
            an: {
              lp: 'type',
              ns: 'http:\/\/www.w3.org\/1999\/xlink'
            },
            t: 'a'
          }, {
            n: 'href',
            an: {
              lp: 'href',
              ns: 'http:\/\/www.w3.org\/1999\/xlink'
            },
            t: 'a'
          }, {
            n: 'role',
            an: {
              lp: 'role',
              ns: 'http:\/\/www.w3.org\/1999\/xlink'
            },
            t: 'a'
          }, {
            n: 'arcrole',
            an: {
              lp: 'arcrole',
              ns: 'http:\/\/www.w3.org\/1999\/xlink'
            },
            t: 'a'
          }, {
            n: 'title',
            an: {
              lp: 'title',
              ns: 'http:\/\/www.w3.org\/1999\/xlink'
            },
            t: 'a'
          }, {
            n: 'show',
            ti: 'XLink_1_0.ShowType',
            an: {
              lp: 'show',
              ns: 'http:\/\/www.w3.org\/1999\/xlink'
            },
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'XLink_1_0.ActuateType',
            an: {
              lp: 'actuate',
              ns: 'http:\/\/www.w3.org\/1999\/xlink'
            },
            t: 'a'
          }]
      }, {
        ln: 'Post',
        tn: null,
        ps: [{
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'EXGeographicBoundingBox',
        tn: null,
        ps: [{
            n: 'westBoundLongitude',
            rq: true,
            ti: 'Double'
          }, {
            n: 'eastBoundLongitude',
            rq: true,
            ti: 'Double'
          }, {
            n: 'southBoundLatitude',
            rq: true,
            ti: 'Double'
          }, {
            n: 'northBoundLatitude',
            rq: true,
            ti: 'Double'
          }]
      }, {
        ln: 'FeatureListURL',
        tn: null,
        ps: [{
            n: 'format',
            rq: true,
            en: 'Format'
          }, {
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'OperationType',
        ps: [{
            n: 'format',
            rq: true,
            col: true,
            en: 'Format'
          }, {
            n: 'dcpType',
            rq: true,
            col: true,
            en: 'DCPType',
            ti: '.DCPType'
          }]
      }, {
        ln: 'ContactInformation',
        tn: null,
        ps: [{
            n: 'contactPersonPrimary',
            en: 'ContactPersonPrimary',
            ti: '.ContactPersonPrimary'
          }, {
            n: 'contactPosition',
            en: 'ContactPosition'
          }, {
            n: 'contactAddress',
            en: 'ContactAddress',
            ti: '.ContactAddress'
          }, {
            n: 'contactVoiceTelephone',
            en: 'ContactVoiceTelephone'
          }, {
            n: 'contactFacsimileTelephone',
            en: 'ContactFacsimileTelephone'
          }, {
            n: 'contactElectronicMailAddress',
            en: 'ContactElectronicMailAddress'
          }]
      }, {
        ln: 'Style',
        tn: null,
        ps: [{
            n: 'name',
            rq: true,
            en: 'Name'
          }, {
            n: 'title',
            rq: true,
            en: 'Title'
          }, {
            n: '_abstract',
            en: 'Abstract'
          }, {
            n: 'legendURL',
            mno: 0,
            col: true,
            en: 'LegendURL',
            ti: '.LegendURL'
          }, {
            n: 'styleSheetURL',
            en: 'StyleSheetURL',
            ti: '.StyleSheetURL'
          }, {
            n: 'styleURL',
            en: 'StyleURL',
            ti: '.StyleURL'
          }]
      }, {
        ln: 'StyleSheetURL',
        tn: null,
        ps: [{
            n: 'format',
            rq: true,
            en: 'Format'
          }, {
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'Keyword',
        tn: null,
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'vocabulary',
            an: {
              lp: 'vocabulary'
            },
            t: 'a'
          }]
      }, {
        ln: 'BoundingBox',
        tn: null,
        ps: [{
            n: 'crs',
            rq: true,
            an: {
              lp: 'CRS'
            },
            t: 'a'
          }, {
            n: 'minx',
            rq: true,
            ti: 'Double',
            an: {
              lp: 'minx'
            },
            t: 'a'
          }, {
            n: 'miny',
            rq: true,
            ti: 'Double',
            an: {
              lp: 'miny'
            },
            t: 'a'
          }, {
            n: 'maxx',
            rq: true,
            ti: 'Double',
            an: {
              lp: 'maxx'
            },
            t: 'a'
          }, {
            n: 'maxy',
            rq: true,
            ti: 'Double',
            an: {
              lp: 'maxy'
            },
            t: 'a'
          }, {
            n: 'resx',
            ti: 'Double',
            an: {
              lp: 'resx'
            },
            t: 'a'
          }, {
            n: 'resy',
            ti: 'Double',
            an: {
              lp: 'resy'
            },
            t: 'a'
          }]
      }, {
        ln: 'AuthorityURL',
        tn: null,
        ps: [{
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }, {
            n: 'name',
            rq: true,
            ti: 'NMToken',
            an: {
              lp: 'name'
            },
            t: 'a'
          }]
      }, {
        ln: 'Layer',
        tn: null,
        ps: [{
            n: 'name',
            en: 'Name'
          }, {
            n: 'title',
            rq: true,
            en: 'Title'
          }, {
            n: '_abstract',
            en: 'Abstract'
          }, {
            n: 'keywordList',
            en: 'KeywordList',
            ti: '.KeywordList'
          }, {
            n: 'crs',
            mno: 0,
            col: true,
            en: 'CRS'
          }, {
            n: 'exGeographicBoundingBox',
            en: 'EX_GeographicBoundingBox',
            ti: '.EXGeographicBoundingBox'
          }, {
            n: 'boundingBox',
            mno: 0,
            col: true,
            en: 'BoundingBox',
            ti: '.BoundingBox'
          }, {
            n: 'dimension',
            mno: 0,
            col: true,
            en: 'Dimension',
            ti: '.Dimension'
          }, {
            n: 'attribution',
            en: 'Attribution',
            ti: '.Attribution'
          }, {
            n: 'authorityURL',
            mno: 0,
            col: true,
            en: 'AuthorityURL',
            ti: '.AuthorityURL'
          }, {
            n: 'identifier',
            mno: 0,
            col: true,
            en: 'Identifier',
            ti: '.Identifier'
          }, {
            n: 'metadataURL',
            mno: 0,
            col: true,
            en: 'MetadataURL',
            ti: '.MetadataURL'
          }, {
            n: 'dataURL',
            mno: 0,
            col: true,
            en: 'DataURL',
            ti: '.DataURL'
          }, {
            n: 'featureListURL',
            mno: 0,
            col: true,
            en: 'FeatureListURL',
            ti: '.FeatureListURL'
          }, {
            n: 'style',
            mno: 0,
            col: true,
            en: 'Style',
            ti: '.Style'
          }, {
            n: 'minScaleDenominator',
            en: 'MinScaleDenominator',
            ti: 'Double'
          }, {
            n: 'maxScaleDenominator',
            en: 'MaxScaleDenominator',
            ti: 'Double'
          }, {
            n: 'layer',
            mno: 0,
            col: true,
            en: 'Layer',
            ti: '.Layer'
          }, {
            n: 'queryable',
            ti: 'Boolean',
            an: {
              lp: 'queryable'
            },
            t: 'a'
          }, {
            n: 'cascaded',
            ti: 'NonNegativeInteger',
            an: {
              lp: 'cascaded'
            },
            t: 'a'
          }, {
            n: 'opaque',
            ti: 'Boolean',
            an: {
              lp: 'opaque'
            },
            t: 'a'
          }, {
            n: 'noSubsets',
            ti: 'Boolean',
            an: {
              lp: 'noSubsets'
            },
            t: 'a'
          }, {
            n: 'fixedWidth',
            ti: 'NonNegativeInteger',
            an: {
              lp: 'fixedWidth'
            },
            t: 'a'
          }, {
            n: 'fixedHeight',
            ti: 'NonNegativeInteger',
            an: {
              lp: 'fixedHeight'
            },
            t: 'a'
          }]
      }, {
        ln: 'Exception',
        tn: null,
        ps: [{
            n: 'format',
            rq: true,
            col: true,
            en: 'Format'
          }]
      }, {
        ln: 'StyleURL',
        tn: null,
        ps: [{
            n: 'format',
            rq: true,
            en: 'Format'
          }, {
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'Service',
        tn: null,
        ps: [{
            n: 'name',
            rq: true,
            en: 'Name'
          }, {
            n: 'title',
            rq: true,
            en: 'Title'
          }, {
            n: '_abstract',
            en: 'Abstract'
          }, {
            n: 'keywordList',
            en: 'KeywordList',
            ti: '.KeywordList'
          }, {
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }, {
            n: 'contactInformation',
            en: 'ContactInformation',
            ti: '.ContactInformation'
          }, {
            n: 'fees',
            en: 'Fees'
          }, {
            n: 'accessConstraints',
            en: 'AccessConstraints'
          }, {
            n: 'layerLimit',
            en: 'LayerLimit',
            ti: 'PositiveInteger'
          }, {
            n: 'maxWidth',
            en: 'MaxWidth',
            ti: 'PositiveInteger'
          }, {
            n: 'maxHeight',
            en: 'MaxHeight',
            ti: 'PositiveInteger'
          }]
      }, {
        ln: 'Identifier',
        tn: null,
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'authority',
            rq: true,
            an: {
              lp: 'authority'
            },
            t: 'a'
          }]
      }, {
        ln: 'LegendURL',
        tn: null,
        ps: [{
            n: 'format',
            rq: true,
            en: 'Format'
          }, {
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }, {
            n: 'width',
            ti: 'PositiveInteger',
            an: {
              lp: 'width'
            },
            t: 'a'
          }, {
            n: 'height',
            ti: 'PositiveInteger',
            an: {
              lp: 'height'
            },
            t: 'a'
          }]
      }, {
        ln: 'LogoURL',
        tn: null,
        ps: [{
            n: 'format',
            rq: true,
            en: 'Format'
          }, {
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }, {
            n: 'width',
            ti: 'PositiveInteger',
            an: {
              lp: 'width'
            },
            t: 'a'
          }, {
            n: 'height',
            ti: 'PositiveInteger',
            an: {
              lp: 'height'
            },
            t: 'a'
          }]
      }, {
        ln: 'MetadataURL',
        tn: null,
        ps: [{
            n: 'format',
            rq: true,
            en: 'Format'
          }, {
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }, {
            n: 'type',
            rq: true,
            ti: 'NMToken',
            an: {
              lp: 'type'
            },
            t: 'a'
          }]
      }, {
        ln: 'ContactPersonPrimary',
        tn: null,
        ps: [{
            n: 'contactPerson',
            rq: true,
            en: 'ContactPerson'
          }, {
            n: 'contactOrganization',
            rq: true,
            en: 'ContactOrganization'
          }]
      }, {
        ln: 'HTTP',
        tn: null,
        ps: [{
            n: 'get',
            rq: true,
            en: 'Get',
            ti: '.Get'
          }, {
            n: 'post',
            en: 'Post',
            ti: '.Post'
          }]
      }, {
        ln: 'WMSCapabilities',
        tn: null,
        ps: [{
            n: 'service',
            rq: true,
            en: 'Service',
            ti: '.Service'
          }, {
            n: 'capability',
            rq: true,
            en: 'Capability',
            ti: '.Capability'
          }, {
            n: 'version',
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'updateSequence',
            an: {
              lp: 'updateSequence'
            },
            t: 'a'
          }]
      }, {
        ln: 'Get',
        tn: null,
        ps: [{
            n: 'onlineResource',
            rq: true,
            en: 'OnlineResource',
            ti: '.OnlineResource'
          }]
      }, {
        ln: 'Request',
        tn: null,
        ps: [{
            n: 'getCapabilities',
            rq: true,
            en: 'GetCapabilities',
            ti: '.OperationType'
          }, {
            n: 'getMap',
            rq: true,
            en: 'GetMap',
            ti: '.OperationType'
          }, {
            n: 'getFeatureInfo',
            en: 'GetFeatureInfo',
            ti: '.OperationType'
          }, {
            n: 'extendedOperation',
            mno: 0,
            col: true,
            mx: false,
            dom: false,
            en: '_ExtendedOperation',
            ti: '.OperationType',
            t: 'er'
          }]
      }],
    eis: [{
        en: 'City'
      }, {
        en: 'FeatureListURL',
        ti: '.FeatureListURL'
      }, {
        en: 'StyleSheetURL',
        ti: '.StyleSheetURL'
      }, {
        en: 'Dimension',
        ti: '.Dimension'
      }, {
        en: 'Address'
      }, {
        en: 'Fees'
      }, {
        en: 'MaxWidth',
        ti: 'PositiveInteger'
      }, {
        en: 'DataURL',
        ti: '.DataURL'
      }, {
        en: 'ContactPersonPrimary',
        ti: '.ContactPersonPrimary'
      }, {
        en: 'DCPType',
        ti: '.DCPType'
      }, {
        en: 'Attribution',
        ti: '.Attribution'
      }, {
        en: 'AuthorityURL',
        ti: '.AuthorityURL'
      }, {
        en: 'AccessConstraints'
      }, {
        en: 'EX_GeographicBoundingBox',
        ti: '.EXGeographicBoundingBox'
      }, {
        en: 'GetCapabilities',
        ti: '.OperationType'
      }, {
        en: 'Request',
        ti: '.Request'
      }, {
        en: 'MinScaleDenominator',
        ti: 'Double'
      }, {
        en: 'GetMap',
        ti: '.OperationType'
      }, {
        en: 'MetadataURL',
        ti: '.MetadataURL'
      }, {
        en: 'Capability',
        ti: '.Capability'
      }, {
        en: 'GetFeatureInfo',
        ti: '.OperationType'
      }, {
        en: 'ContactVoiceTelephone'
      }, {
        en: 'Layer',
        ti: '.Layer'
      }, {
        en: 'MaxHeight',
        ti: 'PositiveInteger'
      }, {
        en: 'Name'
      }, {
        en: 'BoundingBox',
        ti: '.BoundingBox'
      }, {
        en: 'Style',
        ti: '.Style'
      }, {
        en: 'OtherExtendedOperation',
        ti: '.OperationType',
        sh: '_ExtendedOperation'
      }, {
        en: 'OnlineResource',
        ti: '.OnlineResource'
      }, {
        en: 'Exception',
        ti: '.Exception'
      }, {
        en: 'HTTP',
        ti: '.HTTP'
      }, {
        en: 'Service',
        ti: '.Service'
      }, {
        en: 'OtherExtendedCapabilities',
        ti: 'AnyType',
        sh: '_ExtendedCapabilities'
      }, {
        en: 'LegendURL',
        ti: '.LegendURL'
      }, {
        en: 'LogoURL',
        ti: '.LogoURL'
      }, {
        en: 'Format'
      }, {
        en: 'ContactElectronicMailAddress'
      }, {
        en: 'ContactPosition'
      }, {
        en: 'ContactOrganization'
      }, {
        en: 'StateOrProvince'
      }, {
        en: 'PostCode'
      }, {
        en: 'Title'
      }, {
        en: 'KeywordList',
        ti: '.KeywordList'
      }, {
        en: 'Country'
      }, {
        en: '_ExtendedOperation',
        ti: '.OperationType'
      }, {
        en: 'ContactAddress',
        ti: '.ContactAddress'
      }, {
        en: 'Get',
        ti: '.Get'
      }, {
        en: '_ExtendedCapabilities',
        ti: 'AnyType'
      }, {
        en: 'StyleURL',
        ti: '.StyleURL'
      }, {
        en: 'Abstract'
      }, {
        en: 'LayerLimit',
        ti: 'PositiveInteger'
      }, {
        en: 'WMS_Capabilities',
        ti: '.WMSCapabilities'
      }, {
        en: 'ContactFacsimileTelephone'
      }, {
        en: 'MaxScaleDenominator',
        ti: 'Double'
      }, {
        en: 'Identifier',
        ti: '.Identifier'
      }, {
        en: 'AddressType'
      }, {
        en: 'Keyword',
        ti: '.Keyword'
      }, {
        en: 'ContactPerson'
      }, {
        en: 'ContactInformation',
        ti: '.ContactInformation'
      }, {
        en: 'CRS'
      }, {
        en: 'Post',
        ti: '.Post'
      }]
  };
  return {
    WMS_1_3_0: WMS_1_3_0
  };
};
if (typeof define === 'function' && define.amd) {
  define([], WMS_1_3_0_Module_Factory);
}
else {
  var WMS_1_3_0_Module = WMS_1_3_0_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.WMS_1_3_0 = WMS_1_3_0_Module.WMS_1_3_0;
  }
  else {
    var WMS_1_3_0 = WMS_1_3_0_Module.WMS_1_3_0;
  }
}
},{}],15:[function(require,module,exports){
var WMS_1_3_0_Exceptions_Module_Factory = function () {
  var WMS_1_3_0_Exceptions = {
    n: 'WMS_1_3_0_Exceptions',
    dens: 'http:\/\/www.opengis.net\/ogc',
    tis: [{
        ln: 'ServiceExceptionType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'code',
            an: {
              lp: 'code'
            },
            t: 'a'
          }, {
            n: 'locator',
            an: {
              lp: 'locator'
            },
            t: 'a'
          }]
      }, {
        ln: 'ServiceExceptionReport',
        tn: null,
        ps: [{
            n: 'serviceException',
            mno: 0,
            col: true,
            en: 'ServiceException',
            ti: '.ServiceExceptionType'
          }, {
            n: 'version',
            an: {
              lp: 'version'
            },
            t: 'a'
          }]
      }],
    eis: [{
        en: 'ServiceExceptionReport',
        ti: '.ServiceExceptionReport'
      }]
  };
  return {
    WMS_1_3_0_Exceptions: WMS_1_3_0_Exceptions
  };
};
if (typeof define === 'function' && define.amd) {
  define([], WMS_1_3_0_Exceptions_Module_Factory);
}
else {
  var WMS_1_3_0_Exceptions_Module = WMS_1_3_0_Exceptions_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.WMS_1_3_0_Exceptions = WMS_1_3_0_Exceptions_Module.WMS_1_3_0_Exceptions;
  }
  else {
    var WMS_1_3_0_Exceptions = WMS_1_3_0_Exceptions_Module.WMS_1_3_0_Exceptions;
  }
}
},{}],16:[function(require,module,exports){
var WPS_1_0_0_Module_Factory = function () {
  var WPS_1_0_0 = {
    n: 'WPS_1_0_0',
    dens: 'http:\/\/www.opengis.net\/wps\/1.0.0',
    deps: ['OWS_1_1_0'],
    tis: [{
        ln: 'InputDescriptionType',
        bti: '.DescriptionType',
        ps: [{
            n: 'complexData',
            rq: true,
            en: {
              lp: 'ComplexData'
            },
            ti: '.SupportedComplexDataInputType'
          }, {
            n: 'literalData',
            rq: true,
            en: {
              lp: 'LiteralData'
            },
            ti: '.LiteralInputType'
          }, {
            n: 'boundingBoxData',
            rq: true,
            en: {
              lp: 'BoundingBoxData'
            },
            ti: '.SupportedCRSsType'
          }, {
            n: 'minOccurs',
            rq: true,
            ti: 'NonNegativeInteger',
            an: {
              lp: 'minOccurs'
            },
            t: 'a'
          }, {
            n: 'maxOccurs',
            rq: true,
            ti: 'PositiveInteger',
            an: {
              lp: 'maxOccurs'
            },
            t: 'a'
          }]
      }, {
        ln: 'LiteralDataType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'dataType',
            an: {
              lp: 'dataType'
            },
            t: 'a'
          }, {
            n: 'uom',
            an: {
              lp: 'uom'
            },
            t: 'a'
          }]
      }, {
        ln: 'LiteralInputType',
        bti: '.LiteralOutputType',
        ps: [{
            n: 'allowedValues',
            rq: true,
            en: {
              lp: 'AllowedValues',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.AllowedValues'
          }, {
            n: 'anyValue',
            rq: true,
            en: {
              lp: 'AnyValue',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.AnyValue'
          }, {
            n: 'valuesReference',
            rq: true,
            en: {
              lp: 'ValuesReference'
            },
            ti: '.ValuesReferenceType'
          }, {
            n: 'defaultValue',
            en: {
              lp: 'DefaultValue'
            }
          }]
      }, {
        ln: 'SupportedUOMsType.Default',
        tn: null,
        ps: [{
            n: 'uom',
            rq: true,
            en: {
              lp: 'UOM',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.DomainMetadataType'
          }]
      }, {
        ln: 'ValuesReferenceType',
        ps: [{
            n: 'reference',
            an: {
              lp: 'reference',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            t: 'a'
          }, {
            n: 'valuesForm',
            an: {
              lp: 'valuesForm'
            },
            t: 'a'
          }]
      }, {
        ln: 'StatusType',
        ps: [{
            n: 'processAccepted',
            rq: true,
            en: 'ProcessAccepted'
          }, {
            n: 'processStarted',
            rq: true,
            en: 'ProcessStarted',
            ti: '.ProcessStartedType'
          }, {
            n: 'processPaused',
            rq: true,
            en: 'ProcessPaused',
            ti: '.ProcessStartedType'
          }, {
            n: 'processSucceeded',
            rq: true,
            en: 'ProcessSucceeded'
          }, {
            n: 'processFailed',
            rq: true,
            en: 'ProcessFailed',
            ti: '.ProcessFailedType'
          }, {
            n: 'creationTime',
            rq: true,
            ti: 'DateTime',
            an: {
              lp: 'creationTime'
            },
            t: 'a'
          }]
      }, {
        ln: 'ExecuteResponse.ProcessOutputs',
        tn: null,
        ps: [{
            n: 'output',
            rq: true,
            col: true,
            en: 'Output',
            ti: '.OutputDataType'
          }]
      }, {
        ln: 'InputReferenceType.Header',
        tn: null,
        ps: [{
            n: 'key',
            rq: true,
            an: {
              lp: 'key'
            },
            t: 'a'
          }, {
            n: 'value',
            rq: true,
            an: {
              lp: 'value'
            },
            t: 'a'
          }]
      }, {
        ln: 'ResponseBaseType',
        ps: [{
            n: 'service',
            rq: true,
            an: {
              lp: 'service'
            },
            t: 'a'
          }, {
            n: 'version',
            rq: true,
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'lang',
            rq: true,
            an: {
              lp: 'lang',
              ns: 'http:\/\/www.w3.org\/XML\/1998\/namespace'
            },
            t: 'a'
          }]
      }, {
        ln: 'SupportedComplexDataInputType',
        bti: '.SupportedComplexDataType',
        ps: [{
            n: 'maximumMegabytes',
            ti: 'Integer',
            an: {
              lp: 'maximumMegabytes'
            },
            t: 'a'
          }]
      }, {
        ln: 'OutputReferenceType',
        ps: [{
            n: 'href',
            rq: true,
            an: {
              lp: 'href'
            },
            t: 'a'
          }, {
            n: 'mimeType',
            an: {
              lp: 'mimeType'
            },
            t: 'a'
          }, {
            n: 'encoding',
            an: {
              lp: 'encoding'
            },
            t: 'a'
          }, {
            n: 'schema',
            an: {
              lp: 'schema'
            },
            t: 'a'
          }]
      }, {
        ln: 'DescriptionType',
        ps: [{
            n: 'identifier',
            rq: true,
            en: {
              lp: 'Identifier',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.CodeType'
          }, {
            n: 'title',
            rq: true,
            en: {
              lp: 'Title',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.LanguageStringType'
          }, {
            n: '_abstract',
            en: {
              lp: 'Abstract',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.LanguageStringType'
          }, {
            n: 'metadata',
            mno: 0,
            col: true,
            en: {
              lp: 'Metadata',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.MetadataType'
          }]
      }, {
        ln: 'Execute',
        tn: null,
        bti: '.RequestBaseType',
        ps: [{
            n: 'identifier',
            rq: true,
            en: {
              lp: 'Identifier',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.CodeType'
          }, {
            n: 'dataInputs',
            en: 'DataInputs',
            ti: '.DataInputsType'
          }, {
            n: 'responseForm',
            en: 'ResponseForm',
            ti: '.ResponseFormType'
          }]
      }, {
        ln: 'ResponseDocumentType',
        ps: [{
            n: 'output',
            rq: true,
            col: true,
            en: 'Output',
            ti: '.DocumentOutputDefinitionType'
          }, {
            n: 'storeExecuteResponse',
            ti: 'Boolean',
            an: {
              lp: 'storeExecuteResponse'
            },
            t: 'a'
          }, {
            n: 'lineage',
            ti: 'Boolean',
            an: {
              lp: 'lineage'
            },
            t: 'a'
          }, {
            n: 'status',
            ti: 'Boolean',
            an: {
              lp: 'status'
            },
            t: 'a'
          }]
      }, {
        ln: 'LanguagesType',
        ps: [{
            n: 'language',
            rq: true,
            col: true,
            en: {
              lp: 'Language',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'Language'
          }]
      }, {
        ln: 'DocumentOutputDefinitionType',
        bti: '.OutputDefinitionType',
        ps: [{
            n: 'title',
            en: {
              lp: 'Title',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.LanguageStringType'
          }, {
            n: '_abstract',
            en: {
              lp: 'Abstract',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.LanguageStringType'
          }, {
            n: 'asReference',
            ti: 'Boolean',
            an: {
              lp: 'asReference'
            },
            t: 'a'
          }]
      }, {
        ln: 'WPSCapabilitiesType',
        bti: 'OWS_1_1_0.CapabilitiesBaseType',
        ps: [{
            n: 'processOfferings',
            rq: true,
            en: 'ProcessOfferings',
            ti: '.ProcessOfferings'
          }, {
            n: 'languages',
            rq: true,
            en: 'Languages',
            ti: '.Languages'
          }, {
            n: 'wsdl',
            en: 'WSDL',
            ti: '.WSDL'
          }, {
            n: 'service',
            rq: true,
            ti: 'AnySimpleType',
            an: {
              lp: 'service'
            },
            t: 'a'
          }, {
            n: 'lang',
            rq: true,
            an: {
              lp: 'lang',
              ns: 'http:\/\/www.w3.org\/XML\/1998\/namespace'
            },
            t: 'a'
          }]
      }, {
        ln: 'OutputDescriptionType',
        bti: '.DescriptionType',
        ps: [{
            n: 'complexOutput',
            rq: true,
            en: {
              lp: 'ComplexOutput'
            },
            ti: '.SupportedComplexDataType'
          }, {
            n: 'literalOutput',
            rq: true,
            en: {
              lp: 'LiteralOutput'
            },
            ti: '.LiteralOutputType'
          }, {
            n: 'boundingBoxOutput',
            rq: true,
            en: {
              lp: 'BoundingBoxOutput'
            },
            ti: '.SupportedCRSsType'
          }]
      }, {
        ln: 'SupportedComplexDataType',
        ps: [{
            n: '_default',
            rq: true,
            en: {
              lp: 'Default'
            },
            ti: '.ComplexDataCombinationType'
          }, {
            n: 'supported',
            rq: true,
            en: {
              lp: 'Supported'
            },
            ti: '.ComplexDataCombinationsType'
          }]
      }, {
        ln: 'InputReferenceType',
        ps: [{
            n: 'header',
            mno: 0,
            col: true,
            en: 'Header',
            ti: '.InputReferenceType.Header'
          }, {
            n: 'body',
            rq: true,
            en: 'Body',
            ti: 'AnyType'
          }, {
            n: 'bodyReference',
            rq: true,
            en: 'BodyReference',
            ti: '.InputReferenceType.BodyReference'
          }, {
            n: 'href',
            rq: true,
            an: {
              lp: 'href',
              ns: 'http:\/\/www.w3.org\/1999\/xlink'
            },
            t: 'a'
          }, {
            n: 'method',
            an: {
              lp: 'method'
            },
            t: 'a'
          }, {
            n: 'mimeType',
            an: {
              lp: 'mimeType'
            },
            t: 'a'
          }, {
            n: 'encoding',
            an: {
              lp: 'encoding'
            },
            t: 'a'
          }, {
            n: 'schema',
            an: {
              lp: 'schema'
            },
            t: 'a'
          }]
      }, {
        ln: 'ProcessDescriptions',
        tn: null,
        bti: '.ResponseBaseType',
        ps: [{
            n: 'processDescription',
            rq: true,
            col: true,
            en: {
              lp: 'ProcessDescription'
            },
            ti: '.ProcessDescriptionType'
          }]
      }, {
        ln: 'ProcessDescriptionType',
        bti: '.ProcessBriefType',
        ps: [{
            n: 'dataInputs',
            en: {
              lp: 'DataInputs'
            },
            ti: '.ProcessDescriptionType.DataInputs'
          }, {
            n: 'processOutputs',
            rq: true,
            en: {
              lp: 'ProcessOutputs'
            },
            ti: '.ProcessDescriptionType.ProcessOutputs'
          }, {
            n: 'storeSupported',
            ti: 'Boolean',
            an: {
              lp: 'storeSupported'
            },
            t: 'a'
          }, {
            n: 'statusSupported',
            ti: 'Boolean',
            an: {
              lp: 'statusSupported'
            },
            t: 'a'
          }]
      }, {
        ln: 'Languages',
        tn: null,
        ps: [{
            n: '_default',
            rq: true,
            en: 'Default',
            ti: '.Languages.Default'
          }, {
            n: 'supported',
            rq: true,
            en: 'Supported',
            ti: '.LanguagesType'
          }]
      }, {
        ln: 'ComplexDataDescriptionType',
        ps: [{
            n: 'mimeType',
            rq: true,
            en: {
              lp: 'MimeType'
            }
          }, {
            n: 'encoding',
            en: {
              lp: 'Encoding'
            }
          }, {
            n: 'schema',
            en: {
              lp: 'Schema'
            }
          }]
      }, {
        ln: 'InputType',
        ps: [{
            n: 'identifier',
            rq: true,
            en: {
              lp: 'Identifier',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.CodeType'
          }, {
            n: 'title',
            en: {
              lp: 'Title',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.LanguageStringType'
          }, {
            n: '_abstract',
            en: {
              lp: 'Abstract',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.LanguageStringType'
          }, {
            n: 'reference',
            rq: true,
            en: 'Reference',
            ti: '.InputReferenceType'
          }, {
            n: 'data',
            rq: true,
            en: 'Data',
            ti: '.DataType'
          }]
      }, {
        ln: 'ResponseFormType',
        ps: [{
            n: 'responseDocument',
            rq: true,
            en: 'ResponseDocument',
            ti: '.ResponseDocumentType'
          }, {
            n: 'rawDataOutput',
            rq: true,
            en: 'RawDataOutput',
            ti: '.OutputDefinitionType'
          }]
      }, {
        ln: 'CRSsType',
        ps: [{
            n: 'crs',
            rq: true,
            col: true,
            en: {
              lp: 'CRS'
            }
          }]
      }, {
        ln: 'UOMsType',
        ps: [{
            n: 'uom',
            rq: true,
            col: true,
            en: {
              lp: 'UOM',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.DomainMetadataType'
          }]
      }, {
        ln: 'ProcessStartedType',
        ps: [{
            n: 'value',
            t: 'v'
          }, {
            n: 'percentCompleted',
            ti: 'Int',
            an: {
              lp: 'percentCompleted'
            },
            t: 'a'
          }]
      }, {
        ln: 'ProcessBriefType',
        bti: '.DescriptionType',
        ps: [{
            n: 'profile',
            mno: 0,
            col: true,
            en: 'Profile'
          }, {
            n: 'wsdl',
            en: 'WSDL',
            ti: '.WSDL'
          }, {
            n: 'processVersion',
            rq: true,
            an: {
              lp: 'processVersion',
              ns: 'http:\/\/www.opengis.net\/wps\/1.0.0'
            },
            t: 'a'
          }]
      }, {
        ln: 'ExecuteResponse',
        tn: null,
        bti: '.ResponseBaseType',
        ps: [{
            n: 'process',
            rq: true,
            en: 'Process',
            ti: '.ProcessBriefType'
          }, {
            n: 'status',
            rq: true,
            en: 'Status',
            ti: '.StatusType'
          }, {
            n: 'dataInputs',
            en: 'DataInputs',
            ti: '.DataInputsType'
          }, {
            n: 'outputDefinitions',
            en: 'OutputDefinitions',
            ti: '.OutputDefinitionsType'
          }, {
            n: 'processOutputs',
            en: 'ProcessOutputs',
            ti: '.ExecuteResponse.ProcessOutputs'
          }, {
            n: 'serviceInstance',
            rq: true,
            an: {
              lp: 'serviceInstance'
            },
            t: 'a'
          }, {
            n: 'statusLocation',
            an: {
              lp: 'statusLocation'
            },
            t: 'a'
          }]
      }, {
        ln: 'LiteralOutputType',
        ps: [{
            n: 'dataType',
            en: {
              lp: 'DataType',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.DomainMetadataType'
          }, {
            n: 'uoMs',
            en: {
              lp: 'UOMs'
            },
            ti: '.SupportedUOMsType'
          }]
      }, {
        ln: 'SupportedCRSsType',
        ps: [{
            n: '_default',
            rq: true,
            en: {
              lp: 'Default'
            },
            ti: '.SupportedCRSsType.Default'
          }, {
            n: 'supported',
            rq: true,
            en: {
              lp: 'Supported'
            },
            ti: '.CRSsType'
          }]
      }, {
        ln: 'GetCapabilities',
        tn: null,
        ps: [{
            n: 'acceptVersions',
            en: 'AcceptVersions',
            ti: 'OWS_1_1_0.AcceptVersionsType'
          }, {
            n: 'service',
            rq: true,
            an: {
              lp: 'service'
            },
            t: 'a'
          }, {
            n: 'language',
            an: {
              lp: 'language'
            },
            t: 'a'
          }]
      }, {
        ln: 'SupportedCRSsType.Default',
        tn: null,
        ps: [{
            n: 'crs',
            rq: true,
            en: {
              lp: 'CRS'
            }
          }]
      }, {
        ln: 'OutputDefinitionsType',
        ps: [{
            n: 'output',
            rq: true,
            col: true,
            en: 'Output',
            ti: '.DocumentOutputDefinitionType'
          }]
      }, {
        ln: 'Languages.Default',
        tn: null,
        ps: [{
            n: 'language',
            rq: true,
            en: {
              lp: 'Language',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'Language'
          }]
      }, {
        ln: 'ProcessDescriptionType.DataInputs',
        tn: null,
        ps: [{
            n: 'input',
            rq: true,
            col: true,
            en: {
              lp: 'Input'
            },
            ti: '.InputDescriptionType'
          }]
      }, {
        ln: 'ProcessDescriptionType.ProcessOutputs',
        tn: null,
        ps: [{
            n: 'output',
            rq: true,
            col: true,
            en: {
              lp: 'Output'
            },
            ti: '.OutputDescriptionType'
          }]
      }, {
        ln: 'ComplexDataType',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'content',
            col: true,
            t: 'ae'
          }, {
            n: 'mimeType',
            an: {
              lp: 'mimeType'
            },
            t: 'a'
          }, {
            n: 'encoding',
            an: {
              lp: 'encoding'
            },
            t: 'a'
          }, {
            n: 'schema',
            an: {
              lp: 'schema'
            },
            t: 'a'
          }]
      }, {
        ln: 'DataType',
        ps: [{
            n: 'complexData',
            rq: true,
            en: 'ComplexData',
            ti: '.ComplexDataType'
          }, {
            n: 'literalData',
            rq: true,
            en: 'LiteralData',
            ti: '.LiteralDataType'
          }, {
            n: 'boundingBoxData',
            rq: true,
            en: 'BoundingBoxData',
            ti: 'OWS_1_1_0.BoundingBoxType'
          }]
      }, {
        ln: 'WSDL',
        tn: null,
        ps: [{
            n: 'href',
            rq: true,
            an: {
              lp: 'href',
              ns: 'http:\/\/www.w3.org\/1999\/xlink'
            },
            t: 'a'
          }]
      }, {
        ln: 'InputReferenceType.BodyReference',
        tn: null,
        ps: [{
            n: 'href',
            rq: true,
            an: {
              lp: 'href',
              ns: 'http:\/\/www.w3.org\/1999\/xlink'
            },
            t: 'a'
          }]
      }, {
        ln: 'DataInputsType',
        ps: [{
            n: 'input',
            rq: true,
            col: true,
            en: 'Input',
            ti: '.InputType'
          }]
      }, {
        ln: 'ComplexDataCombinationsType',
        ps: [{
            n: 'format',
            rq: true,
            col: true,
            en: {
              lp: 'Format'
            },
            ti: '.ComplexDataDescriptionType'
          }]
      }, {
        ln: 'DescribeProcess',
        tn: null,
        bti: '.RequestBaseType',
        ps: [{
            n: 'identifier',
            rq: true,
            col: true,
            en: {
              lp: 'Identifier',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.CodeType'
          }]
      }, {
        ln: 'OutputDataType',
        bti: '.DescriptionType',
        ps: [{
            n: 'reference',
            rq: true,
            en: 'Reference',
            ti: '.OutputReferenceType'
          }, {
            n: 'data',
            rq: true,
            en: 'Data',
            ti: '.DataType'
          }]
      }, {
        ln: 'ProcessFailedType',
        ps: [{
            n: 'exceptionReport',
            rq: true,
            en: {
              lp: 'ExceptionReport',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.ExceptionReport'
          }]
      }, {
        ln: 'ComplexDataCombinationType',
        ps: [{
            n: 'format',
            rq: true,
            en: {
              lp: 'Format'
            },
            ti: '.ComplexDataDescriptionType'
          }]
      }, {
        ln: 'ProcessOfferings',
        tn: null,
        ps: [{
            n: 'process',
            rq: true,
            col: true,
            en: 'Process',
            ti: '.ProcessBriefType'
          }]
      }, {
        ln: 'SupportedUOMsType',
        ps: [{
            n: '_default',
            rq: true,
            en: {
              lp: 'Default'
            },
            ti: '.SupportedUOMsType.Default'
          }, {
            n: 'supported',
            rq: true,
            en: {
              lp: 'Supported'
            },
            ti: '.UOMsType'
          }]
      }, {
        ln: 'RequestBaseType',
        ps: [{
            n: 'service',
            rq: true,
            an: {
              lp: 'service'
            },
            t: 'a'
          }, {
            n: 'version',
            rq: true,
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'language',
            an: {
              lp: 'language'
            },
            t: 'a'
          }]
      }, {
        ln: 'OutputDefinitionType',
        ps: [{
            n: 'identifier',
            rq: true,
            en: {
              lp: 'Identifier',
              ns: 'http:\/\/www.opengis.net\/ows\/1.1'
            },
            ti: 'OWS_1_1_0.CodeType'
          }, {
            n: 'uom',
            an: {
              lp: 'uom'
            },
            t: 'a'
          }, {
            n: 'mimeType',
            an: {
              lp: 'mimeType'
            },
            t: 'a'
          }, {
            n: 'encoding',
            an: {
              lp: 'encoding'
            },
            t: 'a'
          }, {
            n: 'schema',
            an: {
              lp: 'schema'
            },
            t: 'a'
          }]
      }],
    eis: [{
        en: 'ProcessOfferings',
        ti: '.ProcessOfferings'
      }, {
        en: 'Capabilities',
        ti: '.WPSCapabilitiesType'
      }, {
        en: 'Execute',
        ti: '.Execute'
      }, {
        en: 'WSDL',
        ti: '.WSDL'
      }, {
        en: 'ProcessDescriptions',
        ti: '.ProcessDescriptions'
      }, {
        en: 'ExecuteResponse',
        ti: '.ExecuteResponse'
      }, {
        en: 'DescribeProcess',
        ti: '.DescribeProcess'
      }, {
        en: 'GetCapabilities',
        ti: '.GetCapabilities'
      }, {
        en: 'Languages',
        ti: '.Languages'
      }]
  };
  return {
    WPS_1_0_0: WPS_1_0_0
  };
};
if (typeof define === 'function' && define.amd) {
  define([], WPS_1_0_0_Module_Factory);
}
else {
  var WPS_1_0_0_Module = WPS_1_0_0_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.WPS_1_0_0 = WPS_1_0_0_Module.WPS_1_0_0;
  }
  else {
    var WPS_1_0_0 = WPS_1_0_0_Module.WPS_1_0_0;
  }
}
},{}],17:[function(require,module,exports){
var XLink_1_0_Module_Factory = function () {
  var XLink_1_0 = {
    n: 'XLink_1_0',
    dens: 'http:\/\/www.w3.org\/1999\/xlink',
    dans: 'http:\/\/www.w3.org\/1999\/xlink',
    tis: [{
        ln: 'Simple',
        tn: 'simple',
        ps: [{
            n: 'content',
            col: true,
            t: 'ae'
          }, {
            n: 'type',
            ti: 'Token',
            t: 'a'
          }, {
            n: 'href',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'Token',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'Token',
            t: 'a'
          }]
      }, {
        ln: 'ArcType',
        tn: 'arcType',
        ps: [{
            n: 'locatorTitle',
            mno: 0,
            col: true,
            en: 'title',
            ti: '.TitleEltType'
          }, {
            n: 'type',
            rq: true,
            ti: 'Token',
            t: 'a'
          }, {
            n: 'arcrole',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'show',
            ti: 'Token',
            t: 'a'
          }, {
            n: 'actuate',
            ti: 'Token',
            t: 'a'
          }, {
            n: 'from',
            ti: 'NCName',
            t: 'a'
          }, {
            n: 'to',
            ti: 'NCName',
            t: 'a'
          }]
      }, {
        ln: 'TitleEltType',
        tn: 'titleEltType',
        ps: [{
            n: 'content',
            col: true,
            t: 'ae'
          }, {
            n: 'type',
            rq: true,
            ti: 'Token',
            t: 'a'
          }, {
            n: 'lang',
            an: {
              lp: 'lang',
              ns: 'http:\/\/www.w3.org\/XML\/1998\/namespace'
            },
            t: 'a'
          }]
      }, {
        ln: 'ResourceType',
        tn: 'resourceType',
        ps: [{
            n: 'content',
            col: true,
            t: 'ae'
          }, {
            n: 'type',
            rq: true,
            ti: 'Token',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'label',
            ti: 'NCName',
            t: 'a'
          }]
      }, {
        ln: 'LocatorType',
        tn: 'locatorType',
        ps: [{
            n: 'locatorTitle',
            mno: 0,
            col: true,
            en: 'title',
            ti: '.TitleEltType'
          }, {
            n: 'type',
            rq: true,
            ti: 'Token',
            t: 'a'
          }, {
            n: 'href',
            rq: true,
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }, {
            n: 'label',
            ti: 'NCName',
            t: 'a'
          }]
      }, {
        ln: 'Extended',
        tn: 'extended',
        ps: [{
            n: 'extendedModel',
            mno: 0,
            col: true,
            etis: [{
                en: 'title',
                ti: '.TitleEltType'
              }, {
                en: 'resource',
                ti: '.ResourceType'
              }, {
                en: 'locator',
                ti: '.LocatorType'
              }, {
                en: 'arc',
                ti: '.ArcType'
              }],
            t: 'es'
          }, {
            n: 'type',
            rq: true,
            ti: 'Token',
            t: 'a'
          }, {
            n: 'role',
            t: 'a'
          }, {
            n: 'title',
            t: 'a'
          }]
      }, {
        t: 'enum',
        ln: 'ActuateType',
        bti: 'Token',
        vs: ['onLoad', 'onRequest', 'other', 'none']
      }, {
        t: 'enum',
        ln: 'ShowType',
        bti: 'Token',
        vs: ['new', 'replace', 'embed', 'other', 'none']
      }, {
        t: 'enum',
        ln: 'TypeType',
        bti: 'Token',
        vs: ['simple', 'extended', 'title', 'resource', 'locator', 'arc']
      }],
    eis: [{
        en: 'locator',
        ti: '.LocatorType'
      }, {
        en: 'title',
        ti: '.TitleEltType'
      }, {
        en: 'arc',
        ti: '.ArcType'
      }, {
        en: 'resource',
        ti: '.ResourceType'
      }]
  };
  return {
    XLink_1_0: XLink_1_0
  };
};
if (typeof define === 'function' && define.amd) {
  define([], XLink_1_0_Module_Factory);
}
else {
  var XLink_1_0_Module = XLink_1_0_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.XLink_1_0 = XLink_1_0_Module.XLink_1_0;
  }
  else {
    var XLink_1_0 = XLink_1_0_Module.XLink_1_0;
  }
}
},{}],18:[function(require,module,exports){
var XSD_1_0_Module_Factory = function () {
  var XSD_1_0 = {
    n: 'XSD_1_0',
    dens: 'http:\/\/www.w3.org\/2001\/XMLSchema',
    tis: [{
        ln: 'Annotation',
        tn: null,
        bti: '.OpenAttrs',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'appinfo',
            mno: 0,
            col: true,
            ti: '.Appinfo'
          }, {
            n: 'documentation',
            mno: 0,
            col: true,
            ti: '.Documentation'
          }, {
            n: 'id',
            ti: 'ID',
            an: {
              lp: 'id'
            },
            t: 'a'
          }]
      }, {
        ln: 'Union',
        tn: null,
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'simpleType',
            mno: 0,
            col: true,
            ti: '.LocalSimpleType'
          }, {
            n: 'memberTypes',
            ti: {
              t: 'l',
              bti: 'QName'
            },
            an: {
              lp: 'memberTypes'
            },
            t: 'a'
          }]
      }, {
        ln: 'Redefine',
        tn: null,
        bti: '.OpenAttrs',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'annotation',
            mno: 0,
            col: true,
            ti: '.Annotation'
          }, {
            n: 'simpleType',
            mno: 0,
            col: true,
            ti: '.TopLevelSimpleType'
          }, {
            n: 'complexType',
            mno: 0,
            col: true,
            ti: '.TopLevelComplexType'
          }, {
            n: 'group',
            mno: 0,
            col: true,
            ti: '.NamedGroup'
          }, {
            n: 'attributeGroup',
            mno: 0,
            col: true,
            ti: '.NamedAttributeGroup'
          }, {
            n: 'schemaLocation',
            rq: true,
            an: {
              lp: 'schemaLocation'
            },
            t: 'a'
          }, {
            n: 'id',
            ti: 'ID',
            an: {
              lp: 'id'
            },
            t: 'a'
          }]
      }, {
        ln: 'ComplexRestrictionType',
        tn: 'complexRestrictionType',
        bti: '.RestrictionType'
      }, {
        ln: 'NarrowMaxMin',
        tn: 'narrowMaxMin',
        bti: '.LocalElement'
      }, {
        ln: 'Notation',
        tn: null,
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'name',
            rq: true,
            ti: 'NCName',
            an: {
              lp: 'name'
            },
            t: 'a'
          }, {
            n: '_public',
            ti: 'Token',
            an: {
              lp: 'public'
            },
            t: 'a'
          }, {
            n: 'system',
            an: {
              lp: 'system'
            },
            t: 'a'
          }]
      }, {
        ln: 'Annotated',
        tn: 'annotated',
        bti: '.OpenAttrs',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'annotation',
            ti: '.Annotation'
          }, {
            n: 'id',
            ti: 'ID',
            an: {
              lp: 'id'
            },
            t: 'a'
          }]
      }, {
        ln: 'Selector',
        tn: null,
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'xpath',
            rq: true,
            an: {
              lp: 'xpath'
            },
            t: 'a'
          }]
      }, {
        ln: 'SimpleType',
        tn: 'simpleType',
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'restriction',
            rq: true,
            ti: '.Restriction'
          }, {
            n: 'list',
            rq: true,
            ti: '.List'
          }, {
            n: 'union',
            rq: true,
            ti: '.Union'
          }, {
            n: '_final',
            ti: {
              t: 'l'
            },
            an: {
              lp: 'final'
            },
            t: 'a'
          }, {
            n: 'name',
            ti: 'NCName',
            an: {
              lp: 'name'
            },
            t: 'a'
          }]
      }, {
        ln: 'NamedAttributeGroup',
        tn: 'namedAttributeGroup',
        bti: '.AttributeGroup'
      }, {
        ln: 'Attribute',
        tn: 'attribute',
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'simpleType',
            ti: '.LocalSimpleType'
          }, {
            n: 'type',
            ti: 'QName',
            an: {
              lp: 'type'
            },
            t: 'a'
          }, {
            n: 'use',
            an: {
              lp: 'use'
            },
            t: 'a'
          }, {
            n: '_default',
            an: {
              lp: 'default'
            },
            t: 'a'
          }, {
            n: 'fixed',
            an: {
              lp: 'fixed'
            },
            t: 'a'
          }, {
            n: 'form',
            ti: 'NMToken',
            an: {
              lp: 'form'
            },
            t: 'a'
          }, {
            n: 'name',
            ti: 'NCName',
            an: {
              lp: 'name'
            },
            t: 'a'
          }, {
            n: 'ref',
            ti: 'QName',
            an: {
              lp: 'ref'
            },
            t: 'a'
          }]
      }, {
        ln: 'SimpleExplicitGroup',
        tn: 'simpleExplicitGroup',
        bti: '.ExplicitGroup'
      }, {
        ln: 'LocalComplexType',
        tn: 'localComplexType',
        bti: '.ComplexType'
      }, {
        ln: 'Appinfo',
        tn: null,
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'content',
            col: true,
            t: 'ae'
          }, {
            n: 'source',
            an: {
              lp: 'source'
            },
            t: 'a'
          }]
      }, {
        ln: 'RestrictionType',
        tn: 'restrictionType',
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'group',
            rq: true,
            ti: '.GroupRef'
          }, {
            n: 'all',
            rq: true,
            ti: '.All'
          }, {
            n: 'choice',
            rq: true,
            ti: '.ExplicitGroup'
          }, {
            n: 'sequence',
            rq: true,
            ti: '.ExplicitGroup'
          }, {
            n: 'simpleType',
            ti: '.LocalSimpleType'
          }, {
            n: 'whiteSpace',
            col: true,
            ti: '.WhiteSpace'
          }, {
            n: 'length',
            col: true,
            ti: '.NumFacet'
          }, {
            n: 'enumeration',
            col: true,
            ti: '.NoFixedFacet'
          }, {
            n: 'minExclusive',
            col: true,
            ti: '.Facet'
          }, {
            n: 'maxExclusive',
            col: true,
            ti: '.Facet'
          }, {
            n: 'maxLength',
            col: true,
            ti: '.NumFacet'
          }, {
            n: 'pattern',
            col: true,
            ti: '.Pattern'
          }, {
            n: 'minInclusive',
            col: true,
            ti: '.Facet'
          }, {
            n: 'minLength',
            col: true,
            ti: '.NumFacet'
          }, {
            n: 'fractionDigits',
            col: true,
            ti: '.NumFacet'
          }, {
            n: 'totalDigits',
            col: true,
            ti: '.TotalDigits'
          }, {
            n: 'maxInclusive',
            col: true,
            ti: '.Facet'
          }, {
            n: 'attribute',
            mno: 0,
            col: true,
            ti: '.Attribute'
          }, {
            n: 'attributeGroup',
            mno: 0,
            col: true,
            ti: '.AttributeGroupRef'
          }, {
            n: 'anyAttribute',
            ti: '.Wildcard'
          }, {
            n: 'base',
            rq: true,
            ti: 'QName',
            an: {
              lp: 'base'
            },
            t: 'a'
          }]
      }, {
        ln: 'Import',
        tn: null,
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'namespace',
            an: {
              lp: 'namespace'
            },
            t: 'a'
          }, {
            n: 'schemaLocation',
            an: {
              lp: 'schemaLocation'
            },
            t: 'a'
          }]
      }, {
        ln: 'List',
        tn: null,
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'simpleType',
            ti: '.LocalSimpleType'
          }, {
            n: 'itemType',
            ti: 'QName',
            an: {
              lp: 'itemType'
            },
            t: 'a'
          }]
      }, {
        ln: 'AttributeGroup',
        tn: 'attributeGroup',
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'attribute',
            mno: 0,
            col: true,
            ti: '.Attribute'
          }, {
            n: 'attributeGroup',
            mno: 0,
            col: true,
            ti: '.AttributeGroupRef'
          }, {
            n: 'anyAttribute',
            ti: '.Wildcard'
          }, {
            n: 'name',
            ti: 'NCName',
            an: {
              lp: 'name'
            },
            t: 'a'
          }, {
            n: 'ref',
            ti: 'QName',
            an: {
              lp: 'ref'
            },
            t: 'a'
          }]
      }, {
        ln: 'Pattern',
        tn: null,
        bti: '.NoFixedFacet'
      }, {
        ln: 'Element',
        tn: 'element',
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'simpleType',
            rq: true,
            ti: '.LocalSimpleType'
          }, {
            n: 'complexType',
            rq: true,
            ti: '.LocalComplexType'
          }, {
            n: 'unique',
            col: true,
            ti: '.Keybase'
          }, {
            n: 'key',
            col: true,
            ti: '.Keybase'
          }, {
            n: 'keyref',
            col: true,
            ti: '.Keyref'
          }, {
            n: 'type',
            ti: 'QName',
            an: {
              lp: 'type'
            },
            t: 'a'
          }, {
            n: 'substitutionGroup',
            ti: 'QName',
            an: {
              lp: 'substitutionGroup'
            },
            t: 'a'
          }, {
            n: '_default',
            an: {
              lp: 'default'
            },
            t: 'a'
          }, {
            n: 'fixed',
            an: {
              lp: 'fixed'
            },
            t: 'a'
          }, {
            n: 'nillable',
            ti: 'Boolean',
            an: {
              lp: 'nillable'
            },
            t: 'a'
          }, {
            n: '_abstract',
            ti: 'Boolean',
            an: {
              lp: 'abstract'
            },
            t: 'a'
          }, {
            n: '_final',
            ti: {
              t: 'l'
            },
            an: {
              lp: 'final'
            },
            t: 'a'
          }, {
            n: 'block',
            ti: {
              t: 'l'
            },
            an: {
              lp: 'block'
            },
            t: 'a'
          }, {
            n: 'form',
            ti: 'NMToken',
            an: {
              lp: 'form'
            },
            t: 'a'
          }, {
            n: 'name',
            ti: 'NCName',
            an: {
              lp: 'name'
            },
            t: 'a'
          }, {
            n: 'ref',
            ti: 'QName',
            an: {
              lp: 'ref'
            },
            t: 'a'
          }, {
            n: 'minOccurs',
            ti: 'NonNegativeInteger',
            an: {
              lp: 'minOccurs'
            },
            t: 'a'
          }, {
            n: 'maxOccurs',
            an: {
              lp: 'maxOccurs'
            },
            t: 'a'
          }]
      }, {
        ln: 'Keyref',
        tn: null,
        bti: '.Keybase',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'refer',
            rq: true,
            ti: 'QName',
            an: {
              lp: 'refer'
            },
            t: 'a'
          }]
      }, {
        ln: 'NamedGroup',
        tn: 'namedGroup',
        bti: '.RealGroup'
      }, {
        ln: 'LocalElement',
        tn: 'localElement',
        bti: '.Element'
      }, {
        ln: 'Schema',
        tn: null,
        bti: '.OpenAttrs',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'include',
            mno: 0,
            col: true,
            ti: '.Include'
          }, {
            n: '_import',
            mno: 0,
            col: true,
            en: 'import',
            ti: '.Import'
          }, {
            n: 'redefine',
            mno: 0,
            col: true,
            ti: '.Redefine'
          }, {
            n: 'simpleType',
            mno: 0,
            col: true,
            ti: '.TopLevelSimpleType'
          }, {
            n: 'complexType',
            mno: 0,
            col: true,
            ti: '.TopLevelComplexType'
          }, {
            n: 'group',
            mno: 0,
            col: true,
            ti: '.NamedGroup'
          }, {
            n: 'attributeGroup',
            mno: 0,
            col: true,
            ti: '.NamedAttributeGroup'
          }, {
            n: 'element',
            mno: 0,
            col: true,
            ti: '.TopLevelElement'
          }, {
            n: 'attribute',
            mno: 0,
            col: true,
            ti: '.TopLevelAttribute'
          }, {
            n: 'notation',
            mno: 0,
            col: true,
            ti: '.Notation'
          }, {
            n: 'annotation',
            mno: 0,
            col: true,
            ti: '.Annotation'
          }, {
            n: 'targetNamespace',
            an: {
              lp: 'targetNamespace'
            },
            t: 'a'
          }, {
            n: 'version',
            ti: 'Token',
            an: {
              lp: 'version'
            },
            t: 'a'
          }, {
            n: 'finalDefault',
            ti: {
              t: 'l'
            },
            an: {
              lp: 'finalDefault'
            },
            t: 'a'
          }, {
            n: 'blockDefault',
            ti: {
              t: 'l'
            },
            an: {
              lp: 'blockDefault'
            },
            t: 'a'
          }, {
            n: 'attributeFormDefault',
            ti: 'NMToken',
            an: {
              lp: 'attributeFormDefault'
            },
            t: 'a'
          }, {
            n: 'elementFormDefault',
            ti: 'NMToken',
            an: {
              lp: 'elementFormDefault'
            },
            t: 'a'
          }, {
            n: 'id',
            ti: 'ID',
            an: {
              lp: 'id'
            },
            t: 'a'
          }, {
            n: 'lang',
            an: {
              lp: 'lang',
              ns: 'http:\/\/www.w3.org\/XML\/1998\/namespace'
            },
            t: 'a'
          }]
      }, {
        ln: 'Documentation',
        tn: null,
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'content',
            col: true,
            t: 'ae'
          }, {
            n: 'source',
            an: {
              lp: 'source'
            },
            t: 'a'
          }, {
            n: 'lang',
            an: {
              lp: 'lang',
              ns: 'http:\/\/www.w3.org\/XML\/1998\/namespace'
            },
            t: 'a'
          }]
      }, {
        ln: 'Wildcard',
        tn: 'wildcard',
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'namespace',
            ti: {
              t: 'l'
            },
            an: {
              lp: 'namespace'
            },
            t: 'a'
          }, {
            n: 'processContents',
            an: {
              lp: 'processContents'
            },
            t: 'a'
          }]
      }, {
        ln: 'Facet',
        tn: 'facet',
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'value',
            rq: true,
            ti: 'AnySimpleType',
            an: {
              lp: 'value'
            },
            t: 'a'
          }, {
            n: 'fixed',
            ti: 'Boolean',
            an: {
              lp: 'fixed'
            },
            t: 'a'
          }]
      }, {
        ln: 'OpenAttrs',
        tn: 'openAttrs',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }]
      }, {
        ln: 'WhiteSpace',
        tn: null,
        bti: '.Facet'
      }, {
        ln: 'Group',
        tn: 'group',
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'choice',
            col: true,
            ti: '.ExplicitGroup'
          }, {
            n: 'all',
            col: true,
            ti: '.All'
          }, {
            n: 'element',
            col: true,
            ti: '.LocalElement'
          }, {
            n: 'sequence',
            col: true,
            ti: '.ExplicitGroup'
          }, {
            n: 'group',
            col: true,
            ti: '.GroupRef'
          }, {
            n: 'any',
            col: true,
            ti: '.Any'
          }, {
            n: 'name',
            ti: 'NCName',
            an: {
              lp: 'name'
            },
            t: 'a'
          }, {
            n: 'ref',
            ti: 'QName',
            an: {
              lp: 'ref'
            },
            t: 'a'
          }, {
            n: 'minOccurs',
            ti: 'NonNegativeInteger',
            an: {
              lp: 'minOccurs'
            },
            t: 'a'
          }, {
            n: 'maxOccurs',
            an: {
              lp: 'maxOccurs'
            },
            t: 'a'
          }]
      }, {
        ln: 'TopLevelComplexType',
        tn: 'topLevelComplexType',
        bti: '.ComplexType'
      }, {
        ln: 'NoFixedFacet',
        tn: 'noFixedFacet',
        bti: '.Facet'
      }, {
        ln: 'GroupRef',
        tn: 'groupRef',
        bti: '.RealGroup'
      }, {
        ln: 'LocalSimpleType',
        tn: 'localSimpleType',
        bti: '.SimpleType'
      }, {
        ln: 'SimpleExtensionType',
        tn: 'simpleExtensionType',
        bti: '.ExtensionType'
      }, {
        ln: 'Any',
        tn: null,
        bti: '.Wildcard',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'minOccurs',
            ti: 'NonNegativeInteger',
            an: {
              lp: 'minOccurs'
            },
            t: 'a'
          }, {
            n: 'maxOccurs',
            an: {
              lp: 'maxOccurs'
            },
            t: 'a'
          }]
      }, {
        ln: 'TotalDigits',
        tn: null,
        bti: '.NumFacet'
      }, {
        ln: 'ExtensionType',
        tn: 'extensionType',
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'group',
            rq: true,
            ti: '.GroupRef'
          }, {
            n: 'all',
            rq: true,
            ti: '.All'
          }, {
            n: 'choice',
            rq: true,
            ti: '.ExplicitGroup'
          }, {
            n: 'sequence',
            rq: true,
            ti: '.ExplicitGroup'
          }, {
            n: 'attribute',
            mno: 0,
            col: true,
            ti: '.Attribute'
          }, {
            n: 'attributeGroup',
            mno: 0,
            col: true,
            ti: '.AttributeGroupRef'
          }, {
            n: 'anyAttribute',
            ti: '.Wildcard'
          }, {
            n: 'base',
            rq: true,
            ti: 'QName',
            an: {
              lp: 'base'
            },
            t: 'a'
          }]
      }, {
        ln: 'ComplexContent',
        tn: null,
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'restriction',
            rq: true,
            ti: '.ComplexRestrictionType'
          }, {
            n: 'extension',
            rq: true,
            ti: '.ExtensionType'
          }, {
            n: 'mixed',
            ti: 'Boolean',
            an: {
              lp: 'mixed'
            },
            t: 'a'
          }]
      }, {
        ln: 'SimpleRestrictionType',
        tn: 'simpleRestrictionType',
        bti: '.RestrictionType'
      }, {
        ln: 'TopLevelElement',
        tn: 'topLevelElement',
        bti: '.Element'
      }, {
        ln: 'ExplicitGroup',
        tn: 'explicitGroup',
        bti: '.Group'
      }, {
        ln: 'Restriction',
        tn: null,
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'simpleType',
            ti: '.LocalSimpleType'
          }, {
            n: 'whiteSpace',
            col: true,
            ti: '.WhiteSpace'
          }, {
            n: 'length',
            col: true,
            ti: '.NumFacet'
          }, {
            n: 'enumeration',
            col: true,
            ti: '.NoFixedFacet'
          }, {
            n: 'minExclusive',
            col: true,
            ti: '.Facet'
          }, {
            n: 'maxExclusive',
            col: true,
            ti: '.Facet'
          }, {
            n: 'maxLength',
            col: true,
            ti: '.NumFacet'
          }, {
            n: 'pattern',
            col: true,
            ti: '.Pattern'
          }, {
            n: 'minInclusive',
            col: true,
            ti: '.Facet'
          }, {
            n: 'minLength',
            col: true,
            ti: '.NumFacet'
          }, {
            n: 'fractionDigits',
            col: true,
            ti: '.NumFacet'
          }, {
            n: 'totalDigits',
            col: true,
            ti: '.TotalDigits'
          }, {
            n: 'maxInclusive',
            col: true,
            ti: '.Facet'
          }, {
            n: 'base',
            ti: 'QName',
            an: {
              lp: 'base'
            },
            t: 'a'
          }]
      }, {
        ln: 'All',
        tn: 'all',
        bti: '.ExplicitGroup'
      }, {
        ln: 'Keybase',
        tn: 'keybase',
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'selector',
            rq: true,
            ti: '.Selector'
          }, {
            n: 'field',
            rq: true,
            col: true,
            ti: '.Field'
          }, {
            n: 'name',
            rq: true,
            ti: 'NCName',
            an: {
              lp: 'name'
            },
            t: 'a'
          }]
      }, {
        ln: 'AttributeGroupRef',
        tn: 'attributeGroupRef',
        bti: '.AttributeGroup'
      }, {
        ln: 'SimpleContent',
        tn: null,
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'restriction',
            rq: true,
            ti: '.SimpleRestrictionType'
          }, {
            n: 'extension',
            rq: true,
            ti: '.SimpleExtensionType'
          }]
      }, {
        ln: 'RealGroup',
        tn: 'realGroup',
        bti: '.Group'
      }, {
        ln: 'Include',
        tn: null,
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'schemaLocation',
            rq: true,
            an: {
              lp: 'schemaLocation'
            },
            t: 'a'
          }]
      }, {
        ln: 'Field',
        tn: null,
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'xpath',
            rq: true,
            an: {
              lp: 'xpath'
            },
            t: 'a'
          }]
      }, {
        ln: 'NumFacet',
        tn: 'numFacet',
        bti: '.Facet'
      }, {
        ln: 'ComplexType',
        tn: 'complexType',
        bti: '.Annotated',
        ps: [{
            n: 'otherAttributes',
            t: 'aa'
          }, {
            n: 'simpleContent',
            rq: true,
            ti: '.SimpleContent'
          }, {
            n: 'complexContent',
            rq: true,
            ti: '.ComplexContent'
          }, {
            n: 'group',
            rq: true,
            ti: '.GroupRef'
          }, {
            n: 'all',
            rq: true,
            ti: '.All'
          }, {
            n: 'choice',
            rq: true,
            ti: '.ExplicitGroup'
          }, {
            n: 'sequence',
            rq: true,
            ti: '.ExplicitGroup'
          }, {
            n: 'attribute',
            mno: 0,
            col: true,
            ti: '.Attribute'
          }, {
            n: 'attributeGroup',
            mno: 0,
            col: true,
            ti: '.AttributeGroupRef'
          }, {
            n: 'anyAttribute',
            ti: '.Wildcard'
          }, {
            n: 'name',
            ti: 'NCName',
            an: {
              lp: 'name'
            },
            t: 'a'
          }, {
            n: 'mixed',
            ti: 'Boolean',
            an: {
              lp: 'mixed'
            },
            t: 'a'
          }, {
            n: '_abstract',
            ti: 'Boolean',
            an: {
              lp: 'abstract'
            },
            t: 'a'
          }, {
            n: '_final',
            ti: {
              t: 'l'
            },
            an: {
              lp: 'final'
            },
            t: 'a'
          }, {
            n: 'block',
            ti: {
              t: 'l'
            },
            an: {
              lp: 'block'
            },
            t: 'a'
          }]
      }, {
        ln: 'TopLevelSimpleType',
        tn: 'topLevelSimpleType',
        bti: '.SimpleType'
      }, {
        ln: 'TopLevelAttribute',
        tn: 'topLevelAttribute',
        bti: '.Attribute'
      }, {
        t: 'enum',
        ln: 'TypeDerivationControl',
        bti: 'NMToken',
        vs: ['extension', 'restriction', 'list', 'union']
      }, {
        t: 'enum',
        ln: 'DerivationControl',
        bti: 'NMToken',
        vs: ['substitution', 'extension', 'restriction', 'list', 'union']
      }, {
        t: 'enum',
        ln: 'FormChoice',
        bti: 'NMToken',
        vs: ['qualified', 'unqualified']
      }, {
        t: 'enum',
        ln: 'ReducedDerivationControl',
        bti: 'NMToken',
        vs: ['extension', 'restriction']
      }],
    eis: [{
        en: 'union',
        ti: '.Union'
      }, {
        en: 'documentation',
        ti: '.Documentation'
      }, {
        en: 'simpleType',
        ti: '.TopLevelSimpleType'
      }, {
        en: 'appinfo',
        ti: '.Appinfo'
      }, {
        en: 'all',
        ti: '.All'
      }, {
        en: 'complexContent',
        ti: '.ComplexContent'
      }, {
        en: 'annotation',
        ti: '.Annotation'
      }, {
        en: 'totalDigits',
        ti: '.TotalDigits'
      }, {
        en: 'selector',
        ti: '.Selector'
      }, {
        en: 'complexType',
        ti: '.TopLevelComplexType'
      }, {
        en: 'length',
        ti: '.NumFacet'
      }, {
        en: 'attribute',
        ti: '.TopLevelAttribute'
      }, {
        en: 'enumeration',
        ti: '.NoFixedFacet'
      }, {
        en: 'group',
        ti: '.NamedGroup'
      }, {
        en: 'list',
        ti: '.List'
      }, {
        en: 'maxLength',
        ti: '.NumFacet'
      }, {
        en: 'minExclusive',
        ti: '.Facet'
      }, {
        en: 'unique',
        ti: '.Keybase'
      }, {
        en: 'attributeGroup',
        ti: '.NamedAttributeGroup'
      }, {
        en: 'group',
        ti: '.GroupRef',
        sc: '.Group'
      }, {
        en: 'redefine',
        ti: '.Redefine'
      }, {
        en: 'restriction',
        ti: '.Restriction'
      }, {
        en: 'simpleContent',
        ti: '.SimpleContent'
      }, {
        en: 'fractionDigits',
        ti: '.NumFacet'
      }, {
        en: 'choice',
        ti: '.ExplicitGroup'
      }, {
        en: 'schema',
        ti: '.Schema'
      }, {
        en: 'import',
        ti: '.Import'
      }, {
        en: 'whiteSpace',
        ti: '.WhiteSpace'
      }, {
        en: 'field',
        ti: '.Field'
      }, {
        en: 'element',
        ti: '.TopLevelElement'
      }, {
        en: 'minLength',
        ti: '.NumFacet'
      }, {
        en: 'any',
        ti: '.Any'
      }, {
        en: 'anyAttribute',
        ti: '.Wildcard'
      }, {
        en: 'key',
        ti: '.Keybase'
      }, {
        en: 'include',
        ti: '.Include'
      }, {
        en: 'maxExclusive',
        ti: '.Facet'
      }, {
        en: 'element',
        ti: '.LocalElement',
        sc: '.Group'
      }, {
        en: 'maxInclusive',
        ti: '.Facet'
      }, {
        en: 'keyref',
        ti: '.Keyref'
      }, {
        en: 'minInclusive',
        ti: '.Facet'
      }, {
        en: 'pattern',
        ti: '.Pattern'
      }, {
        en: 'sequence',
        ti: '.ExplicitGroup'
      }, {
        en: 'notation',
        ti: '.Notation'
      }]
  };
  return {
    XSD_1_0: XSD_1_0
  };
};
if (typeof define === 'function' && define.amd) {
  define([], XSD_1_0_Module_Factory);
}
else {
  var XSD_1_0_Module = XSD_1_0_Module_Factory();
  if (typeof module !== 'undefined' && module.exports) {
    module.exports.XSD_1_0 = XSD_1_0_Module.XSD_1_0;
  }
  else {
    var XSD_1_0 = XSD_1_0_Module.XSD_1_0;
  }
}
},{}],19:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 1.0.1 Copyright (c) 2011-2016, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                if (callback) {
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules/amdefine/amdefine.js")
},{"_process":21,"path":20}],20:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":21}],21:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])(1)
});