(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
require('./test-utils');
require('./test-maps');
require('./test-boxes');
require('./test-styleRuleBuilder');
require('./test-ol3StyleConverter');
require('./test-SLDStyleConverter');
require('./test-WPSClassify');
require('./test-styleDirectives.js');
require('./test-timeDirectives.js');
require('./test-styleChoices.js');
require('./test-StyleComplete.js');
require('./test-storyPins.js');
require('./test-timeServices.js');
require('./test-MapConfigTransformer.js');
require('./test-WFSDescribeFeatureType.js');
require('./test-pins.js');

},{"./test-MapConfigTransformer.js":58,"./test-SLDStyleConverter":59,"./test-StyleComplete.js":60,"./test-WFSDescribeFeatureType.js":61,"./test-WPSClassify":62,"./test-boxes":63,"./test-maps":64,"./test-ol3StyleConverter":65,"./test-pins.js":66,"./test-storyPins.js":67,"./test-styleChoices.js":68,"./test-styleDirectives.js":69,"./test-styleRuleBuilder":70,"./test-timeDirectives.js":71,"./test-timeServices.js":72,"./test-utils":73}],2:[function(require,module,exports){
/*eslint-disable no-unused-vars*/
/*!
 * jQuery JavaScript Library v3.1.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2016-07-07T21:44Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.1.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.0
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-01-04
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true;
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {
	// Known :disabled false positives:
	// IE: *[disabled]:not(button, input, select, textarea, optgroup, option, menuitem, fieldset)
	// not IE: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Check form elements and option elements for explicit disabling
		return "label" in elem && elem.disabled === disabled ||
			"form" in elem && elem.disabled === disabled ||

			// Check non-disabled form elements for fieldset[disabled] ancestors
			"form" in elem && elem.disabled === false && (
				// Support: IE6-11+
				// Ancestry is covered for us
				elem.isDisabled === disabled ||

				// Otherwise, assume any non-<option> under fieldset[disabled] is disabled
				/* jshint -W018 */
				elem.isDisabled !== !disabled &&
					("label" in elem || !disabledAncestor( elem )) !== disabled
			);
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			resolve.call( undefined, value );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.call( undefined, value );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnotwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? JSON.parse( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) ),
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support: IE <=9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox <=42
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			return ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

function manipulationTarget( elem, content ) {
	if ( jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE <=9 only
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val,
		valueIsBorderBox = true,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE <=11 only
	// Running getBoundingClientRect on a disconnected node
	// in IE throws an error.
	if ( elem.getClientRects().length ) {
		val = elem.getBoundingClientRect()[ name ];
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function raf() {
	if ( timerId ) {
		window.requestAnimationFrame( raf );
		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off or if document is hidden
	if ( jQuery.fx.off || document.hidden ) {
		opt.duration = 0;

	} else {
		opt.duration = typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.requestAnimationFrame ?
			window.requestAnimationFrame( raf ) :
			window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	if ( window.cancelAnimationFrame ) {
		window.cancelAnimationFrame( timerId );
	} else {
		window.clearInterval( timerId );
	}

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g,
	rspaces = /[\x20\t\r\n\f]+/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace( rreturn, "" ) :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in uncached url if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rts, "" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win, rect, doc,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		// Make sure element is not hidden (display: none)
		if ( rect.width || rect.height ) {
			doc = elem.ownerDocument;
			win = getWindow( doc );
			docElem = doc.documentElement;

			return {
				top: rect.top + win.pageYOffset - docElem.clientTop,
				left: rect.left + win.pageXOffset - docElem.clientLeft
			};
		}

		// Return zeros for disconnected and hidden elements (gh-2310)
		return rect;
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.parseJSON = JSON.parse;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}





var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}


return jQuery;
} );

},{}],3:[function(require,module,exports){
exports.time = require('./time/controls');
exports.maps = require('./time/maps');
exports.maps.pins = require('./time/pins');
exports.maps.boxes = require('./time/boxes');
exports.utils = require('./time/utils');

},{"./time/boxes":4,"./time/controls":5,"./time/maps":7,"./time/pins":9,"./time/utils":11}],4:[function(require,module,exports){
var utils = require('./utils');

function Box(options) {
    this.range = options.range || null;
    this.data = options.data || null;
    this.layerIds = options.layerIds || null;
    this.center = options.center || null; // ol.Coordinate
    this.resolution = options.resolution || null;
    this.allowPan = options.allowPan;
    this.allowZoom = options.allowZoom;
    this.speed = options.speed;  // interval, seconds
    this.title = options.title || '';
    this.id = options.id || new Date().getUTCMilliseconds();
    this.zoom = options.zoom || null;
    this._offset = 0;
    if (this.range === null) {
        if(this.data) {
            this.range = utils.createRange(this.data[0], this.data[this.data.length - 1]);
        }else{
            this.range = utils.createRange(options.start_time, options.end_time);
        }
    }
    // @todo possible divide by zero if speed.interval not set!
    this._steps = this.data === null ? Math.floor(this.range.width() / this.speed.interval) + 1: this.data.length;
}
Box.prototype.getSteps = function() {
    return this._steps;
};
Box.prototype.getRange = function() {
    return this.range;
};
Box.prototype.getIndex = function(instant) {
    return this.data ? utils.find(this.data, instant) :
        Math.floor(Math.min(this.range.width(), Math.max(0, instant - this.range.start)) / this.speed.interval);
};
Box.prototype.getDate = function(idx) {
    idx = idx - this._offset;
    return this.data ? this.data[idx] : this.range.start + (idx * this.speed.interval);
};


function getTime(props, prop) {
    var val = props[prop];
    if (typeof val != 'undefined') {
        return val *= 1000;
    }
    return null;
}

/**
 * Load Box from geojson, reprojecting from 4326 to the provided
 * projection.
 * @param {Object} geojson
 * @param {String} projection
 * @returns array of Box features
 */
exports.loadFromGeoJSON = function(geojson, projection) {
    if (projection) {
        projection = ol.proj.get(projection);
    }
    return geojson.features.map(function(f) {
        var props = f.properties;
        //props.the_geom = f.geometry;
        props.id = f.id;
        props.start_time = getTime(props, 'start_time');
        props.end_time = getTime(props, 'end_time');
        return new Box(props, projection);
    });
};

function findBox(boxes, idx) {
    var i, ii;
    var box;
    for (i = 0, ii = boxes.length; i < ii; i++) {
        box = boxes[i];
        if (idx >= box._offset) {
            if (i + 1 < ii) {
                if (idx < boxes[i + 1]._offset) {
                    break;
                }
            } else {
                break;
            }
        }
    }
    return box;
}

exports.BoxModel = function(boxArray) {
    var boxes,
        range,
        steps;
    function updateBoxes(neu) {
        var offset = 0;
        boxes = neu.map(function(b) {
            var box = new Box(b);
            box._offset = offset;
            offset += box.getSteps();
            return box;
        });
        range = utils.computeRange(boxes, 'range');
        steps = offset;
    }
    updateBoxes(boxArray);
    this.getRange = function() {
        return range;
    };
    this.getSteps = function() {
        return steps;
    };
    this.getRangeAt = function(s, e) {
        var start = findBox(boxes, s);
        var end = findBox(boxes, e);
        return utils.createRange(start.getDate(s), end.getDate(e));
    };
    this.getIndex = function(instant) {
        var idx = 0, i;
        if (instant < boxes[0].getRange().start) {
            return 0;
        }
        for (i = 0; i < boxes.length; i++) {
            var box = boxes[i];
            var range = box.getRange();
            if (instant >= range.start && instant <= range.end) {
                idx += box.getIndex(instant);
                break;
            } else {
                idx += box.getSteps();
            }
        }
        return idx;
    };
    this.setRange = function(newRange) {
        if (boxes.length == 1) {
            // @todo support for range
            if (utils.isRangeLike(newRange)) {
                throw new Error('not supported yet');
            }
            boxes[0].data = newRange;
            // @todo must set here or constructor is dumb and doesn't recompute
            boxes[0].range = utils.computeRange(newRange);
        } else {
            // @todo finish
            console.log('more than one story box to update range with!');
        }
        updateBoxes(boxes);
    };
    this.update = function(options) {

    };
};

exports.findBox = findBox;
exports.Box = Box;

},{"./utils":11}],5:[function(require,module,exports){
var utils = require('./utils');
var models = require('./models');
var timeslider = require('./slider');
var line = require('./line');
var maps = require('./maps');

/**
 * Facade object and guts of slider/timeline/playback logic.
 *
 * Since playback is driven by a timeout, all other potential events
 * are fired in an async manner to ensure a uniform API.
 */
function TimeController(model, slider, timeline, controls, chapterCount) {
    this.model = model;
    this.slider = slider;
    this.timeline = timeline;
    this.loop = 'none';

    var self = this,
        currentTimelineWindow = getTimelineWindow(),
        isAdjusting = false,
        started = false,
        timeout = null,
        events = new utils.Events(),
        deferred = [];

    function getTimelineWindow() {
        return utils.createRange(timeline.getWindow());
    }

    function adjust(fun, a, b) {
        if (isAdjusting) {
            return;
        }
        isAdjusting = true;
        try {
            fun(a, b);
        } finally {
            isAdjusting = false;
        }
    }

    function centerTimeline(range) {
        var c = model.mode === 'cumulative' ? range.end : range.center();
        timeline.moveTo(c);
        publishRangeChange(range);
    }

    function adjustSlider(range) {
        if (timeline.isWindowMax()) {
            return;
        }

        var center = range.center();
        var idx = model.getIndex(center);
        if (model.mode === 'cumulative') {
            slider.growTo(idx);
        } else {
            slider.center(idx);
        }
        timeline.setTime(center);
        publishRangeChange(slider.getRange());
    }

    function updateSlider(range) {
        if (utils.rangesEqual(range, currentTimelineWindow)) {
            return;
        }
        range = utils.createRange(range);
        // zoom or scroll event?
        if (range.width() !== currentTimelineWindow.width()) {
            timeline.moveToCurrentTime();
        } else {
            adjustSlider(range);
        }
        currentTimelineWindow = range;
    }

    slider.on('rangeChanged', function(ev, range) {
        clearTimeout();
        adjust(centerTimeline, range);
        schedule();
    });
    timeline.on('rangechanged', function(range) {
        adjust(updateSlider, range);
    });
    timeline.on('select', function(properties) {
        console.log("Selected items: ", properties.items);
    });
    function clearTimeout() {
        if (timeout !== null) {
            window.clearTimeout(timeout);
        }
        timeout = null;
    }

    function move(amt) {
        timeout = null;
        var atEnd;
        if (model.mode === 'cumulative') {
            atEnd = slider.grow(amt);
        } else {
            atEnd = slider.move(amt);
        }
        if (atEnd) {
            if (self.loop === 'chapter') {
                slider.jump(0);
            } else if (self.loop === 'story') {
              var currentChapter = window.location.hash.split("/")[2];
              var nextChapter = currentChapter === undefined || currentChapter === null ? 2 : parseInt(currentChapter) + 1;
              console.log(chapterCount);
              if(nextChapter <= chapterCount) {
                  console.log("Going to Chapter ", nextChapter);
                  window.location.href = '#/chapter/' + nextChapter;
                  slider.jump(0);
              } else {
                console.log("Going to Chapter 1");
                window.location.href = '#/chapter/1';
                slider.jump(0);
              }
            } else {
              self.stop();
            }
        }
        centerTimeline(slider.getRange());
        if (started) {
            schedule();
        }
    }

    function schedule() {
        if (started) {
            // @todo respect playback interval options...
            var wait = model.interval;
            $.when.apply($, deferred).then(function() {
                if (started) {
                    timeout = window.setTimeout(move, wait, 1);
                }
            }, function() {
                // the deferred was rejected, if arguments provided, this
                // represents an error state so don't continue playing
                if (arguments.length === 0 && started && timeout === null) {
                    timeout = window.setTimeout(move, wait, 1);
                } else {
                    self.stop();
                }
            });
            deferred = [];
        }
    }

    function run() {
        publishStateChange("running");
        move(1);
    }

    function publishRangeChange(data) {
        if (typeof data === 'undefined') {
            data = slider.getRange();
        }
        publish("rangeChange", data);
    }

    function publishStateChange(state) {
        publish("stateChange", state);
    }

    function publish(event, data) {
        events.event(event).publish(data);
    }

    this.defer = function(defer) {
        deferred.push(defer);
    };
    this.getCurrentRange = function() {
        return slider.getRange();
    };
    this.update = function(options) {
        model.update(options);
        slider.update(model);
        timeline.update(model);
        window.setTimeout(publishRangeChange, 0);
    };
    this.start = function() {
        if (started) {
            return;
        }
        deferred = [];
        started = true;
        window.setTimeout(run, 0);
    };
    this.stop = function() {
        deferred = [];
        started = false;
        clearTimeout();
        window.setTimeout(publishStateChange, 0, 'stopped');
    };
    this.next = function() {
        clearTimeout();
        window.setTimeout(move, 0, 1);
    };
    this.prev = function() {
        clearTimeout();
        window.setTimeout(move, 0, -1);
    };
    this.isStarted = function() {
        return started;
    };
    this.on = function(event, f) {
        events.event(event).subscribe(f);
    };
}

/**
 * annotation model:
 * title
 * content
 * the_geom
 * start_time
 * end_time
 * in_timeline
 * in_map
 * appearance
 */
function Annotations(annotations) {
    var ann = annotations || [];
    function inTimeline() {
        return ann.filter(function(a) {
            return a.in_timeline;
        });
    }
    this.getTimeLineAnnotatons = function() {
        return inTimeline(true);
    };
    this.update = function(annotations) {
        this.ann = annotations;
    };
}

/**
 * box model:
 * title
 * content
 * the_geom
 * start_time
 * end_time
 * in_timeline
 * in_map
 * appearance
 */
function Boxes(boxes) {
    var box = boxes || [];
    function inTimeline() {
        return box.filter(function(b) {
            return true;//b.in_timeline;
        });
    }
    this.getTimeLineBoxes = function() {
        return inTimeline(true);
    };
    this.update = function(boxes) {
        this.box = boxes;
    };
}


/**
 * common lingo:
 * instant: a single point in time
 * extent, range: has property start and end
 * start, end: long values representing UTC (internal) but generally,
 *             a date
 * interval: multipier * precision
 * precision: tick, second, minute, hour, day, week, month, year
 *            note: tick implies a multipier of 1
 * speed: object with property seconds (framerate) and optional interval
 *
 * options = {
 *   annotations: [ {
 *      title,
 *      content,
 *      the_geom,
 *      start_time,
 *      end_time,
 *      in_timeline,
 *      in_map,
 *      appearance
 *      } ... ],
 *   map: ol.Map,
 *   boxes : [ {
 *      range : {
 *          start, end
 *      },
 *      center: ol.Coordinate,
 *      resolution: float,
 *      static: boolean,
 *      speed: { interval, seconds }
 *      } ... ],
 *   data : [ date ...] | rangeWithInterval,
 *   playback : {
 *      mode: instant | range | cumulative,
 *      fixed: boolean
 *   },
 *   timeLineId : element id,
 *   timeSliderId : element id,
 *   controlsId: element id
 *
 * }
 */
function create(options) {
    // @todo for layers, annotations won't exist and, intially, we won't
    //       have playback settings for layers...
    var model,
        annotations = new Annotations(options.annotations),
        boxes = options.boxes,
        chapterCount = options.chapterCount,
        totalRange,
        slider,
        timeline,
        mapController,
        controls;
    options.boxy = new Boxes(options.boxes);
    // make a default box if none provided
    if (typeof boxes == 'undefined' || boxes.length === 0) {
        var interval = 0, data = null;
        if (Array.isArray(options.data)) {
            data = options.data;
            totalRange = utils.computeRange(options.data);
        } else {
            interval = options.data.interval || utils.pickInterval(options.data);
            totalRange = options.data;
        }
        boxes = [{
                data: data,
                range: totalRange,
                speed: {
                    interval: interval,
                    seconds: 3
                }
            }];
    }

    model = new models.TimeModel(options, boxes, annotations);
    slider = new timeslider.TimeSlider(options.timeSliderId || 'slider', model);
    timeline = new line.TimeLine(options.timeLineId || 'timeline', model);

    var timeControls = new TimeController(model, slider, timeline, controls, chapterCount);
    mapController = new maps.MapController(options, timeControls);
    return timeControls;
}

exports.create = create;
exports.maps = maps;
exports.utils = utils;

},{"./line":6,"./maps":7,"./models":8,"./slider":10,"./utils":11}],6:[function(require,module,exports){
var Timeline = require('vis/lib/timeline/Timeline');
var utils = require('./utils');

/**
 * Display annotations or other temporal instant/extent. Allow adjusting
 * time (either instant or extent) by dragging.
 * @param {type} id
 * @param {type} model
 * @returns {_L1.TimeLine}
 */
exports.TimeLine = function(id, model) {
    var dom = $("#" + id);
    var timeline = null;
    // @revisit - internally the timeline seems to apply the offset when
    //            creating a tool tip, does this cause problems elsewhere?
    var offset = new Date().getTimezoneOffset() * 60 * 1000;

    function init(model) {
        var story_pin_label = 'Story Pin';
        var elements = [], layer_groups = [], groups = [{id: story_pin_label, title: story_pin_label, time: []}], options;
        var range = model.getRange();
        if (range.isEmpty()) {
            range = utils.createRange(Date.now());
        }
        elements = model.annotations.getTimeLineAnnotatons().map(function(ann, i) {
            /*jshint eqnull:true */
            var start = ann.start_time != null ? ann.start_time : range.start;
            var end = ann.end_time != null ? ann.end_time : range.end;
            var type = start === end ? 'box' : 'range';
            return {
                id: ann.id,
                start: start,
                end: end,
                content: ann.content || ann.title,
                title: ann.title,
                type: type,
                group: story_pin_label
            };
        });
        if (model.boxy.box) {
            elementss = model.boxy.box.map(function(box, i) {
                /*jshint eqnull:true */
                var start = box.range != null ? box.range.start : range.start;
                var end = box.range != null ? box.range.end : range.end;
                var type = 'background';
                return {
                    id: 'sb' + box.id,
                    start: start,
                    end: end,
                    content: box.content || box.title,
                    type: type
                };
            });
            elements = elements.concat(elementss);
        }
        layer_groups = $.map(model.storyLayers, function(lyr, i) {
            var id = lyr.get('id');
            var title = lyr.get('title');
            var times = lyr.get('times') || [];

            for (var j = 0; j < times.length; j++) {
                elements.push({
                    id: id + ':' + i + ':' + j,
                    group: id,
                    content: "",
                    start: times[j],
                    type: 'box'
                });
            }

            return {
                id: id,
                content: title
            };
        });

        groups = groups.concat(layer_groups);

        var height = $( document ).height() * 0.35;

        options = {
            min: range.start,
            max: range.end,
            start: range.start,
            end: range.end,
            height: (height < 300)? 138: height,
            maxHeight: 400,
            showCurrentTime: false
        };
        if (timeline === null) {
            timeline = new Timeline(dom.get(0), elements, options);
            timeline.setGroups(groups);
            timeline.setCurrentTime(range.start);
            timeline.addCustomTime();
        } else {
            timeline.setOptions(options);
            timeline.setItems(elements);
            timeline.setGroups(groups);
        }
    }
    init(model);

    // updates from user dragging customtime bar
    // @todo will not update slider currently at min timeline zoom as it
    // is difficult to determine whether an event is from zooming or dragging
    // need to wrap event handling to better differentiate
    timeline.on('timechanged', function() {
        timeline.moveTo(timeline.getCustomTime(), {animate: false});
    });

    this.moveTo = function(time) {
        timeline.moveTo(time, {animate: false});
        this.setTime(time);
    };
    this.setTime = function(time) {
        timeline.setCustomTime(time + offset);
    };
    this.isWindowMax = function() {
        return utils.rangesEqual(timeline.getWindow(), model.getRange());
    };
    this.moveToCurrentTime = function() {
        var current = timeline.getCustomTime().getTime();
        var width = utils.createRange(timeline.getWindow()).width();
        var range = model.getRange();
        if (current === range.start) {
            timeline.setWindow(range.start, range.start + width, {animate: false});
        } else if (current === range.end) {
            timeline.setWindow(range.end - width, range.end, {animate: false});
        } else {
            timeline.moveTo(current, {animate: false});
        }
    };
    this.getWindow = function() {
        return timeline.getWindow();
    };
    this.on = function(ev, cb) {
        timeline.on(ev, cb);
    };
    this.update = init;
    // @todo detect click or dblclick event and position based on % of total width
};

},{"./utils":11,"vis/lib/timeline/Timeline":39}],7:[function(require,module,exports){
/*jshint loopfunc: true */
var utils = require('./utils');
var moment = require('moment');

/**
 * Read the provide ol3 WMS capabilities document
 * @param {type} caps
 * @returns an object of name->[date|interval]|interval-range mappings
 */
exports.readCapabilitiesTimeDimensions = function(caps, openlayers2) {
    var dimensions = {};
    function readRange(subparts) {
        if (subparts.length < 2) {
            throw new Error('expected 2 parts for range : ' + subparts);
        }
        var range = utils.createRange(subparts[0], subparts[1]);
        if (subparts.length == 3) {
            range.duration = subparts[2];
            range = new utils.Interval(range);
        }
        return range;
    }
    function readPart(part) {
        var subparts = part.split('/');
        if (subparts.length == 1) {
            return utils.getTime(subparts[0]);
        } else {
            return readRange(subparts);
        }
    }
    function parse(dimension) {
        var dims = openlayers2 ? dimension : dimension.split(',');
        if (dims.length == 1) {
            var read = readPart(dims[0]);
            return typeof read === 'number' ? [read] : read;
        }
        return dims.map(readPart);
    }
    if (openlayers2 === true) {
        if (caps.dimensions && caps.dimensions.time) {
            dimensions = parse(caps.dimensions.time.values);
        } else {
            dimensions = undefined;
        }
    } else {
        // @todo need to make layer scanning recursive?
        caps.value.capability.layer.layer.forEach(function(lyr) {
            if (lyr.dimension) {
                dimensions[lyr.name] = parse(lyr.extent[0].value);
            }
        });
    }
    return dimensions;
};

function TileLoadListener(tileStatusCallback) {
    var tilesLoading = {};
    var deferred = $.Deferred(),
          cancelled = false;
    function remainingTiles() {
        var t = 0;
        for (var i in tilesLoading) {
            t += tilesLoading[i];
        }
        return t;
    }
    var listener = {
        deferred: deferred,
        cancel: function() {
            cancelled = true;
            for (var s in tilesLoading) {
                tilesLoading[s] = 0;
            }
            if (deferred) {
                deferred.reject(); // notify we've aborted but w/out error
            }
            if (tileStatusCallback) {
                tileStatusCallback(0);
            }
        },
        tileQueued: function(source) {
            if (cancelled) {
                return;
            }
            var key;
            if (source instanceof ol.source.TileWMS) {
                key = source.getUrls()[0];
            } else if (source instanceof ol.source.ImageWMS) {
                key = source.getUrl();
            }
            tilesLoading[key] = (tilesLoading[key] || 0) + 1;
            if (tileStatusCallback) {
                tileStatusCallback(remainingTiles());
            }
        },
        tileLoaded: function(event, source) {
            if (cancelled) {
                return;
            }
            var key;
            if (source instanceof ol.source.TileWMS) {
                key = source.getUrls()[0];
            } else if (source instanceof ol.source.ImageWMS) {
                key = source.getUrl();
            }
            tilesLoading[key] -= 1;
            var remaining = remainingTiles();
            if (tileStatusCallback) {
                tileStatusCallback(remaining);
            }
            if (remaining === 0 && deferred) {
                deferred.resolve();
            }
        }
    };
    // workaround for when the tiles are cached and no events are triggered
    // this adds a constant (small) additional delay to the current play rate
    // under optimal (cached) conditions
    // @todo can this safely be shortened?
    window.setTimeout(function() {
        if (Object.keys(tilesLoading).length === 0) {
            listener.cancel();
        }
    },100);
    return listener;
}

function filterVectorLayer(storyLayer, range) {
    var timeAttr = storyLayer.get('timeAttribute'), l_features = storyLayer.get('features');
    if (timeAttr === undefined || l_features === undefined) {
        return;
    }
    range = utils.createRange(range);
    // loop over all original features and filter them
    var features = [];
    var layer = storyLayer.getLayer();
    visitAllLayerFeatureTimes(storyLayer, function(f,r) {
        if (range.intersects(r)) {
            features.push(f);
        }
    });
    layer.getSource().clear(true);
    layer.getSource().addFeatures(features);
}


function filterVectorBoxLayer(storyLayer, range) {
    var timeAttr = storyLayer.get('timeAttribute'), l_features = storyLayer.get('features');
    if (timeAttr === undefined || l_features === undefined) {
        return;
    }
    range = utils.createRange(range);
    // loop over all original features and filter them
    var features = [];
    visitAllLayerFeatureTimes(storyLayer, function(f,r) {
        if (range.intersects(r)) {
            features.push(f);
        }
    });

    return features;
}
/**
 * Call the provided visitor function on the specified features using the
 * configuration provided in the layer. The visitor function will be called
 * with the feature, and start and end time, if any. The features visited will
 * be, in order of priority: the provided (optional) features argument, the
 * layer property 'features', the layer's source features.
 * @param {StoryLayer} story layer
 * @param {function} visitor function(feature, start, end)
 * @param {array} features (opitonal)
 */
function visitAllLayerFeatureTimes(storyLayer, visitor, features) {
    var startAtt = storyLayer.get('timeAttribute');
    var endAtt = storyLayer.get('endTimeAttribute');
    var rangeGetter;
    var layer = storyLayer.getLayer();
    features = features || storyLayer.get('features') || layer.getSource().getFeatures();
    if (endAtt) {
        rangeGetter = function(f) {
            if(f.range){
                return f.range;
            }else {
                var start = f.get(startAtt);
                var end = f.get(endAtt);
                return utils.createRange(start, end);
            }
        };
    } else {
        rangeGetter = function(f) {
            if(f.range){
                return f.range;
            }else {
                var start = f.get(startAtt);
                return utils.createRange(start, start);
            }
        };
    }
    utils.visitRanges(features, rangeGetter, visitor);
}

/**
 * Compute the range of the provided features using the layer's configured
 * timeattributes. If the optional features array is omitted, the features
 * will come from the layer.
 * @param {StoryLayer} storyLayer
 * @param {array} features (optional)
 * @returns {storytools.core.time.Range} range of features
 */
exports.computeVectorRange = function(storyLayer, features) {
    var startAtt = storyLayer.get('timeAttribute');
    var endAtt = storyLayer.get('endTimeAttribute');
    var layer = storyLayer.getLayer();
    features = features || storyLayer.get('features') || layer.getSource().getFeatures();
    return utils.computeRange(features, function(f) {
        return utils.createRange(f.get(startAtt), f.get(endAtt));
    });
};

exports.filterVectorLayer = filterVectorLayer;
exports.filterVectorBoxLayer = filterVectorBoxLayer;

exports.MapController = function(options, timeControls) {
    var loadListener = null,
          tileStatusCallback = options.tileStatusCallback,
          storyMap = options.storyMap;
    function layerAdded(layer) {
        var source, image;
        var loaded = function(event) {
            // grab the active loadListener to avoid phantom onloads
            // when listener is cancelled
            var currentListener = loadListener;
            if (currentListener) {
                currentListener.tileLoaded(event, source);
            }
        };
        var loadstart = function() {
            // grab the active loadListener to avoid phantom onloads
            // when listener is cancelled
            var currentListener = loadListener;
            if (currentListener) {
                currentListener.tileQueued(source);
            }
        };
        if (layer instanceof ol.layer.Tile && layer.getSource() instanceof ol.source.TileWMS) {
            source = layer.getSource();
            source.on('tileloadstart', loadstart);
            source.on('tileloadend', loaded);
            // @todo handle onerror and cancel deferred with an example
            // to stop automatic playback
            source.on('tileloaderror', loaded);
        } else if (layer instanceof ol.layer.Image && layer.getSource() instanceof ol.source.ImageWMS) {
            source = layer.getSource();
            source.on('imageloadstart', loadstart);
            source.on('imageloadend', loaded);
            source.on('imageloaderror', loaded);
        }
    }
    function createLoadListener() {
        if (loadListener !== null) {
            loadListener.cancel();
        }
        loadListener = new TileLoadListener(tileStatusCallback);
        return loadListener;
    }

    function updateCenterAndZoom(range){
        var currentBoxes = filterVectorBoxLayer(storyMap.storyBoxesLayer, range);

        if(currentBoxes && currentBoxes.length > 0) {
            var currentBox = currentBoxes[0];
            
            if (currentBox.center) {
                storyMap.animateCenterAndZoom(currentBox.center, currentBox.zoom);
            }
        }else{
            if (storyMap.returnToExtent) {
                storyMap.animateCenterAndZoom(storyMap.getCenter(), storyMap.getZoom());
            }
        }
    }

    function updateLayers(range) {
        var storyLayers = storyMap.getStoryLayers();
        var time = new Date(range.start).toISOString();
        if (range.start != range.end) {
            time += "/" + new Date(range.end).toISOString();
        }
        for (var i = 0; i < storyLayers.getLength(); i++) {
            var storyLayer = storyLayers.item(i), layer = storyLayer.getLayer();
            if ((layer instanceof ol.layer.Tile && layer.getSource() instanceof ol.source.TileWMS) ||
                  (layer instanceof ol.layer.Image && layer.getSource() instanceof ol.source.ImageWMS)) {
                if (storyLayer.get('times')) {
                    layer.getSource().updateParams({TIME: time});
                }
            } else if (layer instanceof ol.layer.Vector) {
                filterVectorLayer(storyLayer, range);
            }
        }
        // this is a non-story layer - not part of the main collection
        filterVectorLayer(storyMap.storyPinsLayer, range);
        if (storyLayers.getLength() >= 1) {
            timeControls.defer(createLoadListener().deferred);
        }
    }
    var me = this;
    me.layers = {};
    storyMap.getStoryLayers().on('add', function(ev) {
        var lyr = ev.element, id = lyr.get('id');
        if (me.layers[id] !== true) {
            layerAdded(lyr.getLayer());
            me.layers[id] = true;
        }
    });
    storyMap.getStoryLayers().forEach(function(lyr) {
        var id = lyr.get('id');
        if (id !== undefined && me.layers[id] !== true) {
            layerAdded(lyr.getLayer());
            me.layers[id] = true;
        }
    });
    timeControls.on('rangeChange', updateCenterAndZoom);
    timeControls.on('rangeChange', updateLayers);
};

},{"./utils":11,"moment":28}],8:[function(require,module,exports){
var utils = require('./utils');
var BoxModel = require('./boxes').BoxModel;

/**
 * @todo document me
 */
exports.TimeModel = function(options, boxes, annotations) {
    
    var events = new utils.Events(),
        boxModel = new BoxModel(boxes);

    this.annotations = annotations;
    this.boxes = boxes;
    this.boxy = options.boxy;
    this.storyLayers = [];
    this.fixed = false;
    this.mode = 'instant';
    this.interval = 1000;

    function init(opts) {
        if (opts.hasOwnProperty('fixed')) {
            this.fixed = opts.fixed;
        }

        if (opts.hasOwnProperty('speed') && opts.speed !== undefined) {
            this.interval = opts.speed;
        }

        if (opts.hasOwnProperty('mode') && opts.mode !== undefined) {
            this.mode = opts.mode;
        }
        if (opts.hasOwnProperty('annotations')) {
            this.annotations.update(opts.annotations);
        }
        if (opts.hasOwnProperty('boxes')) {
            this.boxy.update(opts.boxes);
        }

        if (opts.hasOwnProperty('storyLayers')) {
            this.storyLayers = opts.storyLayers;
        }

        // @todo is the best name for this
        if (opts.hasOwnProperty('data')) {
            boxModel.setRange(opts.data);
        }
    }

    init.call(this, options);
    this.getRange = function() {
        return boxModel.getRange();
    };
    this.getTotalRange = function() {
        // @todo need to access layers and cached dimension data
        //       and consider annotations?
        throw Error('not implemented');
    };
    this.update = init;
    this.getSteps = function() {
        return boxModel.getSteps();
    };
    this.getIndex = function(instant) {
        return boxModel.getIndex(instant);
    };
    this.getRangeAt = function(i, j) {
        return boxModel.getRangeAt(i, j);
    };
};

},{"./boxes":4,"./utils":11}],9:[function(require,module,exports){
var format = new ol.format.GeoJSON();


var StoryPin = function(data, projection) {
    ol.Feature.call(this, data);
    if (data) {
        if (data.the_geom) {
            var geom = data.the_geom;
            if (typeof geom === 'string' || 'type' in geom) {
                geom = format.readGeometry(geom, {
                    featureProjection: projection
                });
            }
            this.setGeometry(geom);
            delete data.the_geom;
        }
        this.setId(data.id);
    }
};
StoryPin.prototype = Object.create(ol.Feature.prototype);
StoryPin.prototype.constructor = StoryPin;
// expose these simply for the timeline - it doesn't know they're features
['id','start_time','end_time','content','title','in_timeline','in_map', 'auto_show', 'pause_playback'].forEach(function(prop) {
    Object.defineProperty(StoryPin.prototype, prop, {
        get: function() {
            var val = this.get(prop);
            return typeof val === 'undefined' ? null : val;
        },
        set: function(val) {
            this.set(prop, val);
        }
    });
});

/*
 var start = ann.start_time != null ? ann.start_time : range.start;
 var end = ann.end_time != null ? ann.end_time : range.end;
 var type = start === end ? 'box' : 'range';
 return {
 id: ann.id,
 start: start,
 end: end,
 content: ann.content || ann.title,
 title: ann.title,
 type: type
 };
 */

function getTime(props, prop) {
    var val = props[prop];
    if (typeof val != 'undefined') {
        return val *= 1000;
    }
    return null;
}

/**
 * Load StoryPins from geojson, reprojecting from 4326 to the provided
 * projection.
 * @param {Object} geojson
 * @param {String} projection
 * @returns array of StoryPin features
 */
exports.loadFromGeoJSON = function(geojson, projection) {
    if (projection) {
        projection = ol.proj.get(projection);
    }
    return geojson.features.map(function(f) {
        var props = f.properties;
        props.the_geom = f.geometry;
        props.id = f.id;
        props.start_time = getTime(props, 'start_time');
        props.end_time = getTime(props, 'end_time');
        return new StoryPin(props, projection);
    });
};

exports.StoryPin = StoryPin;

},{}],10:[function(require,module,exports){
/**
 * Visual feedback of complete story line. Allow dragging of range, click
 * to position.
 *
 * Playback Modes
 * - fixed cumulative (min fixed at 0, max adjusts with tick)
 * - fixed range playback (range fixed, window adjusts with tick)
 * - fixed instant (like fixed range but range of 0)
 * - open range playback (fully adjustable min/max, window adjusts with tick)
 *
 * Internal model
 * - 0-N where N is either the number of instants or the total number of extents
 *
 * @param {type} id
 * @param {type} model
 * @returns {TimeSlider}
 */
exports.TimeSlider = function(id, model) {
    var slider = $("#" + id);
    var initialized = false;
    var singleSlider;

    function init(model) {
        var options = {
            step: 1,
            start: [0, 0],
            animate: false,
            connect: true,
            range: {
                min: 0,
                max: model.getSteps() - 1
            },
            behaviour: 'drag-snap'
        };
        singleSlider = false;

        /*if (model.fixed) {
            // @todo need model interval
        }*/

        if (model.mode === 'cumulative') {
            singleSlider = true;
            options.connect = 'lower';
        } else if (model.mode === 'instant') {
            singleSlider = true;
            options.connect = false;
        } else if (model.mode === 'range') {
            if (model.fixed) {
                // ideally we'd support snap but it breaks fixed
                options.behaviour = 'drag-fixed';
            }
        } else {
            throw "invalid model mode : " + model.mode;
        }

        if (initialized) {
            // have to update values based on current state
            var range = getSliderRangeInternal();
            if (singleSlider) {
                options.start = range[0];
            } else {
                if (range[0] === range[1]) {
                    range[1] += 1;
                }
                options.start = range;
            }
        } else if (singleSlider) {
            options.start = 0;
        }
        slider.noUiSlider(options, initialized);
        if (!initialized) {
            slider.bind('slide', function(ev) {
                var range = getRange();
                slider.trigger('rangeChanged', range);
            });
        }
        initialized = true;
    }

    init(model);

    function getSliderRangeInternal() {
        var range = slider.val();
        if (! Array.isArray(range)) {
            range = parseInt(range, 10);
            range = [model.mode === 'cumulative' ? 0 : range, range];
        } else {
            range = range.map(function(i) { return parseInt(i, 10); });
        }
        return range;
    }

    function getRange() {
        var range = getSliderRangeInternal();
        return model.getRangeAt(range[0], range[1]);
    }

    function width() {
        var range = getSliderRangeInternal();
        return range[1] - range[0];
    }

    function isAtEnd(left) {
        var range = getSliderRangeInternal();
        if (left) {
            return range[0] === 0;
        }
        return range[1] === model.getSteps()-1;
    }

    function setValue(val) {
        // normalize nouislider.val to handle array
        if (singleSlider) {
            slider.val(val[1]);
        } else {
            slider.val(val);
        }
    }

    this.slider = slider;
    this.on = function() {
        slider.on.apply(slider, arguments);
    };
    this.getSliderRangeInternal = getSliderRangeInternal;
    this.center = function(index) {
        var half = Math.floor(width() / 2);
        setValue([index - half, index + half]);
    };
    this.move = function(amt) {
        var vals  = getSliderRangeInternal();
        vals[0] += amt;
        vals[1] += amt;
        setValue(vals);
        return isAtEnd(amt < 0);
    };
    this.grow = function(amt) {
        var vals = getSliderRangeInternal();
        vals[1] += amt;
        setValue(vals);
        return isAtEnd(false);
    };
    this.growTo = function(where) {
        var vals = getSliderRangeInternal();
        vals[1] = where;
        setValue(vals);
        return isAtEnd(false);
    };
    this.jump = function(to) {
        setValue([to, to + width()]);
    };
    this.getRange = getRange;
    this.update = init;
};

},{}],11:[function(require,module,exports){
var moment = require('moment');

/**
 * Get the number of milliseconds from the provided arg.
 * @param arg - either Date, range (returns start), string or number
 * @returns milliseconds or null if nothing provided
 */
getTime = function(arg) {
    var type = typeof arg;
    if (type === 'number') {
        return arg;
    }
    if (arg instanceof Date) {
        return arg.getTime();
    }
    if (type === 'string') {
        return parseDate(arg).getTime();
    }
    /*jshint eqnull:true */
    if (arg == null) {
        return null;
    }
    if (isRangeLike(arg)) {
        /*jshint eqnull:true */
        return getTime(arg.start != null ? arg.start : arg.end);
    }
    throw new Error('cannot call getTime with ' + type + ", : " + arg);
};

isRangeLike = function(object) {
    /*jshint eqnull:true */
    return object != null && (object.hasOwnProperty('start') || object.hasOwnProperty('end'));
};

exports.isRangeLike = isRangeLike;

exports.createRange = function(start, end) {
    if (arguments.length === 1) {
        var other = start;
        if (isRangeLike(other)) {
            start = other.start;
            end = other.end;
        } else {
            end = start;
        }
    }
    /*jshint eqnull:true */
    if (start != null && end != null && start > end) {
        throw new Error('start > end');
    }
    return new Range(getTime(start), getTime(end));
};

exports.rangesEqual = function(a, b) {
    return getTime(a.start) === getTime(b.start) &&
        getTime(a.end) === getTime(b.end);
};

function rangeContains(range, time) {
    /*jshint eqnull:true */
    if (time == null) {
        throw new Error('invalid time argument');
    }
    /*jshint eqnull:true */
    return ((range.start != null ? time >= range.start : true) &&
           (range.end != null ? time < range.end : true)) ||
           range.start === range.end && time === range.start;
}

exports.parseISODuration = function(duration) {
    var values = exports.isoDurationToMoment(duration);
    return moment.duration(values).asMilliseconds();
};

exports.Interval = function(start, end, duration) {
    if (typeof start === 'object') {
        var opts = start;
        start = opts.start;
        end = opts.end;
        duration = opts.duration;
    }
    if (start === end) {
        throw new Error('interval should have width');
    }
    Range.call(this, start, end);
    this.duration = duration;
    this.interval = exports.parseISODuration(this.duration);
    this.offset = exports.createOffsetter(this);
};

function Range(start, end) {
    if (isNaN(start) || isNaN(end)) {
        throw new Error('invalid start and/or end');
    }
    this.start = start;
    this.end = end;
}
/**
 * extend this Range by another. This algorithm will consider an open-ended
 * range to represent a minimum of start and maximum of end.
 * @param {type} other
 * @returns {undefined}
 */
Range.prototype.extend = function(other) {
    /*jshint eqnull:true */
    if (!isRangeLike(other)) {
        other = exports.createRange(other);
    }
    var start = getTime(other.start);
    var end = getTime(other.end);
    if (start == null) {
        start = end;
    }
    if (end == null) {
        end = start;
    }
    if (start != null) {
        if (this.start == null) {
            this.start = start;
        } else {
            this.start = Math.min(this.start, start);
        }
    }
    if (end != null) {
        if (this.end == null) {
            this.end = end;
        } else {
            this.end = Math.max(this.end, end);
        }
    }
};
Range.prototype.intersects = function(other) {
    if (isRangeLike(other)) {
        /*jshint eqnull:true */
        var es = other.start == null ? Number.MIN_VALUE : other.start;
        var ee = other.end == null ? Number.MAX_VALUE : other.end;
        // intersection if (any)
        // effective end in this range
        // effective start in this range
        // effective start before and effective end after
        return rangeContains(this, es) ||
            rangeContains(this, ee) ||
            es <= this.start && ee >= this.end;
    } else {
        return rangeContains(this, getTime(other));
    }
};
Range.prototype.toString = function() {
    return new Date(this.start).toUTCString() + " : " + new Date(this.end).toUTCString();
};
Range.prototype.center = function() {
    return Math.floor(this.start + (this.end - this.start) / 2);
};
Range.prototype.width = function() {
    return this.end - this.start;
};
Range.prototype.isEmpty = function() {
    /*jshint eqnull:true */
    return this.end == null && this.start == null;
};
exports.Range = Range;



/**
 * Compute the overall range of provided args. Args may be an array of:
 * date or long, range, object with property/function yielding range for the
 * object.
 * @param {type} args
 * @returns range will have start/end even if the same time.
 */
exports.computeRange = function(args, rangeGetter) {
    var range = new Range(null, null);
    exports.visitRanges(args, rangeGetter, function(arg, r) {
        range.extend(r);
    });
    /*jshint eqnull:true */
    if (range.start == null) {
        range.start = range.end;
    }
    if (range.end == null) {
        range.end = range.start;
    }
    return range;
};

exports.visitRanges = function(objects, rangeGetter, visitor) {
    var getRange;
    if (typeof rangeGetter == 'string') {
        getRange = function(object) {
            return object[rangeGetter];
        };
    } else if (typeof rangeGetter == 'function') {
        getRange = rangeGetter;
    } else {
        getRange = function(object) {
            return isRangeLike(object) ? object : exports.createRange(object);
        };
    }
    for (var i = 0, ii = objects.length; i < ii; i++) {
        var object = objects[i];
        visitor(object, getRange(object));
    }
};

/** for the given what, find the index in the items that what is closest
 * to. items must be sorted. The lowest closest value possible is returned.
 */
exports.binarySearch = function(items, what) {
    var start = 0;
    var stop = items.length - 1;
    var mid = stop + start / 2 | 0;
    var val;
    if (what < items[0]) {
        return 0;
    }
    if (what > items[stop]) {
        return items.length - 1;
    }
    while ((val = items[mid]) !== what && start < stop) {
        if (what > val) {
            if (what < items[mid + 1]) {
                return mid;
            }
        } else if (what < val) {
            if (what > items[mid - 1]) {
                return mid - 1;
            }
            stop = mid - 1;
        }
        mid = stop + start / 2 | 0;
    }
    return mid;
};

exports.find = function(items, what) {
    if (what < items[0]) {
        return 0;
    }
    for (var i = 0, ii = items.length - 1; i < ii; i++) {
        if (what >= items[i] && what < items[i + 1]) {
            return i;
        }
    }
    return items.length - 1;
};

exports.Events = function() {
    var topics = {};

    // @todo introduce setting topics with arguments and logging/exception
    // on un-fired event

    function event(id) {
        var callbacks, method,
                topic = id && topics[ id ];
        if (!topic) {
            callbacks = jQuery.Callbacks();
            topic = {
                publish: callbacks.fire,
                subscribe: callbacks.add,
                unsubscribe: callbacks.remove
            };
            if (id) {
                topics[ id ] = topic;
            }
        }
        return topic;
    }

    return {
        event: event
    };
};

exports.pickInterval = function(range) {
    var intervals = [
        moment.duration(1, 'seconds').asMilliseconds(),
        moment.duration(1, 'minutes').asMilliseconds(),
        moment.duration(1, 'hours').asMilliseconds(),
        moment.duration(1, 'days').asMilliseconds(),
        moment.duration(1, 'weeks').asMilliseconds(),
        moment.duration(1, 'months').asMilliseconds(),
        moment.duration(1, 'years').asMilliseconds()
    ];
    return intervals[Math.max(exports.find(intervals, range.width()) - 1, 0)];
};

exports.getTime = getTime;

/**
 * Read an iso duration into a moment.js object.
 * @param {string} duration
 * @returns {object} with moment.js info
 */
exports.isoDurationToMoment = function(duration) {
    if (duration.charAt(0) != 'P') {
        throw new Error('expected P as starting duration : ' + duration);
    }
    var pattern = /(\d+)(\w)/g;
    var date = null, time = null, values = {};
    duration = duration.substring(1);
    if (duration.indexOf('T') >= 0) {
        var parts = duration.split('T');
        date = parts[0];
        time = parts[1];
    } else {
        date = duration;
    }
    var mapping = {
        'Y': 'years',
        'M': 'months',
        'W': 'weeks',
        'D': 'days',
        'H': 'hours',
        'm': 'minutes',
        'S': 'seconds'
    };
    function parse(chunk, time) {
        function read(amount, part) {
            if (time && part == 'M') {
                part = 'm';
            }
            var mappedTo = mapping[part];
            if (typeof mappedTo == 'undefined') {
                throw Error('unknown duration specifier : ' + part);
            }
            values[mappedTo] = parseFloat(amount);
        }
        var next;
        while ((next = pattern.exec(chunk)) !== null) {
            read(next[1], next[2]);
        }
    }
    if (date !== null) {
        parse(date, false);
    }
    if (time !== null) {
        parse(time, true);
    }
    return values;
};

/**
 * Get a function for the provided duration that computes a new timestamp based on a
 * provided date and optional multiplier (negative for reverse).
 * @param {string} iso duration
 * @returns {function} offsetter(timestamp, multiplier=1)
 */
exports.createOffsetter = function(intervalOrDuration) {
    var duration = typeof intervalOrDuration === 'string' ? intervalOrDuration: intervalOrDuration.duration;
    var values = exports.isoDurationToMoment(duration);
    // as of writing, moment assumes y=365d and m=30d resulting in slow
    // day of month shifts that break ticks from matching
    // so we take care of this using a more accurate approach
    // ** the current approach breaks down if the day of month is greater than
    // 28 and day of month will no longer be retained (will shift)
    if ('years' in values || 'months' in values) {
        var years = values.years;
        var months = values.months;
        values.years = 0;
        values.months = 0;
        var millis = moment.duration(values).asMilliseconds();
        return function(ts, mult) {
            mult = mult || 1;
            var d = new Date(ts);
            /*jshint eqnull:true */
            var y = d.getUTCFullYear();
            if (years != null) {
                y += mult * years;
            }
            var m = d.getUTCMonth();
            if (months != null) {
                m += mult * months;
            }
            d.setUTCFullYear(y, m);
            return d.getTime() + (mult * millis);
        };
    } else {
        var offset = moment.duration(values).asMilliseconds();
        return function(ts, mult) {
            mult = mult || 1;
            return ts + (mult * offset);
        };
    }
};


/**
 * Contains implementations of Date.parse and date.toISOString that match the
 *     ECMAScript 5 specification for parsing RFC 3339 dates.
 *     http://tools.ietf.org/html/rfc3339
 */


/**
 * The regex to be used for validating dates. You can provide your own
 * regex for instance for adding support for years before BC. Default
 * value is: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/
 */
var dateRegEx = /^(-?)(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/;


/**
 * Generate a date object from a string.  The format for the string follows
 *     the profile of ISO 8601 for date and time on the Internet (see
 *     http://tools.ietf.org/html/rfc3339).  We don't call the native
 *     Date.parse because of inconsistency between implmentations.  In
 *     Chrome, calling Date.parse with a string that doesn't contain any
 *     indication of the timezone (e.g. "2011"), the date is interpreted
 *     in local time.  On Firefox, the assumption is UTC.
 *
 * Parameters:
 * str - {String} A string representing the date (e.g.
 *     "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z",
 *     "2010-08-07T11:58:23.123-06", "-3000-08-07T16:58:23.123Z").
 *
 * Returns:
 * {Date} A date object.  If the string could not be parsed, an invalid
 *     date is returned (i.e. isNaN(date.getTime())).
 */
parseDate = function(str) {
  var date;
  var match = str.match(dateRegEx);
  if (match && (match[2] || match[8])) { // must have at least year or time
    var year = parseInt(match[2], 10) || 0;
    if (match[1]){
      year = year * -1;
    }
    var month = (parseInt(match[3], 10) - 1) || 0;
    var day = parseInt(match[4], 10) || 1;
    date = new Date(Date.UTC(year, month, day));
    // optional time
    var type = match[8];
    if (type) {
      var hours = parseInt(match[5], 10);
      var minutes = parseInt(match[6], 10);
      var secFrac = parseFloat(match[7]);
      var seconds = secFrac | 0;
      var milliseconds = Math.round(1000 * (secFrac - seconds));
      date.setUTCHours(hours, minutes, seconds, milliseconds);
      // check offset
      if (type !== "Z") {
        var hoursOffset = parseInt(type, 10);
        var minutesOffset = parseInt(match[9], 10) || 0;
        var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);
        date = new Date(date.getTime() + offset);
      }
    }
  } else {
    date = new Date("invalid");
  }
  return date;
};

},{"moment":28}],12:[function(require,module,exports){
//'use strict';
exports.SLDStyleConverter = function() {
    return {
        generateStyle: function(style, layerName, asString) {
            var config = this.convertJSON(style, layerName);
            if (!this.context) {
                this.context = new owsjs.Jsonix.Context([owsjs.mappings.XLink_1_0, owsjs.mappings.Filter_1_0_0, owsjs.mappings.GML_2_1_2, owsjs.mappings.SLD_1_0_0], {
                    namespacePrefixes: {
                        'http://www.w3.org/1999/xlink': 'xlink',
                        'http://www.opengis.net/sld': 'sld',
                        'http://www.opengis.net/ogc': 'ogc'
                    }
                });
                this.marshaller = this.context.createMarshaller();
            }
            if (asString === true) {
                return this.marshaller.marshalString(config);
            } else {
                return this.marshaller.marshalDocument(config);
            }
        },
        createFill: function(style, styleRule) {
            return {
                cssParameter: [{
                    name: 'fill',
                    content: [(styleRule && styleRule.style.symbol.fillColor) ? styleRule.style.symbol.fillColor : style.symbol.fillColor]
                }, {
                    name: 'fill-opacity',
                    content: [String(styleRule ? (styleRule.style.symbol.fillOpacity || 100) / 100 : (style.symbol.fillOpacity || 100) / 100)]
                }]
            };
        },
        createStroke: function(style, styleRule) {
            var dashArray;
            if (style.stroke.strokeStyle === 'dashed') {
                dashArray = '5';
            } else if (style.stroke.strokeStyle ==='dotted') {
                dashArray = '1 2';
            }
            return {
                cssParameter: [{
                    name: 'stroke',
                    content: [(styleRule && styleRule.style.stroke.strokeColor) ? styleRule.style.stroke.strokeColor : style.stroke.strokeColor]
                }, {
                    name: 'stroke-width',
                    content: style.stroke.strokeWidth ? [String(style.stroke.strokeWidth)] : undefined
                }, {
                    name: 'stroke-opacity',
                    content: style.stroke.strokeOpacity ? [String(style.stroke.strokeOpacity / 100)] : undefined
                }, {
                    name: 'stroke-dasharray',
                    content: dashArray ? [dashArray] : undefined
                }]
            };
        },
        createPolygonSymbolizer: function(style, styleRule) {
            var fill = this.createFill(style, styleRule);
            var stroke = this.createStroke(style);
            var polygon = {
                name: {
                    localPart: 'PolygonSymbolizer',
                    namespaceURI: "http://www.opengis.net/sld"
                },
                value: {
                    fill: fill,
                    stroke: stroke
                }
            };
            return polygon;
        },
        createPointSymbolizer: function(style, styleRule) {
            var fill = this.createFill(style, styleRule); 
            var stroke = this.createStroke(style);
            var graphicOrMark;
            if (style.symbol && style.symbol.graphic) {
                var a = document.createElement("a");
                // @todo appending icon commons attributes should go elsewhere
                a.href = style.symbol.graphic + '?' +
                    'fill=' + encodeURIComponent((styleRule && styleRule.style.symbol.fillColor) ? styleRule.style.symbol.fillColor : style.symbol.fillColor) +
                    "&stroke=" + encodeURIComponent(style.stroke.strokeColor);
                graphicOrMark = [{
                        TYPE_NAME: "SLD_1_0_0.ExternalGraphic",
                        fill: fill,
                        stroke: stroke,
                        format: "image/svg+xml",
                        onlineResource: {
                            href: a.href
                        }
                    }];
            } else {
                graphicOrMark = [{
                        TYPE_NAME: "SLD_1_0_0.Mark",
                        fill: fill,
                        stroke: stroke,
                        wellKnownName: style.symbol && style.symbol.shape || 'circle'
                    }];
            }
            var opacity = 1;
            if (style.symbol && angular.isDefined(style.symbol.fillOpacity)) {
                opacity = Math.max(0.01, style.symbol.fillOpacity) / 100;
            }
            return {
                name: {
                    localPart: 'PointSymbolizer',
                    namespaceURI: "http://www.opengis.net/sld"
                },
                value: {
                    graphic: {
                        externalGraphicOrMark: graphicOrMark,
                        opacity: {
                            content: [String(opacity)]
                        },
                        size: {
                            content: [String(styleRule && styleRule.style.symbol && styleRule.style.symbol.size ||
                                  style.symbol && style.symbol.size || 10)]
                        },
                        rotation: style.symbol && style.symbol.rotationAttribute ? {
                            content: [style.symbol.rotationUnits === 'degrees' ? {
                                name: {
                                    localPart: "PropertyName",
                                    namespaceURI: "http://www.opengis.net/ogc"
                                },
                                value: {
                                    content: [style.symbol.rotationAttribute]
                                }
                            } : {
                                name: {
                                    localPart: "Div",
                                    namespaceURI: "http://www.opengis.net/ogc"
                                },
                                value: {
                                    expression: [{
                                        name: {
                                            localPart: "PropertyName",
                                            namespaceURI: "http://www.opengis.net/ogc"
                                        },
                                        value: {
                                            content: [style.symbol.rotationAttribute]
                                        }
                                    }, {
                                        name: {
                                            localPart: "Div",
                                            namespaceURI: "http://www.opengis.net/ogc"
                                        },
                                        value: {
                                            expression: [{
                                                name: {
                                                    localPart: "Function",
                                                    namespaceURI: "http://www.opengis.net/ogc"
                                                },
                                                value: {
                                                    name: "pi"
                                                }
                                            }, {
                                                name: {
                                                    localPart: "Literal",
                                                    namespaceURI: "http://www.opengis.net/ogc"
                                                },
                                                value: {
                                                    content: ["360"]
                                                }
                                            }]
                                        }
                                    }]
                                }
                            }]
                        } : undefined
                    }
                }
            };
        },
        createLineSymbolizer: function(style, styleRule) {
            return {
                name: {
                    localPart: 'LineSymbolizer',
                    namespaceURI: "http://www.opengis.net/sld"
                },
                value: {
                    stroke: this.createStroke(style, styleRule)
                }
            };
        },
        createTextSymbolizer: function(style) {
            var fontFamily;
            var styleFontFamily = style.label.fontFamily.toLowerCase();
            if (styleFontFamily === 'serif') {
                fontFamily  = 'Serif';
            } else if (styleFontFamily === 'sans-serif') {
                fontFamily = 'SansSerif';
            } else if (styleFontFamily === 'cursive') {
                fontFamily = 'Comic Sans MS';
            } else if (styleFontFamily === 'monospace') {
                fontFamily = 'Courier New';
            }
            return {
                name: {
                    localPart: 'TextSymbolizer',
                    namespaceURI: "http://www.opengis.net/sld"
                },
                value: {
                    fill: {
                        cssParameter: [{
                                name: 'fill',
                                content: [style.label.fillColor]
                            }]
                    },
                    halo: {
                        fill: {
                            cssParameter: [{
                                name: 'fill',
                                content: ['#FFFFFF']
                            }]
                        },
                        radius: {
                            content: ['1']
                        }
                    },
                    labelPlacement: {
                        linePlacement: {}
                    },
                    font: {
                        cssParameter: [{
                                name: 'font-family',
                                content: fontFamily ? [fontFamily]: undefined
                            }, {
                                name: 'font-size',
                                content: [String(style.label.fontSize)]
                            }, {
                                name: 'font-style',
                                content: [style.label.fontStyle]
                            }, {
                                name: 'font-weight',
                                content: [style.label.fontWeight]
                            }]
                    },
                    label: {
                        content: [{
                                name: {
                                    localPart: "PropertyName",
                                    namespaceURI: "http://www.opengis.net/ogc"
                                },
                                value: {
                                    content: [style.label.attribute]
                                }
                            }]
                    },
                    vendorOption: [{
                        name: 'maxDisplacement',
                        content: '40'
                    }, {
                        name: 'autoWrap',
                        content: '40'
                    }, {
                        name: 'spaceAround',
                        content: '0'
                    }, {
                        name: 'followLine',
                        content: 'false'
                    }, {
                        name: 'group',
                        content: 'yes'
                    }, {
                        name: 'goodnessOfFit',
                        content: '0.2'
                    }, {
                        name: 'conflictResolution',
                        content: 'true'
                    }]
                }
            };
        },
        convertJSON: function(style, layerName) {
            var result = {
                name: {
                    namespaceURI: 'http://www.opengis.net/sld',
                    localPart: 'StyledLayerDescriptor'
                }
            };
            result.value = {
                version: "1.0.0",
                namedLayerOrUserLayer: [{
                        TYPE_NAME: "SLD_1_0_0.NamedLayer",
                        name: layerName,
                        namedStyleOrUserStyle: [{
                                TYPE_NAME: "SLD_1_0_0.UserStyle",
                                featureTypeStyle: [{
                                        rule: []
                                    }]
                            }]
                    }]
            };
            var rule, ruleContainer = result.value.namedLayerOrUserLayer[0].namedStyleOrUserStyle[0].featureTypeStyle[0].rule;
            if (style.rules) {
                for (var i = 0, ii = style.rules.length; i < ii; ++i) {
                    var styleRule = style.rules[i];
                    var filter;
                    if (styleRule.value) {
                        filter = {
                            comparisonOps: {
                                name: {
                                    namespaceURI: "http://www.opengis.net/ogc",
                                    localPart: "PropertyIsEqualTo"
                                },
                                value: {
                                    expression: [{
                                            name: {
                                                namespaceURI: "http://www.opengis.net/ogc",
                                                localPart: "PropertyName"
                                            },
                                            value: {
                                                content: [style.classify.attribute]
                                            }
                                        }, {
                                            name: {
                                                namespaceURI: "http://www.opengis.net/ogc",
                                                localPart: "Literal"
                                            },
                                            value: {
                                                content: [String(styleRule.value)]
                                            }
                                        }]
                                }
                            }
                        };
                    } else if (styleRule.range) {
                        filter = {
                            comparisonOps: {
                                name: {
                                    namespaceURI: "http://www.opengis.net/ogc",
                                    localPart: "PropertyIsBetween"
                                },
                                value: {
                                    expression: {
                                        name: {
                                            namespaceURI: "http://www.opengis.net/ogc",
                                            localPart: "PropertyName"
                                        },
                                        value: {
                                            content: [style.classify.attribute]
                                        }
                                    },
                                    lowerBoundary: {
                                        expression: {
                                            name: {
                                                namespaceURI: "http://www.opengis.net/ogc",
                                                localPart: "Literal"
                                            },
                                            value: {
                                                content: [String(styleRule.range.min)]
                                            }
                                        }
                                    },
                                    upperBoundary: {
                                        expression: {
                                            name: {
                                                namespaceURI: "http://www.opengis.net/ogc",
                                                localPart: "Literal"
                                            },
                                            value: {
                                                content: [String(styleRule.range.max)]
                                            }
                                        }
                                    }
                                }
                            }
                        };
                    }
                    rule = {
                        title: styleRule.name,
                        name: styleRule.name,
                        filter: filter,
                        symbolizer: []
                    };
                    if (style.geomType === "point") {
                        rule.symbolizer.push(this.createPointSymbolizer(style, styleRule));
                    } else if (style.geomType === "line") {
                        rule.symbolizer.push(this.createLineSymbolizer(style, styleRule));
                    } else if (style.geomType === "polygon") {
                        rule.symbolizer.push(this.createPolygonSymbolizer(style, styleRule));
                    }
                    if (style.label && style.label.attribute !== null) {
                        rule.symbolizer.push(this.createTextSymbolizer(style));
                    }
                    ruleContainer.push(rule);
                }
            } else {
                // single rule, multiple symbolizers
                rule = {
                    symbolizer: []
                };
                ruleContainer.push(rule);
                if (style.geomType === 'point') {
                    rule.symbolizer.push(this.createPointSymbolizer(style));
                } else if (style.geomType === 'line') {
                    rule.symbolizer.push(this.createLineSymbolizer(style));
                } else if (style.geomType === 'polygon') {
                    rule.symbolizer.push(this.createPolygonSymbolizer(style));
                }
                if (style.label && style.label.attribute !== null) {
                    rule.symbolizer.push(this.createTextSymbolizer(style));
                }
            }
            return result;
        }
    };
};

},{}],13:[function(require,module,exports){
exports.StyleComplete = function() {
    return {
        isComplete: function(style) {
            if (style === undefined) {
                return false;
            }

            if (style.classify) {
                if (style.classify.method === "unique") {
                    if (style.classify.attribute === null || style.classify.maxClasses === null || !style.classify.colorPalette) {
                        return false;
                    }
                } else if (style.classify.method === null || style.classify.attribute === null || style.classify.colorRamp === null || style.rules.length === 0) {
                    return false;
                }
            }
            return true;
        }
    };
};

},{}],14:[function(require,module,exports){
//'use strict';

exports.WFSDescribeFeatureType = function() {

    this.parseResult = function(xml) {
        if (!this.context) {
            this.context = new owsjs.Jsonix.Context([
                owsjs.mappings.XSD_1_0
            ]);
            this.unmarshaller = this.context.createUnmarshaller();
        }
        var schema = this.unmarshaller.unmarshalString(xml).value;
        var featureNS = schema.targetNamespace;
        var element = schema.complexType[0].complexContent.extension.sequence.element;
        var fields = [];
        var geometryType, timeAttr;
        for (var i=0, ii=element.length; i<ii; ++i) {
            var el = element[i];
            if (el.type.namespaceURI === 'http://www.opengis.net/gml') {
                var lp = el.type.localPart;
                if (lp.indexOf('Polygon') !== -1) {
                    geometryType = 'polygon';
                } else if (lp.indexOf('LineString') !== -1) {
                    geometryType = 'line';
                } else if (lp.indexOf('Point') !== -1) {
                    geometryType = 'point';
                }
            } else if (el.type.localPart === 'dateTime') {
                if (timeAttr === undefined) {
                    timeAttr = el.name;
                } else {
                    timeAttr = null;
                }
            }
            fields.push({name: el.name, type: el.type.localPart, typeNS: el.type.namespaceURI});
        }
        return {
            timeAttribute: timeAttr,
            featureNS: featureNS,
            geomType: geometryType,
            attributes: fields
        };
    };

};

},{}],15:[function(require,module,exports){
//'use strict';

exports.WPSClassify = function() {

    this.parseResult = function(xml) {
        var doc = new DOMParser().parseFromString(xml, 'application/xml');
        var exceptions = doc.getElementsByTagNameNS('http://www.opengis.net/ows/1.1', 'ExceptionText');
        if (exceptions.length ===0) {
            var classes = doc.getElementsByTagName('Class');
            var rules = [];
            for (var i=0, ii=classes.length; i<ii; ++i) {
                var min = classes[i].getAttribute('lowerBound');
                var max = classes[i].getAttribute('upperBound');
                rules.push({
                    name: min + '-' + max,
                    range: {
                        min: min,
                        max: max
                    }
                });
            }
            return {
                success: true,
                rules: rules
            };
        } else {
            return {
                success: false,
                msg: exceptions[0].textContent
            };
        }
    };

    this.createContext = function() {
        this.context = new owsjs.Jsonix.Context([
            owsjs.mappings.XLink_1_0,
            owsjs.mappings.OWS_1_1_0,
            owsjs.mappings.Filter_1_1_0,
            owsjs.mappings.OWS_1_0_0,
            owsjs.mappings.SMIL_2_0,
            owsjs.mappings.SMIL_2_0_Language,
            owsjs.mappings.GML_3_1_1,
            owsjs.mappings.WFS_1_1_0,
            owsjs.mappings.WPS_1_0_0
        ], {
            namespacePrefixes: {
                'http://www.w3.org/1999/xlink': 'xlink',
                'http://www.opengis.net/wps/1.0.0': 'wps',
                'http://www.opengis.net/ows/1.1': 'ows',
                'http://www.opengis.net/wfs': 'wfs'
            }
        });
        this.marshaller = this.context.createMarshaller();
    };

    this.getUniqueValues = function(data, asString) {
        if (!this.context) {
            this.createContext();
        }
        var config = this.generateMainConfig('gs:Unique', "application/json", data);
        config.value.dataInputs.input.push({
            identifier: {
                value: 'attribute'
            },
            data: {
                literalData: {
                    value: data.attribute
                }
            }
        });
        if (asString === true) {
            return this.marshaller.marshalString(config);
        } else {
            return this.marshaller.marshalDocument(config);
        }
    };

    this.generateMainConfig = function(processId, mimeType, data) {
        return {
            name: {
                localPart: "Execute",
                namespaceURI: "http://www.opengis.net/wps/1.0.0"
            },
            value: {
                service: "WPS",
                version: "1.0.0",
                identifier: {
                    value: processId
                },
                responseForm: {
                    rawDataOutput: {
                        identifier: {
                            value: "results"
                        },
                        mimeType: mimeType
                    }
                },
                dataInputs: {
                    input: [{
                            identifier: {
                                value: 'features'
                            },
                            reference: {
                                method: 'POST',
                                mimeType: 'text/xml',
                                href: 'http://geoserver/wfs',
                                body: {
                                    content: [{
                                            name: {
                                                namespaceURI: "http://www.opengis.net/wfs",
                                                localPart: "GetFeature"
                                            },
                                            value: {
                                                outputFormat: "GML2",
                                                service: "WFS",
                                                version: "1.1.0",
                                                query: [{
                                                        typeName: [{ns: data.featureNS, lp: data.typeName.split(':')[1] || data.typeName, p: data.featurePrefix}]
                                                    }]
                                            }
                                        }]
                                }
                            }
                        }
                    ]
                }
            }
        };
    };

    this.classifyVector = function(data, asString) {
        if (!this.context) {
            this.createContext();
        }
        var config = this.generateMainConfig('vec:FeatureClassStats', undefined, data);
        config.value.dataInputs.input.push({
            identifier: {
                value: 'attribute'
            },
            data: {
                literalData: {
                    value: data.attribute
                }
            }
        }, {
            identifier: {
                value: 'classes'
            },
            data: {
                literalData: {
                    value: String(data.numClasses)
                }
            }
        }, {
            identifier: {
                value: 'method'
            },
            data: {
                literalData: {
                    value: data.method
                }
            }
        }, {
            identifier: {
                value: 'stats'
            },
            data: {
                literalData: {
                    value: 'mean' /* TODO currently we need to send at least 1 stats input */
                }
            }
        });
        if (asString === true) {
            return this.marshaller.marshalString(config);
        } else {
            return this.marshaller.marshalDocument(config);
        }
    };
};

},{}],16:[function(require,module,exports){
exports.MapConfigTransformer = function(data) {
    var layers = [], i, ii, mode = 'instant';
    // look for playback mode in tools
    if (data.tools) {
        for (i=0, ii=data.tools.length; i<ii; ++i) {
            var tool = data.tools[i];
            if (tool.ptype === "gxp_playback" && tool.outputConfig) {
                if (tool.outputConfig.playbackMode === 'cumulative') {
                    mode = 'cumulative';
                }
                // TODO other modes
            }
        }
    }
    for (i=0, ii=data.map.layers.length; i<ii; ++i) {
         var layer = data.map.layers[i];
         // TODO for the editor we also need the invisible layers
         if (layer.visibility === true) {
             var source = data.sources[layer.source];
             var layerConfig = {
                 visibility: layer.visibility,
                 group: layer.group
             };
             if (source.ptype === "gxp_mapquestsource") {
                 layerConfig.type = 'MapQuest';
                 layerConfig.layer = layer.name === 'naip' ? 'sat' : 'osm';
                 layerConfig.title = layer.title;
                 layers.push(layerConfig);
             } else if (source.ptype === "gxp_mapboxsource") {
                 layerConfig.type = 'MapBox';
                 layerConfig.name = layer.name;
                 layerConfig.title = layer.title;
                 layers.push(layerConfig);
             } else if (source.ptype === "gx_olsource" || source.ptype === "gxp_wmscsource") {
                 layerConfig.type = (source.ptype === "gx_olsource") ? layer.type.replace('OpenLayers.Layer.', '') : "WMS";
                 if (layerConfig.type === 'OSM') {
                     if (layerConfig.args && layerConfig.args[0] === 'Humanitarian OpenStreetMap') {
                         layerConfig.type = 'HOT';
                     }
                     layerConfig.title = layer.title;
                 } else if (layerConfig.type === 'WMS') {
                     var params;
                     if (source.ptype === "gx_olsource") {
                         params = layer.args[2] || {};
                         for (var key in params) {
                             if (params[key].constructor === Array) {
                                 params[key.toUpperCase()] = params[key].join(',');
                                 delete params[key];
                             }
                         }
                         layerConfig.url = layer.args[1];
                     } else {
                         params = {
                             LAYERS: layer.name,
                             STYLES: layer.styles,
                             TILED: 'TRUE',
                             FORMAT: layer.format || 'image/png',
                             TRANSPARENT: layer.transparent || 'TRUE'
                         };
                         if (layer.tiled === false) {
                             layerConfig.singleTile = true;
                         }
                         layerConfig.id = layer.name;
                         layerConfig.name = layer.name;
                         layerConfig.title = layer.titleAlias || layer.title;
                         layerConfig.maskings = layer.maskings;
                         // TODO not sure if this is the best place to do this?
                         layerConfig.url = source.url.replace('http://mapstory.org/geoserver/', '/geoserver/');
                     }
                     layerConfig.params = params;
                     layerConfig.params.VERSION = '1.1.1';
                     if (layer.capability) {
                         layerConfig.latlonBBOX = layer.capability.llbbox;
                         // TODO require dependency explicitly?
                         var times = storytools.core.time.maps.readCapabilitiesTimeDimensions(layer.capability, true);
                         if (times !== undefined) {
                             layerConfig.times = times;
                         }
                         // info for custom tileGrid
                         if (layer.capability.tileSets) {
                             for (var srs in layer.capability.tileSets[0].bbox) {
                                 var bbox = layer.capability.tileSets[0].bbox[srs].bbox;
                                 layerConfig.bbox = bbox;
                             }
                             layerConfig.resolutions = layer.capability.tileSets[0].resolutions;
                         }
                     }
                 }
                 layers.push(layerConfig);
             } else if (window.console) {
                 window.console.warn('Unknown source type in map config: ' + source.ptype);
             }
         }
     }
     return {
         id: data.id,
         playbackMode: mode,
         map: {
             center: data.map.center,
             projection: data.map.projection,
             zoom: data.map.zoom,
             layers: layers
         }
     };
};

},{}],17:[function(require,module,exports){
(function() {
  'use strict';

  var module = angular.module('storytools.core.ogc', [
  ]);

  // @todo - provisional default story pins style
  var defaultStyle = [new ol.style.Style({
    fill: new ol.style.Fill({color: 'rgba(255, 0, 0, 0.1)'}),
    stroke: new ol.style.Stroke({color: 'red', width: 1}),
    image: new ol.style.Circle({
      radius: 10,
      fill: new ol.style.Fill({color: 'rgba(255, 0, 0, 0.1)'}),
      stroke: new ol.style.Stroke({color: 'red', width: 1})
    })
  })];

  function StoryMap(data) {
    ol.Object.call(this, data);
    this.map_ = new ol.Map({target: data.target, pixelRatio: 1});
    this.overlay = new ol.FeatureOverlay({
      map: this.map_,
      style: defaultStyle
    });
    this.title = "Default Mapstory";
    this.abstract = "No Information Supplied.";
    this.owner = "";
    this.mode = "instant";
    this.returnToExtent = data.returnToExtent || false;
    this.center = [0,0];
    this.zoom = 2;
    this.storyLayers_ = new ol.Collection();
    this.animationDuration_ = data.animationDuration || 500;
    this.storyBoxesLayer = new StoryLayer({
      timeAttribute: 'start_time',
      endTimeAttribute: 'end_time',
      layer: new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: defaultStyle
      })
    });
    this.storyPinsLayer = new StoryLayer({
      timeAttribute: 'start_time',
      endTimeAttribute: 'end_time',
      layer: new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: defaultStyle
      })
    });
    this.addStoryPinsLayer();
    this.addStoryBoxesLayer();
  }

  StoryMap.prototype = Object.create(ol.Object.prototype);
  StoryMap.prototype.constructor = StoryMap;

  StoryMap.prototype.addStoryPinsLayer = function() {
    this.map_.addLayer(this.storyPinsLayer.getLayer());
  };

  StoryMap.prototype.addStoryBoxesLayer = function() {
    this.map_.addLayer(this.storyBoxesLayer.getLayer());
  };

  StoryMap.prototype.setStoryOwner = function(storyOwner) {
    this.owner =  storyOwner;
  };

  StoryMap.prototype.getStoryOwner = function() {
    return this.owner;
  };

  StoryMap.prototype.getCenter = function() {
    return this.center;
  };

  StoryMap.prototype.getZoom = function() {
    return this.zoom;
  };

  StoryMap.prototype.setStoryTitle = function(storyTitle) {
    this.title =  storyTitle;
  };

  StoryMap.prototype.setCenter = function(center) {
    this.center =  center;
  };

  StoryMap.prototype.setZoom = function(zoom) {
    this.zoom =  zoom;
  };

  StoryMap.prototype.setMode = function(playbackMode) {
    this.mode =  playbackMode;
  };

  StoryMap.prototype.setStoryAbstract = function(storyAbstract) {
    this.abstract =  storyAbstract;
  };


  StoryMap.prototype.getStoryTitle = function() {
    return this.title;
  };

  StoryMap.prototype.getStoryAbstract = function() {
    return this.abstract;
  };

  StoryMap.prototype.setBaseLayer = function(baseLayer) {
    this.set('baselayer', baseLayer);
    this.map_.getLayers().forEach(function(lyr) {
      if (lyr.get('group') === 'background') {
        this.map_.removeLayer(lyr);
      }
    }, this);
    this.map_.getLayers().insertAt(0, this.get('baselayer'));
  };

  StoryMap.prototype.addStoryLayer = function(storyLayer) {
    storyLayer.storyMap_ = this;
    this.storyLayers_.push(storyLayer);
    // keep pins layer on top
    var idx = this.map_.getLayers().getLength(), me = this;
    this.map_.getLayers().forEach(function(sl) {
      if (sl === me.storyPinsLayer) {
        idx -= 1;
      }
    });
    this.map_.getLayers().insertAt(
          idx,
          storyLayer.getLayer()
    );
  };

  StoryMap.prototype.getStoryLayers = function() {
    return this.storyLayers_;
  };

  StoryMap.prototype.getMap = function() {
    return this.map_;
  };

  StoryMap.prototype.clear = function() {
    this.map_.getLayers().clear();
    this.storyLayers_.clear();
    this.addStoryPinsLayer();
  };

  StoryMap.prototype.animatePanAndBounce = function(center, zoom){

    var duration = 2000;
    var start = +new Date();

    var view = this.map_.getView();

    if(view.getCenter() != center){

      var pan = ol.animation.pan({
        duration: this.animationDuration_,
        source: view.getCenter(),
        start: start
      });


      var bounce = ol.animation.bounce({
        duration: duration,
        resolution: 2 * view.getResolution(),
        start: start
      });

      this.map_.beforeRender(pan, bounce);

      view.setCenter(center);
      view.setZoom(zoom);
    }
  };

  StoryMap.prototype.animateCenterAndZoom = function(center, zoom) {
    var view = this.map_.getView();
    if (view.getCenter() !== center || view.getZoom() !== zoom) {
      this.map_.beforeRender(ol.animation.pan({
        duration: this.animationDuration_,
        source: view.getCenter()
      }));
      view.setCenter(center);
      this.map_.beforeRender(ol.animation.zoom({
        resolution: view.getResolution(),
        duration: this.animationDuration_
      }));
      view.setZoom(zoom);
    }
  };

  StoryMap.prototype.setAllowPan = function(allowPan) {
    this.map_.getInteractions().forEach(function(i) {
      if (i instanceof ol.interaction.KeyboardPan ||
            i instanceof ol.interaction.DragPan) {
        i.setActive(allowPan);
      }
    });
  };

  StoryMap.prototype.setAllowZoom = function(allowZoom) {
    var zoomCtrl;
    this.map_.getControls().forEach(function(c) {
      if (c instanceof ol.control.Zoom) {
        zoomCtrl = c;
      }
    });
    if (!allowZoom) {
      this.map_.removeControl(zoomCtrl);
    } else {
      this.map_.addControl(new ol.control.Zoom());
    }
    this.map_.getInteractions().forEach(function(i) {
      if (i instanceof ol.interaction.DoubleClickZoom ||
            i instanceof ol.interaction.PinchZoom ||
            i instanceof ol.interaction.DragZoom ||
            i instanceof ol.interaction.MouseWheelZoom) {
        i.setActive(allowZoom);
      }
    });
  };

  module.constant('StoryMap', StoryMap);

  function EditableStoryMap(data) {
    StoryMap.call(this, data);
  }

  EditableStoryMap.prototype = Object.create(StoryMap.prototype);
  EditableStoryMap.prototype.constructor = EditableStoryMap;

  module.constant('EditableStoryMap', EditableStoryMap);

  EditableStoryMap.prototype.getState = function() {
    var config = {};
    config.map = {
      center: this.map_.getView().getCenter(),
      projection: this.map_.getView().getProjection().getCode(),
      zoom: this.map_.getView().getZoom(),
      layers: []
    };
    var mapId = this.get('id');
    if (mapId >= 0) {
      config.id = mapId;
    }
    var baseLayer = this.get('baselayer');
    if (baseLayer) {
      var baseLayerState = this.get('baselayer').get('state');
      baseLayerState.group = 'background';
      baseLayerState.visibility = true;
      config.map.layers.push(baseLayerState);
    }
    this.storyLayers_.forEach(function(storyLayer) {
      config.map.layers.push(storyLayer.getState());
    });
    return config;
  };

  EditableStoryMap.prototype.removeStoryLayer = function(storyLayer) {
    this.storyLayers_.remove(storyLayer);
    this.map_.removeLayer(storyLayer.getLayer());
  };

  function StoryLayer(data) {
    if (data.times && storytools.core.time.utils.isRangeLike(data.times)) {
      data.times = new storytools.core.time.utils.Interval(data.times);
    }
    ol.Object.call(this, data);
    var layer;
    if (this.get('type') === 'VECTOR') {
      layer = new ol.layer.Vector({source: new ol.source.Vector()});
    } else if (this.get('type') === 'HEATMAP') {
      layer = new ol.layer.Heatmap({
        radius: data.style.radius,
        opacity: data.style.opacity,
        source: new ol.source.Vector()
      });
    } else if (this.get('type') === 'WMS') {
      var config = {
        useOldAsInterimTiles: true
      };
      if (this.get('singleTile') === true) {
        layer = new ol.layer.Image(config);
      } else {
        layer = new ol.layer.Tile(config);
      }
    } else {
      layer = data.layer;
    }
    this.layer_ = layer;
  }

  StoryLayer.prototype = Object.create(ol.Object.prototype);
  StoryLayer.prototype.constructor = StoryLayer;

  StoryLayer.prototype.getStoryMap = function() {
    return this.storyMap_;
  };

  StoryLayer.prototype.setWMSSource = function() {
    var layer = this.getLayer();
    var name = this.get('name');
    var times = this.get('times');
    var singleTile = this.get('singleTile');
    var params = this.get('params') || {
            'LAYERS': name,
            'VERSION': '1.1.0',
            'TILED': true
          };
    if (times) {
      params.TIME = new Date(times.start || times[0]).toISOString();
    }
    if (singleTile) {
      layer.setSource(new ol.source.ImageWMS({
        params: params,
        url: this.get('url'),
        serverType: 'geoserver'
      }));
    } else {
      var tileGrid, resolutions = this.get('resolutions'),
            bbox = this.get('bbox');
      if (resolutions && bbox) {
        tileGrid = new ol.tilegrid.TileGrid({
          extent: bbox,
          resolutions: resolutions
        });
      }
      // @todo use urls for subdomain loading
      layer.setSource(new ol.source.TileWMS({
        url: this.get('url'),
        params: params,
        tileGrid: tileGrid,
        serverType: 'geoserver'
      }));
    }
  };

  StoryLayer.prototype.getState = function() {
    var state = this.getProperties();
    delete state.features;
    return state;
  };

  StoryLayer.prototype.getLayer = function() {
    return this.layer_;
  };

  StoryLayer.prototype.setLayer = function(layer) {
    if (this.layer_ && this.storyMap_) {
      var map = this.storyMap_.map_;
      var idx = map.getLayers().getArray().indexOf(this.layer_);
      map.getLayers().setAt(idx, layer);
    }
    this.layer_ = layer;
  };

  module.constant('StoryLayer', StoryLayer);

  function EditableStoryLayer(data) {
    StoryLayer.call(this, data);
  }

  EditableStoryLayer.prototype = Object.create(StoryLayer.prototype);
  EditableStoryLayer.prototype.constructor = EditableStoryLayer;

  module.constant('EditableStoryLayer', EditableStoryLayer);

  module.service('stAnnotateLayer', function($http, $q) {
    return {
      loadCapabilities: function(storyLayer) {
        var request = 'GetCapabilities', service = 'WMS';
        // always use the virtual service for GetCapabilities
        var url = storyLayer.get('url');
        if (url === '/geoserver/wms') {
          var name = storyLayer.get('name');
          var parts = name.split(':');
          url = url.replace('/geoserver', '/geoserver/' + parts[0] + '/' + parts[1]);
        }
        url = url.replace('http:', '');

        return $http({
          method: 'GET',
          url: url,
          params: {
            'REQUEST': request,
            'SERVICE': service,
            'VERSION': '1.1.1',
            'TILED': true
          }
        }).success(function(data) {
          var context = new owsjs.Jsonix.Context([
            owsjs.mappings.WMSC_1_1_1
          ]);
          var unmarshaller = context.createUnmarshaller();
          var caps = unmarshaller.unmarshalString(data);
          var layer = caps.value.capability.layer;
          storyLayer.set('latlonBBOX', [
            parseFloat(layer.latLonBoundingBox.minx),
            parseFloat(layer.latLonBoundingBox.miny),
            parseFloat(layer.latLonBoundingBox.maxx),
            parseFloat(layer.latLonBoundingBox.maxy)
          ]);
          var vendorSpecificCapabilities = caps.value.capability.vendorSpecificCapabilities;
          var tileSets = (vendorSpecificCapabilities)? vendorSpecificCapabilities.tileSet: [];
          for (var i=0, ii=tileSets.length; i<ii; ++i) {
            if (tileSets[i].srs === 'EPSG:900913') {
              storyLayer.set('resolutions', tileSets[i].resolutions.split(' '));
              var bbox = tileSets[i].boundingBox;
              storyLayer.set('bbox', [
                parseFloat(bbox.minx),
                parseFloat(bbox.miny),
                parseFloat(bbox.maxx),
                parseFloat(bbox.maxy)
              ]);
              break;
            }
          }
          var found = storytools.core.time.maps.readCapabilitiesTimeDimensions(caps);
          var name = storyLayer.get('name');
          if (name in found) {
            storyLayer.set('times', found[name]);
          }
        });
      },
      describeFeatureType: function(storyLayer) {
        var me = this;
        var request = 'DescribeFeatureType', service = 'WFS';
        var id = storyLayer.get('id');
        return $http({
          method: 'GET',
          url: storyLayer.get('url').replace('http:', ''),
          params: {
            'SERVICE': service,
            'VERSION': '1.0.0',
            'REQUEST': request,
            'TYPENAME': id
          }
        }).success(function(data) {
          var parser = new storytools.edit.WFSDescribeFeatureType.WFSDescribeFeatureType();
          var layerInfo = parser.parseResult(data);
          if (layerInfo.timeAttribute) {
            storyLayer.set('timeAttribute', layerInfo.timeAttribute);
          } else if (storyLayer.get('timeEndpoint')) {
            me.getTimeAttribute(storyLayer);
          }
          var parts = id.split(':');
          storyLayer.set('typeName', id);
          storyLayer.set('featurePrefix', parts[0]);
          storyLayer.set('featureNS', layerInfo.featureNS);
          storyLayer.set('geomType', layerInfo.geomType);
          storyLayer.set('attributes', layerInfo.attributes);
        });
      },
      getTimeAttribute: function(storyLayer) {
        var me = this;
        return $http({
          method: 'GET',
          url: storyLayer.get('timeEndpoint')
        }).success(function(data) {
          storyLayer.set('timeAttribute', data.attribute);
          if (data.endAttribute) {
            storyLayer.set('endTimeAttribute', data.endAttribute);
          }
        });
      },
      getStyleName: function(storyLayer) {
        if (storyLayer.get('canStyleWMS')) {
          var me = this;
          return $http({
            method: 'GET',
            url: storyLayer.get('path') + 'rest/layers/' + storyLayer.get('id') + '.json'
          }).success(function(response) {
            storyLayer.set('styleName', response.layer.defaultStyle.name);
          });
        } else {
          return $q.when('');
        }
      },
      getFeatures: function(storyLayer, map) {
        var name = storyLayer.get('id');
        var wfsUrl = storyLayer.get('url') + '?service=WFS&version=1.1.0&request=GetFeature&typename=' +
              name + '&outputFormat=application/json' +
              '&srsName=' + map.getView().getProjection().getCode();
        return $http({
          method: 'GET',
          url: wfsUrl
        }).success(function(response) {
          var layer = storyLayer.getLayer();
          var features = new ol.format.GeoJSON().readFeatures(response);
          storyLayer.set('features', features);
        });
      }
    };
  });

  module.service('stBaseLayerBuilder', function() {
    return {
      buildLayer: function(data) {
        if (data.type === 'MapQuest') {
          return new ol.layer.Tile({
            state: data,
            title: data.title,
            group: 'background',
            source: new ol.source.MapQuest({layer: data.layer})
          });
        } else if (data.type === 'ESRI') {
          return new ol.layer.Tile({
            source: new ol.source.XYZ({
              attributions: [
                new ol.Attribution({
                  html: 'Tiles &copy; <a href="http://services.arcgisonline.com/ArcGIS/' +
                  'rest/services/World_Topo_Map/MapServer">ArcGIS</a>'
                })
              ],
              url: 'http://server.arcgisonline.com/ArcGIS/rest/services/' +
              'World_Topo_Map/MapServer/tile/{z}/{y}/{x}'
            })
          });
        }else if (data.type === 'HOT') {
          return new ol.layer.Tile({
            state: data,
            title: data.title,
            group: 'background',
            source: new ol.source.OSM({
              attributions: [
                new ol.Attribution({
                  html: 'Tiles courtesy of <a href="//hot.openstreetmap.org/" target="_blank">Humanitarian OpenStreetMap Team</a>'
                }),
                ol.source.OSM.ATTRIBUTION
              ],
              crossOrigin: null,
              url: '//{a-c}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png'
            })
          });
        } else if (data.type === 'OSM') {
          return new ol.layer.Tile({
            state: data,
            title: data.title,
            group: 'background',
            source: new ol.source.OSM()
          });
        } else if (data.type === 'MapBox') {
          var layer = new ol.layer.Tile({state: data, title: data.title, group: 'background'});
          var name = data.name;
          var urls = [
            '//a.tiles.mapbox.com/v1/mapbox.',
            '//b.tiles.mapbox.com/v1/mapbox.',
            '//c.tiles.mapbox.com/v1/mapbox.',
            '//d.tiles.mapbox.com/v1/mapbox.'
          ];
          var tileUrlFunction = function(tileCoord, pixelRatio, projection) {
            var zxy = tileCoord;
            if (zxy[1] < 0 || zxy[2] < 0) {
              return "";
            }
            return urls[Math.round(Math.random()*3)] + name + '/' +
                  zxy[0].toString()+'/'+ zxy[1].toString() +'/'+
                  zxy[2].toString() +'.png';
          };
          layer.setSource(new ol.source.TileImage({
            crossOrigin: null,
            attributions: [
              new ol.Attribution({
                html: /^world/.test(name) ?
                      "<a href='//mapbox.com'>MapBox</a> | Some Data &copy; OSM CC-BY-SA | <a href='//mapbox.com/tos'>Terms of Service</a>" :
                      "<a href='//mapbox.com'>MapBox</a> | <a href='//mapbox.com/tos'>Terms of Service</a>"
              })
            ],
            tileGrid: new ol.tilegrid.TileGrid({
              origin: [-128 * 156543.03390625, -128 * 156543.03390625],
              resolutions: [
                156543.03390625, 78271.516953125, 39135.7584765625,
                19567.87923828125, 9783.939619140625, 4891.9698095703125,
                2445.9849047851562, 1222.9924523925781, 611.4962261962891,
                305.74811309814453, 152.87405654907226, 76.43702827453613,
                38.218514137268066, 19.109257068634033, 9.554628534317017,
                4.777314267158508, 2.388657133579254, 1.194328566789627,
                0.5971642833948135
              ]
            }),
            tileUrlFunction: tileUrlFunction
          }));
          return layer;
        } else if (data.type === 'WMS') {
          return new ol.layer.Tile({
            group: "background",
            source: new ol.source.TileWMS({
              url: data.url,
              params: data.params
            })
          });
        } else {
          throw new Error('no type for : ' + JSON.stringify(data));
        }
      }
    };
  });

  module.service('stEditableLayerBuilder', function($q, stAnnotateLayer, stBaseLayerBuilder) {
    return {
      buildEditableLayer: function(data, map) {
        var layer = new EditableStoryLayer(data);
        var deferred = $q.defer();
        var promises = [];
        // TODO add this back when we have WMS-C GetCaps
        var needsCaps = !(data.latlonBBOX && data.times/* && data.bbox && data.resolutions*/);
        if (needsCaps) {
          promises.push(stAnnotateLayer.loadCapabilities(layer));
        }
        var needsDFT = !data.attributes;
        if (needsDFT) {
          promises.push(stAnnotateLayer.describeFeatureType(layer));
        }
        if ((data.type === 'VECTOR' || data.type === 'HEATMAP') && !data.features) {
          promises.push(stAnnotateLayer.getFeatures(layer, map));
        } else {
          promises.push(stAnnotateLayer.getStyleName(layer));
        }
        $q.all(
              promises
        ).then(function() {
                // this needs to be done here when everything is resolved
                if (layer.get('features')) {
                  var times = layer.get('times');
                  if (times) {
                    var start = times.start || times[0];
                    storytools.core.time.maps.filterVectorLayer(layer, {start: start, end: start});
                  } else {
                    layer.getLayer().getSource().addFeatures(layer.get('features'));
                  }
                } else {
                  layer.setWMSSource();
                }
                deferred.resolve(layer);
              }, function() {
                deferred.reject(arguments);
              });
        return deferred.promise;
      }
    };
  });

  module.service('stLayerBuilder', function($q) {
    return {
      buildLayer: function(data, map) {
        var layer = new StoryLayer(data);
        var deferred = $q.defer();
        layer.setWMSSource();
        deferred.resolve(layer);
        return deferred.promise;
      }
    };
  });

  module.service('stStoryMapBaseBuilder', function(stBaseLayerBuilder) {
    return {
      defaultMap: function(storymap) {
        storymap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
        this.setBaseLayer(storymap, {
          title: 'World Topo Map',
          type: 'ESRI',
          name: 'world-topo-map'
        });
      },
      setBaseLayer: function(storymap, data) {
        var baseLayer = stBaseLayerBuilder.buildLayer(data);
        storymap.setBaseLayer(baseLayer);
      }
    };
  });

  module.service('stStoryMapBuilder', function(stLayerBuilder, stStoryMapBaseBuilder) {
    return {
      modifyStoryMap: function(storymap, data) {
        storymap.clear();
        var mapConfig = storytools.mapstory.MapConfigTransformer.MapConfigTransformer(data);
        if (mapConfig.id >= 0) {
          storymap.set('id', mapConfig.id);
          storymap.setMode(mapConfig.playbackMode);
          if (data.about !== undefined){
            storymap.setStoryTitle(data.about.title);
            storymap.setStoryAbstract(data.about.abstract);
            storymap.setStoryOwner(data.about.owner);
          }

          storymap.setCenter(mapConfig.map.center);
          storymap.setZoom(mapConfig.map.zoom);
        }
        for (var i = 0, ii = mapConfig.map.layers.length; i < ii; ++i) {
          var layerConfig = mapConfig.map.layers[i];
          if (layerConfig.group === 'background' && layerConfig.visibility === true) {
            stStoryMapBaseBuilder.setBaseLayer(storymap, layerConfig);
          } else {
            /*jshint loopfunc: true */
            stLayerBuilder.buildLayer(layerConfig, storymap.getMap()).then(function(sl) {
              // TODO insert at the correct index
              storymap.addStoryLayer(sl);
            });
          }
        }
        storymap.getMap().setView(new ol.View({
          center: mapConfig.map.center,
          zoom: mapConfig.map.zoom,
          minZoom: 3,
          maxZoom: 17
        }));
      }
    };
  });

  module.service('stEditableStoryMapBuilder', function(stStoryMapBaseBuilder, stEditableLayerBuilder) {
    return {
      modifyStoryLayer: function(storylayer, newType) {
        var data = storylayer.getProperties();
        var storymap = storylayer.getStoryMap();
        data.type = newType ? newType : ((data.type === 'WMS') ? 'VECTOR' : 'WMS');
        if (data.type === 'WMS') {
          delete data.features;
        }
        stEditableLayerBuilder.buildEditableLayer(data, storymap.getMap()).then(function(sl) {
          // sequence is important here, first change layer, then the type.
          storylayer.setLayer(sl.getLayer());
          storylayer.set('type', sl.get('type'));
        });
      },
      modifyStoryMap: function(storymap, data) {
        storymap.clear();
        var mapConfig = storytools.mapstory.MapConfigTransformer.MapConfigTransformer(data);
        if (mapConfig.id >= 0) {
          storymap.set('id', mapConfig.id);
          storymap.setMode(mapConfig.playbackMode);
          if (data.about !== undefined){
            storymap.setStoryTitle(data.about.title);
            storymap.setStoryAbstract(data.about.abstract);
            storymap.setStoryOwner(data.about.owner);
          }
        }
        for (var i = 0, ii = mapConfig.map.layers.length; i < ii; ++i) {
          var layerConfig = mapConfig.map.layers[i];
          if (layerConfig.group === 'background' && layerConfig.visibility === true) {
            stStoryMapBaseBuilder.setBaseLayer(storymap, layerConfig);
          } else {
            /*jshint loopfunc: true */
            stEditableLayerBuilder.buildEditableLayer(layerConfig, storymap.getMap()).then(function(sl) {
              // TODO insert at the correct index
              storymap.addStoryLayer(sl);
            });
          }
        }
        storymap.getMap().setView(new ol.View({
          center: mapConfig.map.center,
          zoom: mapConfig.map.zoom,
          projection: mapConfig.map.projection,
          minZoom: 3,
          maxZoom: 17
        }));
      }
    };
  });

})();

},{}],18:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.core.pins', [
    ]);

    var pins = storytools.core.maps.pins;

    function StoryPinLayerManager() {
        this.storyPins = [];
        this.map = null;
    }
    StoryPinLayerManager.prototype.pinsChanged = function(pins, action) {
        var i;
        if (action == 'delete') {
            for (i = 0; i < pins.length; i++) {
                var pin = pins[i];
                for (var j = 0, jj = this.storyPins.length; j < jj; j++) {
                    if (this.storyPins[j].id == pin.id) {
                        this.storyPins.splice(j, 1);
                        break;
                    }
                }
            }
        } else if (action == 'add') {
            for (i = 0; i < pins.length; i++) {
                this.storyPins.push(pins[i]);
            }
        } else if (action == 'change') {
            // provided edits could be used to optimize below
        } else {
            throw new Error('action? :' + action);
        }
        // @todo optimize by looking at changes
        var times = this.storyPins.map(function(p) {
            if (p.start_time > p.end_time) {
                return storytools.core.utils.createRange(p.end_time, p.start_time);
            } else {
                return storytools.core.utils.createRange(p.start_time, p.end_time);
            }
        });
        this.map.storyPinsLayer.set('times', times);
        this.map.storyPinsLayer.set('features', this.storyPins);
    };
    StoryPinLayerManager.prototype.loadFromGeoJSON = function(geojson, projection, overwrite) {

        if (overwrite){
            this.storyPins = [];
        }

        if (geojson && geojson.features) {
            var loaded = pins.loadFromGeoJSON(geojson, projection);
            this.pinsChanged(loaded, 'add', true);
        }
    };

    module.service('StoryPinLayerManager', StoryPinLayerManager);

    module.constant('StoryPin', pins.StoryPin);

    // @todo naive implementation on local storage for now
    module.service('stAnnotationsStore', function(StoryPinLayerManager) {
        function path(mapid) {
            return '/maps/' + mapid + '/annotations';
        }
        function get(mapid) {
            var saved = localStorage.getItem(path(mapid));
            saved = (saved === null) ? [] : JSON.parse(saved);
            // TODO is this still needed?
            /*saved.forEach(function(s) {
                s.the_geom = format.readGeometry(s.the_geom);
            });*/
            return saved;
        }
        function set(mapid, annotations) {
            // TODO is this still needed?
            /*annotations.forEach(function(s) {
                if (s.the_geom && !angular.isString(s.the_geom)) {
                    s.the_geom = format.writeGeometry(s.the_geom);
                }
            });*/
            localStorage.setItem(path(mapid),
                new ol.format.GeoJSON().writeFeatures(annotations,
                    {dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'})
            );
        }
        return {
            loadAnnotations: function(mapid, projection) {
                return StoryPinLayerManager.loadFromGeoJSON(get(mapid), projection);
            },
            deleteAnnotations: function(annotations) {
                var saved = get();
                var toDelete = annotations.map(function(d) {
                    return d.id;
                });
                saved = saved.filter(function(s) {
                    return toDelete.indexOf(s.id) < 0;
                });
                set(saved);
            },
            saveAnnotations: function(mapid, annotations) {
                var saved = get();
                var maxId = 0;
                saved.forEach(function(s) {
                    maxId = Math.max(maxId, s.id);
                });
                var clones = [];
                annotations.forEach(function(a) {
                    if (typeof a.id == 'undefined') {
                        a.id = ++maxId;
                    }
                    var clone = a.clone();
                    if (a.get('start_time') !== undefined) {
                        clone.set('start_time', a.get('start_time')/1000);
                    }
                    if (a.get('end_time') !== undefined) {
                        clone.set('end_time', a.get('end_time')/1000);
                    }
                    clones.push(clone);
                });
                set(mapid, clones);
            }
        };
    });

})();

},{}],19:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.core.style.ol3StyleConverter', []);

    module.factory('ol3MarkRenderer', function(ol3StyleConverter) {
        return function(shapeName, size) {
            var black = ol3StyleConverter.getColor('#000000');
            var strokeWidth = 3; // hack to fix down-scaling for x and cross
            var opts = {color: black, width: strokeWidth};
            var canvas = angular.element(ol3StyleConverter.generateShape({
                    symbol: {shape: shapeName, size: size - strokeWidth}
                },
                new ol.style.Fill(opts),
                new ol.style.Stroke(opts)).getImage());
            return canvas;
        };
    });

    module.factory('ol3StyleConverter', function(stSvgIcon) {
        return {
            generateShapeConfig: function(style, fill, stroke) {
                var shape = style.symbol.shape,
                    // final size is actually (2 * (radius + stroke.width)) + 1
                    radius = style.symbol.size / 2;
                if (shape === 'circle') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        radius: radius
                    };
                } else if (shape === 'square') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 4,
                        radius: radius,
                        angle: Math.PI / 4
                    };
                } else if (shape === 'triangle') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 3,
                        radius: radius,
                        angle: 0
                    };
                } else if (shape === 'star') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 5,
                        radius: radius,
                        radius2: 0.5*radius,
                        angle: 0
                    };
                } else if (shape === 'cross') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 4,
                        radius: radius,
                        radius2: 0,
                        angle: 0
                    };
                } else if (shape === 'x') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 4,
                        radius: radius,
                        radius2: 0,
                        angle: Math.PI / 4
                    };
                }
            },
            calculateRotation: function(style, feature) {
                if (style.symbol && style.symbol.rotationAttribute) {
                    if (style.symbol.rotationUnits === 'radians') {
                        return feature.get(style.symbol.rotationAttribute);
                    } else {
                        return (feature.get(style.symbol.rotationAttribute)/360)*Math.PI;
                    }
                } else {
                    return undefined;
                }
            },
            generateShape: function(style, fill, stroke, feature) {
                var config = this.generateShapeConfig(style, fill, stroke);
                if (config && feature) {
                    config.rotation = this.calculateRotation(style, feature);
                }
                if (style.symbol.graphic) {
                    var info = stSvgIcon.getImage(style.symbol.graphic, fill.getColor(), stroke.getColor(), true);
                    return new ol.style.Icon({
                        src: info.dataURI,
                        rotation: this.calculateRotation(style, feature),
                        scale: style.symbol.size / Math.max(info.width, info.height),
                        opacity: style.symbol.opacity
                    });
                } else if (style.symbol.shape === 'circle') {
                    return new ol.style.Circle(config);
                } else {
                    return new ol.style.RegularShape(config);
                }
            },
            getText: function(style, feature) {
                if (style.label && style.label.attribute) {
                    return '' + feature.get(style.label.attribute);
                } else {
                    return undefined;
                }
            },
            generateText: function(style, stroke, feature) {
                if (style.label && style.label.attribute !== null) {
                    return new ol.style.Text({
                        fill: new ol.style.Fill({color: style.label.fillColor}),
                        stroke: stroke,
                        font: style.label.fontStyle + ' ' + style.label.fontWeight + ' ' + style.label.fontSize + 'px ' + style.label.fontFamily,
                        text: this.getText(style, feature)
                    });
                }
            },
            getColor: function(color, opacity) {
                var rgba = ol.color.asArray(color);
                if (opacity !== undefined) {
                    rgba = rgba.slice();
                    rgba[3] = opacity/100;
                }
                return 'rgba(' + rgba.join(',') + ')';
            },
            generateCacheKey: function(style, feature) {
                var text = this.getText(style, feature);
                var classify = (style.classify && style.classify.attribute) ? feature.get(style.classify.attribute) : undefined;
                var rotation = (style.symbol && style.symbol.rotationAttribute) ? feature.get(style.symbol.rotationAttribute): undefined;
                return text + '|' + classify + '|' + rotation;
            },
            generateStyle: function(style, feature, resolution) {
                var result, key2;
                if (!this.styleCache_) {
                    this.styleCache_ = {};
                }
                var key = JSON.stringify(style);
                if (this.styleCache_[key]) {
                    if (!this.styleCache_[key].length) {
                        key2 = this.generateCacheKey(style, feature);
                        if (this.styleCache_[key][key2]) {
                            return this.styleCache_[key][key2];
                        }
                    } else {
                        return this.styleCache_[key];
                    }
                }
                var stroke;
                if (style.stroke) {
                    var lineDash;
                    if (style.stroke.strokeStyle === 'dashed') {
                        lineDash = [5];
                    } else if (style.stroke.strokeStyle === 'dotted') {
                        lineDash = [1,2];
                    }
                    stroke = new ol.style.Stroke({
                        lineDash: lineDash,
                        color: this.getColor(style.stroke.strokeColor, style.stroke.strokeOpacity),
                        width: style.stroke.strokeWidth
                    });
                }
                if (style.classify && style.classify.attribute !== null) {
                    var label;
                    for (var i=0, ii=style.rules.length; i<ii; ++i) {
                        var rule = style.rules[i];
                        var attrVal = feature.get(style.classify.attribute);
                        var match = false;
                        if (rule.value !== undefined) {
                            match = attrVal === rule.value;
                        } else if (rule.range) {
                            match = (attrVal >= rule.range.min && attrVal <= rule.range.max);
                        }
                        if (match) {
                            label = this.generateText(style, stroke, feature);
                            if (style.geomType === 'point' && rule.style.symbol.fillColor) {
                                result = [new ol.style.Style({
                                    text: label,
                                    image: this.generateShape(style, new ol.style.Fill({color: rule.style.symbol.fillColor}), stroke, feature)
                                })];
                            } else if (style.geomType === 'line' && rule.style.stroke.strokeColor) {
                                result = [new ol.style.Style({
                                    text: label,
                                    stroke: new ol.style.Stroke({
                                        color: rule.style.stroke.strokeColor,
                                        width: 2
                                    })
                                })];
                            } else if (style.geomType === 'polygon' && rule.style.symbol.fillColor) {
                                result = [new ol.style.Style({
                                    text: label,
                                    stroke: stroke,
                                    fill: new ol.style.Fill({
                                        color: rule.style.symbol.fillColor
                                    })
                                })];
                            }
                        }
                    }
                    if (result) {
                        if (!this.styleCache_[key]) {
                            this.styleCache_[key] = {};
                        }
                        key2 = this.generateCacheKey(style, feature);
                        this.styleCache_[key][key2] = result;
                    }
                } else {
                    var fill = new ol.style.Fill({
                        color: this.getColor(style.symbol.fillColor, style.symbol.fillOpacity)
                    });
                    result = [
                        new ol.style.Style({
                            image: this.generateShape(style, fill, stroke, feature),
                            fill: fill,
                            stroke: stroke,
                            text: this.generateText(style, stroke, feature)
                        })
                    ];
                }
                if (result) {
                    var hasText = result[0].getText();
                    if (hasText || (style.classify && style.classify.attribute) || (style.symbol && style.symbol.rotationAttribute)) {
                        if (!this.styleCache_[key]) {
                            this.styleCache_[key] = {};
                        }
                        key2= this.generateCacheKey(style, feature);
                        this.styleCache_[key][key2] = result;
                    } else {
                        this.styleCache_[key] = result;
                    }
                }
                return result;
            }
        };
    });
})();

},{}],20:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.core.style.svgIcon', []);

    module.factory('stSvgIcon', function($cacheFactory, $http, $q, $log) {
        var element = angular.element(document.createElement('div'));
        var imageCache = $cacheFactory('stSvgImage');
        var dataCache = $cacheFactory('stSvgData');
        function process(svg, fill, stroke) {
            element.html(svg);
            // @todo make smarter
            ['path', 'polygon', 'circle', 'ellipse', 'rect', 'line', 'polyline'].forEach(function(el) {
                angular.forEach(element.find(el), function(e) {
                    // @todo does it make sense to override stroke width?
                    e = angular.element(e);
                    var css = {
                        opacity: 1
                    };
                    var existingFill = e.css('fill') || e.attr('fill') || '';
                    if (existingFill != 'none' && existingFill != 'rgb(255, 255, 255)' && existingFill.toLowerCase() != '#ffffff') {
                        css.fill = fill;
                    }
                    var existingStroke = e.css('stroke') || e.attr('stroke');
                    if (existingStroke != 'none') {
                        css.stroke = stroke;
                    }
                    e.css(css);
                });
            });
            var root = element.find('svg');
            var width = parseInt(root.attr('width'));
            var height = parseInt(root.attr('height'));
            // ugh - we're totally guessing here but things go badly without:
            // on firefox: ns_error_not_available on calling canvas.drawimage
            // on chrome: very large icon (default size as it renders)
            // we might be able to set the src on an img element and figure this out...
            if (isNaN(width) || isNaN(height)) {
                root.attr('width', 64);
                root.attr('height', 64);
                width = 64;
                height = 64;
            }
            var dataURI = 'data:image/svg+xml;base64,' + btoa(element.html());
            return {
                dataURI: dataURI,
                width: width,
                height: height
            };
        }
        return {
            getImage: function(svgURI, fill, stroke, sync) {
                var key = svgURI + fill + stroke;
                var cached = imageCache.get(key);
                var deferred = $q.defer();
                if (cached) {
                    if (sync) {
                        return cached;
                    }
                    deferred.resolve(cached);
                } else {
                    if (sync) {
                        var svg = dataCache.get(svgURI);
                        if (svg) {
                            var imageInfo = process(svg, fill, stroke);
                            imageInfo.uri = svgURI;
                            imageCache.put(key, imageInfo);
                            return imageInfo;
                        }
                        $log.warning('no svg for', svgURI);
                        return null;
                    }
                    this.getImageData(svgURI).then(function(response) {
                        var imageInfo = process(response.data, fill, stroke);
                        imageInfo.uri = svgURI;
                        imageCache.put(key, imageInfo);
                        deferred.resolve(imageInfo);
                    }, function() {
                        deferred.reject('error');
                    });
                }
                return deferred.promise;
            },
            getImageData: function(svgURI) {
                return $http.get(svgURI, {cache: true}).success(function(response) {
                    dataCache.put(svgURI, response);
                    return response;
                }).error(function() {
                    $log.warn('error fetching ' + svgURI);
                });
            }
        };
    });

})();

},{}],21:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.core.time.services', []);

    var stutils = storytools.core.time.utils;

    /**
     * Compute a sorted, unique array of ticks for the provided layers. The
     * algorithm uses any provided instant or extent(start value used) list values
     * and looks at the total range of all interval values creating a tick at the
     * minimum interval for the total range. See the tests for examples.
     * @param {array|ol.Map} layersWithTime
     * @returns array of ticks
     */
    function computeTicks(layersWithTime) {
        // allow a map to be passed in
        if (!angular.isArray(layersWithTime)) {
            var storyMap = layersWithTime;
            layersWithTime = storyMap.getStoryLayers().getArray().filter(function(l) {
                var times = l.get('times');
                /*jshint eqnull:true */
                return times != null;
            });
            layersWithTime.push(storyMap.storyPinsLayer);
            layersWithTime.push(storyMap.storyBoxesLayer);
        }
        var ticks = {};
        var totalRange = null;
        var intervals = [];
        function addTick(add) {
            add = stutils.getTime(add);
            if (add !== null && ! (add in ticks)) {
                ticks[add] = 1;
            }
        }
        layersWithTime.forEach(function(l) {
            var times = l.get('times');
            var range;
            if (angular.isArray(times)) {
                // an array of instants or extents
                range = stutils.computeRange(times);
                if (times.length) {
                    if (stutils.isRangeLike(times[0])) {
                        times.forEach(function(r) {
                            addTick(r.start);
                            if (totalRange === null) {
                                totalRange = stutils.createRange(r);
                            } else {
                                totalRange.extend(r);
                            }
                        });
                    } else {
                        times.forEach(function(r) {
                            addTick(r);
                        });
                    }
                }
                // add a tick at the end to ensure we get there
                /*jshint eqnull:true */
                if (range.end != null) {
                    addTick(range.end);
                }
            } else if (times) {
                // a interval (range+duration)
                range = times;
                intervals.push(times);
            }
            if (totalRange === null) {
                // copy, will be modifying
                totalRange = stutils.createRange(range);
            } else {
                totalRange.extend(range);
            }
        });
        if (intervals.length) {
            intervals.sort(function(a, b) {
                return a.interval - b.interval;
            });
            var smallest = intervals[0];
            var start = totalRange.start;
            while (start <= totalRange.end) {
                addTick(start);
                start = smallest.offset(start);
            }
        }
        ticks = Object.getOwnPropertyNames(ticks).map(function(t) {
            return parseInt(t);
        });
        return ticks.sort(function(a, b) {
            return a - b;
        });
    }

    function TimeControlsManager($log, $rootScope, StoryPinLayerManager, MapManager) {
        this.timeControls = null;
        var timeControlsManager = this;

        function maybeCreateTimeControls(update) {
            $log.debug("Creating TimeControls with boxes: ");
           // $log.debug(StoryBoxLayerManager.storyBoxes);
            if (timeControlsManager.timeControls !== null) {
                if (update) {
                    var values = update();
                    if (values) {
                        timeControlsManager.timeControls.update(values);
                    }
                }
                return;
            }
            var range = computeTicks(MapManager.storyMap);
            if (range.length) {
                var annotations = StoryPinLayerManager.storyPins;
                timeControlsManager.timeControls = storytools.core.time.create({
                    annotations: annotations,
                    storyMap: MapManager.storyMap,
                    storyLayers: MapManager.storyMap.getStoryLayers().getArray(),
                    data: range,
                    mode: MapManager.storyMap.mode,
                    tileStatusCallback: function(remaining) {
                        $rootScope.$broadcast('tilesLoaded', remaining);
                    },
                    chapterCount: MapManager.chapterCount
                });
                timeControlsManager.timeControls.on('rangeChange', function(range) {
                    timeControlsManager.currentRange = range;
                    var pinsToCheck = StoryPinLayerManager.storyPins.filter(function (pin) {
                        return pin.get('auto_show');
                    });

                    for (var iPin = 0; iPin < pinsToCheck.length; iPin += 1) {
                        var pin = pinsToCheck[iPin];
                        var pinRange = stutils.createRange(pin.start_time, pin.end_time);
                        if (pinRange.intersects(range)) {
                            $rootScope.$broadcast('show-pin', pin);
                        }
                    }
                });
            }
        }

        MapManager.storyMap.getStoryLayers().on('change:length', function() {
            maybeCreateTimeControls(function() {
                var range = computeTicks(MapManager.storyMap);
                if (range.length) {
                    return {
                        storyLayers: MapManager.storyMap.getStoryLayers().getArray(),
                        data: range
                    };
                }
            });
        });
        var pinsLayer = MapManager.storyMap.storyPinsLayer;
        var boxesLayer = MapManager.storyMap.storyBoxesLayer;
        pinsLayer.on('change:features', function() {
            maybeCreateTimeControls(function() {
                var range = computeTicks(MapManager.storyMap);
                if (range.length) {
                    return {
                        storyLayers: MapManager.storyMap.getStoryLayers().getArray(),
                        annotations: pinsLayer.get("features"),
                        boxes: boxesLayer.get("features"),
                        data: range
                    };
                }
            });
        });

        boxesLayer.on('change:features', function() {
            maybeCreateTimeControls(function() {
                var range = computeTicks(MapManager.storyMap);
                if (range.length) {
                    return {
                        annotations: pinsLayer.get("features"),
                        data: range,
                        boxes: boxesLayer.get("features")
                    };
                }
            });
        });

        maybeCreateTimeControls();
    }

    module.constant('TimeControlsManager', TimeControlsManager);

    module.service('TimeMachine', function() {
        return {
            computeTicks: computeTicks
        };
    });
})();

},{}],22:[function(require,module,exports){
(function() {
    'use strict';
    var module = angular.module('storytools.edit.style.directives', []);

    function editorDirective(name, templateUrl, property, linker) {
        module.directive(name, ['stStyleChoices', function(styleChoices) {
            return {
                restrict: 'E',
                scope: {
                    stModel: "=",
                    property: "@",
                    popover: "@popoverText",
                },
                templateUrl: 'style/widgets/' + templateUrl,
                link: function(scope, element, attrs) {
                    // @todo bleck - grabbing the layer from the parent
                    // should be replaced with something more explicit
                    scope.layer = scope.$parent.layer;
                    scope.$watch(function() {
                        return scope.$parent.layer;
                    }, function(neu) {
                        scope.layer = neu;
                    });
                    // endbleck
                    scope.model = scope.stModel[property || scope.property];
                    scope.styleChoices = styleChoices;
                    if (linker) {
                        linker(scope, element, attrs);
                    }
                }
            };
        }]);
    }

    module.directive('styleEditor', function() {
        return {
            restrict: 'E',
            templateUrl: 'style/style-editor.html',
            controller: 'styleEditorController',
            require: '?styleEditorController',
            scope: {
                layer : '=',
                onChange : '=',
                formChanged : '='
            }
        };
    });

    module.directive('attributeCombo', function($log) {
        return {
            restrict: 'E',
            templateUrl: 'style/widgets/attribute-combo.html',
            scope: {
                layer: '=',
                model: "=stModel",
                onChange: "=?",
                css: "@css",
            },
            link: function(scope, element, attrs) {
                function readAttributes() {
                    var atts = [];
                    if (scope.layer) {
                        scope.layer.get('attributes').forEach(function(a) {
                            var include = true;
                            if (attrs.filter === 'nogeom') {
                                include = a.typeNS !== 'http://www.opengis.net/gml';
                            } else if (attrs.filter === 'number') {
                                include = a.type === 'integer' ||
                                    a.type === 'double' ||
                                    a.type === 'long';
                            } else if (attrs.filter === 'unique') {
                                include = a.type === 'integer' ||
                                    a.type === 'string' ||
                                    a.type === 'long';
                            } else if (attrs.filter) {
                                $log.warn('unknown filter', attrs.filter);
                            }
                            if (attrs.include) {
                                include = attrs.include.indexOf(a.type) >= 0;
                            }
                            if (include) {
                                atts.push(a.name);
                            }
                        });
                        atts.sort();
                        scope.attributes = atts;
                    } else {
                        scope.attributes = [];
                    }
                }
                // @todo is watch actually needed here (possibly the case if reusing the editor)
                scope.$watch('layer', function(neu, old) {
                    if (neu != old) {
                        readAttributes();
                    }
                });
                readAttributes();
                // default property to modify
                scope.property = attrs.property || 'attribute';
                // if not provided, the default behavior is to change the model
                if (!scope.onChange) {
                    scope.onChange = function(property, val) {
                        scope.model[property] = val;
                    };
                }
            }
        };
    });

    editorDirective('symbolEditor', 'symbol-editor.html', 'symbol', function(scope, el, attrs) {
        ['showGraphic', 'showRotation', 'hideColor'].forEach(function(opt) {
            scope[opt] = attrs[opt];
        });
        scope.getSymbolizerText = function(model) {
            return model.shape || model.graphic;
        };
        scope.getSymbolizerImage = function(name) {
            return '';
        };
    });
    editorDirective('strokeEditor', 'stroke-editor.html', 'stroke');
    editorDirective('numberEditor', 'number-editor.html', null, function(scope, el, attrs) {
        var defaults = {
            max: 30,
            min: 0,
            step: 1
        };
        Object.keys(defaults).forEach(function(e) {
            scope[e] = attrs[e] || defaults[e];
        });
        function wheel(ev) {
            var input = el.find('input');
            var min = Number(input.attr('min')) || 0;
            var max = Number(input.attr('max'));
            var step = Number(input.attr('step')) || 1;
            var val = scope.stModel[scope.property];
            var scroll = ev.detail || ev.wheelDelta;
            val = Math.min(max, val + (scroll > 0 ? -step: step));
            val = Math.max(min, val);
            scope.$apply(function() {
                scope.stModel[scope.property] = val;
            });
        }
        el[0].addEventListener('DOMMouseScroll', wheel, false ); // For FF and Opera
        el[0].addEventListener('mousewheel', wheel, false ); // For others
    });
    editorDirective('colorEditor', 'color-editor.html');
    editorDirective('labelEditor', 'label-editor.html', 'label', function(scope) {
        // @todo other options
        scope.styleModel = {
            bold : scope.model.fontWeight == 'bold',
            italic : scope.model.fontStyle == 'italic'
        };
        scope.styleModelChange = function() {
            scope.model.fontWeight = scope.styleModel.bold ? 'bold' : 'normal';
            scope.model.fontStyle = scope.styleModel.italic ? 'italic' : 'normal';
        };
    });

    // @todo break into pieces or make simpler
    // @todo doesn't watch iconCommons.defaults() - can become out of date
    module.directive('graphicEditor', function(stStyleChoices, ol3MarkRenderer, iconCommons, iconCommonsSearch, stSvgIcon) {
        return {
            restrict: 'E',
            templateUrl: 'style/widgets/graphic-editor.html',
            scope: {
                symbol: '='
            },

            link: function(scope, element, attrs) {
                function canvas(symbol) {
                    var el = angular.element(ol3MarkRenderer(symbol, 24));
                    el.addClass('symbol-icon');
                    el.attr('mark', symbol); // for testing until we use data URI
                    return el;
                }
                function image(icon) {
                    var el = angular.element('<img>');
                    el.attr('src', icon.dataURI);
                    el.addClass('symbol-icon');
                    el.attr('graphic', icon.uri);
                    return el;
                }
                // update the element with the data-current-symbol attribute
                // to match the current symbol
                function current() {
                    var el = angular.element(element[0].querySelector('[data-current-symbol]'));
                    el.find('*').remove();
                    if (scope.symbol.shape) {
                        el.append(canvas(scope.symbol.shape));
                    } else if (scope.symbol.graphic) {
                        stSvgIcon.getImage(scope.symbol.graphic, '#000', '#fff').then(function(icon) {
                            el.append(image(icon));
                        });
                    }
                }
                var clicked = function() {
                    var el = angular.element(this);
                    if (el.attr('shape')) {
                        scope.symbol.shape = el.attr('shape');
                        scope.symbol.graphic = null;
                    } else if (el.attr('graphic')) {
                        scope.symbol.shape = null;
                        scope.symbol.graphic = el.attr('graphic');
                    }
                    current();
                };
                // this might be done another way but because we get canvas elements
                // back from ol3 styles, we build the dom manually
                var list = angular.element(element[0].getElementsByClassName('ol-marks'));
                stStyleChoices.symbolizers.forEach(function(s) {
                    var img = canvas(s);
                    img.attr('shape', s);
                    img.on('click', clicked);
                    list.append(img);
                });
                function updateRecent() {
                    list = angular.element(element[0].getElementsByClassName('recent-icons'));
                    list.html('');
                    iconCommons.defaults().then(function(icons) {
                        icons.forEach(function(icon, i) {
                            var img = image(icon);
                            img.on('click', clicked);
                            list.append(img);
                        });
                        // we're relying on this in the tests as a means of
                        // knowing when the recent icons loading has completed
                        scope.recent = icons;
                    });
                }
                // only in scope for triggering in tests
                scope._updateRecent = function() {
                    updateRecent();
                    current();
                };
                scope._updateRecent();
                scope.showIconCommons = function() {
                    iconCommonsSearch.search().then(function(selected) {
                        // since ol3 style creation is sync, preload icon before setting
                        stSvgIcon.getImageData(selected.href).then(function() {
                            scope.symbol.shape = null;
                            scope.symbol.graphic = selected.href;
                            scope._updateRecent();
                        });
                    });
                };
            }
        };
    });

    module.directive('classifyEditor', function() {
        return {
            restrict: 'E',
            templateUrl: 'style/widgets/classify-editor.html',
            scope: true,
            link: function(scope, element, attrs) {
                ['showMethod','showMaxClasses', 'showRange',
                    'showColorRamp','showColorPalette', 'attributeFilter'].forEach(function(opt) {
                    scope[opt] = attrs[opt];
                });
            }
        };
    });

    module.directive('colorRamp', function() {
        return {
            restrict: 'A',
            scope: {
                ramp: "=ramp"
            },
            link: function(scope, element, attrs) {
                function render() {
                    var ctx = element[0].getContext('2d');
                    var gradient = ctx.createLinearGradient(0, 0, attrs.width, 0);
                    Object.getOwnPropertyNames(scope.ramp).forEach(function(stop) {
                        stop = parseFloat(stop);
                        if (!isNaN(stop)) {
                            gradient.addColorStop(stop, scope.ramp[stop]);
                        }
                    });
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, attrs.width, attrs.height);
                }
                scope.$watch('ramp', render);
                render();
            }
        };
    });

    module.directive('colorField', function() {
        var regex = /(^#[0-9a-f]{6}$)|(^#[0-9a-f]{3}$)/i;
        function validColor(value) {
            // @todo support named colors?
            return regex.exec(value);
        }
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function(scope, element, attrs, ctrl) {
                ctrl.$parsers.push(function(viewValue) {
                    ctrl.$setValidity('color', validColor(viewValue));
                    return viewValue;
                });
                ctrl.$formatters.push(function(modelValue) {
                    // when loaded but also possible the picker widget modifies
                    ctrl.$setValidity('color', validColor(modelValue));
                    return modelValue;
                });
            }
        };
    });

    module.directive('noClose', function() {
        return {
            link: function($scope, $element) {
                $element.on('click', function($event) {
                    $event.stopPropagation();
                });
            }
        };
    });

    module.directive('styleTypeEditor', function($compile, $templateCache) {
        return {
            restrict: "E",
            link: function(scope, element, attrs) {
                scope.$watch('currentEditor', function() {
                    var currentEditor = scope.currentEditor;
                    if (scope.currentEditor) {
                        var templateUrl = 'style/types/' + currentEditor.name.replace(' ', '-') + ".html";
                        element.html($templateCache.get(templateUrl));
                        $compile(element.contents())(scope);
                    } else {
                        element.html('');
                    }
                });
            }
        };
    });

    module.directive('rulesEditor', function() {
        return {
            restrict: 'E',
            templateUrl: 'style/rules-editor.html',
            link: function(scope, element, attrs) {
                scope.deleteRule = function(rule) {
                    scope.activeStyle.rules = scope.activeStyle.rules.filter(function(r) {
                        return r !== rule;
                    });
                };
            }
        };
    });
})();

},{}],23:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.edit.style.iconCommons', []);

    module.factory('iconCommons', function($q, stSvgIcon, stRecentChoices) {
        return {
            defaults: function() {
                return $q.all(stRecentChoices.icons.recent.map(function(uri) {
                    return stSvgIcon.getImage(uri);
                }));
            }
        };
    });

    module.factory('iconCommonsSearch', function($http, $modal, $injector) {
        var iconCommonsHost = $injector.has('iconCommonsHost') ?
            $injector.get('iconCommonsHost') : 'http://localhost:8000';
        function fixHrefs(stuff) {
            var toFix = stuff.icons || stuff;
            for (var i = 0, ii = toFix.length; i < ii; i++) {
                toFix[i].href = iconCommonsHost + toFix[i].href;
            }
            return stuff;
        }
        return {
            tagEndpoint: iconCommonsHost + '/icons/icon',
            search: function() {
                this.modal = $modal.open({
                    size: 'lg',
                    controller: 'iconCommonsController',
                    templateUrl: 'style/widgets/icon-commons-search.html'
                });
                return this.modal ? this.modal.result : null;
            },
            getCollections: function() {
                return $http.get(iconCommonsHost + '/icons/collections').success(function(data) {
                    return fixHrefs(data);
                });
            },
            getMore: function(collection) {
                var href = collection.href;
                if (href.indexOf(iconCommonsHost) !== 0) {
                    href = iconCommonsHost + href;
                }
                return $http.get(href, {
                    params: {
                        page: collection._nextPage
                    }
                }).success(function(data) {
                    return fixHrefs(data);
                });
            },
            getCollectionIcons: function(collection) {
                var params = {};
                if (collection._nextPage) {
                    params.page = collection._nextPage;
                }
                return $http.get(iconCommonsHost + collection.href, {
                    params: params
                }).success(function(data) {
                    return fixHrefs(data);
                });
            },
            getByTag: function(tag) {
                return $http.get(this.tagEndpoint, {
                    params: {
                        tag: tag
                    }
                }).success(function(data) {
                    return fixHrefs(data);
                });
            },
            getTags: function(q) {
                return $http.get(iconCommonsHost + '/icons/search/tags', {
                    params: {
                        query: q
                    }
                }).then(function(response) {
                    return response.data.tags;
                });
            }
        };
    });

    module.controller('iconCommonsController', function($scope, iconCommonsSearch, stRecentChoices) {
        var tagCollection = {
            href: iconCommonsSearch.tagEndpoint
        }, collection = {
        };
        function handleCollections(collection, response) {
            var icons = response.data.icons;
            if (collection._icons) {
                collection._icons = collection._icons.concat(icons);
            } else {
                collection._icons = icons;
            }
            collection._more = response.data.page < response.data.pages;
            collection._nextPage = response.data.page + 1;
            $scope.icons = collection;
        }
        $scope.loadMore = function() {
            iconCommonsSearch.getMore($scope.icons).then(function(data) {
                handleCollections($scope.icons, data);
            });
        };
        $scope.close = function() {
            stRecentChoices.icons.add($scope.selectedIcon.href);
            iconCommonsSearch.modal.close($scope.selectedIcon);
        };
        $scope.dismiss = function() {
            iconCommonsSearch.modal.dismiss();
        };
        $scope.tagSelect = function(tag) {
            tagCollection._icons = [];
            iconCommonsSearch.getByTag(tag).then(function(data) {
                handleCollections(tagCollection, data);
            });
        };
        $scope.viewCollections = function() {
            $scope.icons = collection;
        };
        $scope.viewTags = function() {
            $scope.icons = tagCollection;
        };
        $scope.collectionSelect = function(collection) {
            collection._icons = [];
            iconCommonsSearch.getCollectionIcons(collection).then(function(data) {
                handleCollections(collection, data);
            });
        };
        $scope.iconSelected = function(icon, done) {
            $scope.selectedIcon = icon;
            if (done) {
                $scope.close();
            }
        };
        $scope.selectedClass = function(icon) {
            return icon === $scope.selectedIcon ? 'active' : null;
        };
        $scope.getTags = iconCommonsSearch.getTags;
        iconCommonsSearch.getCollections().then(function(response) {
            $scope.collections = response.data.collections;
        });
    });
})();
},{}],24:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.edit.style.styleChoices', []);

    module.factory('stStyleChoices', function() {
        return {
            symbolizers: [
                'circle', 'square', 'triangle', 'star', 'cross', 'x'
            ],
            rotationUnits: [
                'degrees', 'radians'
            ],
            strokeStyle: [
                'solid', 'dashed', 'dotted'
            ],
            fontFamily: [
                'serif', 'sans-serif', 'cursive', 'monospace'
            ],
            colorRamps: [
                {
                    0: '#ff0000',
                    1: '#0000ff'
                },
                {
                    0: '#00ff00',
                    1: '#ffff00'
                }
            ],
            // @todo build these statically ahead of time using color-scheme-js
            colorPalettes: [
                {
                    name: 'colors 1',
                    vals: ["#ff9900", "#b36b00", "#ffe6bf", "#ffcc80",
                        "#00b366", "#007d48", "#bfffe4", "#80ffc9",
                        "#400099", "#2d006b", "#dabfff", "#b580ff"]
                },
                {
                    name: 'colors 2',
                    vals: ["#ff99aa", "#b36baa", "#aae6bf", "#aacc80",
                        "#00b366", "#007d48", "#bfaae4", "#80aac9",
                        "#40aa99", "#2daa6b", "#dabfaa", "#b580aa"]
                }
            ],
            classMethods: [
                'Natural Breaks',
                'Equal Interval',
                'Quantile'/*,
                'Geometric Interval',
                'Standard Deviation'*/
            ],
            getPalette: function(name) {
                var found = this.colorPalettes.filter(function(p) {
                    return p.name === name;
                });
                return found.length ? found[0] : null;
            }
        };
    });

    module.factory('stRecentChoices', function() {
        return {
            icons: new RecentChoices('icons', 24)
        };
    });

    function RecentChoices(name, max) {
        this._max = max;
        this._key = 'stRecentChoices-' + name;
        var saved = localStorage.getItem(this._key);
        this.recent = saved ? JSON.parse(saved) : [];
    }

    RecentChoices.prototype.clear = function() {
        this.recent = [];
        localStorage.setItem(this._key, JSON.stringify(this.recent));
    };

    RecentChoices.prototype.add = function(choice) {
        if (this.recent.indexOf(choice) === -1) {
            this.recent.push(choice);
            if (this.recent.length > this._max) {
                this.recent.shift();
            }
            localStorage.setItem(this._key, JSON.stringify(this.recent));
        }
    };

})();

},{}],25:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.edit.style.styleRuleBuilder', [
        'storytools.edit.style.styleTypes',
        'storytools.edit.style.styleChoices'
    ]);

    module.factory('stStyleRuleBuilder', function(stStyleTypes, stStyleChoices) {
        function hex(v) {
            return ('00' + v.toString(16)).slice(-2);
        }
        function colorRampValues(ramp, num) {
            if (num === 1) {
                return [ramp[0]];
            }
            var colors = [];
            var rampStops = Object.keys(ramp).filter(function(x) {
                return x.toString().charAt(0) != '$';
            });
            rampStops.sort();
            var ms = rampStops.map(function(k) {
                var val = ramp[k];
                return [parseInt('0x' + val.substr(1, 2)),
                    parseInt('0x' + val.substr(3, 2)),
                    parseInt('0x' + val.substr(5, 2))
                ];
            });
            var step = 1.0 / (num - 1);
            function getStops(val) {
                // @todo find stops
                return [rampStops[0], rampStops[1]];
            }

            // @todo hsv interpolation (yields brighter colors)?
            for (var i = 0; i < num; i++) {
                var val = i * step;
                var stops = getStops(val);
                var r = (val - stops[0]) / (stops[1] - stops[0]);
                var start = ms[stops[0]];
                var stop = ms[stops[1]];
                var red = Math.floor(start[0] + (stop[0] - start[0]) * r);
                var green = Math.floor(start[1] + (stop[1] - start[1]) * r);
                var blue = Math.floor(start[2] + (stop[2] - start[2]) * r);
                colors.push('#' + hex(red) + hex(green) + hex(blue));
            }
            return colors;
        }
        function buildRule(rule, context) {
            var type = context.styleType.rule;
            var ruleStyle = {};
            angular.forEach(type, function(copyRule, styleProp) {
                var target = {};
                angular.forEach(copyRule, function(copySource, copyDest) {
                    var val = null;
                    switch (copySource) {
                        case 'color':
                            if (context.colors) {
                                val = context.colors[context.index % context.colors.length];
                            }
                            break;
                        case 'range':
                            if (context.rangeStep) {
                                val = Math.round(context.rangeStep * context.index);
                            }
                            break;
                        default:
                            throw 'invalid copySource ' + copySource;
                    }
                    if (val !== null) {
                        target[copyDest] = val;
                    }
                });
                ruleStyle[styleProp] = target;
            });
            rule.style = ruleStyle;
        }

        return {
            _colorRampValues: colorRampValues,
            buildRuleStyles: function(style) {
                var colors;
                var rangeStep;
                if (style.classify) {
                    if (style.classify.colorRamp) {
                        colors = colorRampValues(style.classify.colorRamp, style.rules.length);
                    } else if (style.classify.colorPalette) {
                        var palette = stStyleChoices.getPalette(style.classify.colorPalette);
                        // @todo interpolate if needed?
                        colors = palette.vals;
                    }
                    if (style.classify.range) {
                        rangeStep = (style.classify.range.max - style.classify.range.min) / style.rules.length;
                    }
                }
                var context = {
                    colors: colors,
                    rangeStep: rangeStep,
                    style: style,
                    styleType: stStyleTypes.getStyleType(style.typeName)
                };
                style.rules.forEach(function(r, i) {
                    context.index = i;
                    buildRule(r, context);
                });
            }
        };
    });
})();

},{}],26:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.edit.style.styleTypes', []);

    var defaultSymbol = {
        size: 10,
        shape: 'circle',
        graphic: null,
        graphicType: null,
        fillColor: '#f59620',
        fillOpacity: 70,
        rotationAttribute: null,
        rotationUnits: 'degrees'
    };

    var defaultStroke = {
        strokeColor: '#f59620',
        strokeWidth: 1,
        strokeStyle: 'solid',
        strokeOpacity: 100
    };

    var defaultLabel = {
        attribute: null,
        fillColor: '#f59620',
        fontFamily: 'Serif',
        fontSize: 10,
        fontStyle: 'normal',
        fontWeight: 'normal',
        placement: 'point'
    };

    var defaultUniqueClass = {
        method: 'unique',
        attribute: null,
        maxClasses: 5,
        colorRamp: null
    };

    var defaultBreaksClass = {
        method: null,
        attribute: null,
        maxClasses: 5,
        colorRamp: null
    };

    var defaultRangeClass = {
        method: null,
        attribute: null,
        maxClasses: 5,
        range: {
            min: 0,
            max: 16
        }
    };

    var types = [
        {
            name: 'simple point',
            displayName: 'Simple',
            prototype: {
                geomType: 'point'
            }
        },
        {
            name: 'unique point',
            displayName: 'Unique',
            prototype: {
                geomType: 'point',
                classify: defaultUniqueClass
            },
            rule: {
                symbol : {
                    fillColor: 'color'
                }
            }
        },
        {
            name: 'class point',
            displayName: 'Choropleth',
            prototype: {
                geomType: 'point',
                classify: defaultBreaksClass
            },
            rule: {
                symbol : {
                    fillColor: 'color'
                }
            }
        },
        {
            name: 'graduated point',
            displayName: 'Graduated',
            prototype: {
                geomType: 'point',
                classify: defaultRangeClass
            },
            rule: {
                symbol: {
                    size: 'range'
                }
            }
        },
        {
            name: 'heatmap',
            displayName: 'HeatMap',
            prototype: {
                geomType: 'point',
                radius: 8,
                opacity: 0.8
            }
        },
        {
            name: 'simple line',
            displayName: 'Simple',
            prototype: {
                geomType: 'line'
            }
        },
        {
            name: 'unique line',
            displayName: 'Unique',
            prototype: {
                geomType: 'line',
                classify: defaultUniqueClass
            },
            rule: {
                stroke : {
                    strokeColor: 'color'
                }
            }
        },
        {
            name: 'simple polygon',
            displayName: 'Simple',
            prototype: {
                geomType: 'polygon'
            }
        },
        {
            name: 'unique polygon',
            displayName: 'Unique',
            prototype: {
                geomType: 'polygon',
                classify: defaultUniqueClass
            },
            rule: {
                symbol : {
                    fillColor: 'color'
                }
            }
        },
        {
            name: 'class polygon',
            displayName: 'Choropleth',
            prototype: {
                geomType: 'polygon',
                classify: defaultBreaksClass
            },
            rule: {
                symbol : {
                    fillColor: 'color'
                }
            }
        }
    ];

    module.run(function($injector) {
        if ($injector.has('stStyleDefaults')) {
            var defaults = $injector.get('stStyleDefaults');
            [defaultSymbol, defaultStroke].forEach(function(s) {
                Object.keys(s).forEach(function(k) {
                    if (k in defaults) {
                        s[k] = defaults[k];
                    }
                });
            });
        }
    });

    module.factory('stStyleTypes', function() {
        return {
            getTypes: function(storyLayer) {
                return angular.copy(types).filter(function(f) {
                    return f.prototype.geomType === storyLayer.get('geomType');
                });
            },
            getStyleType: function(typeName) {
                var match = types.filter(function(t) {
                    return t.name == typeName;
                });
                if (match.length >  1) {
                    throw 'duplicate type names!';
                }
                return match.length === 0 ? null : match[0];
            },
            createStyle: function(styleType) {
                var base = {
                    symbol: defaultSymbol,
                    stroke: defaultStroke,
                    label: defaultLabel,
                    typeName: styleType.name
                };
                var style = angular.extend({}, angular.copy(base), styleType.prototype);
                if ('classify' in style) {
                    style.rules = [];
                }
                return style;
            }
        };
    });
})();

},{}],27:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.edit.time.directives', []);

    module.directive('stDateTimeField', function() {
        return {
            restrict: 'E',
            templateUrl: 'time/date-time-field.html',
            scope: {
                dateTime: '=',
                currentTime: '='
            },
            link: function(scope, elem) {
                scope.open = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();

                    scope.opened = true;
                };
            }
        };
    });

    module.directive('isoDateTime', function($log) {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModelCtrl) {
                ngModelCtrl.$formatters.push(function(modelValue) {
                    /*jshint eqnull:true */
                    var retval = modelValue != null ? new Date(modelValue).toISOString() : '';
                    return retval;
                });
                ngModelCtrl.$parsers.push(function(viewValue) {
                    var parsed =  Date.parse(viewValue);
                    var valid = !isNaN(parsed);
                    ngModelCtrl.$setValidity('dateTime', valid);
                    return valid ? parsed : null;
                });
                scope.setFromCurrentTime = function() {
                    if (scope.currentTime) {
                        ngModelCtrl.$modelValue = scope.currentTime;
                    } else {
                        $log.error('no current time provided!');
                    }
                };
            }
        };
    });
})();
},{}],28:[function(require,module,exports){
//! moment.js
//! version : 2.14.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        return Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        var k;
        for (k in obj) {
            // even if its not own property I'd still call it non-empty
            return false;
        }
        return true;
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = create_utc__createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        ordinalParse: defaultOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                            'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, parentConfig = baseConfig;
            // MERGE
            if (locales[name] != null) {
                parentConfig = locales[name]._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (isDate(input)) {
            config._d = input;
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIOROITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = stringGet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = stringSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var prototype__proto = Locale.prototype;

    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto.ordinal         = ordinal;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    prototype__proto.weekdaysRegex       =        weekdaysRegex;
    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function lists__listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function lists__listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function lists__listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function lists__listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.14.1';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.updateLocale          = updateLocale;
    utils_hooks__hooks.locales               = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.calendarFormat        = getCalendarFormat;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],29:[function(require,module,exports){
var util = require('./util');

/**
 * DataSet
 *
 * Usage:
 *     var dataSet = new DataSet({
 *         fieldId: '_id',
 *         type: {
 *             // ...
 *         }
 *     });
 *
 *     dataSet.add(item);
 *     dataSet.add(data);
 *     dataSet.update(item);
 *     dataSet.update(data);
 *     dataSet.remove(id);
 *     dataSet.remove(ids);
 *     var data = dataSet.get();
 *     var data = dataSet.get(id);
 *     var data = dataSet.get(ids);
 *     var data = dataSet.get(ids, options, data);
 *     dataSet.clear();
 *
 * A data set can:
 * - add/remove/update data
 * - gives triggers upon changes in the data
 * - can  import/export data in various data formats
 *
 * @param {Array | DataTable} [data]    Optional array with initial data
 * @param {Object} [options]   Available options:
 *                             {String} fieldId Field name of the id in the
 *                                              items, 'id' by default.
 *                             {Object.<String, String} type
 *                                              A map with field names as key,
 *                                              and the field type as value.
 * @constructor DataSet
 */
// TODO: add a DataSet constructor DataSet(data, options)
function DataSet (data, options) {
  // correctly read optional arguments
  if (data && !Array.isArray(data) && !util.isDataTable(data)) {
    options = data;
    data = null;
  }

  this._options = options || {};
  this._data = {};                                 // map with data indexed by id
  this._fieldId = this._options.fieldId || 'id';   // name of the field containing id
  this._type = {};                                 // internal field types (NOTE: this can differ from this._options.type)

  // all variants of a Date are internally stored as Date, so we can convert
  // from everything to everything (also from ISODate to Number for example)
  if (this._options.type) {
    for (var field in this._options.type) {
      if (this._options.type.hasOwnProperty(field)) {
        var value = this._options.type[field];
        if (value == 'Date' || value == 'ISODate' || value == 'ASPDate') {
          this._type[field] = 'Date';
        }
        else {
          this._type[field] = value;
        }
      }
    }
  }

  // TODO: deprecated since version 1.1.1 (or 2.0.0?)
  if (this._options.convert) {
    throw new Error('Option "convert" is deprecated. Use "type" instead.');
  }

  this._subscribers = {};  // event subscribers

  // add initial data when provided
  if (data) {
    this.add(data);
  }
}

/**
 * Subscribe to an event, add an event listener
 * @param {String} event        Event name. Available events: 'put', 'update',
 *                              'remove'
 * @param {function} callback   Callback method. Called with three parameters:
 *                                  {String} event
 *                                  {Object | null} params
 *                                  {String | Number} senderId
 */
DataSet.prototype.on = function(event, callback) {
  var subscribers = this._subscribers[event];
  if (!subscribers) {
    subscribers = [];
    this._subscribers[event] = subscribers;
  }

  subscribers.push({
    callback: callback
  });
};

// TODO: make this function deprecated (replaced with `on` since version 0.5)
DataSet.prototype.subscribe = DataSet.prototype.on;

/**
 * Unsubscribe from an event, remove an event listener
 * @param {String} event
 * @param {function} callback
 */
DataSet.prototype.off = function(event, callback) {
  var subscribers = this._subscribers[event];
  if (subscribers) {
    this._subscribers[event] = subscribers.filter(function (listener) {
      return (listener.callback != callback);
    });
  }
};

// TODO: make this function deprecated (replaced with `on` since version 0.5)
DataSet.prototype.unsubscribe = DataSet.prototype.off;

/**
 * Trigger an event
 * @param {String} event
 * @param {Object | null} params
 * @param {String} [senderId]       Optional id of the sender.
 * @private
 */
DataSet.prototype._trigger = function (event, params, senderId) {
  if (event == '*') {
    throw new Error('Cannot trigger event *');
  }

  var subscribers = [];
  if (event in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers[event]);
  }
  if ('*' in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers['*']);
  }

  for (var i = 0; i < subscribers.length; i++) {
    var subscriber = subscribers[i];
    if (subscriber.callback) {
      subscriber.callback(event, params, senderId || null);
    }
  }
};

/**
 * Add data.
 * Adding an item will fail when there already is an item with the same id.
 * @param {Object | Array | DataTable} data
 * @param {String} [senderId] Optional sender id
 * @return {Array} addedIds      Array with the ids of the added items
 */
DataSet.prototype.add = function (data, senderId) {
  var addedIds = [],
      id,
      me = this;

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      id = me._addItem(data[i]);
      addedIds.push(id);
    }
  }
  else if (util.isDataTable(data)) {
    // Google DataTable
    var columns = this._getColumnNames(data);
    for (var row = 0, rows = data.getNumberOfRows(); row < rows; row++) {
      var item = {};
      for (var col = 0, cols = columns.length; col < cols; col++) {
        var field = columns[col];
        item[field] = data.getValue(row, col);
      }

      id = me._addItem(item);
      addedIds.push(id);
    }
  }
  else if (data instanceof Object) {
    // Single item
    id = me._addItem(data);
    addedIds.push(id);
  }
  else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', {items: addedIds}, senderId);
  }

  return addedIds;
};

/**
 * Update existing items. When an item does not exist, it will be created
 * @param {Object | Array | DataTable} data
 * @param {String} [senderId] Optional sender id
 * @return {Array} updatedIds     The ids of the added or updated items
 */
DataSet.prototype.update = function (data, senderId) {
  var addedIds = [],
      updatedIds = [],
      me = this,
      fieldId = me._fieldId;

  var addOrUpdate = function (item) {
    var id = item[fieldId];
    if (me._data[id]) {
      // update item
      id = me._updateItem(item);
      updatedIds.push(id);
    }
    else {
      // add new item
      id = me._addItem(item);
      addedIds.push(id);
    }
  };

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      addOrUpdate(data[i]);
    }
  }
  else if (util.isDataTable(data)) {
    // Google DataTable
    var columns = this._getColumnNames(data);
    for (var row = 0, rows = data.getNumberOfRows(); row < rows; row++) {
      var item = {};
      for (var col = 0, cols = columns.length; col < cols; col++) {
        var field = columns[col];
        item[field] = data.getValue(row, col);
      }

      addOrUpdate(item);
    }
  }
  else if (data instanceof Object) {
    // Single item
    addOrUpdate(data);
  }
  else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', {items: addedIds}, senderId);
  }
  if (updatedIds.length) {
    this._trigger('update', {items: updatedIds}, senderId);
  }

  return addedIds.concat(updatedIds);
};

/**
 * Get a data item or multiple items.
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *     get(options: Object, data: Array | DataTable)
 *
 *     get(id: Number | String)
 *     get(id: Number | String, options: Object)
 *     get(id: Number | String, options: Object, data: Array | DataTable)
 *
 *     get(ids: Number[] | String[])
 *     get(ids: Number[] | String[], options: Object)
 *     get(ids: Number[] | String[], options: Object, data: Array | DataTable)
 *
 * Where:
 *
 * {Number | String} id         The id of an item
 * {Number[] | String{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 *                              {String} [returnType] Type of data to be
 *                                  returned. Can be 'DataTable' or 'Array' (default)
 *                              {Object.<String, String>} [type]
 *                              {String[]} [fields] field names to be returned
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * {Array | DataTable} [data]   If provided, items will be appended to this
 *                              array or table. Required in case of Google
 *                              DataTable.
 *
 * @throws Error
 */
DataSet.prototype.get = function (args) {
  var me = this;

  // parse the arguments
  var id, ids, options, data;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number') {
    // get(id [, options] [, data])
    id = arguments[0];
    options = arguments[1];
    data = arguments[2];
  }
  else if (firstType == 'Array') {
    // get(ids [, options] [, data])
    ids = arguments[0];
    options = arguments[1];
    data = arguments[2];
  }
  else {
    // get([, options] [, data])
    options = arguments[0];
    data = arguments[1];
  }

  // determine the return type
  var returnType;
  if (options && options.returnType) {
    var allowedValues = ["DataTable", "Array", "Object"];
    returnType = allowedValues.indexOf(options.returnType) == -1 ? "Array" : options.returnType;

    if (data && (returnType != util.getType(data))) {
      throw new Error('Type of parameter "data" (' + util.getType(data) + ') ' +
          'does not correspond with specified options.type (' + options.type + ')');
    }
    if (returnType == 'DataTable' && !util.isDataTable(data)) {
      throw new Error('Parameter "data" must be a DataTable ' +
          'when options.type is "DataTable"');
    }
  }
  else if (data) {
    returnType = (util.getType(data) == 'DataTable') ? 'DataTable' : 'Array';
  }
  else {
    returnType = 'Array';
  }

  // build options
  var type = options && options.type || this._options.type;
  var filter = options && options.filter;
  var items = [], item, itemId, i, len;

  // convert items
  if (id != undefined) {
    // return a single item
    item = me._getItem(id, type);
    if (filter && !filter(item)) {
      item = null;
    }
  }
  else if (ids != undefined) {
    // return a subset of items
    for (i = 0, len = ids.length; i < len; i++) {
      item = me._getItem(ids[i], type);
      if (!filter || filter(item)) {
        items.push(item);
      }
    }
  }
  else {
    // return all items
    for (itemId in this._data) {
      if (this._data.hasOwnProperty(itemId)) {
        item = me._getItem(itemId, type);
        if (!filter || filter(item)) {
          items.push(item);
        }
      }
    }
  }

  // order the results
  if (options && options.order && id == undefined) {
    this._sort(items, options.order);
  }

  // filter fields of the items
  if (options && options.fields) {
    var fields = options.fields;
    if (id != undefined) {
      item = this._filterFields(item, fields);
    }
    else {
      for (i = 0, len = items.length; i < len; i++) {
        items[i] = this._filterFields(items[i], fields);
      }
    }
  }

  // return the results
  if (returnType == 'DataTable') {
    var columns = this._getColumnNames(data);
    if (id != undefined) {
      // append a single item to the data table
      me._appendRow(data, columns, item);
    }
    else {
      // copy the items to the provided data table
      for (i = 0; i < items.length; i++) {
        me._appendRow(data, columns, items[i]);
      }
    }
    return data;
  }
  else if (returnType == "Object") {
    var result = {};
    for (i = 0; i < items.length; i++) {
      result[items[i].id] = items[i];
    }
    return result;
  }
  else {
    // return an array
    if (id != undefined) {
      // a single item
      return item;
    }
    else {
      // multiple items
      if (data) {
        // copy the items to the provided array
        for (i = 0, len = items.length; i < len; i++) {
          data.push(items[i]);
        }
        return data;
      }
      else {
        // just return our array
        return items;
      }
    }
  }
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array} ids
 */
DataSet.prototype.getIds = function (options) {
  var data = this._data,
      filter = options && options.filter,
      order = options && options.order,
      type = options && options.type || this._options.type,
      i,
      len,
      id,
      item,
      items,
      ids = [];

  if (filter) {
    // get filtered items
    if (order) {
      // create ordered list
      items = [];
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = this._getItem(id, type);
          if (filter(item)) {
            items.push(item);
          }
        }
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids[i] = items[i][this._fieldId];
      }
    }
    else {
      // create unordered list
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = this._getItem(id, type);
          if (filter(item)) {
            ids.push(item[this._fieldId]);
          }
        }
      }
    }
  }
  else {
    // get all items
    if (order) {
      // create an ordered list
      items = [];
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          items.push(data[id]);
        }
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids[i] = items[i][this._fieldId];
      }
    }
    else {
      // create unordered list
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = data[id];
          ids.push(item[this._fieldId]);
        }
      }
    }
  }

  return ids;
};

/**
 * Returns the DataSet itself. Is overwritten for example by the DataView,
 * which returns the DataSet it is connected to instead.
 */
DataSet.prototype.getDataSet = function () {
  return this;
};

/**
 * Execute a callback function for every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<String, String>} [type]
 *                              {String[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 */
DataSet.prototype.forEach = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      data = this._data,
      item,
      id;

  if (options && options.order) {
    // execute forEach on ordered list
    var items = this.get(options);

    for (var i = 0, len = items.length; i < len; i++) {
      item = items[i];
      id = item[this._fieldId];
      callback(item, id);
    }
  }
  else {
    // unordered
    for (id in data) {
      if (data.hasOwnProperty(id)) {
        item = this._getItem(id, type);
        if (!filter || filter(item)) {
          callback(item, id);
        }
      }
    }
  }
};

/**
 * Map every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<String, String>} [type]
 *                              {String[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Object[]} mappedItems
 */
DataSet.prototype.map = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      mappedItems = [],
      data = this._data,
      item;

  // convert and filter items
  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      item = this._getItem(id, type);
      if (!filter || filter(item)) {
        mappedItems.push(callback(item, id));
      }
    }
  }

  // order items
  if (options && options.order) {
    this._sort(mappedItems, options.order);
  }

  return mappedItems;
};

/**
 * Filter the fields of an item
 * @param {Object} item
 * @param {String[]} fields     Field names
 * @return {Object} filteredItem
 * @private
 */
DataSet.prototype._filterFields = function (item, fields) {
  var filteredItem = {};

  for (var field in item) {
    if (item.hasOwnProperty(field) && (fields.indexOf(field) != -1)) {
      filteredItem[field] = item[field];
    }
  }

  return filteredItem;
};

/**
 * Sort the provided array with items
 * @param {Object[]} items
 * @param {String | function} order      A field name or custom sort function.
 * @private
 */
DataSet.prototype._sort = function (items, order) {
  if (util.isString(order)) {
    // order by provided field name
    var name = order; // field name
    items.sort(function (a, b) {
      var av = a[name];
      var bv = b[name];
      return (av > bv) ? 1 : ((av < bv) ? -1 : 0);
    });
  }
  else if (typeof order === 'function') {
    // order by sort function
    items.sort(order);
  }
  // TODO: extend order by an Object {field:String, direction:String}
  //       where direction can be 'asc' or 'desc'
  else {
    throw new TypeError('Order must be a function or a string');
  }
};

/**
 * Remove an object by pointer or by id
 * @param {String | Number | Object | Array} id Object or id, or an array with
 *                                              objects or ids to be removed
 * @param {String} [senderId] Optional sender id
 * @return {Array} removedIds
 */
DataSet.prototype.remove = function (id, senderId) {
  var removedIds = [],
      i, len, removedId;

  if (Array.isArray(id)) {
    for (i = 0, len = id.length; i < len; i++) {
      removedId = this._remove(id[i]);
      if (removedId != null) {
        removedIds.push(removedId);
      }
    }
  }
  else {
    removedId = this._remove(id);
    if (removedId != null) {
      removedIds.push(removedId);
    }
  }

  if (removedIds.length) {
    this._trigger('remove', {items: removedIds}, senderId);
  }

  return removedIds;
};

/**
 * Remove an item by its id
 * @param {Number | String | Object} id   id or item
 * @returns {Number | String | null} id
 * @private
 */
DataSet.prototype._remove = function (id) {
  if (util.isNumber(id) || util.isString(id)) {
    if (this._data[id]) {
      delete this._data[id];
      return id;
    }
  }
  else if (id instanceof Object) {
    var itemId = id[this._fieldId];
    if (itemId && this._data[itemId]) {
      delete this._data[itemId];
      return itemId;
    }
  }
  return null;
};

/**
 * Clear the data
 * @param {String} [senderId] Optional sender id
 * @return {Array} removedIds    The ids of all removed items
 */
DataSet.prototype.clear = function (senderId) {
  var ids = Object.keys(this._data);

  this._data = {};

  this._trigger('remove', {items: ids}, senderId);

  return ids;
};

/**
 * Find the item with maximum value of a specified field
 * @param {String} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.max = function (field) {
  var data = this._data,
      max = null,
      maxField = null;

  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!max || itemField > maxField)) {
        max = item;
        maxField = itemField;
      }
    }
  }

  return max;
};

/**
 * Find the item with minimum value of a specified field
 * @param {String} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.min = function (field) {
  var data = this._data,
      min = null,
      minField = null;

  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!min || itemField < minField)) {
        min = item;
        minField = itemField;
      }
    }
  }

  return min;
};

/**
 * Find all distinct values of a specified field
 * @param {String} field
 * @return {Array} values  Array containing all distinct values. If data items
 *                         do not contain the specified field are ignored.
 *                         The returned array is unordered.
 */
DataSet.prototype.distinct = function (field) {
  var data = this._data;
  var values = [];
  var fieldType = this._options.type && this._options.type[field] || null;
  var count = 0;
  var i;

  for (var prop in data) {
    if (data.hasOwnProperty(prop)) {
      var item = data[prop];
      var value = item[field];
      var exists = false;
      for (i = 0; i < count; i++) {
        if (values[i] == value) {
          exists = true;
          break;
        }
      }
      if (!exists && (value !== undefined)) {
        values[count] = value;
        count++;
      }
    }
  }

  if (fieldType) {
    for (i = 0; i < values.length; i++) {
      values[i] = util.convert(values[i], fieldType);
    }
  }

  return values;
};

/**
 * Add a single item. Will fail when an item with the same id already exists.
 * @param {Object} item
 * @return {String} id
 * @private
 */
DataSet.prototype._addItem = function (item) {
  var id = item[this._fieldId];

  if (id != undefined) {
    // check whether this id is already taken
    if (this._data[id]) {
      // item already exists
      throw new Error('Cannot add item: item with id ' + id + ' already exists');
    }
  }
  else {
    // generate an id
    id = util.randomUUID();
    item[this._fieldId] = id;
  }

  var d = {};
  for (var field in item) {
    if (item.hasOwnProperty(field)) {
      var fieldType = this._type[field];  // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
  }
  this._data[id] = d;

  return id;
};

/**
 * Get an item. Fields can be converted to a specific type
 * @param {String} id
 * @param {Object.<String, String>} [types]  field types to convert
 * @return {Object | null} item
 * @private
 */
DataSet.prototype._getItem = function (id, types) {
  var field, value;

  // get the item from the dataset
  var raw = this._data[id];
  if (!raw) {
    return null;
  }

  // convert the items field types
  var converted = {};
  if (types) {
    for (field in raw) {
      if (raw.hasOwnProperty(field)) {
        value = raw[field];
        converted[field] = util.convert(value, types[field]);
      }
    }
  }
  else {
    // no field types specified, no converting needed
    for (field in raw) {
      if (raw.hasOwnProperty(field)) {
        value = raw[field];
        converted[field] = value;
      }
    }
  }
  return converted;
};

/**
 * Update a single item: merge with existing item.
 * Will fail when the item has no id, or when there does not exist an item
 * with the same id.
 * @param {Object} item
 * @return {String} id
 * @private
 */
DataSet.prototype._updateItem = function (item) {
  var id = item[this._fieldId];
  if (id == undefined) {
    throw new Error('Cannot update item: item has no id (item: ' + JSON.stringify(item) + ')');
  }
  var d = this._data[id];
  if (!d) {
    // item doesn't exist
    throw new Error('Cannot update item: no item with id ' + id + ' found');
  }

  // merge with current item
  for (var field in item) {
    if (item.hasOwnProperty(field)) {
      var fieldType = this._type[field];  // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
  }

  return id;
};

/**
 * Get an array with the column names of a Google DataTable
 * @param {DataTable} dataTable
 * @return {String[]} columnNames
 * @private
 */
DataSet.prototype._getColumnNames = function (dataTable) {
  var columns = [];
  for (var col = 0, cols = dataTable.getNumberOfColumns(); col < cols; col++) {
    columns[col] = dataTable.getColumnId(col) || dataTable.getColumnLabel(col);
  }
  return columns;
};

/**
 * Append an item as a row to the dataTable
 * @param dataTable
 * @param columns
 * @param item
 * @private
 */
DataSet.prototype._appendRow = function (dataTable, columns, item) {
  var row = dataTable.addRow();

  for (var col = 0, cols = columns.length; col < cols; col++) {
    var field = columns[col];
    dataTable.setValue(row, col, item[field]);
  }
};

module.exports = DataSet;

},{"./util":52}],30:[function(require,module,exports){
var util = require('./util');
var DataSet = require('./DataSet');

/**
 * DataView
 *
 * a dataview offers a filtered view on a dataset or an other dataview.
 *
 * @param {DataSet | DataView} data
 * @param {Object} [options]   Available options: see method get
 *
 * @constructor DataView
 */
function DataView (data, options) {
  this._data = null;
  this._ids = {}; // ids of the items currently in memory (just contains a boolean true)
  this._options = options || {};
  this._fieldId = 'id'; // name of the field containing id
  this._subscribers = {}; // event subscribers

  var me = this;
  this.listener = function () {
    me._onEvent.apply(me, arguments);
  };

  this.setData(data);
}

// TODO: implement a function .config() to dynamically update things like configured filter
// and trigger changes accordingly

/**
 * Set a data source for the view
 * @param {DataSet | DataView} data
 */
DataView.prototype.setData = function (data) {
  var ids, i, len;

  if (this._data) {
    // unsubscribe from current dataset
    if (this._data.unsubscribe) {
      this._data.unsubscribe('*', this.listener);
    }

    // trigger a remove of all items in memory
    ids = [];
    for (var id in this._ids) {
      if (this._ids.hasOwnProperty(id)) {
        ids.push(id);
      }
    }
    this._ids = {};
    this._trigger('remove', {items: ids});
  }

  this._data = data;

  if (this._data) {
    // update fieldId
    this._fieldId = this._options.fieldId ||
        (this._data && this._data.options && this._data.options.fieldId) ||
        'id';

    // trigger an add of all added items
    ids = this._data.getIds({filter: this._options && this._options.filter});
    for (i = 0, len = ids.length; i < len; i++) {
      id = ids[i];
      this._ids[id] = true;
    }
    this._trigger('add', {items: ids});

    // subscribe to new dataset
    if (this._data.on) {
      this._data.on('*', this.listener);
    }
  }
};

/**
 * Get data from the data view
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *     get(options: Object, data: Array | DataTable)
 *
 *     get(id: Number)
 *     get(id: Number, options: Object)
 *     get(id: Number, options: Object, data: Array | DataTable)
 *
 *     get(ids: Number[])
 *     get(ids: Number[], options: Object)
 *     get(ids: Number[], options: Object, data: Array | DataTable)
 *
 * Where:
 *
 * {Number | String} id         The id of an item
 * {Number[] | String{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 *                              {String} [type] Type of data to be returned. Can
 *                                              be 'DataTable' or 'Array' (default)
 *                              {Object.<String, String>} [convert]
 *                              {String[]} [fields] field names to be returned
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * {Array | DataTable} [data]   If provided, items will be appended to this
 *                              array or table. Required in case of Google
 *                              DataTable.
 * @param args
 */
DataView.prototype.get = function (args) {
  var me = this;

  // parse the arguments
  var ids, options, data;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number' || firstType == 'Array') {
    // get(id(s) [, options] [, data])
    ids = arguments[0];  // can be a single id or an array with ids
    options = arguments[1];
    data = arguments[2];
  }
  else {
    // get([, options] [, data])
    options = arguments[0];
    data = arguments[1];
  }

  // extend the options with the default options and provided options
  var viewOptions = util.extend({}, this._options, options);

  // create a combined filter method when needed
  if (this._options.filter && options && options.filter) {
    viewOptions.filter = function (item) {
      return me._options.filter(item) && options.filter(item);
    }
  }

  // build up the call to the linked data set
  var getArguments = [];
  if (ids != undefined) {
    getArguments.push(ids);
  }
  getArguments.push(viewOptions);
  getArguments.push(data);

  return this._data && this._data.get.apply(this._data, getArguments);
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array} ids
 */
DataView.prototype.getIds = function (options) {
  var ids;

  if (this._data) {
    var defaultFilter = this._options.filter;
    var filter;

    if (options && options.filter) {
      if (defaultFilter) {
        filter = function (item) {
          return defaultFilter(item) && options.filter(item);
        }
      }
      else {
        filter = options.filter;
      }
    }
    else {
      filter = defaultFilter;
    }

    ids = this._data.getIds({
      filter: filter,
      order: options && options.order
    });
  }
  else {
    ids = [];
  }

  return ids;
};

/**
 * Get the DataSet to which this DataView is connected. In case there is a chain
 * of multiple DataViews, the root DataSet of this chain is returned.
 * @return {DataSet} dataSet
 */
DataView.prototype.getDataSet = function () {
  var dataSet = this;
  while (dataSet instanceof DataView) {
    dataSet = dataSet._data;
  }
  return dataSet || null;
};

/**
 * Event listener. Will propagate all events from the connected data set to
 * the subscribers of the DataView, but will filter the items and only trigger
 * when there are changes in the filtered data set.
 * @param {String} event
 * @param {Object | null} params
 * @param {String} senderId
 * @private
 */
DataView.prototype._onEvent = function (event, params, senderId) {
  var i, len, id, item,
      ids = params && params.items,
      data = this._data,
      added = [],
      updated = [],
      removed = [];

  if (ids && data) {
    switch (event) {
      case 'add':
        // filter the ids of the added items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);
          if (item) {
            this._ids[id] = true;
            added.push(id);
          }
        }

        break;

      case 'update':
        // determine the event from the views viewpoint: an updated
        // item can be added, updated, or removed from this view.
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);

          if (item) {
            if (this._ids[id]) {
              updated.push(id);
            }
            else {
              this._ids[id] = true;
              added.push(id);
            }
          }
          else {
            if (this._ids[id]) {
              delete this._ids[id];
              removed.push(id);
            }
            else {
              // nothing interesting for me :-(
            }
          }
        }

        break;

      case 'remove':
        // filter the ids of the removed items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          if (this._ids[id]) {
            delete this._ids[id];
            removed.push(id);
          }
        }

        break;
    }

    if (added.length) {
      this._trigger('add', {items: added}, senderId);
    }
    if (updated.length) {
      this._trigger('update', {items: updated}, senderId);
    }
    if (removed.length) {
      this._trigger('remove', {items: removed}, senderId);
    }
  }
};

// copy subscription functionality from DataSet
DataView.prototype.on = DataSet.prototype.on;
DataView.prototype.off = DataSet.prototype.off;
DataView.prototype._trigger = DataSet.prototype._trigger;

// TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)
DataView.prototype.subscribe = DataView.prototype.on;
DataView.prototype.unsubscribe = DataView.prototype.off;

module.exports = DataView;
},{"./DataSet":29,"./util":52}],31:[function(require,module,exports){
var Hammer = require('./module/hammer');

/**
 * Fake a hammer.js gesture. Event can be a ScrollEvent or MouseMoveEvent
 * @param {Element} element
 * @param {Event} event
 */
exports.fakeGesture = function(element, event) {
  var eventType = null;

  // for hammer.js 1.0.5
  // var gesture = Hammer.event.collectEventData(this, eventType, event);

  // for hammer.js 1.0.6+
  var touches = Hammer.event.getTouchList(event, eventType);
  var gesture = Hammer.event.collectEventData(this, eventType, touches, event);

  // on IE in standards mode, no touches are recognized by hammer.js,
  // resulting in NaN values for center.pageX and center.pageY
  if (isNaN(gesture.center.pageX)) {
    gesture.center.pageX = event.pageX;
  }
  if (isNaN(gesture.center.pageY)) {
    gesture.center.pageY = event.pageY;
  }

  return gesture;
};

},{"./module/hammer":32}],32:[function(require,module,exports){
// Only load hammer.js when in a browser environment
// (loading hammer.js in a node.js environment gives errors)
if (typeof window !== 'undefined') {
  module.exports = window['Hammer'] || require('hammerjs');
}
else {
  module.exports = function () {
    throw Error('hammer.js is only available in a browser, not in node.js.');
  }
}

},{"hammerjs":54}],33:[function(require,module,exports){
// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.
module.exports = (typeof window !== 'undefined') && window['moment'] || require('moment');

},{"moment":55}],34:[function(require,module,exports){
var mousetrap = require('mousetrap');
var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var util = require('../util');

/**
 * Turn an element into an clickToUse element.
 * When not active, the element has a transparent overlay. When the overlay is
 * clicked, the mode is changed to active.
 * When active, the element is displayed with a blue border around it, and
 * the interactive contents of the element can be used. When clicked outside
 * the element, the elements mode is changed to inactive.
 * @param {Element} container
 * @constructor
 */
function Activator(container) {
  this.active = false;

  this.dom = {
    container: container
  };

  this.dom.overlay = document.createElement('div');
  this.dom.overlay.className = 'overlay';

  this.dom.container.appendChild(this.dom.overlay);

  this.hammer = Hammer(this.dom.overlay, {prevent_default: false});
  this.hammer.on('tap', this._onTapOverlay.bind(this));

  // block all touch events (except tap)
  var me = this;
  var events = [
    'touch', 'pinch',
    'doubletap', 'hold',
    'dragstart', 'drag', 'dragend',
    'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
  ];
  events.forEach(function (event) {
    me.hammer.on(event, function (event) {
      event.stopPropagation();
    });
  });

  // attach a tap event to the window, in order to deactivate when clicking outside the timeline
  this.windowHammer = Hammer(window, {prevent_default: false});
  this.windowHammer.on('tap', function (event) {
    // deactivate when clicked outside the container
    if (!_hasParent(event.target, container)) {
      me.deactivate();
    }
  });

  // mousetrap listener only bounded when active)
  this.escListener = this.deactivate.bind(this);
}

// turn into an event emitter
Emitter(Activator.prototype);

// The currently active activator
Activator.current = null;

/**
 * Destroy the activator. Cleans up all created DOM and event listeners
 */
Activator.prototype.destroy = function () {
  this.deactivate();

  // remove dom
  this.dom.overlay.parentNode.removeChild(this.dom.overlay);

  // cleanup hammer instances
  this.hammer = null;
  this.windowHammer = null;
  // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)
};

/**
 * Activate the element
 * Overlay is hidden, element is decorated with a blue shadow border
 */
Activator.prototype.activate = function () {
  // we allow only one active activator at a time
  if (Activator.current) {
    Activator.current.deactivate();
  }
  Activator.current = this;

  this.active = true;
  this.dom.overlay.style.display = 'none';
  util.addClassName(this.dom.container, 'vis-active');

  this.emit('change');
  this.emit('activate');

  // ugly hack: bind ESC after emitting the events, as the Network rebinds all
  // keyboard events on a 'change' event
  mousetrap.bind('esc', this.escListener);
};

/**
 * Deactivate the element
 * Overlay is displayed on top of the element
 */
Activator.prototype.deactivate = function () {
  this.active = false;
  this.dom.overlay.style.display = '';
  util.removeClassName(this.dom.container, 'vis-active');
  mousetrap.unbind('esc', this.escListener);

  this.emit('change');
  this.emit('deactivate');
};

/**
 * Handle a tap event: activate the container
 * @param event
 * @private
 */
Activator.prototype._onTapOverlay = function (event) {
  // activate the container
  this.activate();
  event.stopPropagation();
};

/**
 * Test whether the element has the requested parent element somewhere in
 * its chain of parent nodes.
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @returns {boolean} Returns true when the parent is found somewhere in the
 *                    chain of parent nodes.
 * @private
 */
function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true
    }
    element = element.parentNode;
  }
  return false;
}

module.exports = Activator;

},{"../module/hammer":32,"../util":52,"emitter-component":53,"mousetrap":56}],35:[function(require,module,exports){
var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var util = require('../util');
var DataSet = require('../DataSet');
var DataView = require('../DataView');
var Range = require('./Range');
var TimeAxis = require('./component/TimeAxis');
var CurrentTime = require('./component/CurrentTime');
var CustomTime = require('./component/CustomTime');
var ItemSet = require('./component/ItemSet');
var Activator = require('../shared/Activator');

/**
 * Create a timeline visualization
 * @param {HTMLElement} container
 * @param {vis.DataSet | Array | google.visualization.DataTable} [items]
 * @param {Object} [options]  See Core.setOptions for the available options.
 * @constructor
 */
function Core () {}

// turn Core into an event emitter
Emitter(Core.prototype);

/**
 * Create the main DOM for the Core: a root panel containing left, right,
 * top, bottom, content, and background panel.
 * @param {Element} container  The container element where the Core will
 *                             be attached.
 * @private
 */
Core.prototype._create = function (container) {
  this.dom = {};

  this.dom.root                 = document.createElement('div');
  this.dom.background           = document.createElement('div');
  this.dom.backgroundVertical   = document.createElement('div');
  this.dom.backgroundHorizontal = document.createElement('div');
  this.dom.centerContainer      = document.createElement('div');
  this.dom.leftContainer        = document.createElement('div');
  this.dom.rightContainer       = document.createElement('div');
  this.dom.center               = document.createElement('div');
  this.dom.left                 = document.createElement('div');
  this.dom.right                = document.createElement('div');
  this.dom.top                  = document.createElement('div');
  this.dom.bottom               = document.createElement('div');
  this.dom.shadowTop            = document.createElement('div');
  this.dom.shadowBottom         = document.createElement('div');
  this.dom.shadowTopLeft        = document.createElement('div');
  this.dom.shadowBottomLeft     = document.createElement('div');
  this.dom.shadowTopRight       = document.createElement('div');
  this.dom.shadowBottomRight    = document.createElement('div');

  this.dom.root.className                 = 'vis timeline root';
  this.dom.background.className           = 'vispanel background';
  this.dom.backgroundVertical.className   = 'vispanel background vertical';
  this.dom.backgroundHorizontal.className = 'vispanel background horizontal';
  this.dom.centerContainer.className      = 'vispanel center';
  this.dom.leftContainer.className        = 'vispanel left';
  this.dom.rightContainer.className       = 'vispanel right';
  this.dom.top.className                  = 'vispanel top';
  this.dom.bottom.className               = 'vispanel bottom';
  this.dom.left.className                 = 'content';
  this.dom.center.className               = 'content';
  this.dom.right.className                = 'content';
  this.dom.shadowTop.className            = 'shadow top';
  this.dom.shadowBottom.className         = 'shadow bottom';
  this.dom.shadowTopLeft.className        = 'shadow top';
  this.dom.shadowBottomLeft.className     = 'shadow bottom';
  this.dom.shadowTopRight.className       = 'shadow top';
  this.dom.shadowBottomRight.className    = 'shadow bottom';

  this.dom.root.appendChild(this.dom.background);
  this.dom.root.appendChild(this.dom.backgroundVertical);
  this.dom.root.appendChild(this.dom.backgroundHorizontal);
  this.dom.root.appendChild(this.dom.centerContainer);
  this.dom.root.appendChild(this.dom.leftContainer);
  this.dom.root.appendChild(this.dom.rightContainer);
  this.dom.root.appendChild(this.dom.top);
  this.dom.root.appendChild(this.dom.bottom);

  this.dom.centerContainer.appendChild(this.dom.center);
  this.dom.leftContainer.appendChild(this.dom.left);
  this.dom.rightContainer.appendChild(this.dom.right);

  this.dom.centerContainer.appendChild(this.dom.shadowTop);
  this.dom.centerContainer.appendChild(this.dom.shadowBottom);
  this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);
  this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);
  this.dom.rightContainer.appendChild(this.dom.shadowTopRight);
  this.dom.rightContainer.appendChild(this.dom.shadowBottomRight);

  this.on('rangechange', this.redraw.bind(this));
  this.on('change', this.redraw.bind(this));
  this.on('touch', this._onTouch.bind(this));
  this.on('pinch', this._onPinch.bind(this));
  this.on('dragstart', this._onDragStart.bind(this));
  this.on('drag', this._onDrag.bind(this));

  // create event listeners for all interesting events, these events will be
  // emitted via emitter
  this.hammer = Hammer(this.dom.root, {
    preventDefault: true
  });
  this.listeners = {};

  var me = this;
  var events = [
    'touch', 'pinch',
    'tap', 'doubletap', 'hold',
    'dragstart', 'drag', 'dragend',
    'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
  ];
  events.forEach(function (event) {
    var listener = function () {
      var args = [event].concat(Array.prototype.slice.call(arguments, 0));
      if (me.isActive()) {
        me.emit.apply(me, args);
      }
    };
    me.hammer.on(event, listener);
    me.listeners[event] = listener;
  });

  // size properties of each of the panels
  this.props = {
    root: {},
    background: {},
    centerContainer: {},
    leftContainer: {},
    rightContainer: {},
    center: {},
    left: {},
    right: {},
    top: {},
    bottom: {},
    border: {},
    scrollTop: 0,
    scrollTopMin: 0
  };
  this.touch = {}; // store state information needed for touch events

  // attach the root panel to the provided container
  if (!container) throw new Error('No container provided');
  container.appendChild(this.dom.root);
};

/**
 * Set options. Options will be passed to all components loaded in the Timeline.
 * @param {Object} [options]
 *                           {String} orientation
 *                              Vertical orientation for the Timeline,
 *                              can be 'bottom' (default) or 'top'.
 *                           {String | Number} width
 *                              Width for the timeline, a number in pixels or
 *                              a css string like '1000px' or '75%'. '100%' by default.
 *                           {String | Number} height
 *                              Fixed height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'. If undefined,
 *                              The Timeline will automatically size such that
 *                              its contents fit.
 *                           {String | Number} minHeight
 *                              Minimum height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'.
 *                           {String | Number} maxHeight
 *                              Maximum height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'.
 *                           {Number | Date | String} start
 *                              Start date for the visible window
 *                           {Number | Date | String} end
 *                              End date for the visible window
 */
Core.prototype.setOptions = function (options) {
  if (options) {
    // copy the known options
    var fields = ['width', 'height', 'minHeight', 'maxHeight', 'autoResize', 'start', 'end', 'orientation', 'clickToUse', 'dataAttributes'];
    util.selectiveExtend(fields, this.options, options);

    if ('clickToUse' in options) {
      if (options.clickToUse) {
        this.activator = new Activator(this.dom.root);
      }
      else {
        if (this.activator) {
          this.activator.destroy();
          delete this.activator;
        }
      }
    }

    // enable/disable autoResize
    this._initAutoResize();
  }

  // propagate options to all components
  this.components.forEach(function (component) {
    component.setOptions(options);
  });

  // TODO: remove deprecation error one day (deprecated since version 0.8.0)
  if (options && options.order) {
    throw new Error('Option order is deprecated. There is no replacement for this feature.');
  }

  // redraw everything
  this.redraw();
};

/**
 * Returns true when the Timeline is active.
 * @returns {boolean}
 */
Core.prototype.isActive = function () {
  return !this.activator || this.activator.active;
};

/**
 * Destroy the Core, clean up all DOM elements and event listeners.
 */
Core.prototype.destroy = function () {
  // unbind datasets
  this.clear();

  // remove all event listeners
  this.off();

  // stop checking for changed size
  this._stopAutoResize();

  // remove from DOM
  if (this.dom.root.parentNode) {
    this.dom.root.parentNode.removeChild(this.dom.root);
  }
  this.dom = null;

  // remove Activator
  if (this.activator) {
    this.activator.destroy();
    delete this.activator;
  }

  // cleanup hammer touch events
  for (var event in this.listeners) {
    if (this.listeners.hasOwnProperty(event)) {
      delete this.listeners[event];
    }
  }
  this.listeners = null;
  this.hammer = null;

  // give all components the opportunity to cleanup
  this.components.forEach(function (component) {
    component.destroy();
  });

  this.body = null;
};


/**
 * Set a custom time bar
 * @param {Date} time
 */
Core.prototype.setCustomTime = function (time) {
  if (!this.customTime) {
    throw new Error('Cannot get custom time: Custom time bar is not enabled');
  }

  this.customTime.setCustomTime(time);
};

/**
 * Retrieve the current custom time.
 * @return {Date} customTime
 */
Core.prototype.getCustomTime = function() {
  if (!this.customTime) {
    throw new Error('Cannot get custom time: Custom time bar is not enabled');
  }

  return this.customTime.getCustomTime();
};


/**
 * Get the id's of the currently visible items.
 * @returns {Array} The ids of the visible items
 */
Core.prototype.getVisibleItems = function() {
  return this.itemSet && this.itemSet.getVisibleItems() || [];
};



/**
 * Clear the Core. By Default, items, groups and options are cleared.
 * Example usage:
 *
 *     timeline.clear();                // clear items, groups, and options
 *     timeline.clear({options: true}); // clear options only
 *
 * @param {Object} [what]      Optionally specify what to clear. By default:
 *                             {items: true, groups: true, options: true}
 */
Core.prototype.clear = function(what) {
  // clear items
  if (!what || what.items) {
    this.setItems(null);
  }

  // clear groups
  if (!what || what.groups) {
    this.setGroups(null);
  }

  // clear options of timeline and of each of the components
  if (!what || what.options) {
    this.components.forEach(function (component) {
      component.setOptions(component.defaultOptions);
    });

    this.setOptions(this.defaultOptions); // this will also do a redraw
  }
};

/**
 * Set Core window such that it fits all items
 * @param {Object} [options]  Available options:
 *                            `animate: boolean | number`
 *                                 If true (default), the range is animated
 *                                 smoothly to the new window.
 *                                 If a number, the number is taken as duration
 *                                 for the animation. Default duration is 500 ms.
 */
Core.prototype.fit = function(options) {
  // apply the data range as range
  var dataRange = this.getItemRange();

  // add 5% space on both sides
  var start = dataRange.min;
  var end = dataRange.max;
  if (start != null && end != null) {
    var interval = (end.valueOf() - start.valueOf());
    if (interval <= 0) {
      // prevent an empty interval
      interval = 24 * 60 * 60 * 1000; // 1 day
    }
    start = new Date(start.valueOf() - interval * 0.05);
    end = new Date(end.valueOf() + interval * 0.05);
  }

  // skip range set if there is no start and end date
  if (start === null && end === null) {
    return;
  }

  var animate = (options && options.animate !== undefined) ? options.animate : true;
  this.range.setRange(start, end, animate);
};

/**
 * Set the visible window. Both parameters are optional, you can change only
 * start or only end. Syntax:
 *
 *     TimeLine.setWindow(start, end)
 *     TimeLine.setWindow(range)
 *
 * Where start and end can be a Date, number, or string, and range is an
 * object with properties start and end.
 *
 * @param {Date | Number | String | Object} [start] Start date of visible window
 * @param {Date | Number | String} [end]            End date of visible window
 * @param {Object} [options]  Available options:
 *                            `animate: boolean | number`
 *                                 If true (default), the range is animated
 *                                 smoothly to the new window.
 *                                 If a number, the number is taken as duration
 *                                 for the animation. Default duration is 500 ms.
 */
Core.prototype.setWindow = function(start, end, options) {
  var animate = (options && options.animate !== undefined) ? options.animate : true;
  if (arguments.length == 1) {
    var range = arguments[0];
    this.range.setRange(range.start, range.end, animate);
  }
  else {
    this.range.setRange(start, end, animate);
  }
};

/**
 * Move the window such that given time is centered on screen.
 * @param {Date | Number | String} time
 * @param {Object} [options]  Available options:
 *                            `animate: boolean | number`
 *                                 If true (default), the range is animated
 *                                 smoothly to the new window.
 *                                 If a number, the number is taken as duration
 *                                 for the animation. Default duration is 500 ms.
 */
Core.prototype.moveTo = function(time, options) {
  var interval = this.range.end - this.range.start;
  var t = util.convert(time, 'Date').valueOf();

  var start = t - interval / 2;
  var end = t + interval / 2;
  var animate = (options && options.animate !== undefined) ? options.animate : true;

  this.range.setRange(start, end, animate);
};

/**
 * Get the visible window
 * @return {{start: Date, end: Date}}   Visible range
 */
Core.prototype.getWindow = function() {
  var range = this.range.getRange();
  return {
    start: new Date(range.start),
    end: new Date(range.end)
  };
};

/**
 * Force a redraw of the Core. Can be useful to manually redraw when
 * option autoResize=false
 */
Core.prototype.redraw = function() {
  var resized = false,
    options = this.options,
    props = this.props,
    dom = this.dom;

  if (!dom) return; // when destroyed

  // update class names
  if (options.orientation == 'top') {
    util.addClassName(dom.root, 'top');
    util.removeClassName(dom.root, 'bottom');
  }
  else {
    util.removeClassName(dom.root, 'top');
    util.addClassName(dom.root, 'bottom');
  }

  // update root width and height options
  dom.root.style.maxHeight = util.option.asSize(options.maxHeight, '');
  dom.root.style.minHeight = util.option.asSize(options.minHeight, '');
  dom.root.style.width = util.option.asSize(options.width, '');

  // calculate border widths
  props.border.left   = (dom.centerContainer.offsetWidth - dom.centerContainer.clientWidth) / 2;
  props.border.right  = props.border.left;
  props.border.top    = (dom.centerContainer.offsetHeight - dom.centerContainer.clientHeight) / 2;
  props.border.bottom = props.border.top;
  var borderRootHeight= dom.root.offsetHeight - dom.root.clientHeight;
  var borderRootWidth = dom.root.offsetWidth - dom.root.clientWidth;

  // workaround for a bug in IE: the clientWidth of an element with
  // a height:0px and overflow:hidden is not calculated and always has value 0
  if (dom.centerContainer.clientHeight === 0) {
    props.border.left = props.border.top;
    props.border.right  = props.border.left;
  }
  if (dom.root.clientHeight === 0) {
    borderRootWidth = borderRootHeight;
  }

  // calculate the heights. If any of the side panels is empty, we set the height to
  // minus the border width, such that the border will be invisible
  props.center.height = dom.center.offsetHeight;
  props.left.height   = dom.left.offsetHeight;
  props.right.height  = dom.right.offsetHeight;
  props.top.height    = dom.top.clientHeight    || -props.border.top;
  props.bottom.height = dom.bottom.clientHeight || -props.border.bottom;

  // TODO: compensate borders when any of the panels is empty.

  // apply auto height
  // TODO: only calculate autoHeight when needed (else we cause an extra reflow/repaint of the DOM)
  var contentHeight = Math.max(props.left.height, props.center.height, props.right.height);
  var autoHeight = props.top.height + contentHeight + props.bottom.height +
    borderRootHeight + props.border.top + props.border.bottom;
  dom.root.style.height = util.option.asSize(options.height, autoHeight + 'px');

  // calculate heights of the content panels
  props.root.height = dom.root.offsetHeight;
  props.background.height = props.root.height - borderRootHeight;
  var containerHeight = props.root.height - props.top.height - props.bottom.height -
    borderRootHeight;
  props.centerContainer.height  = containerHeight;
  props.leftContainer.height    = containerHeight;
  props.rightContainer.height   = props.leftContainer.height;

  // calculate the widths of the panels
  props.root.width = dom.root.offsetWidth;
  props.background.width = props.root.width - borderRootWidth;
  props.left.width = dom.leftContainer.clientWidth   || -props.border.left;
  props.leftContainer.width = props.left.width;
  props.right.width = dom.rightContainer.clientWidth || -props.border.right;
  props.rightContainer.width = props.right.width;
  var centerWidth = props.root.width - props.left.width - props.right.width - borderRootWidth;
  props.center.width          = centerWidth;
  props.centerContainer.width = centerWidth;
  props.top.width             = centerWidth;
  props.bottom.width          = centerWidth;

  // resize the panels
  dom.background.style.height           = props.background.height + 'px';
  dom.backgroundVertical.style.height   = props.background.height + 'px';
  dom.backgroundHorizontal.style.height = props.centerContainer.height + 'px';
  dom.centerContainer.style.height      = props.centerContainer.height + 'px';
  dom.leftContainer.style.height        = props.leftContainer.height + 'px';
  dom.rightContainer.style.height       = props.rightContainer.height + 'px';

  dom.background.style.width            = props.background.width + 'px';
  dom.backgroundVertical.style.width    = props.centerContainer.width + 'px';
  dom.backgroundHorizontal.style.width  = props.background.width + 'px';
  dom.centerContainer.style.width       = props.center.width + 'px';
  dom.top.style.width                   = props.top.width + 'px';
  dom.bottom.style.width                = props.bottom.width + 'px';

  // reposition the panels
  dom.background.style.left           = '0';
  dom.background.style.top            = '0';
  dom.backgroundVertical.style.left   = (props.left.width + props.border.left) + 'px';
  dom.backgroundVertical.style.top    = '0';
  dom.backgroundHorizontal.style.left = '0';
  dom.backgroundHorizontal.style.top  = props.top.height + 'px';
  dom.centerContainer.style.left      = props.left.width + 'px';
  dom.centerContainer.style.top       = props.top.height + 'px';
  dom.leftContainer.style.left        = '0';
  dom.leftContainer.style.top         = props.top.height + 'px';
  dom.rightContainer.style.left       = (props.left.width + props.center.width) + 'px';
  dom.rightContainer.style.top        = props.top.height + 'px';
  dom.top.style.left                  = props.left.width + 'px';
  dom.top.style.top                   = '0';
  dom.bottom.style.left               = props.left.width + 'px';
  dom.bottom.style.top                = (props.top.height + props.centerContainer.height) + 'px';

  // update the scrollTop, feasible range for the offset can be changed
  // when the height of the Core or of the contents of the center changed
  this._updateScrollTop();

  // reposition the scrollable contents
  var offset = this.props.scrollTop;
  if (options.orientation == 'bottom') {
    offset += Math.max(this.props.centerContainer.height - this.props.center.height -
      this.props.border.top - this.props.border.bottom, 0);
  }
  dom.center.style.left = '0';
  dom.center.style.top  = offset + 'px';
  dom.left.style.left   = '0';
  dom.left.style.top    = offset + 'px';
  dom.right.style.left  = '0';
  dom.right.style.top   = offset + 'px';

  // show shadows when vertical scrolling is available
  var visibilityTop = this.props.scrollTop == 0 ? 'hidden' : '';
  var visibilityBottom = this.props.scrollTop == this.props.scrollTopMin ? 'hidden' : '';
  dom.shadowTop.style.visibility          = visibilityTop;
  dom.shadowBottom.style.visibility       = visibilityBottom;
  dom.shadowTopLeft.style.visibility      = visibilityTop;
  dom.shadowBottomLeft.style.visibility   = visibilityBottom;
  dom.shadowTopRight.style.visibility     = visibilityTop;
  dom.shadowBottomRight.style.visibility  = visibilityBottom;

  // redraw all components
  this.components.forEach(function (component) {
    resized = component.redraw() || resized;
  });
  if (resized) {
    // keep repainting until all sizes are settled
    this.redraw();
  }
};

// TODO: deprecated since version 1.1.0, remove some day
Core.prototype.repaint = function () {
  throw new Error('Function repaint is deprecated. Use redraw instead.');
};

/**
 * Set a current time. This can be used for example to ensure that a client's
 * time is synchronized with a shared server time.
 * Only applicable when option `showCurrentTime` is true.
 * @param {Date | String | Number} time     A Date, unix timestamp, or
 *                                          ISO date string.
 */
Core.prototype.setCurrentTime = function(time) {
  if (!this.currentTime) {
    throw new Error('Option showCurrentTime must be true');
  }

  this.currentTime.setCurrentTime(time);
};

/**
 * Get the current time.
 * Only applicable when option `showCurrentTime` is true.
 * @return {Date} Returns the current time.
 */
Core.prototype.getCurrentTime = function() {
  if (!this.currentTime) {
    throw new Error('Option showCurrentTime must be true');
  }

  return this.currentTime.getCurrentTime();
};

/**
 * Convert a position on screen (pixels) to a datetime
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 * @private
 */
// TODO: move this function to Range
Core.prototype._toTime = function(x) {
  var conversion = this.range.conversion(this.props.center.width);
  return new Date(x / conversion.scale + conversion.offset);
};


/**
 * Convert a position on the global screen (pixels) to a datetime
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 * @private
 */
// TODO: move this function to Range
Core.prototype._toGlobalTime = function(x) {
  var conversion = this.range.conversion(this.props.root.width);
  return new Date(x / conversion.scale + conversion.offset);
};

/**
 * Convert a datetime (Date object) into a position on the screen
 * @param {Date}   time A date
 * @return {int}   x    The position on the screen in pixels which corresponds
 *                      with the given date.
 * @private
 */
// TODO: move this function to Range
Core.prototype._toScreen = function(time) {
  var conversion = this.range.conversion(this.props.center.width);
  return (time.valueOf() - conversion.offset) * conversion.scale;
};


/**
 * Convert a datetime (Date object) into a position on the root
 * This is used to get the pixel density estimate for the screen, not the center panel
 * @param {Date}   time A date
 * @return {int}   x    The position on root in pixels which corresponds
 *                      with the given date.
 * @private
 */
// TODO: move this function to Range
Core.prototype._toGlobalScreen = function(time) {
  var conversion = this.range.conversion(this.props.root.width);
  return (time.valueOf() - conversion.offset) * conversion.scale;
};


/**
 * Initialize watching when option autoResize is true
 * @private
 */
Core.prototype._initAutoResize = function () {
  if (this.options.autoResize == true) {
    this._startAutoResize();
  }
  else {
    this._stopAutoResize();
  }
};

/**
 * Watch for changes in the size of the container. On resize, the Panel will
 * automatically redraw itself.
 * @private
 */
Core.prototype._startAutoResize = function () {
  var me = this;

  this._stopAutoResize();

  this._onResize = function() {
    if (me.options.autoResize != true) {
      // stop watching when the option autoResize is changed to false
      me._stopAutoResize();
      return;
    }

    if (me.dom.root) {
      // check whether the frame is resized
      // Note: we compare offsetWidth here, not clientWidth. For some reason,
      // IE does not restore the clientWidth from 0 to the actual width after
      // changing the timeline's container display style from none to visible
      if ((me.dom.root.offsetWidth != me.props.lastWidth) ||
        (me.dom.root.offsetHeight != me.props.lastHeight)) {
        me.props.lastWidth = me.dom.root.offsetWidth;
        me.props.lastHeight = me.dom.root.offsetHeight;

        me.emit('change');
      }
    }
  };

  // add event listener to window resize
  util.addEventListener(window, 'resize', this._onResize);

  this.watchTimer = setInterval(this._onResize, 1000);
};

/**
 * Stop watching for a resize of the frame.
 * @private
 */
Core.prototype._stopAutoResize = function () {
  if (this.watchTimer) {
    clearInterval(this.watchTimer);
    this.watchTimer = undefined;
  }

  // remove event listener on window.resize
  util.removeEventListener(window, 'resize', this._onResize);
  this._onResize = null;
};

/**
 * Start moving the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onTouch = function (event) {
  this.touch.allowDragging = true;
};

/**
 * Start moving the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onPinch = function (event) {
  this.touch.allowDragging = false;
};

/**
 * Start moving the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onDragStart = function (event) {
  this.touch.initialScrollTop = this.props.scrollTop;
};

/**
 * Move the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onDrag = function (event) {
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.touch.allowDragging) return;

  var delta = event.gesture.deltaY;

  var oldScrollTop = this._getScrollTop();
  var newScrollTop = this._setScrollTop(this.touch.initialScrollTop + delta);

  if (newScrollTop != oldScrollTop) {
    this.redraw(); // TODO: this causes two redraws when dragging, the other is triggered by rangechange already
  }
};

/**
 * Apply a scrollTop
 * @param {Number} scrollTop
 * @returns {Number} scrollTop  Returns the applied scrollTop
 * @private
 */
Core.prototype._setScrollTop = function (scrollTop) {
  this.props.scrollTop = scrollTop;
  this._updateScrollTop();
  return this.props.scrollTop;
};

/**
 * Update the current scrollTop when the height of  the containers has been changed
 * @returns {Number} scrollTop  Returns the applied scrollTop
 * @private
 */
Core.prototype._updateScrollTop = function () {
  // recalculate the scrollTopMin
  var scrollTopMin = Math.min(this.props.centerContainer.height - this.props.center.height, 0); // is negative or zero
  if (scrollTopMin != this.props.scrollTopMin) {
    // in case of bottom orientation, change the scrollTop such that the contents
    // do not move relative to the time axis at the bottom
    if (this.options.orientation == 'bottom') {
      this.props.scrollTop += (scrollTopMin - this.props.scrollTopMin);
    }
    this.props.scrollTopMin = scrollTopMin;
  }

  // limit the scrollTop to the feasible scroll range
  if (this.props.scrollTop > 0) this.props.scrollTop = 0;
  if (this.props.scrollTop < scrollTopMin) this.props.scrollTop = scrollTopMin;

  return this.props.scrollTop;
};

/**
 * Get the current scrollTop
 * @returns {number} scrollTop
 * @private
 */
Core.prototype._getScrollTop = function () {
  return this.props.scrollTop;
};

module.exports = Core;

},{"../DataSet":29,"../DataView":30,"../module/hammer":32,"../shared/Activator":34,"../util":52,"./Range":36,"./component/CurrentTime":41,"./component/CustomTime":42,"./component/ItemSet":44,"./component/TimeAxis":45,"emitter-component":53}],36:[function(require,module,exports){
var util = require('../util');
var hammerUtil = require('../hammerUtil');
var moment = require('../module/moment');
var Component = require('./component/Component');

/**
 * @constructor Range
 * A Range controls a numeric range with a start and end value.
 * The Range adjusts the range based on mouse events or programmatic changes,
 * and triggers events when the range is changing or has been changed.
 * @param {{dom: Object, domProps: Object, emitter: Emitter}} body
 * @param {Object} [options]    See description at Range.setOptions
 */
function Range(body, options) {
  var now = moment().hours(0).minutes(0).seconds(0).milliseconds(0);
  this.start = now.clone().add(-3, 'days').valueOf(); // Number
  this.end = now.clone().add(4, 'days').valueOf();   // Number

  this.body = body;

  // default options
  this.defaultOptions = {
    start: null,
    end: null,
    direction: 'horizontal', // 'horizontal' or 'vertical'
    moveable: true,
    zoomable: true,
    min: null,
    max: null,
    zoomMin: 10,                                // milliseconds
    zoomMax: 1000 * 60 * 60 * 24 * 365 * 10000  // milliseconds
  };
  this.options = util.extend({}, this.defaultOptions);

  this.props = {
    touch: {}
  };
  this.animateTimer = null;

  // drag listeners for dragging
  this.body.emitter.on('dragstart', this._onDragStart.bind(this));
  this.body.emitter.on('drag',      this._onDrag.bind(this));
  this.body.emitter.on('dragend',   this._onDragEnd.bind(this));

  // ignore dragging when holding
  this.body.emitter.on('hold', this._onHold.bind(this));

  // mouse wheel for zooming
  this.body.emitter.on('mousewheel',      this._onMouseWheel.bind(this));
  this.body.emitter.on('DOMMouseScroll',  this._onMouseWheel.bind(this)); // For FF

  // pinch to zoom
  this.body.emitter.on('touch', this._onTouch.bind(this));
  this.body.emitter.on('pinch', this._onPinch.bind(this));

  this.setOptions(options);
}

Range.prototype = new Component();

/**
 * Set options for the range controller
 * @param {Object} options      Available options:
 *                              {Number | Date | String} start  Start date for the range
 *                              {Number | Date | String} end    End date for the range
 *                              {Number} min    Minimum value for start
 *                              {Number} max    Maximum value for end
 *                              {Number} zoomMin    Set a minimum value for
 *                                                  (end - start).
 *                              {Number} zoomMax    Set a maximum value for
 *                                                  (end - start).
 *                              {Boolean} moveable Enable moving of the range
 *                                                 by dragging. True by default
 *                              {Boolean} zoomable Enable zooming of the range
 *                                                 by pinching/scrolling. True by default
 */
Range.prototype.setOptions = function (options) {
  if (options) {
    // copy the options that we know
    var fields = ['direction', 'min', 'max', 'zoomMin', 'zoomMax', 'moveable', 'zoomable', 'activate'];
    util.selectiveExtend(fields, this.options, options);

    if ('start' in options || 'end' in options) {
      // apply a new range. both start and end are optional
      this.setRange(options.start, options.end);
    }
  }
};

/**
 * Test whether direction has a valid value
 * @param {String} direction    'horizontal' or 'vertical'
 */
function validateDirection (direction) {
  if (direction != 'horizontal' && direction != 'vertical') {
    throw new TypeError('Unknown direction "' + direction + '". ' +
        'Choose "horizontal" or "vertical".');
  }
}

/**
 * Set a new start and end range
 * @param {Date | Number | String} [start]
 * @param {Date | Number | String} [end]
 * @param {boolean | number} [animate=false]     If true, the range is animated
 *                                               smoothly to the new window.
 *                                               If animate is a number, the
 *                                               number is taken as duration
 *                                               Default duration is 500 ms.
 *
 */
Range.prototype.setRange = function(start, end, animate) {
  var _start = start != undefined ? util.convert(start, 'Date').valueOf() : null;
  var _end   = end != undefined   ? util.convert(end, 'Date').valueOf()   : null;

  this._cancelAnimation();

  if (animate) {
    var me = this;
    var initStart = this.start;
    var initEnd = this.end;
    var duration = typeof animate === 'number' ? animate : 500;
    var initTime = new Date().valueOf();
    var anyChanged = false;

    function next() {
      if (!me.props.touch.dragging) {
        var now = new Date().valueOf();
        var time = now - initTime;
        var done = time > duration;
        var s = (done || _start === null) ? _start : util.easeInOutQuad(time, initStart, _start, duration);
        var e = (done || _end === null)   ? _end   : util.easeInOutQuad(time, initEnd, _end, duration);

        changed = me._applyRange(s, e);
        anyChanged = anyChanged || changed;
        if (changed) {
          me.body.emitter.emit('rangechange', {start: new Date(me.start), end: new Date(me.end)});
        }

        if (done) {
          if (anyChanged) {
            me.body.emitter.emit('rangechanged', {start: new Date(me.start), end: new Date(me.end)});
          }
        }
        else {
          // animate with as high as possible frame rate, leave 20 ms in between
          // each to prevent the browser from blocking
          me.animateTimer = setTimeout(next, 20);
        }
      }
    }

    return next();
  }
  else {
    var changed = this._applyRange(_start, _end);
    if (changed) {
      var params = {start: new Date(this.start), end: new Date(this.end)};
      this.body.emitter.emit('rangechange', params);
      this.body.emitter.emit('rangechanged', params);
    }
  }
};

/**
 * Stop an animation
 * @private
 */
Range.prototype._cancelAnimation = function () {
  if (this.animateTimer) {
    clearTimeout(this.animateTimer);
    this.animateTimer = null;
  }
};

/**
 * Set a new start and end range. This method is the same as setRange, but
 * does not trigger a range change and range changed event, and it returns
 * true when the range is changed
 * @param {Number} [start]
 * @param {Number} [end]
 * @return {Boolean} changed
 * @private
 */
Range.prototype._applyRange = function(start, end) {
  var newStart = (start != null) ? util.convert(start, 'Date').valueOf() : this.start,
      newEnd   = (end != null)   ? util.convert(end, 'Date').valueOf()   : this.end,
      max = (this.options.max != null) ? util.convert(this.options.max, 'Date').valueOf() : null,
      min = (this.options.min != null) ? util.convert(this.options.min, 'Date').valueOf() : null,
      diff;

  // check for valid number
  if (isNaN(newStart) || newStart === null) {
    throw new Error('Invalid start "' + start + '"');
  }
  if (isNaN(newEnd) || newEnd === null) {
    throw new Error('Invalid end "' + end + '"');
  }

  // prevent start < end
  if (newEnd < newStart) {
    newEnd = newStart;
  }

  // prevent start < min
  if (min !== null) {
    if (newStart < min) {
      diff = (min - newStart);
      newStart += diff;
      newEnd += diff;

      // prevent end > max
      if (max != null) {
        if (newEnd > max) {
          newEnd = max;
        }
      }
    }
  }

  // prevent end > max
  if (max !== null) {
    if (newEnd > max) {
      diff = (newEnd - max);
      newStart -= diff;
      newEnd -= diff;

      // prevent start < min
      if (min != null) {
        if (newStart < min) {
          newStart = min;
        }
      }
    }
  }

  // prevent (end-start) < zoomMin
  if (this.options.zoomMin !== null) {
    var zoomMin = parseFloat(this.options.zoomMin);
    if (zoomMin < 0) {
      zoomMin = 0;
    }
    if ((newEnd - newStart) < zoomMin) {
      if ((this.end - this.start) === zoomMin) {
        // ignore this action, we are already zoomed to the minimum
        newStart = this.start;
        newEnd = this.end;
      }
      else {
        // zoom to the minimum
        diff = (zoomMin - (newEnd - newStart));
        newStart -= diff / 2;
        newEnd += diff / 2;
      }
    }
  }

  // prevent (end-start) > zoomMax
  if (this.options.zoomMax !== null) {
    var zoomMax = parseFloat(this.options.zoomMax);
    if (zoomMax < 0) {
      zoomMax = 0;
    }
    if ((newEnd - newStart) > zoomMax) {
      if ((this.end - this.start) === zoomMax) {
        // ignore this action, we are already zoomed to the maximum
        newStart = this.start;
        newEnd = this.end;
      }
      else {
        // zoom to the maximum
        diff = ((newEnd - newStart) - zoomMax);
        newStart += diff / 2;
        newEnd -= diff / 2;
      }
    }
  }

  var changed = (this.start != newStart || this.end != newEnd);

  this.start = newStart;
  this.end = newEnd;

  return changed;
};

/**
 * Retrieve the current range.
 * @return {Object} An object with start and end properties
 */
Range.prototype.getRange = function() {
  return {
    start: this.start,
    end: this.end
  };
};

/**
 * Calculate the conversion offset and scale for current range, based on
 * the provided width
 * @param {Number} width
 * @returns {{offset: number, scale: number}} conversion
 */
Range.prototype.conversion = function (width) {
  return Range.conversion(this.start, this.end, width);
};

/**
 * Static method to calculate the conversion offset and scale for a range,
 * based on the provided start, end, and width
 * @param {Number} start
 * @param {Number} end
 * @param {Number} width
 * @returns {{offset: number, scale: number}} conversion
 */
Range.conversion = function (start, end, width) {
  if (width != 0 && (end - start != 0)) {
    return {
      offset: start,
      scale: width / (end - start)
    }
  }
  else {
    return {
      offset: 0,
      scale: 1
    };
  }
};

/**
 * Start dragging horizontally or vertically
 * @param {Event} event
 * @private
 */
Range.prototype._onDragStart = function(event) {
  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  this.props.touch.start = this.start;
  this.props.touch.end = this.end;
  this.props.touch.dragging = true;

  if (this.body.dom.root) {
    this.body.dom.root.style.cursor = 'move';
  }
};

/**
 * Perform dragging operation
 * @param {Event} event
 * @private
 */
Range.prototype._onDrag = function (event) {
  // only allow dragging when configured as movable
  if (!this.options.moveable) return;
  var direction = this.options.direction;
  validateDirection(direction);

  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  var delta = (direction == 'horizontal') ? event.gesture.deltaX : event.gesture.deltaY;
  var interval = (this.props.touch.end - this.props.touch.start);
  var width = (direction == 'horizontal') ? this.body.domProps.center.width : this.body.domProps.center.height;
  var diffRange = -delta / width * interval;
  this._applyRange(this.props.touch.start + diffRange, this.props.touch.end + diffRange);

  // fire a rangechange event
  this.body.emitter.emit('rangechange', {
    start: new Date(this.start),
    end:   new Date(this.end)
  });
};

/**
 * Stop dragging operation
 * @param {event} event
 * @private
 */
Range.prototype._onDragEnd = function (event) {
  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  this.props.touch.dragging = false;
  if (this.body.dom.root) {
    this.body.dom.root.style.cursor = 'auto';
  }

  // fire a rangechanged event
  this.body.emitter.emit('rangechanged', {
    start: new Date(this.start),
    end:   new Date(this.end)
  });
};

/**
 * Event handler for mouse wheel event, used to zoom
 * Code from http://adomas.org/javascript-mouse-wheel/
 * @param {Event} event
 * @private
 */
Range.prototype._onMouseWheel = function(event) {
  // only allow zooming when configured as zoomable and moveable
  if (!(this.options.zoomable && this.options.moveable)) return;

  // retrieve delta
  var delta = 0;
  if (event.wheelDelta) { /* IE/Opera. */
    delta = event.wheelDelta / 120;
  } else if (event.detail) { /* Mozilla case. */
    // In Mozilla, sign of delta is different than in IE.
    // Also, delta is multiple of 3.
    delta = -event.detail / 3;
  }

  // If delta is nonzero, handle it.
  // Basically, delta is now positive if wheel was scrolled up,
  // and negative, if wheel was scrolled down.
  if (delta) {
    // perform the zoom action. Delta is normally 1 or -1

    // adjust a negative delta such that zooming in with delta 0.1
    // equals zooming out with a delta -0.1
    var scale;
    if (delta < 0) {
      scale = 1 - (delta / 5);
    }
    else {
      scale = 1 / (1 + (delta / 5)) ;
    }

    // calculate center, the date to zoom around
    var gesture = hammerUtil.fakeGesture(this, event),
        pointer = getPointer(gesture.center, this.body.dom.center),
        pointerDate = this._pointerToDate(pointer);

    this.zoom(scale, pointerDate);
  }

  // Prevent default actions caused by mouse wheel
  // (else the page and timeline both zoom and scroll)
  event.preventDefault();
};

/**
 * Start of a touch gesture
 * @private
 */
Range.prototype._onTouch = function (event) {
  this.props.touch.start = this.start;
  this.props.touch.end = this.end;
  this.props.touch.allowDragging = true;
  this.props.touch.center = null;
};

/**
 * On start of a hold gesture
 * @private
 */
Range.prototype._onHold = function () {
  this.props.touch.allowDragging = false;
};

/**
 * Handle pinch event
 * @param {Event} event
 * @private
 */
Range.prototype._onPinch = function (event) {
  // only allow zooming when configured as zoomable and moveable
  if (!(this.options.zoomable && this.options.moveable)) return;

  this.props.touch.allowDragging = false;

  if (event.gesture.touches.length > 1) {
    if (!this.props.touch.center) {
      this.props.touch.center = getPointer(event.gesture.center, this.body.dom.center);
    }

    var scale = 1 / event.gesture.scale,
        initDate = this._pointerToDate(this.props.touch.center);

    // calculate new start and end
    var newStart = parseInt(initDate + (this.props.touch.start - initDate) * scale);
    var newEnd = parseInt(initDate + (this.props.touch.end - initDate) * scale);

    // apply new range
    this.setRange(newStart, newEnd);
  }
};

/**
 * Helper function to calculate the center date for zooming
 * @param {{x: Number, y: Number}} pointer
 * @return {number} date
 * @private
 */
Range.prototype._pointerToDate = function (pointer) {
  var conversion;
  var direction = this.options.direction;

  validateDirection(direction);

  if (direction == 'horizontal') {
    var width = this.body.domProps.center.width;
    conversion = this.conversion(width);
    return pointer.x / conversion.scale + conversion.offset;
  }
  else {
    var height = this.body.domProps.center.height;
    conversion = this.conversion(height);
    return pointer.y / conversion.scale + conversion.offset;
  }
};

/**
 * Get the pointer location relative to the location of the dom element
 * @param {{pageX: Number, pageY: Number}} touch
 * @param {Element} element   HTML DOM element
 * @return {{x: Number, y: Number}} pointer
 * @private
 */
function getPointer (touch, element) {
  return {
    x: touch.pageX - util.getAbsoluteLeft(element),
    y: touch.pageY - util.getAbsoluteTop(element)
  };
}

/**
 * Zoom the range the given scale in or out. Start and end date will
 * be adjusted, and the timeline will be redrawn. You can optionally give a
 * date around which to zoom.
 * For example, try scale = 0.9 or 1.1
 * @param {Number} scale      Scaling factor. Values above 1 will zoom out,
 *                            values below 1 will zoom in.
 * @param {Number} [center]   Value representing a date around which will
 *                            be zoomed.
 */
Range.prototype.zoom = function(scale, center) {
  // if centerDate is not provided, take it half between start Date and end Date
  if (center == null) {
    center = (this.start + this.end) / 2;
  }

  // calculate new start and end
  var newStart = center + (this.start - center) * scale;
  var newEnd = center + (this.end - center) * scale;

  this.setRange(newStart, newEnd);
};

/**
 * Move the range with a given delta to the left or right. Start and end
 * value will be adjusted. For example, try delta = 0.1 or -0.1
 * @param {Number}  delta     Moving amount. Positive value will move right,
 *                            negative value will move left
 */
Range.prototype.move = function(delta) {
  // zoom start Date and end Date relative to the centerDate
  var diff = (this.end - this.start);

  // apply new values
  var newStart = this.start + diff * delta;
  var newEnd = this.end + diff * delta;

  // TODO: reckon with min and max range

  this.start = newStart;
  this.end = newEnd;
};

/**
 * Move the range to a new center point
 * @param {Number} moveTo      New center point of the range
 */
Range.prototype.moveTo = function(moveTo) {
  var center = (this.start + this.end) / 2;

  var diff = center - moveTo;

  // calculate new start and end
  var newStart = this.start - diff;
  var newEnd = this.end - diff;

  this.setRange(newStart, newEnd);
};

module.exports = Range;

},{"../hammerUtil":31,"../module/moment":33,"../util":52,"./component/Component":40}],37:[function(require,module,exports){
// Utility functions for ordering and stacking of items
var EPSILON = 0.001; // used when checking collisions, to prevent round-off errors

/**
 * Order items by their start data
 * @param {Item[]} items
 */
exports.orderByStart = function(items) {
  items.sort(function (a, b) {
    return a.data.start - b.data.start;
  });
};

/**
 * Order items by their end date. If they have no end date, their start date
 * is used.
 * @param {Item[]} items
 */
exports.orderByEnd = function(items) {
  items.sort(function (a, b) {
    var aTime = ('end' in a.data) ? a.data.end : a.data.start,
        bTime = ('end' in b.data) ? b.data.end : b.data.start;

    return aTime - bTime;
  });
};

/**
 * Adjust vertical positions of the items such that they don't overlap each
 * other.
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 * @param {boolean} [force=false]
 *            If true, all items will be repositioned. If false (default), only
 *            items having a top===null will be re-stacked
 */
exports.stack = function(items, margin, force) {
  var i, iMax;

  if (force) {
    // reset top position of all items
    for (i = 0, iMax = items.length; i < iMax; i++) {
      items[i].top = null;
    }
  }

  // calculate new, non-overlapping positions
  for (i = 0, iMax = items.length; i < iMax; i++) {
    var item = items[i];
    if (item.top === null) {
      // initialize top position
      item.top = margin.axis;

      do {
        // TODO: optimize checking for overlap. when there is a gap without items,
        //       you only need to check for items from the next item on, not from zero
        var collidingItem = null;
        for (var j = 0, jj = items.length; j < jj; j++) {
          var other = items[j];
          if (other.top !== null && other !== item && exports.collision(item, other, margin.item)) {
            collidingItem = other;
            break;
          }
        }

        if (collidingItem != null) {
          // There is a collision. Reposition the items above the colliding element
          item.top = collidingItem.top + collidingItem.height + margin.item.vertical;
        }
      } while (collidingItem);
    }
  }
};

/**
 * Adjust vertical positions of the items without stacking them
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 */
exports.nostack = function(items, margin) {
  var i, iMax;

  // reset top position of all items
  for (i = 0, iMax = items.length; i < iMax; i++) {
    items[i].top = margin.axis;
  }
};

/**
 * Test if the two provided items collide
 * The items must have parameters left, width, top, and height.
 * @param {Item} a          The first item
 * @param {Item} b          The second item
 * @param {{horizontal: number, vertical: number}} margin
 *                          An object containing a horizontal and vertical
 *                          minimum required margin.
 * @return {boolean}        true if a and b collide, else false
 */
exports.collision = function(a, b, margin) {
  return ((a.left - margin.horizontal + EPSILON)       < (b.left + b.width) &&
      (a.left + a.width + margin.horizontal - EPSILON) > b.left &&
      (a.top - margin.vertical + EPSILON)              < (b.top + b.height) &&
      (a.top + a.height + margin.vertical - EPSILON)   > b.top);
};

},{}],38:[function(require,module,exports){
var moment = require('../module/moment');

/**
 * @constructor  TimeStep
 * The class TimeStep is an iterator for dates. You provide a start date and an
 * end date. The class itself determines the best scale (step size) based on the
 * provided start Date, end Date, and minimumStep.
 *
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 *
 * Alternatively, you can set a scale by hand.
 * After creation, you can initialize the class by executing first(). Then you
 * can iterate from the start date to the end date via next(). You can check if
 * the end date is reached with the function hasNext(). After each step, you can
 * retrieve the current date via getCurrent().
 * The TimeStep has scales ranging from milliseconds, seconds, minutes, hours,
 * days, to years.
 *
 * Version: 1.2
 *
 * @param {Date} [start]         The start date, for example new Date(2010, 9, 21)
 *                               or new Date(2010, 9, 21, 23, 45, 00)
 * @param {Date} [end]           The end date
 * @param {Number} [minimumStep] Optional. Minimum step size in milliseconds
 */
function TimeStep(start, end, minimumStep) {
  // variables
  this.current = new Date();
  this._start = new Date();
  this._end = new Date();

  this.autoScale  = true;
  this.scale = TimeStep.SCALE.DAY;
  this.step = 1;

  // initialize the range
  this.setRange(start, end, minimumStep);
}

/// enum scale
TimeStep.SCALE = {
  MILLISECOND: 1,
  SECOND: 2,
  MINUTE: 3,
  HOUR: 4,
  DAY: 5,
  WEEKDAY: 6,
  MONTH: 7,
  YEAR: 8
};


/**
 * Set a new range
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 * @param {Date} [start]      The start date and time.
 * @param {Date} [end]        The end date and time.
 * @param {int} [minimumStep] Optional. Minimum step size in milliseconds
 */
TimeStep.prototype.setRange = function(start, end, minimumStep) {
  if (!(start instanceof Date) || !(end instanceof Date)) {
    throw  "No legal start or end date in method setRange";
  }

  this._start = (start != undefined) ? new Date(start.valueOf()) : new Date();
  this._end = (end != undefined) ? new Date(end.valueOf()) : new Date();

  if (this.autoScale) {
    this.setMinimumStep(minimumStep);
  }
};

/**
 * Set the range iterator to the start date.
 */
TimeStep.prototype.first = function() {
  this.current = new Date(this._start.valueOf());
  this.roundToMinor();
};

/**
 * Round the current date to the first minor date value
 * This must be executed once when the current date is set to start Date
 */
TimeStep.prototype.roundToMinor = function() {
  // round to floor
  // IMPORTANT: we have no breaks in this switch! (this is no bug)
  //noinspection FallthroughInSwitchStatementJS
  switch (this.scale) {
    case TimeStep.SCALE.YEAR:
      this.current.setFullYear(this.step * Math.floor(this.current.getFullYear() / this.step));
      this.current.setMonth(0);
    case TimeStep.SCALE.MONTH:        this.current.setDate(1);
    case TimeStep.SCALE.DAY:          // intentional fall through
    case TimeStep.SCALE.WEEKDAY:      this.current.setHours(0);
    case TimeStep.SCALE.HOUR:         this.current.setMinutes(0);
    case TimeStep.SCALE.MINUTE:       this.current.setSeconds(0);
    case TimeStep.SCALE.SECOND:       this.current.setMilliseconds(0);
    //case TimeStep.SCALE.MILLISECOND: // nothing to do for milliseconds
  }

  if (this.step != 1) {
    // round down to the first minor value that is a multiple of the current step size
    switch (this.scale) {
      case TimeStep.SCALE.MILLISECOND:  this.current.setMilliseconds(this.current.getMilliseconds() - this.current.getMilliseconds() % this.step);  break;
      case TimeStep.SCALE.SECOND:       this.current.setSeconds(this.current.getSeconds() - this.current.getSeconds() % this.step); break;
      case TimeStep.SCALE.MINUTE:       this.current.setMinutes(this.current.getMinutes() - this.current.getMinutes() % this.step); break;
      case TimeStep.SCALE.HOUR:         this.current.setHours(this.current.getHours() - this.current.getHours() % this.step); break;
      case TimeStep.SCALE.WEEKDAY:      // intentional fall through
      case TimeStep.SCALE.DAY:          this.current.setDate((this.current.getDate()-1) - (this.current.getDate()-1) % this.step + 1); break;
      case TimeStep.SCALE.MONTH:        this.current.setMonth(this.current.getMonth() - this.current.getMonth() % this.step);  break;
      case TimeStep.SCALE.YEAR:         this.current.setFullYear(this.current.getFullYear() - this.current.getFullYear() % this.step); break;
      default: break;
    }
  }
};

/**
 * Check if the there is a next step
 * @return {boolean}  true if the current date has not passed the end date
 */
TimeStep.prototype.hasNext = function () {
  return (this.current.valueOf() <= this._end.valueOf());
};

/**
 * Do the next step
 */
TimeStep.prototype.next = function() {
  var prev = this.current.valueOf();

  // Two cases, needed to prevent issues with switching daylight savings
  // (end of March and end of October)
  if (this.current.getMonth() < 6)   {
    switch (this.scale) {
      case TimeStep.SCALE.MILLISECOND:

        this.current = new Date(this.current.valueOf() + this.step); break;
      case TimeStep.SCALE.SECOND:       this.current = new Date(this.current.valueOf() + this.step * 1000); break;
      case TimeStep.SCALE.MINUTE:       this.current = new Date(this.current.valueOf() + this.step * 1000 * 60); break;
      case TimeStep.SCALE.HOUR:
        this.current = new Date(this.current.valueOf() + this.step * 1000 * 60 * 60);
        // in case of skipping an hour for daylight savings, adjust the hour again (else you get: 0h 5h 9h ... instead of 0h 4h 8h ...)
        var h = this.current.getHours();
        this.current.setHours(h - (h % this.step));
        break;
      case TimeStep.SCALE.WEEKDAY:      // intentional fall through
      case TimeStep.SCALE.DAY:          this.current.setDate(this.current.getDate() + this.step); break;
      case TimeStep.SCALE.MONTH:        this.current.setMonth(this.current.getMonth() + this.step); break;
      case TimeStep.SCALE.YEAR:         this.current.setFullYear(this.current.getFullYear() + this.step); break;
      default:                      break;
    }
  }
  else {
    switch (this.scale) {
      case TimeStep.SCALE.MILLISECOND:  this.current = new Date(this.current.valueOf() + this.step); break;
      case TimeStep.SCALE.SECOND:       this.current.setSeconds(this.current.getSeconds() + this.step); break;
      case TimeStep.SCALE.MINUTE:       this.current.setMinutes(this.current.getMinutes() + this.step); break;
      case TimeStep.SCALE.HOUR:         this.current.setHours(this.current.getHours() + this.step); break;
      case TimeStep.SCALE.WEEKDAY:      // intentional fall through
      case TimeStep.SCALE.DAY:          this.current.setDate(this.current.getDate() + this.step); break;
      case TimeStep.SCALE.MONTH:        this.current.setMonth(this.current.getMonth() + this.step); break;
      case TimeStep.SCALE.YEAR:         this.current.setFullYear(this.current.getFullYear() + this.step); break;
      default:                      break;
    }
  }

  if (this.step != 1) {
    // round down to the correct major value
    switch (this.scale) {
      case TimeStep.SCALE.MILLISECOND:  if(this.current.getMilliseconds() < this.step) this.current.setMilliseconds(0);  break;
      case TimeStep.SCALE.SECOND:       if(this.current.getSeconds() < this.step) this.current.setSeconds(0);  break;
      case TimeStep.SCALE.MINUTE:       if(this.current.getMinutes() < this.step) this.current.setMinutes(0);  break;
      case TimeStep.SCALE.HOUR:         if(this.current.getHours() < this.step) this.current.setHours(0);  break;
      case TimeStep.SCALE.WEEKDAY:      // intentional fall through
      case TimeStep.SCALE.DAY:          if(this.current.getDate() < this.step+1) this.current.setDate(1); break;
      case TimeStep.SCALE.MONTH:        if(this.current.getMonth() < this.step) this.current.setMonth(0);  break;
      case TimeStep.SCALE.YEAR:         break; // nothing to do for year
      default:                break;
    }
  }

  // safety mechanism: if current time is still unchanged, move to the end
  if (this.current.valueOf() == prev) {
    this.current = new Date(this._end.valueOf());
  }
};


/**
 * Get the current datetime
 * @return {Date}  current The current date
 */
TimeStep.prototype.getCurrent = function() {
  return this.current;
};

/**
 * Set a custom scale. Autoscaling will be disabled.
 * For example setScale(SCALE.MINUTES, 5) will result
 * in minor steps of 5 minutes, and major steps of an hour.
 *
 * @param {TimeStep.SCALE} newScale
 *                               A scale. Choose from SCALE.MILLISECOND,
 *                               SCALE.SECOND, SCALE.MINUTE, SCALE.HOUR,
 *                               SCALE.WEEKDAY, SCALE.DAY, SCALE.MONTH,
 *                               SCALE.YEAR.
 * @param {Number}     newStep   A step size, by default 1. Choose for
 *                               example 1, 2, 5, or 10.
 */
TimeStep.prototype.setScale = function(newScale, newStep) {
  this.scale = newScale;

  if (newStep > 0) {
    this.step = newStep;
  }

  this.autoScale = false;
};

/**
 * Enable or disable autoscaling
 * @param {boolean} enable  If true, autoascaling is set true
 */
TimeStep.prototype.setAutoScale = function (enable) {
  this.autoScale = enable;
};


/**
 * Automatically determine the scale that bests fits the provided minimum step
 * @param {Number} [minimumStep]  The minimum step size in milliseconds
 */
TimeStep.prototype.setMinimumStep = function(minimumStep) {
  if (minimumStep == undefined) {
    return;
  }

  var stepYear       = (1000 * 60 * 60 * 24 * 30 * 12);
  var stepMonth      = (1000 * 60 * 60 * 24 * 30);
  var stepDay        = (1000 * 60 * 60 * 24);
  var stepHour       = (1000 * 60 * 60);
  var stepMinute     = (1000 * 60);
  var stepSecond     = (1000);
  var stepMillisecond= (1);

  // find the smallest step that is larger than the provided minimumStep
  if (stepYear*1000 > minimumStep)        {this.scale = TimeStep.SCALE.YEAR;        this.step = 1000;}
  if (stepYear*500 > minimumStep)         {this.scale = TimeStep.SCALE.YEAR;        this.step = 500;}
  if (stepYear*100 > minimumStep)         {this.scale = TimeStep.SCALE.YEAR;        this.step = 100;}
  if (stepYear*50 > minimumStep)          {this.scale = TimeStep.SCALE.YEAR;        this.step = 50;}
  if (stepYear*10 > minimumStep)          {this.scale = TimeStep.SCALE.YEAR;        this.step = 10;}
  if (stepYear*5 > minimumStep)           {this.scale = TimeStep.SCALE.YEAR;        this.step = 5;}
  if (stepYear > minimumStep)             {this.scale = TimeStep.SCALE.YEAR;        this.step = 1;}
  if (stepMonth*3 > minimumStep)          {this.scale = TimeStep.SCALE.MONTH;       this.step = 3;}
  if (stepMonth > minimumStep)            {this.scale = TimeStep.SCALE.MONTH;       this.step = 1;}
  if (stepDay*5 > minimumStep)            {this.scale = TimeStep.SCALE.DAY;         this.step = 5;}
  if (stepDay*2 > minimumStep)            {this.scale = TimeStep.SCALE.DAY;         this.step = 2;}
  if (stepDay > minimumStep)              {this.scale = TimeStep.SCALE.DAY;         this.step = 1;}
  if (stepDay/2 > minimumStep)            {this.scale = TimeStep.SCALE.WEEKDAY;     this.step = 1;}
  if (stepHour*4 > minimumStep)           {this.scale = TimeStep.SCALE.HOUR;        this.step = 4;}
  if (stepHour > minimumStep)             {this.scale = TimeStep.SCALE.HOUR;        this.step = 1;}
  if (stepMinute*15 > minimumStep)        {this.scale = TimeStep.SCALE.MINUTE;      this.step = 15;}
  if (stepMinute*10 > minimumStep)        {this.scale = TimeStep.SCALE.MINUTE;      this.step = 10;}
  if (stepMinute*5 > minimumStep)         {this.scale = TimeStep.SCALE.MINUTE;      this.step = 5;}
  if (stepMinute > minimumStep)           {this.scale = TimeStep.SCALE.MINUTE;      this.step = 1;}
  if (stepSecond*15 > minimumStep)        {this.scale = TimeStep.SCALE.SECOND;      this.step = 15;}
  if (stepSecond*10 > minimumStep)        {this.scale = TimeStep.SCALE.SECOND;      this.step = 10;}
  if (stepSecond*5 > minimumStep)         {this.scale = TimeStep.SCALE.SECOND;      this.step = 5;}
  if (stepSecond > minimumStep)           {this.scale = TimeStep.SCALE.SECOND;      this.step = 1;}
  if (stepMillisecond*200 > minimumStep)  {this.scale = TimeStep.SCALE.MILLISECOND; this.step = 200;}
  if (stepMillisecond*100 > minimumStep)  {this.scale = TimeStep.SCALE.MILLISECOND; this.step = 100;}
  if (stepMillisecond*50 > minimumStep)   {this.scale = TimeStep.SCALE.MILLISECOND; this.step = 50;}
  if (stepMillisecond*10 > minimumStep)   {this.scale = TimeStep.SCALE.MILLISECOND; this.step = 10;}
  if (stepMillisecond*5 > minimumStep)    {this.scale = TimeStep.SCALE.MILLISECOND; this.step = 5;}
  if (stepMillisecond > minimumStep)      {this.scale = TimeStep.SCALE.MILLISECOND; this.step = 1;}
};

/**
 * Snap a date to a rounded value.
 * The snap intervals are dependent on the current scale and step.
 * @param {Date} date   the date to be snapped.
 * @return {Date} snappedDate
 */
TimeStep.prototype.snap = function(date) {
  var clone = new Date(date.valueOf());

  if (this.scale == TimeStep.SCALE.YEAR) {
    var year = clone.getFullYear() + Math.round(clone.getMonth() / 12);
    clone.setFullYear(Math.round(year / this.step) * this.step);
    clone.setMonth(0);
    clone.setDate(0);
    clone.setHours(0);
    clone.setMinutes(0);
    clone.setSeconds(0);
    clone.setMilliseconds(0);
  }
  else if (this.scale == TimeStep.SCALE.MONTH) {
    if (clone.getDate() > 15) {
      clone.setDate(1);
      clone.setMonth(clone.getMonth() + 1);
      // important: first set Date to 1, after that change the month.
    }
    else {
      clone.setDate(1);
    }

    clone.setHours(0);
    clone.setMinutes(0);
    clone.setSeconds(0);
    clone.setMilliseconds(0);
  }
  else if (this.scale == TimeStep.SCALE.DAY) {
    //noinspection FallthroughInSwitchStatementJS
    switch (this.step) {
      case 5:
      case 2:
        clone.setHours(Math.round(clone.getHours() / 24) * 24); break;
      default:
        clone.setHours(Math.round(clone.getHours() / 12) * 12); break;
    }
    clone.setMinutes(0);
    clone.setSeconds(0);
    clone.setMilliseconds(0);
  }
  else if (this.scale == TimeStep.SCALE.WEEKDAY) {
    //noinspection FallthroughInSwitchStatementJS
    switch (this.step) {
      case 5:
      case 2:
        clone.setHours(Math.round(clone.getHours() / 12) * 12); break;
      default:
        clone.setHours(Math.round(clone.getHours() / 6) * 6); break;
    }
    clone.setMinutes(0);
    clone.setSeconds(0);
    clone.setMilliseconds(0);
  }
  else if (this.scale == TimeStep.SCALE.HOUR) {
    switch (this.step) {
      case 4:
        clone.setMinutes(Math.round(clone.getMinutes() / 60) * 60); break;
      default:
        clone.setMinutes(Math.round(clone.getMinutes() / 30) * 30); break;
    }
    clone.setSeconds(0);
    clone.setMilliseconds(0);
  } else if (this.scale == TimeStep.SCALE.MINUTE) {
    //noinspection FallthroughInSwitchStatementJS
    switch (this.step) {
      case 15:
      case 10:
        clone.setMinutes(Math.round(clone.getMinutes() / 5) * 5);
        clone.setSeconds(0);
        break;
      case 5:
        clone.setSeconds(Math.round(clone.getSeconds() / 60) * 60); break;
      default:
        clone.setSeconds(Math.round(clone.getSeconds() / 30) * 30); break;
    }
    clone.setMilliseconds(0);
  }
  else if (this.scale == TimeStep.SCALE.SECOND) {
    //noinspection FallthroughInSwitchStatementJS
    switch (this.step) {
      case 15:
      case 10:
        clone.setSeconds(Math.round(clone.getSeconds() / 5) * 5);
        clone.setMilliseconds(0);
        break;
      case 5:
        clone.setMilliseconds(Math.round(clone.getMilliseconds() / 1000) * 1000); break;
      default:
        clone.setMilliseconds(Math.round(clone.getMilliseconds() / 500) * 500); break;
    }
  }
  else if (this.scale == TimeStep.SCALE.MILLISECOND) {
    var step = this.step > 5 ? this.step / 2 : 1;
    clone.setMilliseconds(Math.round(clone.getMilliseconds() / step) * step);
  }
  
  return clone;
};

/**
 * Check if the current value is a major value (for example when the step
 * is DAY, a major value is each first day of the MONTH)
 * @return {boolean} true if current date is major, else false.
 */
TimeStep.prototype.isMajor = function() {
  switch (this.scale) {
    case TimeStep.SCALE.MILLISECOND:
      return (this.current.getMilliseconds() == 0);
    case TimeStep.SCALE.SECOND:
      return (this.current.getSeconds() == 0);
    case TimeStep.SCALE.MINUTE:
      return (this.current.getHours() == 0) && (this.current.getMinutes() == 0);
    // Note: this is no bug. Major label is equal for both minute and hour scale
    case TimeStep.SCALE.HOUR:
      return (this.current.getHours() == 0);
    case TimeStep.SCALE.WEEKDAY: // intentional fall through
    case TimeStep.SCALE.DAY:
      return (this.current.getDate() == 1);
    case TimeStep.SCALE.MONTH:
      return (this.current.getMonth() == 0);
    case TimeStep.SCALE.YEAR:
      return false;
    default:
      return false;
  }
};


/**
 * Returns formatted text for the minor axislabel, depending on the current
 * date and the scale. For example when scale is MINUTE, the current time is
 * formatted as "hh:mm".
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
TimeStep.prototype.getLabelMinor = function(date) {
  if (date == undefined) {
    date = this.current;
  }

  switch (this.scale) {
    case TimeStep.SCALE.MILLISECOND:  return moment(date).format('SSS');
    case TimeStep.SCALE.SECOND:       return moment(date).format('s');
    case TimeStep.SCALE.MINUTE:       return moment(date).format('HH:mm');
    case TimeStep.SCALE.HOUR:         return moment(date).format('HH:mm');
    case TimeStep.SCALE.WEEKDAY:      return moment(date).format('ddd D');
    case TimeStep.SCALE.DAY:          return moment(date).format('D');
    case TimeStep.SCALE.MONTH:        return moment(date).format('MMM');
    case TimeStep.SCALE.YEAR:         return moment(date).format('YYYY');
    default:                          return '';
  }
};


/**
 * Returns formatted text for the major axis label, depending on the current
 * date and the scale. For example when scale is MINUTE, the major scale is
 * hours, and the hour will be formatted as "hh".
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
TimeStep.prototype.getLabelMajor = function(date) {
  if (date == undefined) {
    date = this.current;
  }

  //noinspection FallthroughInSwitchStatementJS
  switch (this.scale) {
    case TimeStep.SCALE.MILLISECOND:return moment(date).format('HH:mm:ss');
    case TimeStep.SCALE.SECOND:     return moment(date).format('D MMMM HH:mm');
    case TimeStep.SCALE.MINUTE:
    case TimeStep.SCALE.HOUR:       return moment(date).format('ddd D MMMM');
    case TimeStep.SCALE.WEEKDAY:
    case TimeStep.SCALE.DAY:        return moment(date).format('MMMM YYYY');
    case TimeStep.SCALE.MONTH:      return moment(date).format('YYYY');
    case TimeStep.SCALE.YEAR:       return '';
    default:                        return '';
  }
};

module.exports = TimeStep;

},{"../module/moment":33}],39:[function(require,module,exports){
var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var util = require('../util');
var DataSet = require('../DataSet');
var DataView = require('../DataView');
var Range = require('./Range');
var Core = require('./Core');
var TimeAxis = require('./component/TimeAxis');
var CurrentTime = require('./component/CurrentTime');
var CustomTime = require('./component/CustomTime');
var ItemSet = require('./component/ItemSet');

/**
 * Create a timeline visualization
 * @param {HTMLElement} container
 * @param {vis.DataSet | Array | google.visualization.DataTable} [items]
 * @param {Object} [options]  See Timeline.setOptions for the available options.
 * @constructor
 * @extends Core
 */
function Timeline (container, items, options) {
  if (!(this instanceof Timeline)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  var me = this;
  this.defaultOptions = {
    start: null,
    end:   null,

    autoResize: true,

    orientation: 'bottom',
    width: null,
    height: null,
    maxHeight: null,
    minHeight: null
  };
  this.options = util.deepExtend({}, this.defaultOptions);

  // Create the DOM, props, and emitter
  this._create(container);

  // all components listed here will be repainted automatically
  this.components = [];

  this.body = {
    dom: this.dom,
    domProps: this.props,
    emitter: {
      on: this.on.bind(this),
      off: this.off.bind(this),
      emit: this.emit.bind(this)
    },
    util: {
      snap: null, // will be specified after TimeAxis is created
      toScreen: me._toScreen.bind(me),
      toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to the root.width
      toTime: me._toTime.bind(me),
      toGlobalTime : me._toGlobalTime.bind(me)
    }
  };

  // range
  this.range = new Range(this.body);
  this.components.push(this.range);
  this.body.range = this.range;

  // time axis
  this.timeAxis = new TimeAxis(this.body);
  this.components.push(this.timeAxis);
  this.body.util.snap = this.timeAxis.snap.bind(this.timeAxis);

  // current time bar
  this.currentTime = new CurrentTime(this.body);
  this.components.push(this.currentTime);

  // custom time bar
  // Note: time bar will be attached in this.setOptions when selected
  this.customTime = new CustomTime(this.body);
  this.components.push(this.customTime);

  // item set
  this.itemSet = new ItemSet(this.body);
  this.components.push(this.itemSet);

  this.itemsData = null;      // DataSet
  this.groupsData = null;     // DataSet

  // apply options
  if (options) {
    this.setOptions(options);
  }

  // create itemset
  if (items) {
    this.setItems(items);
  }
  else {
    this.redraw();
  }
}

// Extend the functionality from Core
Timeline.prototype = new Core();

/**
 * Set items
 * @param {vis.DataSet | Array | google.visualization.DataTable | null} items
 */
Timeline.prototype.setItems = function(items) {
  var initialLoad = (this.itemsData == null);

  // convert to type DataSet when needed
  var newDataSet;
  if (!items) {
    newDataSet = null;
  }
  else if (items instanceof DataSet || items instanceof DataView) {
    newDataSet = items;
  }
  else {
    // turn an array into a dataset
    newDataSet = new DataSet(items, {
      type: {
        start: 'Date',
        end: 'Date'
      }
    });
  }

  // set items
  this.itemsData = newDataSet;
  this.itemSet && this.itemSet.setItems(newDataSet);
  if (initialLoad) {
    if (this.options.start != undefined || this.options.end != undefined) {
      var start = this.options.start != undefined ? this.options.start : null;
      var end   = this.options.end != undefined   ? this.options.end : null;

      this.setWindow(start, end, {animate: false});
    }
    else {
      this.fit({animate: false});
    }
  }
};

/**
 * Set groups
 * @param {vis.DataSet | Array | google.visualization.DataTable} groups
 */
Timeline.prototype.setGroups = function(groups) {
  // convert to type DataSet when needed
  var newDataSet;
  if (!groups) {
    newDataSet = null;
  }
  else if (groups instanceof DataSet || groups instanceof DataView) {
    newDataSet = groups;
  }
  else {
    // turn an array into a dataset
    newDataSet = new DataSet(groups);
  }

  this.groupsData = newDataSet;
  this.itemSet.setGroups(newDataSet);
};

/**
 * Set selected items by their id. Replaces the current selection
 * Unknown id's are silently ignored.
 * @param {string[] | string} [ids]  An array with zero or more id's of the items to be
 *                                selected. If ids is an empty array, all items will be
 *                                unselected.
 * @param {Object} [options]      Available options:
 *                                `focus: boolean`
 *                                    If true, focus will be set to the selected item(s)
 *                                `animate: boolean | number`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window.
 *                                    If a number, the number is taken as duration
 *                                    for the animation. Default duration is 500 ms.
 *                                    Only applicable when option focus is true.
 */
Timeline.prototype.setSelection = function(ids, options) {
  this.itemSet && this.itemSet.setSelection(ids);

  if (options && options.focus) {
    this.focus(ids, options);
  }
};

/**
 * Get the selected items by their id
 * @return {Array} ids  The ids of the selected items
 */
Timeline.prototype.getSelection = function() {
  return this.itemSet && this.itemSet.getSelection() || [];
};

/**
 * Adjust the visible window such that the selected item (or multiple items)
 * are centered on screen.
 * @param {String | String[]} id     An item id or array with item ids
 * @param {Object} [options]      Available options:
 *                                `animate: boolean | number`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window.
 *                                    If a number, the number is taken as duration
 *                                    for the animation. Default duration is 500 ms.
 *                                    Only applicable when option focus is true
 */
Timeline.prototype.focus = function(id, options) {
  if (!this.itemsData || id == undefined) return;

  var ids = Array.isArray(id) ? id : [id];

  // get the specified item(s)
  var itemsData = this.itemsData.getDataSet().get(ids, {
    type: {
      start: 'Date',
      end: 'Date'
    }
  });

  // calculate minimum start and maximum end of specified items
  var start = null;
  var end = null;
  itemsData.forEach(function (itemData) {
    var s = itemData.start.valueOf();
    var e = 'end' in itemData ? itemData.end.valueOf() : itemData.start.valueOf();

    if (start === null || s < start) {
      start = s;
    }

    if (end === null || e > end) {
      end = e;
    }
  });

  if (start !== null && end !== null) {
    // calculate the new middle and interval for the window
    var middle = (start + end) / 2;
    var interval = Math.max((this.range.end - this.range.start), (end - start) * 1.1);

    var animate = (options && options.animate !== undefined) ? options.animate : true;
    this.range.setRange(middle - interval / 2, middle + interval / 2, animate);
  }
};

/**
 * Get the data range of the item set.
 * @returns {{min: Date, max: Date}} range  A range with a start and end Date.
 *                                          When no minimum is found, min==null
 *                                          When no maximum is found, max==null
 */
Timeline.prototype.getItemRange = function() {
  // calculate min from start filed
  var dataset = this.itemsData.getDataSet(),
    min = null,
    max = null;

  if (dataset) {
    // calculate the minimum value of the field 'start'
    var minItem = dataset.min('start');
    min = minItem ? util.convert(minItem.start, 'Date').valueOf() : null;
    // Note: we convert first to Date and then to number because else
    // a conversion from ISODate to Number will fail

    // calculate maximum value of fields 'start' and 'end'
    var maxStartItem = dataset.max('start');
    if (maxStartItem) {
      max = util.convert(maxStartItem.start, 'Date').valueOf();
    }
    var maxEndItem = dataset.max('end');
    if (maxEndItem) {
      if (max == null) {
        max = util.convert(maxEndItem.end, 'Date').valueOf();
      }
      else {
        max = Math.max(max, util.convert(maxEndItem.end, 'Date').valueOf());
      }
    }
  }

  return {
    min: (min != null) ? new Date(min) : null,
    max: (max != null) ? new Date(max) : null
  };
};


module.exports = Timeline;

},{"../DataSet":29,"../DataView":30,"../module/hammer":32,"../util":52,"./Core":35,"./Range":36,"./component/CurrentTime":41,"./component/CustomTime":42,"./component/ItemSet":44,"./component/TimeAxis":45,"emitter-component":53}],40:[function(require,module,exports){
/**
 * Prototype for visual components
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} [body]
 * @param {Object} [options]
 */
function Component (body, options) {
  this.options = null;
  this.props = null;
}

/**
 * Set options for the component. The new options will be merged into the
 * current options.
 * @param {Object} options
 */
Component.prototype.setOptions = function(options) {
  if (options) {
    util.extend(this.options, options);
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
Component.prototype.redraw = function() {
  // should be implemented by the component
  return false;
};

/**
 * Destroy the component. Cleanup DOM and event listeners
 */
Component.prototype.destroy = function() {
  // should be implemented by the component
};

/**
 * Test whether the component is resized since the last time _isResized() was
 * called.
 * @return {Boolean} Returns true if the component is resized
 * @protected
 */
Component.prototype._isResized = function() {
  var resized = (this.props._previousWidth !== this.props.width ||
      this.props._previousHeight !== this.props.height);

  this.props._previousWidth = this.props.width;
  this.props._previousHeight = this.props.height;

  return resized;
};

module.exports = Component;

},{}],41:[function(require,module,exports){
var util = require('../../util');
var Component = require('./Component');
var moment = require('../../module/moment');
var locales = require('../locales');

/**
 * A current time bar
 * @param {{range: Range, dom: Object, domProps: Object}} body
 * @param {Object} [options]        Available parameters:
 *                                  {Boolean} [showCurrentTime]
 * @constructor CurrentTime
 * @extends Component
 */
function CurrentTime (body, options) {
  this.body = body;

  // default options
  this.defaultOptions = {
    showCurrentTime: true,

    locales: locales,
    locale: 'en'
  };
  this.options = util.extend({}, this.defaultOptions);
  this.offset = 0;

  this._create();

  this.setOptions(options);
}

CurrentTime.prototype = new Component();

/**
 * Create the HTML DOM for the current time bar
 * @private
 */
CurrentTime.prototype._create = function() {
  var bar = document.createElement('div');
  bar.className = 'currenttime';
  bar.style.position = 'absolute';
  bar.style.top = '0px';
  bar.style.height = '100%';

  this.bar = bar;
};

/**
 * Destroy the CurrentTime bar
 */
CurrentTime.prototype.destroy = function () {
  this.options.showCurrentTime = false;
  this.redraw(); // will remove the bar from the DOM and stop refreshing

  this.body = null;
};

/**
 * Set options for the component. Options will be merged in current options.
 * @param {Object} options  Available parameters:
 *                          {boolean} [showCurrentTime]
 */
CurrentTime.prototype.setOptions = function(options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['showCurrentTime', 'locale', 'locales'], this.options, options);
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
CurrentTime.prototype.redraw = function() {
  if (this.options.showCurrentTime) {
    var parent = this.body.dom.backgroundVertical;
    if (this.bar.parentNode != parent) {
      // attach to the dom
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      parent.appendChild(this.bar);

      this.start();
    }

    var now = new Date(new Date().valueOf() + this.offset);
    var x = this.body.util.toScreen(now);

    var locale = this.options.locales[this.options.locale];
    var title = locale.current + ' ' + locale.time + ': ' + moment(now).format('dddd, MMMM Do YYYY, H:mm:ss');
    title = title.charAt(0).toUpperCase() + title.substring(1);

    this.bar.style.left = x + 'px';
    this.bar.title = title;
  }
  else {
    // remove the line from the DOM
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
    this.stop();
  }

  return false;
};

/**
 * Start auto refreshing the current time bar
 */
CurrentTime.prototype.start = function() {
  var me = this;

  function update () {
    me.stop();

    // determine interval to refresh
    var scale = me.body.range.conversion(me.body.domProps.center.width).scale;
    var interval = 1 / scale / 10;
    if (interval < 30)   interval = 30;
    if (interval > 1000) interval = 1000;

    me.redraw();

    // start a timer to adjust for the new time
    me.currentTimeTimer = setTimeout(update, interval);
  }

  update();
};

/**
 * Stop auto refreshing the current time bar
 */
CurrentTime.prototype.stop = function() {
  if (this.currentTimeTimer !== undefined) {
    clearTimeout(this.currentTimeTimer);
    delete this.currentTimeTimer;
  }
};

/**
 * Set a current time. This can be used for example to ensure that a client's
 * time is synchronized with a shared server time.
 * @param {Date | String | Number} time     A Date, unix timestamp, or
 *                                          ISO date string.
 */
CurrentTime.prototype.setCurrentTime = function(time) {
  var t = util.convert(time, 'Date').valueOf();
  var now = new Date().valueOf();
  this.offset = t - now;
  this.redraw();
};

/**
 * Get the current time.
 * @return {Date} Returns the current time.
 */
CurrentTime.prototype.getCurrentTime = function() {
  return new Date(new Date().valueOf() + this.offset);
};

module.exports = CurrentTime;

},{"../../module/moment":33,"../../util":52,"../locales":51,"./Component":40}],42:[function(require,module,exports){
var Hammer = require('../../module/hammer');
var util = require('../../util');
var Component = require('./Component');
var moment = require('../../module/moment');
var locales = require('../locales');

/**
 * A custom time bar
 * @param {{range: Range, dom: Object}} body
 * @param {Object} [options]        Available parameters:
 *                                  {Boolean} [showCustomTime]
 * @constructor CustomTime
 * @extends Component
 */

function CustomTime (body, options) {
  this.body = body;

  // default options
  this.defaultOptions = {
    showCustomTime: false,
    locales: locales,
    locale: 'en'
  };
  this.options = util.extend({}, this.defaultOptions);

  this.customTime = new Date();
  this.eventParams = {}; // stores state parameters while dragging the bar

  // create the DOM
  this._create();

  this.setOptions(options);
}

CustomTime.prototype = new Component();

/**
 * Set options for the component. Options will be merged in current options.
 * @param {Object} options  Available parameters:
 *                          {boolean} [showCustomTime]
 */
CustomTime.prototype.setOptions = function(options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['showCustomTime', 'locale', 'locales'], this.options, options);
  }
};

/**
 * Create the DOM for the custom time
 * @private
 */
CustomTime.prototype._create = function() {
  var bar = document.createElement('div');
  bar.className = 'customtime';
  bar.style.position = 'absolute';
  bar.style.top = '0px';
  bar.style.height = '100%';
  this.bar = bar;

  var drag = document.createElement('div');
  drag.style.position = 'relative';
  drag.style.top = '0px';
  drag.style.left = '-10px';
  drag.style.height = '100%';
  drag.style.width = '20px';
  bar.appendChild(drag);

  // attach event listeners
  this.hammer = Hammer(bar, {
    prevent_default: true
  });
  this.hammer.on('dragstart', this._onDragStart.bind(this));
  this.hammer.on('drag',      this._onDrag.bind(this));
  this.hammer.on('dragend',   this._onDragEnd.bind(this));
};

/**
 * Destroy the CustomTime bar
 */
CustomTime.prototype.destroy = function () {
  this.options.showCustomTime = false;
  this.redraw(); // will remove the bar from the DOM

  this.hammer.enable(false);
  this.hammer = null;

  this.body = null;
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
CustomTime.prototype.redraw = function () {
  if (this.options.showCustomTime) {
    var parent = this.body.dom.backgroundVertical;
    if (this.bar.parentNode != parent) {
      // attach to the dom
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      parent.appendChild(this.bar);
    }

    var x = this.body.util.toScreen(this.customTime);

    var locale = this.options.locales[this.options.locale];
    var title = locale.time + ': ' + moment(this.customTime).format('dddd, MMMM Do YYYY, H:mm:ss');
    title = title.charAt(0).toUpperCase() + title.substring(1);

    this.bar.style.left = x + 'px';
    this.bar.title = title;
  }
  else {
    // remove the line from the DOM
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
  }

  return false;
};

/**
 * Set custom time.
 * @param {Date | number | string} time
 */
CustomTime.prototype.setCustomTime = function(time) {
  this.customTime = util.convert(time, 'Date');
  this.redraw();
};

/**
 * Retrieve the current custom time.
 * @return {Date} customTime
 */
CustomTime.prototype.getCustomTime = function() {
  return new Date(this.customTime.valueOf());
};

/**
 * Start moving horizontally
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDragStart = function(event) {
  this.eventParams.dragging = true;
  this.eventParams.customTime = this.customTime;

  event.stopPropagation();
  event.preventDefault();
};

/**
 * Perform moving operating.
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDrag = function (event) {
  if (!this.eventParams.dragging) return;

  var deltaX = event.gesture.deltaX,
      x = this.body.util.toScreen(this.eventParams.customTime) + deltaX,
      time = this.body.util.toTime(x);

  this.setCustomTime(time);

  // fire a timechange event
  this.body.emitter.emit('timechange', {
    time: new Date(this.customTime.valueOf())
  });

  event.stopPropagation();
  event.preventDefault();
};

/**
 * Stop moving operating.
 * @param {event} event
 * @private
 */
CustomTime.prototype._onDragEnd = function (event) {
  if (!this.eventParams.dragging) return;

  // fire a timechanged event
  this.body.emitter.emit('timechanged', {
    time: new Date(this.customTime.valueOf())
  });

  event.stopPropagation();
  event.preventDefault();
};

module.exports = CustomTime;

},{"../../module/hammer":32,"../../module/moment":33,"../../util":52,"../locales":51,"./Component":40}],43:[function(require,module,exports){
var util = require('../../util');
var stack = require('../Stack');
var RangeItem = require('./item/RangeItem');

/**
 * @constructor Group
 * @param {Number | String} groupId
 * @param {Object} data
 * @param {ItemSet} itemSet
 */
function Group (groupId, data, itemSet) {
  this.groupId = groupId;

  this.itemSet = itemSet;

  this.dom = {};
  this.props = {
    label: {
      width: 0,
      height: 0
    }
  };
  this.className = null;

  this.items = {};        // items filtered by groupId of this group
  this.visibleItems = []; // items currently visible in window
  this.orderedItems = {   // items sorted by start and by end
    byStart: [],
    byEnd: []
  };

  this._create();

  this.setData(data);
}

/**
 * Create DOM elements for the group
 * @private
 */
Group.prototype._create = function() {
  var label = document.createElement('div');
  label.className = 'vlabel';
  this.dom.label = label;

  var inner = document.createElement('div');
  inner.className = 'inner';
  label.appendChild(inner);
  this.dom.inner = inner;

  var foreground = document.createElement('div');
  foreground.className = 'group';
  foreground['timeline-group'] = this;
  this.dom.foreground = foreground;

  this.dom.background = document.createElement('div');
  this.dom.background.className = 'group';

  this.dom.axis = document.createElement('div');
  this.dom.axis.className = 'group';

  // create a hidden marker to detect when the Timelines container is attached
  // to the DOM, or the style of a parent of the Timeline is changed from
  // display:none is changed to visible.
  this.dom.marker = document.createElement('div');
  this.dom.marker.style.visibility = 'hidden';
  this.dom.marker.innerHTML = '?';
  this.dom.background.appendChild(this.dom.marker);
};

/**
 * Set the group data for this group
 * @param {Object} data   Group data, can contain properties content and className
 */
Group.prototype.setData = function(data) {
  // update contents
  var content = data && data.content;
  if (content instanceof Element) {
    this.dom.inner.appendChild(content);
  }
  else if (content !== undefined && content !== null) {
    this.dom.inner.innerHTML = content;
  }
  else {
    this.dom.inner.innerHTML = this.groupId || ''; // groupId can be null
  }

  // update title
  this.dom.label.title = data && data.title || '';

  if (!this.dom.inner.firstChild) {
    util.addClassName(this.dom.inner, 'hidden');
  }
  else {
    util.removeClassName(this.dom.inner, 'hidden');
  }

  // update className
  var className = data && data.className || null;
  if (className != this.className) {
    if (this.className) {
      util.removeClassName(this.dom.label, this.className);
      util.removeClassName(this.dom.foreground, this.className);
      util.removeClassName(this.dom.background, this.className);
      util.removeClassName(this.dom.axis, this.className);
    }
    util.addClassName(this.dom.label, className);
    util.addClassName(this.dom.foreground, className);
    util.addClassName(this.dom.background, className);
    util.addClassName(this.dom.axis, className);
    this.className = className;
  }
};

/**
 * Get the width of the group label
 * @return {number} width
 */
Group.prototype.getLabelWidth = function() {
  return this.props.label.width;
};


/**
 * Repaint this group
 * @param {{start: number, end: number}} range
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @param {boolean} [restack=false]  Force restacking of all items
 * @return {boolean} Returns true if the group is resized
 */
Group.prototype.redraw = function(range, margin, restack) {
  var resized = false;

  this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

  // force recalculation of the height of the items when the marker height changed
  // (due to the Timeline being attached to the DOM or changed from display:none to visible)
  var markerHeight = this.dom.marker.clientHeight;
  if (markerHeight != this.lastMarkerHeight) {
    this.lastMarkerHeight = markerHeight;

    util.forEach(this.items, function (item) {
      item.dirty = true;
      if (item.displayed) item.redraw();
    });

    restack = true;
  }

  // reposition visible items vertically
  if (this.itemSet.options.stack) { // TODO: ugly way to access options...
    stack.stack(this.visibleItems, margin, restack);
  }
  else { // no stacking
    stack.nostack(this.visibleItems, margin);
  }

  // recalculate the height of the group
  var height;
  var visibleItems = this.visibleItems;
  if (visibleItems.length) {
    var min = visibleItems[0].top;
    var max = visibleItems[0].top + visibleItems[0].height;
    util.forEach(visibleItems, function (item) {
      min = Math.min(min, item.top);
      max = Math.max(max, (item.top + item.height));
    });
    if (min > margin.axis) {
      // there is an empty gap between the lowest item and the axis
      var offset = min - margin.axis;
      max -= offset;
      util.forEach(visibleItems, function (item) {
        item.top -= offset;
      });
    }
    height = max + margin.item.vertical / 2;
  }
  else {
    height = margin.axis + margin.item.vertical;
  }
  height = Math.max(height, this.props.label.height);

  // calculate actual size and position
  var foreground = this.dom.foreground;
  this.top = foreground.offsetTop;
  this.left = foreground.offsetLeft;
  this.width = foreground.offsetWidth;
  resized = util.updateProperty(this, 'height', height) || resized;

  // recalculate size of label
  resized = util.updateProperty(this.props.label, 'width', this.dom.inner.clientWidth) || resized;
  resized = util.updateProperty(this.props.label, 'height', this.dom.inner.clientHeight) || resized;

  // apply new height
  this.dom.background.style.height  = height + 'px';
  this.dom.foreground.style.height  = height + 'px';
  this.dom.label.style.height = height + 'px';

  // update vertical position of items after they are re-stacked and the height of the group is calculated
  for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
    var item = this.visibleItems[i];
    item.repositionY();
  }

  return resized;
};

/**
 * Show this group: attach to the DOM
 */
Group.prototype.show = function() {
  if (!this.dom.label.parentNode) {
    this.itemSet.dom.labelSet.appendChild(this.dom.label);
  }

  if (!this.dom.foreground.parentNode) {
    this.itemSet.dom.foreground.appendChild(this.dom.foreground);
  }

  if (!this.dom.background.parentNode) {
    this.itemSet.dom.background.appendChild(this.dom.background);
  }

  if (!this.dom.axis.parentNode) {
    this.itemSet.dom.axis.appendChild(this.dom.axis);
  }
};

/**
 * Hide this group: remove from the DOM
 */
Group.prototype.hide = function() {
  var label = this.dom.label;
  if (label.parentNode) {
    label.parentNode.removeChild(label);
  }

  var foreground = this.dom.foreground;
  if (foreground.parentNode) {
    foreground.parentNode.removeChild(foreground);
  }

  var background = this.dom.background;
  if (background.parentNode) {
    background.parentNode.removeChild(background);
  }

  var axis = this.dom.axis;
  if (axis.parentNode) {
    axis.parentNode.removeChild(axis);
  }
};

/**
 * Add an item to the group
 * @param {Item} item
 */
Group.prototype.add = function(item) {
  this.items[item.id] = item;
  item.setParent(this);

  if (this.visibleItems.indexOf(item) == -1) {
    var range = this.itemSet.body.range; // TODO: not nice accessing the range like this
    this._checkIfVisible(item, this.visibleItems, range);
  }
};

/**
 * Remove an item from the group
 * @param {Item} item
 */
Group.prototype.remove = function(item) {
  delete this.items[item.id];
  item.setParent(this.itemSet);

  // remove from visible items
  var index = this.visibleItems.indexOf(item);
  if (index != -1) this.visibleItems.splice(index, 1);

  // TODO: also remove from ordered items?
};

/**
 * Remove an item from the corresponding DataSet
 * @param {Item} item
 */
Group.prototype.removeFromDataSet = function(item) {
  this.itemSet.removeItem(item.id);
};

/**
 * Reorder the items
 */
Group.prototype.order = function() {
  var array = util.toArray(this.items);
  this.orderedItems.byStart = array;
  this.orderedItems.byEnd = this._constructByEndArray(array);

  stack.orderByStart(this.orderedItems.byStart);
  stack.orderByEnd(this.orderedItems.byEnd);
};

/**
 * Create an array containing all items being a range (having an end date)
 * @param {Item[]} array
 * @returns {RangeItem[]}
 * @private
 */
Group.prototype._constructByEndArray = function(array) {
  var endArray = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i] instanceof RangeItem) {
      endArray.push(array[i]);
    }
  }
  return endArray;
};

/**
 * Update the visible items
 * @param {{byStart: Item[], byEnd: Item[]}} orderedItems   All items ordered by start date and by end date
 * @param {Item[]} visibleItems                             The previously visible items.
 * @param {{start: number, end: number}} range              Visible range
 * @return {Item[]} visibleItems                            The new visible items.
 * @private
 */
Group.prototype._updateVisibleItems = function(orderedItems, visibleItems, range) {
  var initialPosByStart,
      newVisibleItems = [],
      i;

  // first check if the items that were in view previously are still in view.
  // this handles the case for the RangeItem that is both before and after the current one.
  if (visibleItems.length > 0) {
    for (i = 0; i < visibleItems.length; i++) {
      this._checkIfVisible(visibleItems[i], newVisibleItems, range);
    }
  }

  // If there were no visible items previously, use binarySearch to find a visible PointItem or RangeItem (based on startTime)
  if (newVisibleItems.length == 0) {
    initialPosByStart = util.binarySearch(orderedItems.byStart, range, 'data','start');
  }
  else {
    initialPosByStart = orderedItems.byStart.indexOf(newVisibleItems[0]);
  }

  // use visible search to find a visible RangeItem (only based on endTime)
  var initialPosByEnd = util.binarySearch(orderedItems.byEnd, range, 'data','end');

  // if we found a initial ID to use, trace it up and down until we meet an invisible item.
  if (initialPosByStart != -1) {
    for (i = initialPosByStart; i >= 0; i--) {
      if (this._checkIfInvisible(orderedItems.byStart[i], newVisibleItems, range)) {break;}
    }
    for (i = initialPosByStart + 1; i < orderedItems.byStart.length; i++) {
      if (this._checkIfInvisible(orderedItems.byStart[i], newVisibleItems, range)) {break;}
    }
  }

  // if we found a initial ID to use, trace it up and down until we meet an invisible item.
  if (initialPosByEnd != -1) {
    for (i = initialPosByEnd; i >= 0; i--) {
      if (this._checkIfInvisible(orderedItems.byEnd[i], newVisibleItems, range)) {break;}
    }
    for (i = initialPosByEnd + 1; i < orderedItems.byEnd.length; i++) {
      if (this._checkIfInvisible(orderedItems.byEnd[i], newVisibleItems, range)) {break;}
    }
  }

  return newVisibleItems;
};



/**
 * this function checks if an item is invisible. If it is NOT we make it visible
 * and add it to the global visible items. If it is, return true.
 *
 * @param {Item} item
 * @param {Item[]} visibleItems
 * @param {{start:number, end:number}} range
 * @returns {boolean}
 * @private
 */
Group.prototype._checkIfInvisible = function(item, visibleItems, range) {
  if (item.isVisible(range)) {
    if (!item.displayed) item.show();
    item.repositionX();
    if (visibleItems.indexOf(item) == -1) {
      visibleItems.push(item);
    }
    return false;
  }
  else {
    if (item.displayed) item.hide();
    return true;
  }
};

/**
 * this function is very similar to the _checkIfInvisible() but it does not
 * return booleans, hides the item if it should not be seen and always adds to
 * the visibleItems.
 * this one is for brute forcing and hiding.
 *
 * @param {Item} item
 * @param {Array} visibleItems
 * @param {{start:number, end:number}} range
 * @private
 */
Group.prototype._checkIfVisible = function(item, visibleItems, range) {
  if (item.isVisible(range)) {
    if (!item.displayed) item.show();
    // reposition item horizontally
    item.repositionX();
    visibleItems.push(item);
  }
  else {
    if (item.displayed) item.hide();
  }
};

module.exports = Group;

},{"../../util":52,"../Stack":37,"./item/RangeItem":50}],44:[function(require,module,exports){
var Hammer = require('../../module/hammer');
var util = require('../../util');
var DataSet = require('../../DataSet');
var DataView = require('../../DataView');
var Component = require('./Component');
var Group = require('./Group');
var BoxItem = require('./item/BoxItem');
var PointItem = require('./item/PointItem');
var RangeItem = require('./item/RangeItem');
var BackgroundItem = require('./item/BackgroundItem');


var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items

/**
 * An ItemSet holds a set of items and ranges which can be displayed in a
 * range. The width is determined by the parent of the ItemSet, and the height
 * is determined by the size of the items.
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
 * @param {Object} [options]      See ItemSet.setOptions for the available options.
 * @constructor ItemSet
 * @extends Component
 */
function ItemSet(body, options) {
  this.body = body;

  this.defaultOptions = {
    type: null,  // 'box', 'point', 'range', 'background'
    orientation: 'bottom',  // 'top' or 'bottom'
    align: 'auto', // alignment of box items
    stack: true,
    groupOrder: null,

    selectable: true,
    editable: {
      updateTime: false,
      updateGroup: false,
      add: false,
      remove: false
    },

    onAdd: function (item, callback) {
      callback(item);
    },
    onUpdate: function (item, callback) {
      callback(item);
    },
    onMove: function (item, callback) {
      callback(item);
    },
    onRemove: function (item, callback) {
      callback(item);
    },
    onMoving: function (item, callback) {
      callback(item);
    },

    margin: {
      item: {
        horizontal: 10,
        vertical: 10
      },
      axis: 20
    },
    padding: 5
  };

  // options is shared by this ItemSet and all its items
  this.options = util.extend({}, this.defaultOptions);

  // options for getting items from the DataSet with the correct type
  this.itemOptions = {
    type: {start: 'Date', end: 'Date'}
  };

  this.conversion = {
    toScreen: body.util.toScreen,
    toTime: body.util.toTime
  };
  this.dom = {};
  this.props = {};
  this.hammer = null;

  var me = this;
  this.itemsData = null;    // DataSet
  this.groupsData = null;   // DataSet

  // listeners for the DataSet of the items
  this.itemListeners = {
    'add': function (event, params, senderId) {
      me._onAdd(params.items);
    },
    'update': function (event, params, senderId) {
      me._onUpdate(params.items);
    },
    'remove': function (event, params, senderId) {
      me._onRemove(params.items);
    }
  };

  // listeners for the DataSet of the groups
  this.groupListeners = {
    'add': function (event, params, senderId) {
      me._onAddGroups(params.items);
    },
    'update': function (event, params, senderId) {
      me._onUpdateGroups(params.items);
    },
    'remove': function (event, params, senderId) {
      me._onRemoveGroups(params.items);
    }
  };

  this.items = {};      // object with an Item for every data item
  this.groups = {};     // Group object for every group
  this.groupIds = [];

  this.selection = [];  // list with the ids of all selected nodes
  this.stackDirty = true; // if true, all items will be restacked on next redraw

  this.touchParams = {}; // stores properties while dragging
  // create the HTML DOM

  this._create();

  this.setOptions(options);
}

ItemSet.prototype = new Component();

// available item types will be registered here
ItemSet.types = {
  background: BackgroundItem,
  box: BoxItem,
  range: RangeItem,
  point: PointItem
};

/**
 * Create the HTML DOM for the ItemSet
 */
ItemSet.prototype._create = function(){
  var frame = document.createElement('div');
  frame.className = 'itemset';
  frame['timeline-itemset'] = this;
  this.dom.frame = frame;

  // create background panel
  var background = document.createElement('div');
  background.className = 'background';
  frame.appendChild(background);
  this.dom.background = background;

  // create foreground panel
  var foreground = document.createElement('div');
  foreground.className = 'foreground';
  frame.appendChild(foreground);
  this.dom.foreground = foreground;

  // create axis panel
  var axis = document.createElement('div');
  axis.className = 'axis';
  this.dom.axis = axis;

  // create labelset
  var labelSet = document.createElement('div');
  labelSet.className = 'labelset';
  this.dom.labelSet = labelSet;

  // create ungrouped Group
  this._updateUngrouped();

  // attach event listeners
  // Note: we bind to the centerContainer for the case where the height
  //       of the center container is larger than of the ItemSet, so we
  //       can click in the empty area to create a new item or deselect an item.
  this.hammer = Hammer(this.body.dom.centerContainer, {
    prevent_default: true
  });

  // drag items when selected
  this.hammer.on('touch',     this._onTouch.bind(this));
  this.hammer.on('dragstart', this._onDragStart.bind(this));
  this.hammer.on('drag',      this._onDrag.bind(this));
  this.hammer.on('dragend',   this._onDragEnd.bind(this));

  // single select (or unselect) when tapping an item
  this.hammer.on('tap',  this._onSelectItem.bind(this));

  // multi select when holding mouse/touch, or on ctrl+click
  this.hammer.on('hold', this._onMultiSelectItem.bind(this));

  // add item on doubletap
  this.hammer.on('doubletap', this._onAddItem.bind(this));

  // attach to the DOM
  this.show();
};

/**
 * Set options for the ItemSet. Existing options will be extended/overwritten.
 * @param {Object} [options] The following options are available:
 *                           {String} type
 *                              Default type for the items. Choose from 'box'
 *                              (default), 'point', 'range', or 'background'.
 *                              The default style can be overwritten by
 *                              individual items.
 *                           {String} align
 *                              Alignment for the items, only applicable for
 *                              BoxItem. Choose 'center' (default), 'left', or
 *                              'right'.
 *                           {String} orientation
 *                              Orientation of the item set. Choose 'top' or
 *                              'bottom' (default).
 *                           {Function} groupOrder
 *                              A sorting function for ordering groups
 *                           {Boolean} stack
 *                              If true (deafult), items will be stacked on
 *                              top of each other.
 *                           {Number} margin.axis
 *                              Margin between the axis and the items in pixels.
 *                              Default is 20.
 *                           {Number} margin.item.horizontal
 *                              Horizontal margin between items in pixels.
 *                              Default is 10.
 *                           {Number} margin.item.vertical
 *                              Vertical Margin between items in pixels.
 *                              Default is 10.
 *                           {Number} margin.item
 *                              Margin between items in pixels in both horizontal
 *                              and vertical direction. Default is 10.
 *                           {Number} margin
 *                              Set margin for both axis and items in pixels.
 *                           {Number} padding
 *                              Padding of the contents of an item in pixels.
 *                              Must correspond with the items css. Default is 5.
 *                           {Boolean} selectable
 *                              If true (default), items can be selected.
 *                           {Boolean} editable
 *                              Set all editable options to true or false
 *                           {Boolean} editable.updateTime
 *                              Allow dragging an item to an other moment in time
 *                           {Boolean} editable.updateGroup
 *                              Allow dragging an item to an other group
 *                           {Boolean} editable.add
 *                              Allow creating new items on double tap
 *                           {Boolean} editable.remove
 *                              Allow removing items by clicking the delete button
 *                              top right of a selected item.
 *                           {Function(item: Item, callback: Function)} onAdd
 *                              Callback function triggered when an item is about to be added:
 *                              when the user double taps an empty space in the Timeline.
 *                           {Function(item: Item, callback: Function)} onUpdate
 *                              Callback function fired when an item is about to be updated.
 *                              This function typically has to show a dialog where the user
 *                              change the item. If not implemented, nothing happens.
 *                           {Function(item: Item, callback: Function)} onMove
 *                              Fired when an item has been moved. If not implemented,
 *                              the move action will be accepted.
 *                           {Function(item: Item, callback: Function)} onRemove
 *                              Fired when an item is about to be deleted.
 *                              If not implemented, the item will be always removed.
 */
ItemSet.prototype.setOptions = function(options) {
  if (options) {
    // copy all options that we know
    var fields = ['type', 'align', 'orientation', 'padding', 'stack', 'selectable', 'groupOrder', 'dataAttributes', 'template'];
    util.selectiveExtend(fields, this.options, options);

    if ('margin' in options) {
      if (typeof options.margin === 'number') {
        this.options.margin.axis = options.margin;
        this.options.margin.item.horizontal = options.margin;
        this.options.margin.item.vertical = options.margin;
      }
      else if (typeof options.margin === 'object') {
        util.selectiveExtend(['axis'], this.options.margin, options.margin);
        if ('item' in options.margin) {
          if (typeof options.margin.item === 'number') {
            this.options.margin.item.horizontal = options.margin.item;
            this.options.margin.item.vertical = options.margin.item;
          }
          else if (typeof options.margin.item === 'object') {
            util.selectiveExtend(['horizontal', 'vertical'], this.options.margin.item, options.margin.item);
          }
        }
      }
    }

    if ('editable' in options) {
      if (typeof options.editable === 'boolean') {
        this.options.editable.updateTime  = options.editable;
        this.options.editable.updateGroup = options.editable;
        this.options.editable.add         = options.editable;
        this.options.editable.remove      = options.editable;
      }
      else if (typeof options.editable === 'object') {
        util.selectiveExtend(['updateTime', 'updateGroup', 'add', 'remove'], this.options.editable, options.editable);
      }
    }

    // callback functions
    var addCallback = (function (name) {
      var fn = options[name];
      if (fn) {
        if (!(fn instanceof Function)) {
          throw new Error('option ' + name + ' must be a function ' + name + '(item, callback)');
        }
        this.options[name] = fn;
      }
    }).bind(this);
    ['onAdd', 'onUpdate', 'onRemove', 'onMove', 'onMoving'].forEach(addCallback);

    // force the itemSet to refresh: options like orientation and margins may be changed
    this.markDirty();
  }
};

/**
 * Mark the ItemSet dirty so it will refresh everything with next redraw
 */
ItemSet.prototype.markDirty = function() {
  this.groupIds = [];
  this.stackDirty = true;
};

/**
 * Destroy the ItemSet
 */
ItemSet.prototype.destroy = function() {
  this.hide();
  this.setItems(null);
  this.setGroups(null);

  this.hammer = null;

  this.body = null;
  this.conversion = null;
};

/**
 * Hide the component from the DOM
 */
ItemSet.prototype.hide = function() {
  // remove the frame containing the items
  if (this.dom.frame.parentNode) {
    this.dom.frame.parentNode.removeChild(this.dom.frame);
  }

  // remove the axis with dots
  if (this.dom.axis.parentNode) {
    this.dom.axis.parentNode.removeChild(this.dom.axis);
  }

  // remove the labelset containing all group labels
  if (this.dom.labelSet.parentNode) {
    this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);
  }
};

/**
 * Show the component in the DOM (when not already visible).
 * @return {Boolean} changed
 */
ItemSet.prototype.show = function() {
  // show frame containing the items
  if (!this.dom.frame.parentNode) {
    this.body.dom.center.appendChild(this.dom.frame);
  }

  // show axis with dots
  if (!this.dom.axis.parentNode) {
    this.body.dom.backgroundVertical.appendChild(this.dom.axis);
  }

  // show labelset containing labels
  if (!this.dom.labelSet.parentNode) {
    this.body.dom.left.appendChild(this.dom.labelSet);
  }
};

/**
 * Set selected items by their id. Replaces the current selection
 * Unknown id's are silently ignored.
 * @param {string[] | string} [ids] An array with zero or more id's of the items to be
 *                                  selected, or a single item id. If ids is undefined
 *                                  or an empty array, all items will be unselected.
 */
ItemSet.prototype.setSelection = function(ids) {
  var i, ii, id, item;

  if (ids == undefined) ids = [];
  if (!Array.isArray(ids)) ids = [ids];

  // unselect currently selected items
  for (i = 0, ii = this.selection.length; i < ii; i++) {
    id = this.selection[i];
    item = this.items[id];
    if (item) item.unselect();
  }

  // select items
  this.selection = [];
  for (i = 0, ii = ids.length; i < ii; i++) {
    id = ids[i];
    item = this.items[id];
    if (item) {
      this.selection.push(id);
      item.select();
    }
  }
};

/**
 * Get the selected items by their id
 * @return {Array} ids  The ids of the selected items
 */
ItemSet.prototype.getSelection = function() {
  return this.selection.concat([]);
};

/**
 * Get the id's of the currently visible items.
 * @returns {Array} The ids of the visible items
 */
ItemSet.prototype.getVisibleItems = function() {
  var range = this.body.range.getRange();
  var left  = this.body.util.toScreen(range.start);
  var right = this.body.util.toScreen(range.end);

  var ids = [];
  for (var groupId in this.groups) {
    if (this.groups.hasOwnProperty(groupId)) {
      var group = this.groups[groupId];
      var rawVisibleItems = group.visibleItems;

      // filter the "raw" set with visibleItems into a set which is really
      // visible by pixels
      for (var i = 0; i < rawVisibleItems.length; i++) {
        var item = rawVisibleItems[i];
        // TODO: also check whether visible vertically
        if ((item.left < right) && (item.left + item.width > left)) {
          ids.push(item.id);
        }
      }
    }
  }

  return ids;
};

/**
 * Deselect a selected item
 * @param {String | Number} id
 * @private
 */
ItemSet.prototype._deselect = function(id) {
  var selection = this.selection;
  for (var i = 0, ii = selection.length; i < ii; i++) {
    if (selection[i] == id) { // non-strict comparison!
      selection.splice(i, 1);
      break;
    }
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
ItemSet.prototype.redraw = function() {
  var margin = this.options.margin,
      range = this.body.range,
      asSize = util.option.asSize,
      options = this.options,
      orientation = options.orientation,
      resized = false,
      frame = this.dom.frame,
      editable = options.editable.updateTime || options.editable.updateGroup;

  // recalculate absolute position (before redrawing groups)
  this.props.top = this.body.domProps.top.height + this.body.domProps.border.top;
  this.props.left = this.body.domProps.left.width + this.body.domProps.border.left;

  // update class name
  frame.className = 'itemset' + (editable ? ' editable' : '');

  // reorder the groups (if needed)
  resized = this._orderGroups() || resized;

  // check whether zoomed (in that case we need to re-stack everything)
  // TODO: would be nicer to get this as a trigger from Range
  var visibleInterval = range.end - range.start;
  var zoomed = (visibleInterval != this.lastVisibleInterval) || (this.props.width != this.props.lastWidth);
  if (zoomed) this.stackDirty = true;
  this.lastVisibleInterval = visibleInterval;
  this.props.lastWidth = this.props.width;

  // redraw all groups
  var restack = this.stackDirty,
      firstGroup = this._firstGroup(),
      firstMargin = {
        item: margin.item,
        axis: margin.axis
      },
      nonFirstMargin = {
        item: margin.item,
        axis: margin.item.vertical / 2
      },
      height = 0,
      minHeight = margin.axis + margin.item.vertical;
  util.forEach(this.groups, function (group) {
    var groupMargin = (group == firstGroup) ? firstMargin : nonFirstMargin;
    var groupResized = group.redraw(range, groupMargin, restack);
    resized = groupResized || resized;
    height += group.height;
  });
  height = Math.max(height, minHeight);
  this.stackDirty = false;

  // update frame height
  frame.style.height  = asSize(height);

  // calculate actual size
  this.props.width = frame.offsetWidth;
  this.props.height = height;

  // reposition axis

  // reposition axis
  this.dom.axis.style.top = asSize((orientation == 'top') ?
      (this.body.domProps.top.height + this.body.domProps.border.top) :
      (this.body.domProps.top.height + this.body.domProps.centerContainer.height));
  this.dom.axis.style.left = '0';

  // check if this component is resized
  resized = this._isResized() || resized;

  return resized;
};

/**
 * Get the first group, aligned with the axis
 * @return {Group | null} firstGroup
 * @private
 */
ItemSet.prototype._firstGroup = function() {
  var firstGroupIndex = (this.options.orientation == 'top') ? 0 : (this.groupIds.length - 1);
  var firstGroupId = this.groupIds[firstGroupIndex];
  var firstGroup = this.groups[firstGroupId] || this.groups[UNGROUPED];

  return firstGroup || null;
};

/**
 * Create or delete the group holding all ungrouped items. This group is used when
 * there are no groups specified.
 * @protected
 */
ItemSet.prototype._updateUngrouped = function() {
  var ungrouped = this.groups[UNGROUPED];

  if (this.groupsData) {
    // remove the group holding all ungrouped items
    if (ungrouped) {
      ungrouped.hide();
      delete this.groups[UNGROUPED];
    }
  }
  else {
    // create a group holding all (unfiltered) items
    if (!ungrouped) {
      var id = null;
      var data = null;
      ungrouped = new Group(id, data, this);
      this.groups[UNGROUPED] = ungrouped;

      for (var itemId in this.items) {
        if (this.items.hasOwnProperty(itemId)) {
          ungrouped.add(this.items[itemId]);
        }
      }

      ungrouped.show();
    }
  }
};

/**
 * Get the element for the labelset
 * @return {HTMLElement} labelSet
 */
ItemSet.prototype.getLabelSet = function() {
  return this.dom.labelSet;
};

/**
 * Set items
 * @param {vis.DataSet | null} items
 */
ItemSet.prototype.setItems = function(items) {
  var me = this,
      ids,
      oldItemsData = this.itemsData;

  // replace the dataset
  if (!items) {
    this.itemsData = null;
  }
  else if (items instanceof DataSet || items instanceof DataView) {
    this.itemsData = items;
  }
  else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (oldItemsData) {
    // unsubscribe from old dataset
    util.forEach(this.itemListeners, function (callback, event) {
      oldItemsData.off(event, callback);
    });

    // remove all drawn items
    ids = oldItemsData.getIds();
    this._onRemove(ids);
  }

  if (this.itemsData) {
    // subscribe to new dataset
    var id = this.id;
    util.forEach(this.itemListeners, function (callback, event) {
      me.itemsData.on(event, callback, id);
    });

    // add all new items
    ids = this.itemsData.getIds();
    this._onAdd(ids);

    // update the group holding all ungrouped items
    this._updateUngrouped();
  }
};

/**
 * Get the current items
 * @returns {vis.DataSet | null}
 */
ItemSet.prototype.getItems = function() {
  return this.itemsData;
};

/**
 * Set groups
 * @param {vis.DataSet} groups
 */
ItemSet.prototype.setGroups = function(groups) {
  var me = this,
      ids;

  // unsubscribe from current dataset
  if (this.groupsData) {
    util.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.unsubscribe(event, callback);
    });

    // remove all drawn groups
    ids = this.groupsData.getIds();
    this.groupsData = null;
    this._onRemoveGroups(ids); // note: this will cause a redraw
  }

  // replace the dataset
  if (!groups) {
    this.groupsData = null;
  }
  else if (groups instanceof DataSet || groups instanceof DataView) {
    this.groupsData = groups;
  }
  else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (this.groupsData) {
    // subscribe to new dataset
    var id = this.id;
    util.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.on(event, callback, id);
    });

    // draw all ms
    ids = this.groupsData.getIds();
    this._onAddGroups(ids);
  }

  // update the group holding all ungrouped items
  this._updateUngrouped();

  // update the order of all items in each group
  this._order();

  this.body.emitter.emit('change');
};

/**
 * Get the current groups
 * @returns {vis.DataSet | null} groups
 */
ItemSet.prototype.getGroups = function() {
  return this.groupsData;
};

/**
 * Remove an item by its id
 * @param {String | Number} id
 */
ItemSet.prototype.removeItem = function(id) {
  var item = this.itemsData.get(id),
      dataset = this.itemsData.getDataSet();

  if (item) {
    // confirm deletion
    this.options.onRemove(item, function (item) {
      if (item) {
        // remove by id here, it is possible that an item has no id defined
        // itself, so better not delete by the item itself
        dataset.remove(id);
      }
    });
  }
};

/**
 * Handle updated items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onUpdate = function(ids) {
  var me = this;

  ids.forEach(function (id) {
    var itemData = me.itemsData.get(id, me.itemOptions),
        item = me.items[id],
        type = itemData.type || me.options.type || (itemData.end ? 'range' : 'box');

    var constructor = ItemSet.types[type];

    if (item) {
      // update item
      if (!constructor || !(item instanceof constructor)) {
        // item type has changed, delete the item and recreate it
        me._removeItem(item);
        item = null;
      }
      else {
        me._updateItem(item, itemData);
      }
    }

    if (!item) {
      // create item
      if (constructor) {
        item = new constructor(itemData, me.conversion, me.options);
        item.id = id; // TODO: not so nice setting id afterwards
        me._addItem(item);
      }
      else if (type == 'rangeoverflow') {
        // TODO: deprecated since version 2.1.0 (or 3.0.0?). cleanup some day
        throw new TypeError('Item type "rangeoverflow" is deprecated. Use css styling instead: ' +
            '.vis.timeline .item.range .content {overflow: visible;}');
      }
      else {
        throw new TypeError('Unknown item type "' + type + '"');
      }
    }
  });

  this._order();
  this.stackDirty = true; // force re-stacking of all items next redraw
  this.body.emitter.emit('change');
};

/**
 * Handle added items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onAdd = ItemSet.prototype._onUpdate;

/**
 * Handle removed items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onRemove = function(ids) {
  var count = 0;
  var me = this;
  ids.forEach(function (id) {
    var item = me.items[id];
    if (item) {
      count++;
      me._removeItem(item);
    }
  });

  if (count) {
    // update order
    this._order();
    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('change');
  }
};

/**
 * Update the order of item in all groups
 * @private
 */
ItemSet.prototype._order = function() {
  // reorder the items in all groups
  // TODO: optimization: only reorder groups affected by the changed items
  util.forEach(this.groups, function (group) {
    group.order();
  });
};

/**
 * Handle updated groups
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onUpdateGroups = function(ids) {
  this._onAddGroups(ids);
};

/**
 * Handle changed groups
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onAddGroups = function(ids) {
  var me = this;

  ids.forEach(function (id) {
    var groupData = me.groupsData.get(id);
    var group = me.groups[id];

    if (!group) {
      // check for reserved ids
      if (id == UNGROUPED) {
        throw new Error('Illegal group id. ' + id + ' is a reserved id.');
      }

      var groupOptions = Object.create(me.options);
      util.extend(groupOptions, {
        height: null
      });

      group = new Group(id, groupData, me);
      me.groups[id] = group;

      // add items with this groupId to the new group
      for (var itemId in me.items) {
        if (me.items.hasOwnProperty(itemId)) {
          var item = me.items[itemId];
          if (item.data.group == id) {
            group.add(item);
          }
        }
      }

      group.order();
      group.show();
    }
    else {
      // update group
      group.setData(groupData);
    }
  });

  this.body.emitter.emit('change');
};

/**
 * Handle removed groups
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onRemoveGroups = function(ids) {
  var groups = this.groups;
  ids.forEach(function (id) {
    var group = groups[id];

    if (group) {
      group.hide();
      delete groups[id];
    }
  });

  this.markDirty();

  this.body.emitter.emit('change');
};

/**
 * Reorder the groups if needed
 * @return {boolean} changed
 * @private
 */
ItemSet.prototype._orderGroups = function () {
  if (this.groupsData) {
    // reorder the groups
    var groupIds = this.groupsData.getIds({
      order: this.options.groupOrder
    });

    var changed = !util.equalArray(groupIds, this.groupIds);
    if (changed) {
      // hide all groups, removes them from the DOM
      var groups = this.groups;
      groupIds.forEach(function (groupId) {
        groups[groupId].hide();
      });

      // show the groups again, attach them to the DOM in correct order
      groupIds.forEach(function (groupId) {
        groups[groupId].show();
      });

      this.groupIds = groupIds;
    }

    return changed;
  }
  else {
    return false;
  }
};

/**
 * Add a new item
 * @param {Item} item
 * @private
 */
ItemSet.prototype._addItem = function(item) {
  this.items[item.id] = item;

  // add to group
  var groupId = this.groupsData ? item.data.group : UNGROUPED;
  var group = this.groups[groupId];
  if (group) group.add(item);
};

/**
 * Update an existing item
 * @param {Item} item
 * @param {Object} itemData
 * @private
 */
ItemSet.prototype._updateItem = function(item, itemData) {
  var oldGroupId = item.data.group;

  // update the items data (will redraw the item when displayed)
  item.setData(itemData);

  // update group
  if (oldGroupId != item.data.group) {
    var oldGroup = this.groups[oldGroupId];
    if (oldGroup) oldGroup.remove(item);

    var groupId = this.groupsData ? item.data.group : UNGROUPED;
    var group = this.groups[groupId];
    if (group) group.add(item);
  }
};

/**
 * Delete an item from the ItemSet: remove it from the DOM, from the map
 * with items, and from the map with visible items, and from the selection
 * @param {Item} item
 * @private
 */
ItemSet.prototype._removeItem = function(item) {
  // remove from DOM
  item.hide();

  // remove from items
  delete this.items[item.id];

  // remove from selection
  var index = this.selection.indexOf(item.id);
  if (index != -1) this.selection.splice(index, 1);

  // remove from group
  var groupId = this.groupsData ? item.data.group : UNGROUPED;
  var group = this.groups[groupId];
  if (group) group.remove(item);
};

/**
 * Create an array containing all items being a range (having an end date)
 * @param array
 * @returns {Array}
 * @private
 */
ItemSet.prototype._constructByEndArray = function(array) {
  var endArray = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i] instanceof RangeItem) {
      endArray.push(array[i]);
    }
  }
  return endArray;
};

/**
 * Register the clicked item on touch, before dragStart is initiated.
 *
 * dragStart is initiated from a mousemove event, which can have left the item
 * already resulting in an item == null
 *
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onTouch = function (event) {
  // store the touched item, used in _onDragStart
  this.touchParams.item = ItemSet.itemFromTarget(event);
};

/**
 * Start dragging the selected events
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragStart = function (event) {
  if (!this.options.editable.updateTime && !this.options.editable.updateGroup) {
    return;
  }

  var item = this.touchParams.item || null,
      me = this,
      props;

  if (item && item.selected) {
    var dragLeftItem = event.target.dragLeftItem;
    var dragRightItem = event.target.dragRightItem;

    if (dragLeftItem) {
      props = {
        item: dragLeftItem
      };

      if (me.options.editable.updateTime) {
        props.start = item.data.start.valueOf();
      }
      if (me.options.editable.updateGroup) {
        if ('group' in item.data) props.group = item.data.group;
      }

      this.touchParams.itemProps = [props];
    }
    else if (dragRightItem) {
      props = {
        item: dragRightItem
      };

      if (me.options.editable.updateTime) {
        props.end = item.data.end.valueOf();
      }
      if (me.options.editable.updateGroup) {
        if ('group' in item.data) props.group = item.data.group;
      }

      this.touchParams.itemProps = [props];
    }
    else {
      this.touchParams.itemProps = this.getSelection().map(function (id) {
        var item = me.items[id];
        var props = {
          item: item
        };

        if (me.options.editable.updateTime) {
          if ('start' in item.data) props.start = item.data.start.valueOf();
          if ('end' in item.data)   props.end = item.data.end.valueOf();
        }
        if (me.options.editable.updateGroup) {
          if ('group' in item.data) props.group = item.data.group;
        }

        return props;
      });
    }

    event.stopPropagation();
  }
};

/**
 * Drag selected items
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDrag = function (event) {
  if (this.touchParams.itemProps) {
    var me = this;
    var range = this.body.range;
    var snap = this.body.util.snap || null;
    var deltaX = event.gesture.deltaX;
    var scale = (this.props.width / (range.end - range.start));
    var offset = deltaX / scale;

    // move
    this.touchParams.itemProps.forEach(function (props) {
      var newProps = {};

      if ('start' in props) {
        var start = new Date(props.start + offset);
        newProps.start = snap ? snap(start) : start;
      }

      if ('end' in props) {
        var end = new Date(props.end + offset);
        newProps.end = snap ? snap(end) : end;
      }

      if ('group' in props) {
        // drag from one group to another
        var group = ItemSet.groupFromTarget(event);
        newProps.group = group && group.groupId;
      }

      // confirm moving the item
      var itemData = util.extend({}, props.item.data, newProps);
      me.options.onMoving(itemData, function (itemData) {
        if (itemData) {
          me._updateItemProps(props.item, itemData);
        }
      });
    });

    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('change');

    event.stopPropagation();
  }
};

/**
 * Update an items properties
 * @param {Item} item
 * @param {Object} props  Can contain properties start, end, and group.
 * @private
 */
ItemSet.prototype._updateItemProps = function(item, props) {
  // TODO: copy all properties from props to item? (also new ones)
  if ('start' in props) item.data.start = props.start;
  if ('end' in props)   item.data.end   = props.end;
  if ('group' in props && item.data.group != props.group) {
    this._moveToGroup(item, props.group)
  }
};

/**
 * Move an item to another group
 * @param {Item} item
 * @param {String | Number} groupId
 * @private
 */
ItemSet.prototype._moveToGroup = function(item, groupId) {
  var group = this.groups[groupId];
  if (group && group.groupId != item.data.group) {
    var oldGroup = item.parent;
    oldGroup.remove(item);
    oldGroup.order();
    group.add(item);
    group.order();

    item.data.group = group.groupId;
  }
};

/**
 * End of dragging selected items
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragEnd = function (event) {
  if (this.touchParams.itemProps) {
    // prepare a change set for the changed items
    var changes = [],
        me = this,
        dataset = this.itemsData.getDataSet();

    var itemProps = this.touchParams.itemProps ;
    this.touchParams.itemProps = null;
    itemProps.forEach(function (props) {
      var id = props.item.id,
          itemData = me.itemsData.get(id, me.itemOptions);

      var changed = false;
      if ('start' in props.item.data) {
        changed = (props.start != props.item.data.start.valueOf());
        itemData.start = util.convert(props.item.data.start,
                dataset._options.type && dataset._options.type.start || 'Date');
      }
      if ('end' in props.item.data) {
        changed = changed  || (props.end != props.item.data.end.valueOf());
        itemData.end = util.convert(props.item.data.end,
                dataset._options.type && dataset._options.type.end || 'Date');
      }
      if ('group' in props.item.data) {
        changed = changed  || (props.group != props.item.data.group);
        itemData.group = props.item.data.group;
      }

      // only apply changes when start or end is actually changed
      if (changed) {
        me.options.onMove(itemData, function (itemData) {
          if (itemData) {
            // apply changes
            itemData[dataset._fieldId] = id; // ensure the item contains its id (can be undefined)
            changes.push(itemData);
          }
          else {
            // restore original values
            me._updateItemProps(props.item, props);

            me.stackDirty = true; // force re-stacking of all items next redraw
            me.body.emitter.emit('change');
          }
        });
      }
    });

    // apply the changes to the data (if there are changes)
    if (changes.length) {
      dataset.update(changes);
    }

    event.stopPropagation();
  }
};

/**
 * Handle selecting/deselecting an item when tapping it
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onSelectItem = function (event) {
  if (!this.options.selectable) return;

  var ctrlKey  = event.gesture.srcEvent && event.gesture.srcEvent.ctrlKey;
  var shiftKey = event.gesture.srcEvent && event.gesture.srcEvent.shiftKey;
  if (ctrlKey || shiftKey) {
    this._onMultiSelectItem(event);
    return;
  }

  var oldSelection = this.getSelection();

  var item = ItemSet.itemFromTarget(event);
  var selection = item ? [item.id] : [];
  this.setSelection(selection);

  var newSelection = this.getSelection();

  // emit a select event,
  // except when old selection is empty and new selection is still empty
  if (newSelection.length > 0 || oldSelection.length > 0) {
    this.body.emitter.emit('select', {
      items: this.getSelection()
    });
  }

  event.stopPropagation();
};

/**
 * Handle creation and updates of an item on double tap
 * @param event
 * @private
 */
ItemSet.prototype._onAddItem = function (event) {
  if (!this.options.selectable) return;
  if (!this.options.editable.add) return;

  var me = this,
      snap = this.body.util.snap || null,
      item = ItemSet.itemFromTarget(event);

  if (item) {
    // update item

    // execute async handler to update the item (or cancel it)
    var itemData = me.itemsData.get(item.id); // get a clone of the data from the dataset
    this.options.onUpdate(itemData, function (itemData) {
      if (itemData) {
        me.itemsData.update(itemData);
      }
    });
  }
  else {
    // add item
    var xAbs = util.getAbsoluteLeft(this.dom.frame);
    var x = event.gesture.center.pageX - xAbs;
    var start = this.body.util.toTime(x);
    var newItem = {
      start: snap ? snap(start) : start,
      content: 'new item'
    };

    // when default type is a range, add a default end date to the new item
    if (this.options.type === 'range') {
      var end = this.body.util.toTime(x + this.props.width / 5);
      newItem.end = snap ? snap(end) : end;
    }

    newItem[this.itemsData._fieldId] = util.randomUUID();

    var group = ItemSet.groupFromTarget(event);
    if (group) {
      newItem.group = group.groupId;
    }

    // execute async handler to customize (or cancel) adding an item
    this.options.onAdd(newItem, function (item) {
      if (item) {
        me.itemsData.add(item);
        // TODO: need to trigger a redraw?
      }
    });
  }
};

/**
 * Handle selecting/deselecting multiple items when holding an item
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onMultiSelectItem = function (event) {
  if (!this.options.selectable) return;

  var selection,
      item = ItemSet.itemFromTarget(event);

  if (item) {
    // multi select items
    selection = this.getSelection(); // current selection
    var index = selection.indexOf(item.id);
    if (index == -1) {
      // item is not yet selected -> select it
      selection.push(item.id);
    }
    else {
      // item is already selected -> deselect it
      selection.splice(index, 1);
    }
    this.setSelection(selection);

    this.body.emitter.emit('select', {
      items: this.getSelection()
    });

    event.stopPropagation();
  }
};

/**
 * Find an item from an event target:
 * searches for the attribute 'timeline-item' in the event target's element tree
 * @param {Event} event
 * @return {Item | null} item
 */
ItemSet.itemFromTarget = function(event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('timeline-item')) {
      return target['timeline-item'];
    }
    target = target.parentNode;
  }

  return null;
};

/**
 * Find the Group from an event target:
 * searches for the attribute 'timeline-group' in the event target's element tree
 * @param {Event} event
 * @return {Group | null} group
 */
ItemSet.groupFromTarget = function(event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('timeline-group')) {
      return target['timeline-group'];
    }
    target = target.parentNode;
  }

  return null;
};

/**
 * Find the ItemSet from an event target:
 * searches for the attribute 'timeline-itemset' in the event target's element tree
 * @param {Event} event
 * @return {ItemSet | null} item
 */
ItemSet.itemSetFromTarget = function(event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('timeline-itemset')) {
      return target['timeline-itemset'];
    }
    target = target.parentNode;
  }

  return null;
};

module.exports = ItemSet;

},{"../../DataSet":29,"../../DataView":30,"../../module/hammer":32,"../../util":52,"./Component":40,"./Group":43,"./item/BackgroundItem":46,"./item/BoxItem":47,"./item/PointItem":49,"./item/RangeItem":50}],45:[function(require,module,exports){
var util = require('../../util');
var Component = require('./Component');
var TimeStep = require('../TimeStep');
var moment = require('../../module/moment');

/**
 * A horizontal time axis
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
 * @param {Object} [options]        See TimeAxis.setOptions for the available
 *                                  options.
 * @constructor TimeAxis
 * @extends Component
 */
function TimeAxis (body, options) {
  this.dom = {
    foreground: null,
    majorLines: [],
    majorTexts: [],
    minorLines: [],
    minorTexts: [],
    redundant: {
      majorLines: [],
      majorTexts: [],
      minorLines: [],
      minorTexts: []
    }
  };
  this.props = {
    range: {
      start: 0,
      end: 0,
      minimumStep: 0
    },
    lineTop: 0
  };

  this.defaultOptions = {
    orientation: 'bottom',  // supported: 'top', 'bottom'
    // TODO: implement timeaxis orientations 'left' and 'right'
    showMinorLabels: true,
    showMajorLabels: true
  };
  this.options = util.extend({}, this.defaultOptions);

  this.body = body;

  // create the HTML DOM
  this._create();

  this.setOptions(options);
}

TimeAxis.prototype = new Component();

/**
 * Set options for the TimeAxis.
 * Parameters will be merged in current options.
 * @param {Object} options  Available options:
 *                          {string} [orientation]
 *                          {boolean} [showMinorLabels]
 *                          {boolean} [showMajorLabels]
 */
TimeAxis.prototype.setOptions = function(options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['orientation', 'showMinorLabels', 'showMajorLabels'], this.options, options);

    // apply locale to moment.js
    // TODO: not so nice, this is applied globally to moment.js
    if ('locale' in options) {
      if (typeof moment.locale === 'function') {
        // moment.js 2.8.1+
        moment.locale(options.locale);
      }
      else {
        moment.lang(options.locale);
      }
    }
  }
};

/**
 * Create the HTML DOM for the TimeAxis
 */
TimeAxis.prototype._create = function() {
  this.dom.foreground = document.createElement('div');
  this.dom.background = document.createElement('div');

  this.dom.foreground.className = 'timeaxis foreground';
  this.dom.background.className = 'timeaxis background';
};

/**
 * Destroy the TimeAxis
 */
TimeAxis.prototype.destroy = function() {
  // remove from DOM
  if (this.dom.foreground.parentNode) {
    this.dom.foreground.parentNode.removeChild(this.dom.foreground);
  }
  if (this.dom.background.parentNode) {
    this.dom.background.parentNode.removeChild(this.dom.background);
  }

  this.body = null;
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
TimeAxis.prototype.redraw = function () {
  var options = this.options,
      props = this.props,
      foreground = this.dom.foreground,
      background = this.dom.background;

  // determine the correct parent DOM element (depending on option orientation)
  var parent = (options.orientation == 'top') ? this.body.dom.top : this.body.dom.bottom;
  var parentChanged = (foreground.parentNode !== parent);

  // calculate character width and height
  this._calculateCharSize();

  // TODO: recalculate sizes only needed when parent is resized or options is changed
  var orientation = this.options.orientation,
      showMinorLabels = this.options.showMinorLabels,
      showMajorLabels = this.options.showMajorLabels;

  // determine the width and height of the elemens for the axis
  props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
  props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
  props.height = props.minorLabelHeight + props.majorLabelHeight;
  props.width = foreground.offsetWidth;

  props.minorLineHeight = this.body.domProps.root.height - props.majorLabelHeight -
      (options.orientation == 'top' ? this.body.domProps.bottom.height : this.body.domProps.top.height);
  props.minorLineWidth = 1; // TODO: really calculate width
  props.majorLineHeight = props.minorLineHeight + props.majorLabelHeight;
  props.majorLineWidth = 1; // TODO: really calculate width

  //  take foreground and background offline while updating (is almost twice as fast)
  var foregroundNextSibling = foreground.nextSibling;
  var backgroundNextSibling = background.nextSibling;
  foreground.parentNode && foreground.parentNode.removeChild(foreground);
  background.parentNode && background.parentNode.removeChild(background);

  foreground.style.height = this.props.height + 'px';

  this._repaintLabels();

  // put DOM online again (at the same place)
  if (foregroundNextSibling) {
    parent.insertBefore(foreground, foregroundNextSibling);
  }
  else {
    parent.appendChild(foreground)
  }
  if (backgroundNextSibling) {
    this.body.dom.backgroundVertical.insertBefore(background, backgroundNextSibling);
  }
  else {
    this.body.dom.backgroundVertical.appendChild(background)
  }

  return this._isResized() || parentChanged;
};

/**
 * Repaint major and minor text labels and vertical grid lines
 * @private
 */
TimeAxis.prototype._repaintLabels = function () {
  var orientation = this.options.orientation;

  // calculate range and step (step such that we have space for 7 characters per label)
  var start = util.convert(this.body.range.start, 'Number'),
      end = util.convert(this.body.range.end, 'Number'),
      minimumStep = this.body.util.toTime((this.props.minorCharWidth || 10) * 7).valueOf()
          -this.body.util.toTime(0).valueOf();
  var step = new TimeStep(new Date(start), new Date(end), minimumStep);
  this.step = step;

  // Move all DOM elements to a "redundant" list, where they
  // can be picked for re-use, and clear the lists with lines and texts.
  // At the end of the function _repaintLabels, left over elements will be cleaned up
  var dom = this.dom;
  dom.redundant.majorLines = dom.majorLines;
  dom.redundant.majorTexts = dom.majorTexts;
  dom.redundant.minorLines = dom.minorLines;
  dom.redundant.minorTexts = dom.minorTexts;
  dom.majorLines = [];
  dom.majorTexts = [];
  dom.minorLines = [];
  dom.minorTexts = [];

  step.first();
  var xFirstMajorLabel = undefined;
  var max = 0;
  while (step.hasNext() && max < 1000) {
    max++;
    var cur = step.getCurrent(),
        x = this.body.util.toScreen(cur),
        isMajor = step.isMajor();

    // TODO: lines must have a width, such that we can create css backgrounds

    if (this.options.showMinorLabels) {
      this._repaintMinorText(x, step.getLabelMinor(), orientation);
    }

    if (isMajor && this.options.showMajorLabels) {
      if (x > 0) {
        if (xFirstMajorLabel == undefined) {
          xFirstMajorLabel = x;
        }
        this._repaintMajorText(x, step.getLabelMajor(), orientation);
      }
      this._repaintMajorLine(x, orientation);
    }
    else {
      this._repaintMinorLine(x, orientation);
    }

    step.next();
  }

  // create a major label on the left when needed
  if (this.options.showMajorLabels) {
    var leftTime = this.body.util.toTime(0),
        leftText = step.getLabelMajor(leftTime),
        widthText = leftText.length * (this.props.majorCharWidth || 10) + 10; // upper bound estimation

    if (xFirstMajorLabel == undefined || widthText < xFirstMajorLabel) {
      this._repaintMajorText(0, leftText, orientation);
    }
  }

  // Cleanup leftover DOM elements from the redundant list
  util.forEach(this.dom.redundant, function (arr) {
    while (arr.length) {
      var elem = arr.pop();
      if (elem && elem.parentNode) {
        elem.parentNode.removeChild(elem);
      }
    }
  });
};

/**
 * Create a minor label for the axis at position x
 * @param {Number} x
 * @param {String} text
 * @param {String} orientation   "top" or "bottom" (default)
 * @private
 */
TimeAxis.prototype._repaintMinorText = function (x, text, orientation) {
  // reuse redundant label
  var label = this.dom.redundant.minorTexts.shift();

  if (!label) {
    // create new label
    var content = document.createTextNode('');
    label = document.createElement('div');
    label.appendChild(content);
    label.className = 'text minor';
    this.dom.foreground.appendChild(label);
  }
  this.dom.minorTexts.push(label);

  label.childNodes[0].nodeValue = text;

  label.style.top = (orientation == 'top') ? (this.props.majorLabelHeight + 'px') : '0';
  label.style.left = x + 'px';
  //label.title = title;  // TODO: this is a heavy operation
};

/**
 * Create a Major label for the axis at position x
 * @param {Number} x
 * @param {String} text
 * @param {String} orientation   "top" or "bottom" (default)
 * @private
 */
TimeAxis.prototype._repaintMajorText = function (x, text, orientation) {
  // reuse redundant label
  var label = this.dom.redundant.majorTexts.shift();

  if (!label) {
    // create label
    var content = document.createTextNode(text);
    label = document.createElement('div');
    label.className = 'text major';
    label.appendChild(content);
    this.dom.foreground.appendChild(label);
  }
  this.dom.majorTexts.push(label);

  label.childNodes[0].nodeValue = text;
  //label.title = title; // TODO: this is a heavy operation

  label.style.top = (orientation == 'top') ? '0' : (this.props.minorLabelHeight  + 'px');
  label.style.left = x + 'px';
};

/**
 * Create a minor line for the axis at position x
 * @param {Number} x
 * @param {String} orientation   "top" or "bottom" (default)
 * @private
 */
TimeAxis.prototype._repaintMinorLine = function (x, orientation) {
  // reuse redundant line
  var line = this.dom.redundant.minorLines.shift();

  if (!line) {
    // create vertical line
    line = document.createElement('div');
    line.className = 'grid vertical minor';
    this.dom.background.appendChild(line);
  }
  this.dom.minorLines.push(line);

  var props = this.props;
  if (orientation == 'top') {
    line.style.top = props.majorLabelHeight + 'px';
  }
  else {
    line.style.top = this.body.domProps.top.height + 'px';
  }
  line.style.height = props.minorLineHeight + 'px';
  line.style.left = (x - props.minorLineWidth / 2) + 'px';
};

/**
 * Create a Major line for the axis at position x
 * @param {Number} x
 * @param {String} orientation   "top" or "bottom" (default)
 * @private
 */
TimeAxis.prototype._repaintMajorLine = function (x, orientation) {
  // reuse redundant line
  var line = this.dom.redundant.majorLines.shift();

  if (!line) {
    // create vertical line
    line = document.createElement('DIV');
    line.className = 'grid vertical major';
    this.dom.background.appendChild(line);
  }
  this.dom.majorLines.push(line);

  var props = this.props;
  if (orientation == 'top') {
    line.style.top = '0';
  }
  else {
    line.style.top = this.body.domProps.top.height + 'px';
  }
  line.style.left = (x - props.majorLineWidth / 2) + 'px';
  line.style.height = props.majorLineHeight + 'px';
};

/**
 * Determine the size of text on the axis (both major and minor axis).
 * The size is calculated only once and then cached in this.props.
 * @private
 */
TimeAxis.prototype._calculateCharSize = function () {
  // Note: We calculate char size with every redraw. Size may change, for
  // example when any of the timelines parents had display:none for example.

  // determine the char width and height on the minor axis
  if (!this.dom.measureCharMinor) {
    this.dom.measureCharMinor = document.createElement('DIV');
    this.dom.measureCharMinor.className = 'text minor measure';
    this.dom.measureCharMinor.style.position = 'absolute';

    this.dom.measureCharMinor.appendChild(document.createTextNode('0'));
    this.dom.foreground.appendChild(this.dom.measureCharMinor);
  }
  this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight;
  this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth;

  // determine the char width and height on the major axis
  if (!this.dom.measureCharMajor) {
    this.dom.measureCharMajor = document.createElement('DIV');
    this.dom.measureCharMajor.className = 'text minor measure';
    this.dom.measureCharMajor.style.position = 'absolute';

    this.dom.measureCharMajor.appendChild(document.createTextNode('0'));
    this.dom.foreground.appendChild(this.dom.measureCharMajor);
  }
  this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight;
  this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth;
};

/**
 * Snap a date to a rounded value.
 * The snap intervals are dependent on the current scale and step.
 * @param {Date} date   the date to be snapped.
 * @return {Date} snappedDate
 */
TimeAxis.prototype.snap = function(date) {
  return this.step.snap(date);
};

module.exports = TimeAxis;

},{"../../module/moment":33,"../../util":52,"../TimeStep":38,"./Component":40}],46:[function(require,module,exports){
var Hammer = require('../../../module/hammer');
var Item = require('./Item');
var RangeItem = require('./RangeItem');

/**
 * @constructor BackgroundItem
 * @extends Item
 * @param {Object} data             Object containing parameters start, end
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe options
 */
// TODO: implement support for the BackgroundItem just having a start, then being displayed as a sort of an annotation
function BackgroundItem (data, conversion, options) {
  this.props = {
    content: {
      width: 0
    }
  };
  this.overflow = false; // if contents can overflow (css styling), this flag is set to true

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data.id);
    }
    if (data.end == undefined) {
      throw new Error('Property "end" missing in item ' + data.id);
    }
  }

  Item.call(this, data, conversion, options);
}

BackgroundItem.prototype = new Item (null, null, null);

BackgroundItem.prototype.baseClassName = 'item background';

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
BackgroundItem.prototype.isVisible = function(range) {
  // determine visibility
  return (this.data.start < range.end) && (this.data.end > range.start);
};

/**
 * Repaint the item
 */
BackgroundItem.prototype.redraw = function() {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

      // background box
    dom.box = document.createElement('div');
    // className is updated in redraw()

    // contents box
    dom.content = document.createElement('div');
    dom.content.className = 'content';
    dom.box.appendChild(dom.content);

    // attach this item as attribute
    dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var background = this.parent.dom.background;
    if (!background) {
      throw new Error('Cannot redraw time axis: parent has no background container element');
    }
    background.appendChild(dom.box);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.content);
    this._updateDataAttributes(this.dom.content);

    // update class
    var className = (this.data.className ? (' ' + this.data.className) : '') +
        (this.selected ? ' selected' : '');
    dom.box.className = this.baseClassName + className;

    // determine from css whether this box has overflow
    this.overflow = window.getComputedStyle(dom.content).overflow !== 'hidden';

    // recalculate size
    this.props.content.width = this.dom.content.offsetWidth;
    this.height = 0; // set height zero, so this item will be ignored when stacking items

    this.dirty = false;
  }
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
BackgroundItem.prototype.show = RangeItem.prototype.show;

/**
 * Hide the item from the DOM (when visible)
 * @return {Boolean} changed
 */
BackgroundItem.prototype.hide = RangeItem.prototype.hide;

/**
 * Reposition the item horizontally
 * @Override
 */
BackgroundItem.prototype.repositionX = RangeItem.prototype.repositionX;

/**
 * Reposition the item vertically
 * @Override
 */
BackgroundItem.prototype.repositionY = function() {
  var onTop = this.options.orientation === 'top';
  this.dom.content.style.top = onTop ? '' : '0';
  this.dom.content.style.bottom = onTop ? '0' : '';
};

module.exports = BackgroundItem;

},{"../../../module/hammer":32,"./Item":48,"./RangeItem":50}],47:[function(require,module,exports){
var Item = require('./Item');

/**
 * @constructor BoxItem
 * @extends Item
 * @param {Object} data             Object containing parameters start
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe available options
 */
function BoxItem (data, conversion, options) {
  this.props = {
    dot: {
      width: 0,
      height: 0
    },
    line: {
      width: 0,
      height: 0
    }
  };

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data);
    }
  }

  Item.call(this, data, conversion, options);
}

BoxItem.prototype = new Item (null, null, null);

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
BoxItem.prototype.isVisible = function(range) {
  // determine visibility
  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
  var interval = (range.end - range.start) / 4;
  return (this.data.start > range.start - interval) && (this.data.start < range.end + interval);
};

/**
 * Repaint the item
 */
BoxItem.prototype.redraw = function() {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // create main box
    dom.box = document.createElement('DIV');

    // contents box (inside the background box). used for making margins
    dom.content = document.createElement('DIV');
    dom.content.className = 'content';
    dom.box.appendChild(dom.content);

    // line to axis
    dom.line = document.createElement('DIV');
    dom.line.className = 'line';

    // dot on axis
    dom.dot = document.createElement('DIV');
    dom.dot.className = 'dot';

    // attach this item as attribute
    dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) throw new Error('Cannot redraw time axis: parent has no foreground container element');
    foreground.appendChild(dom.box);
  }
  if (!dom.line.parentNode) {
    var background = this.parent.dom.background;
    if (!background) throw new Error('Cannot redraw time axis: parent has no background container element');
    background.appendChild(dom.line);
  }
  if (!dom.dot.parentNode) {
    var axis = this.parent.dom.axis;
    if (!background) throw new Error('Cannot redraw time axis: parent has no axis container element');
    axis.appendChild(dom.dot);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.box);
    this._updateDataAttributes(this.dom.box);

    // update class
    var className = (this.data.className? ' ' + this.data.className : '') +
        (this.selected ? ' selected' : '');
    dom.box.className = 'item box' + className;
    dom.line.className = 'item line' + className;
    dom.dot.className  = 'item dot' + className;

    // recalculate size
    this.props.dot.height = dom.dot.offsetHeight;
    this.props.dot.width = dom.dot.offsetWidth;
    this.props.line.width = dom.line.offsetWidth;
    this.width = dom.box.offsetWidth;
    this.height = dom.box.offsetHeight;

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.box);
};

/**
 * Show the item in the DOM (when not already displayed). The items DOM will
 * be created when needed.
 */
BoxItem.prototype.show = function() {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 */
BoxItem.prototype.hide = function() {
  if (this.displayed) {
    var dom = this.dom;

    if (dom.box.parentNode)   dom.box.parentNode.removeChild(dom.box);
    if (dom.line.parentNode)  dom.line.parentNode.removeChild(dom.line);
    if (dom.dot.parentNode)   dom.dot.parentNode.removeChild(dom.dot);

    this.top = null;
    this.left = null;

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @Override
 */
BoxItem.prototype.repositionX = function() {
  var start = this.conversion.toScreen(this.data.start);
  var align = this.options.align;
  var left;
  var box = this.dom.box;
  var line = this.dom.line;
  var dot = this.dom.dot;

  // calculate left position of the box
  if (align == 'right') {
    this.left = start - this.width;
  }
  else if (align == 'left') {
    this.left = start;
  }
  else {
    // default or 'center'
    this.left = start - this.width / 2;
  }

  // reposition box
  box.style.left = this.left + 'px';

  // reposition line
  line.style.left = (start - this.props.line.width / 2) + 'px';

  // reposition dot
  dot.style.left = (start - this.props.dot.width / 2) + 'px';
};

/**
 * Reposition the item vertically
 * @Override
 */
BoxItem.prototype.repositionY = function() {
  var orientation = this.options.orientation;
  var box = this.dom.box;
  var line = this.dom.line;
  var dot = this.dom.dot;

  if (orientation == 'top') {
    box.style.top     = (this.top || 0) + 'px';

    line.style.top    = '0';
    line.style.height = (this.parent.top + this.top + 1) + 'px';
    line.style.bottom = '';
  }
  else { // orientation 'bottom'
    var itemSetHeight = this.parent.itemSet.props.height; // TODO: this is nasty
    var lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;

    box.style.top     = (this.parent.height - this.top - this.height || 0) + 'px';
    line.style.top    = (itemSetHeight - lineHeight) + 'px';
    line.style.bottom = '0';
  }

  dot.style.top = (-this.props.dot.height / 2) + 'px';
};

module.exports = BoxItem;

},{"./Item":48}],48:[function(require,module,exports){
var Hammer = require('../../../module/hammer');

/**
 * @constructor Item
 * @param {Object} data             Object containing (optional) parameters type,
 *                                  start, end, content, group, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} options          Configuration options
 *                                  // TODO: describe available options
 */
function Item (data, conversion, options) {
  this.id = null;
  this.parent = null;
  this.data = data;
  this.dom = null;
  this.conversion = conversion || {};
  this.options = options || {};

  this.selected = false;
  this.displayed = false;
  this.dirty = true;

  this.top = null;
  this.left = null;
  this.width = null;
  this.height = null;
}

/**
 * Select current item
 */
Item.prototype.select = function() {
  this.selected = true;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Unselect current item
 */
Item.prototype.unselect = function() {
  this.selected = false;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Set data for the item. Existing data will be updated. The id should not
 * be changed. When the item is displayed, it will be redrawn immediately.
 * @param {Object} data
 */
Item.prototype.setData = function(data) {
  this.data = data;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Set a parent for the item
 * @param {ItemSet | Group} parent
 */
Item.prototype.setParent = function(parent) {
  if (this.displayed) {
    this.hide();
    this.parent = parent;
    if (this.parent) {
      this.show();
    }
  }
  else {
    this.parent = parent;
  }
};

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
Item.prototype.isVisible = function(range) {
  // Should be implemented by Item implementations
  return false;
};

/**
 * Show the Item in the DOM (when not already visible)
 * @return {Boolean} changed
 */
Item.prototype.show = function() {
  return false;
};

/**
 * Hide the Item from the DOM (when visible)
 * @return {Boolean} changed
 */
Item.prototype.hide = function() {
  return false;
};

/**
 * Repaint the item
 */
Item.prototype.redraw = function() {
  // should be implemented by the item
};

/**
 * Reposition the Item horizontally
 */
Item.prototype.repositionX = function() {
  // should be implemented by the item
};

/**
 * Reposition the Item vertically
 */
Item.prototype.repositionY = function() {
  // should be implemented by the item
};

/**
 * Repaint a delete button on the top right of the item when the item is selected
 * @param {HTMLElement} anchor
 * @protected
 */
Item.prototype._repaintDeleteButton = function (anchor) {
  if (this.selected && this.options.editable.remove && !this.dom.deleteButton) {
    // create and show button
    var me = this;

    var deleteButton = document.createElement('div');
    deleteButton.className = 'delete';
    deleteButton.title = 'Delete this item';

    Hammer(deleteButton, {
      preventDefault: true
    }).on('tap', function (event) {
      me.parent.removeFromDataSet(me);
      event.stopPropagation();
    });

    anchor.appendChild(deleteButton);
    this.dom.deleteButton = deleteButton;
  }
  else if (!this.selected && this.dom.deleteButton) {
    // remove button
    if (this.dom.deleteButton.parentNode) {
      this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);
    }
    this.dom.deleteButton = null;
  }
};

/**
 * Set HTML contents for the item
 * @param {Element} element   HTML element to fill with the contents
 * @private
 */
Item.prototype._updateContents = function (element) {
  var content;
  if (this.options.template) {
    var itemData = this.parent.itemSet.itemsData.get(this.id); // get a clone of the data from the dataset
    content = this.options.template(itemData);
  }
  else {
    content = this.data.content;
  }

  if (content instanceof Element) {
    element.innerHTML = '';
    element.appendChild(content);
  }
  else if (content != undefined) {
    element.innerHTML = content;
  }
  else {
    throw new Error('Property "content" missing in item ' + this.data.id);
  }
};

/**
 * Set HTML contents for the item
 * @param {Element} element   HTML element to fill with the contents
 * @private
 */
Item.prototype._updateTitle = function (element) {
  if (this.data.title != null) {
    element.title = this.data.title || '';
  }
  else {
    element.removeAttribute('title');
  }
};

/**
 * Process dataAttributes timeline option and set as data- attributes on dom.content
 * @param {Element} element   HTML element to which the attributes will be attached
 * @private
 */
 Item.prototype._updateDataAttributes = function(element) {
  if (this.options.dataAttributes && this.options.dataAttributes.length > 0) {
    for (var i = 0; i < this.options.dataAttributes.length; i++) {
      var name = this.options.dataAttributes[i];
      var value = this.data[name];

      if (value != null) {
        element.setAttribute('data-' + name, value);
      }
      else {
        element.removeAttribute('data-' + name);
      }
    }
  }
};

module.exports = Item;

},{"../../../module/hammer":32}],49:[function(require,module,exports){
var Item = require('./Item');

/**
 * @constructor PointItem
 * @extends Item
 * @param {Object} data             Object containing parameters start
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe available options
 */
function PointItem (data, conversion, options) {
  this.props = {
    dot: {
      top: 0,
      width: 0,
      height: 0
    },
    content: {
      height: 0,
      marginLeft: 0
    }
  };

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data);
    }
  }

  Item.call(this, data, conversion, options);
}

PointItem.prototype = new Item (null, null, null);

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
PointItem.prototype.isVisible = function(range) {
  // determine visibility
  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
  var interval = (range.end - range.start) / 4;
  return (this.data.start > range.start - interval) && (this.data.start < range.end + interval);
};

/**
 * Repaint the item
 */
PointItem.prototype.redraw = function() {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.point = document.createElement('div');
    // className is updated in redraw()

    // contents box, right from the dot
    dom.content = document.createElement('div');
    dom.content.className = 'content';
    dom.point.appendChild(dom.content);

    // dot at start
    dom.dot = document.createElement('div');
    dom.point.appendChild(dom.dot);

    // attach this item as attribute
    dom.point['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.point.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) {
      throw new Error('Cannot redraw time axis: parent has no foreground container element');
    }
    foreground.appendChild(dom.point);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.point);
    this._updateDataAttributes(this.dom.point);

    // update class
    var className = (this.data.className? ' ' + this.data.className : '') +
        (this.selected ? ' selected' : '');
    dom.point.className  = 'item point' + className;
    dom.dot.className  = 'item dot' + className;

    // recalculate size
    this.width = dom.point.offsetWidth;
    this.height = dom.point.offsetHeight;
    this.props.dot.width = dom.dot.offsetWidth;
    this.props.dot.height = dom.dot.offsetHeight;
    this.props.content.height = dom.content.offsetHeight;

    // resize contents
    dom.content.style.marginLeft = 2 * this.props.dot.width + 'px';
    //dom.content.style.marginRight = ... + 'px'; // TODO: margin right

    dom.dot.style.top = ((this.height - this.props.dot.height) / 2) + 'px';
    dom.dot.style.left = (this.props.dot.width / 2) + 'px';

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.point);
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
PointItem.prototype.show = function() {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 */
PointItem.prototype.hide = function() {
  if (this.displayed) {
    if (this.dom.point.parentNode) {
      this.dom.point.parentNode.removeChild(this.dom.point);
    }

    this.top = null;
    this.left = null;

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @Override
 */
PointItem.prototype.repositionX = function() {
  var start = this.conversion.toScreen(this.data.start);

  this.left = start - this.props.dot.width;

  // reposition point
  this.dom.point.style.left = this.left + 'px';
};

/**
 * Reposition the item vertically
 * @Override
 */
PointItem.prototype.repositionY = function() {
  var orientation = this.options.orientation,
      point = this.dom.point;

  if (orientation == 'top') {
    point.style.top = this.top + 'px';
  }
  else {
    point.style.top = (this.parent.height - this.top - this.height) + 'px';
  }
};

module.exports = PointItem;

},{"./Item":48}],50:[function(require,module,exports){
var Hammer = require('../../../module/hammer');
var Item = require('./Item');

/**
 * @constructor RangeItem
 * @extends Item
 * @param {Object} data             Object containing parameters start, end
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe options
 */
function RangeItem (data, conversion, options) {
  this.props = {
    content: {
      width: 0
    }
  };
  this.overflow = false; // if contents can overflow (css styling), this flag is set to true

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data.id);
    }
    if (data.end == undefined) {
      throw new Error('Property "end" missing in item ' + data.id);
    }
  }

  Item.call(this, data, conversion, options);
}

RangeItem.prototype = new Item (null, null, null);

RangeItem.prototype.baseClassName = 'item range';

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
RangeItem.prototype.isVisible = function(range) {
  // determine visibility
  return (this.data.start < range.end) && (this.data.end > range.start);
};

/**
 * Repaint the item
 */
RangeItem.prototype.redraw = function() {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

      // background box
    dom.box = document.createElement('div');
    // className is updated in redraw()

    // contents box
    dom.content = document.createElement('div');
    dom.content.className = 'content';
    dom.box.appendChild(dom.content);

    // attach this item as attribute
    dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) {
      throw new Error('Cannot redraw time axis: parent has no foreground container element');
    }
    foreground.appendChild(dom.box);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.box);
    this._updateDataAttributes(this.dom.box);

    // update class
    var className = (this.data.className ? (' ' + this.data.className) : '') +
        (this.selected ? ' selected' : '');
    dom.box.className = this.baseClassName + className;

    // determine from css whether this box has overflow
    this.overflow = window.getComputedStyle(dom.content).overflow !== 'hidden';

    // recalculate size
    this.props.content.width = this.dom.content.offsetWidth;
    this.height = this.dom.box.offsetHeight;

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.box);
  this._repaintDragLeft();
  this._repaintDragRight();
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
RangeItem.prototype.show = function() {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 * @return {Boolean} changed
 */
RangeItem.prototype.hide = function() {
  if (this.displayed) {
    var box = this.dom.box;

    if (box.parentNode) {
      box.parentNode.removeChild(box);
    }

    this.top = null;
    this.left = null;

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @Override
 */
RangeItem.prototype.repositionX = function() {
  var parentWidth = this.parent.width;
  var start = this.conversion.toScreen(this.data.start);
  var end = this.conversion.toScreen(this.data.end);
  var contentLeft;
  var contentWidth;

  // limit the width of the this, as browsers cannot draw very wide divs
  if (start < -parentWidth) {
    start = -parentWidth;
  }
  if (end > 2 * parentWidth) {
    end = 2 * parentWidth;
  }
  var boxWidth = Math.max(end - start, 1);

  if (this.overflow) {
    this.left = start;
    this.width = boxWidth + this.props.content.width;
    contentWidth = this.props.content.width;

    // Note: The calculation of width is an optimistic calculation, giving
    //       a width which will not change when moving the Timeline
    //       So no re-stacking needed, which is nicer for the eye;
  }
  else {
    this.left = start;
    this.width = boxWidth;
    contentWidth = Math.min(end - start, this.props.content.width);
  }

  this.dom.box.style.left = this.left + 'px';
  this.dom.box.style.width = boxWidth + 'px';

  switch (this.options.align) {
    case 'left':
      this.dom.content.style.left = '0';
      break;

    case 'right':
      this.dom.content.style.left = Math.max((boxWidth - contentWidth - 2 * this.options.padding), 0) + 'px';
      break;

    case 'center':
      this.dom.content.style.left = Math.max((boxWidth - contentWidth - 2 * this.options.padding) / 2, 0) + 'px';
      break;

    default: // 'auto'
      if (this.overflow) {
        // when range exceeds left of the window, position the contents at the left of the visible area
        contentLeft = Math.max(-start, 0);
      }
      else {
        // when range exceeds left of the window, position the contents at the left of the visible area
        if (start < 0) {
          contentLeft = Math.min(-start,
              (end - start - this.props.content.width - 2 * this.options.padding));
          // TODO: remove the need for options.padding. it's terrible.
        }
        else {
          contentLeft = 0;
        }
      }
      this.dom.content.style.left = contentLeft + 'px';
  }
};

/**
 * Reposition the item vertically
 * @Override
 */
RangeItem.prototype.repositionY = function() {
  var orientation = this.options.orientation,
      box = this.dom.box;

  if (orientation == 'top') {
    box.style.top = this.top + 'px';
  }
  else {
    box.style.top = (this.parent.height - this.top - this.height) + 'px';
  }
};

/**
 * Repaint a drag area on the left side of the range when the range is selected
 * @protected
 */
RangeItem.prototype._repaintDragLeft = function () {
  if (this.selected && this.options.editable.updateTime && !this.dom.dragLeft) {
    // create and show drag area
    var dragLeft = document.createElement('div');
    dragLeft.className = 'drag-left';
    dragLeft.dragLeftItem = this;

    // TODO: this should be redundant?
    Hammer(dragLeft, {
      preventDefault: true
    }).on('drag', function () {
          //console.log('drag left')
        });

    this.dom.box.appendChild(dragLeft);
    this.dom.dragLeft = dragLeft;
  }
  else if (!this.selected && this.dom.dragLeft) {
    // delete drag area
    if (this.dom.dragLeft.parentNode) {
      this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);
    }
    this.dom.dragLeft = null;
  }
};

/**
 * Repaint a drag area on the right side of the range when the range is selected
 * @protected
 */
RangeItem.prototype._repaintDragRight = function () {
  if (this.selected && this.options.editable.updateTime && !this.dom.dragRight) {
    // create and show drag area
    var dragRight = document.createElement('div');
    dragRight.className = 'drag-right';
    dragRight.dragRightItem = this;

    // TODO: this should be redundant?
    Hammer(dragRight, {
      preventDefault: true
    }).on('drag', function () {
      //console.log('drag right')
    });

    this.dom.box.appendChild(dragRight);
    this.dom.dragRight = dragRight;
  }
  else if (!this.selected && this.dom.dragRight) {
    // delete drag area
    if (this.dom.dragRight.parentNode) {
      this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);
    }
    this.dom.dragRight = null;
  }
};

module.exports = RangeItem;

},{"../../../module/hammer":32,"./Item":48}],51:[function(require,module,exports){
// English
exports['en'] = {
  current: 'current',
  time: 'time'
};
exports['en_EN'] = exports['en'];
exports['en_US'] = exports['en'];

// Dutch
exports['nl'] = {
  custom: 'aangepaste',
  time: 'tijd'
};
exports['nl_NL'] = exports['nl'];
exports['nl_BE'] = exports['nl'];

},{}],52:[function(require,module,exports){
// utility functions

// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.
var moment = require('./module/moment');

/**
 * Test whether given object is a number
 * @param {*} object
 * @return {Boolean} isNumber
 */
exports.isNumber = function(object) {
  return (object instanceof Number || typeof object == 'number');
};

/**
 * Test whether given object is a string
 * @param {*} object
 * @return {Boolean} isString
 */
exports.isString = function(object) {
  return (object instanceof String || typeof object == 'string');
};

/**
 * Test whether given object is a Date, or a String containing a Date
 * @param {Date | String} object
 * @return {Boolean} isDate
 */
exports.isDate = function(object) {
  if (object instanceof Date) {
    return true;
  }
  else if (exports.isString(object)) {
    // test whether this string contains a date
    var match = ASPDateRegex.exec(object);
    if (match) {
      return true;
    }
    else if (!isNaN(Date.parse(object))) {
      return true;
    }
  }

  return false;
};

/**
 * Test whether given object is an instance of google.visualization.DataTable
 * @param {*} object
 * @return {Boolean} isDataTable
 */
exports.isDataTable = function(object) {
  return (typeof (google) !== 'undefined') &&
      (google.visualization) &&
      (google.visualization.DataTable) &&
      (object instanceof google.visualization.DataTable);
};

/**
 * Create a semi UUID
 * source: http://stackoverflow.com/a/105074/1262753
 * @return {String} uuid
 */
exports.randomUUID = function() {
  var S4 = function () {
    return Math.floor(
        Math.random() * 0x10000 /* 65536 */
    ).toString(16);
  };

  return (
      S4() + S4() + '-' +
          S4() + '-' +
          S4() + '-' +
          S4() + '-' +
          S4() + S4() + S4()
      );
};

/**
 * Extend object a with the properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.extend = function (a, b) {
  for (var i = 1, len = arguments.length; i < len; i++) {
    var other = arguments[i];
    for (var prop in other) {
      if (other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }

  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.selectiveExtend = function (props, a, b) {
  if (!Array.isArray(props)) {
    throw new Error('Array with property names expected as first argument');
  }

  for (var i = 2; i < arguments.length; i++) {
    var other = arguments[i];

    for (var p = 0; p < props.length; p++) {
      var prop = props[p];
      if (other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.selectiveDeepExtend = function (props, a, b) {
  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }
  for (var i = 2; i < arguments.length; i++) {
    var other = arguments[i];
    for (var p = 0; p < props.length; p++) {
      var prop = props[p];
      if (other.hasOwnProperty(prop)) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop]);
          }
          else {
            a[prop] = b[prop];
          }
        } else if (Array.isArray(b[prop])) {
          throw new TypeError('Arrays are not supported by deepExtend');
        } else {
          a[prop] = b[prop];
        }

      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.selectiveNotDeepExtend = function (props, a, b) {
  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }
  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      if (props.indexOf(prop) == -1) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop]);
          }
          else {
            a[prop] = b[prop];
          }
        } else if (Array.isArray(b[prop])) {
          throw new TypeError('Arrays are not supported by deepExtend');
        } else {
          a[prop] = b[prop];
        }
      }
    }
  }
  return a;
};

/**
 * Deep extend an object a with the properties of object b
 * @param {Object} a
 * @param {Object} b
 * @returns {Object}
 */
exports.deepExtend = function(a, b) {
  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }

  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          exports.deepExtend(a[prop], b[prop]);
        }
        else {
          a[prop] = b[prop];
        }
      } else if (Array.isArray(b[prop])) {
        throw new TypeError('Arrays are not supported by deepExtend');
      } else {
        a[prop] = b[prop];
      }
    }
  }
  return a;
};

/**
 * Test whether all elements in two arrays are equal.
 * @param {Array} a
 * @param {Array} b
 * @return {boolean} Returns true if both arrays have the same length and same
 *                   elements.
 */
exports.equalArray = function (a, b) {
  if (a.length != b.length) return false;

  for (var i = 0, len = a.length; i < len; i++) {
    if (a[i] != b[i]) return false;
  }

  return true;
};

/**
 * Convert an object to another type
 * @param {Boolean | Number | String | Date | Moment | Null | undefined} object
 * @param {String | undefined} type   Name of the type. Available types:
 *                                    'Boolean', 'Number', 'String',
 *                                    'Date', 'Moment', ISODate', 'ASPDate'.
 * @return {*} object
 * @throws Error
 */
exports.convert = function(object, type) {
  var match;

  if (object === undefined) {
    return undefined;
  }
  if (object === null) {
    return null;
  }

  if (!type) {
    return object;
  }
  if (!(typeof type === 'string') && !(type instanceof String)) {
    throw new Error('Type must be a string');
  }

  //noinspection FallthroughInSwitchStatementJS
  switch (type) {
    case 'boolean':
    case 'Boolean':
      return Boolean(object);

    case 'number':
    case 'Number':
      return Number(object.valueOf());

    case 'string':
    case 'String':
      return String(object);

    case 'Date':
      if (exports.isNumber(object)) {
        return new Date(object);
      }
      if (object instanceof Date) {
        return new Date(object.valueOf());
      }
      else if (moment.isMoment(object)) {
        return new Date(object.valueOf());
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])); // parse number
        }
        else {
          return moment(object).toDate(); // parse string
        }
      }
      else {
        throw new Error(
            'Cannot convert object of type ' + exports.getType(object) +
                ' to type Date');
      }

    case 'Moment':
      if (exports.isNumber(object)) {
        return moment(object);
      }
      if (object instanceof Date) {
        return moment(object.valueOf());
      }
      else if (moment.isMoment(object)) {
        return moment(object);
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return moment(Number(match[1])); // parse number
        }
        else {
          return moment(object); // parse string
        }
      }
      else {
        throw new Error(
            'Cannot convert object of type ' + exports.getType(object) +
                ' to type Date');
      }

    case 'ISODate':
      if (exports.isNumber(object)) {
        return new Date(object);
      }
      else if (object instanceof Date) {
        return object.toISOString();
      }
      else if (moment.isMoment(object)) {
        return object.toDate().toISOString();
      }
      else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])).toISOString(); // parse number
        }
        else {
          return new Date(object).toISOString(); // parse string
        }
      }
      else {
        throw new Error(
            'Cannot convert object of type ' + exports.getType(object) +
                ' to type ISODate');
      }

    case 'ASPDate':
      if (exports.isNumber(object)) {
        return '/Date(' + object + ')/';
      }
      else if (object instanceof Date) {
        return '/Date(' + object.valueOf() + ')/';
      }
      else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        var value;
        if (match) {
          // object is an ASP date
          value = new Date(Number(match[1])).valueOf(); // parse number
        }
        else {
          value = new Date(object).valueOf(); // parse string
        }
        return '/Date(' + value + ')/';
      }
      else {
        throw new Error(
            'Cannot convert object of type ' + exports.getType(object) +
                ' to type ASPDate');
      }

    default:
      throw new Error('Unknown type "' + type + '"');
  }
};

// parse ASP.Net Date pattern,
// for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
// code from http://momentjs.com/
var ASPDateRegex = /^\/?Date\((\-?\d+)/i;

/**
 * Get the type of an object, for example exports.getType([]) returns 'Array'
 * @param {*} object
 * @return {String} type
 */
exports.getType = function(object) {
  var type = typeof object;

  if (type == 'object') {
    if (object == null) {
      return 'null';
    }
    if (object instanceof Boolean) {
      return 'Boolean';
    }
    if (object instanceof Number) {
      return 'Number';
    }
    if (object instanceof String) {
      return 'String';
    }
    if (object instanceof Array) {
      return 'Array';
    }
    if (object instanceof Date) {
      return 'Date';
    }
    return 'Object';
  }
  else if (type == 'number') {
    return 'Number';
  }
  else if (type == 'boolean') {
    return 'Boolean';
  }
  else if (type == 'string') {
    return 'String';
  }

  return type;
};

/**
 * Retrieve the absolute left value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} left        The absolute left position of this element
 *                              in the browser page.
 */
exports.getAbsoluteLeft = function(elem) {
  return elem.getBoundingClientRect().left + window.pageXOffset;
};

/**
 * Retrieve the absolute top value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} top        The absolute top position of this element
 *                              in the browser page.
 */
exports.getAbsoluteTop = function(elem) {
  return elem.getBoundingClientRect().top + window.pageYOffset;
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
exports.addClassName = function(elem, className) {
  var classes = elem.className.split(' ');
  if (classes.indexOf(className) == -1) {
    classes.push(className); // add the class to the array
    elem.className = classes.join(' ');
  }
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
exports.removeClassName = function(elem, className) {
  var classes = elem.className.split(' ');
  var index = classes.indexOf(className);
  if (index != -1) {
    classes.splice(index, 1); // remove the class from the array
    elem.className = classes.join(' ');
  }
};

/**
 * For each method for both arrays and objects.
 * In case of an array, the built-in Array.forEach() is applied.
 * In case of an Object, the method loops over all properties of the object.
 * @param {Object | Array} object   An Object or Array
 * @param {function} callback       Callback method, called for each item in
 *                                  the object or array with three parameters:
 *                                  callback(value, index, object)
 */
exports.forEach = function(object, callback) {
  var i,
      len;
  if (object instanceof Array) {
    // array
    for (i = 0, len = object.length; i < len; i++) {
      callback(object[i], i, object);
    }
  }
  else {
    // object
    for (i in object) {
      if (object.hasOwnProperty(i)) {
        callback(object[i], i, object);
      }
    }
  }
};

/**
 * Convert an object into an array: all objects properties are put into the
 * array. The resulting array is unordered.
 * @param {Object} object
 * @param {Array} array
 */
exports.toArray = function(object) {
  var array = [];

  for (var prop in object) {
    if (object.hasOwnProperty(prop)) array.push(object[prop]);
  }

  return array;
}

/**
 * Update a property in an object
 * @param {Object} object
 * @param {String} key
 * @param {*} value
 * @return {Boolean} changed
 */
exports.updateProperty = function(object, key, value) {
  if (object[key] !== value) {
    object[key] = value;
    return true;
  }
  else {
    return false;
  }
};

/**
 * Add and event listener. Works for all browsers
 * @param {Element}     element    An html element
 * @param {string}      action     The action, for example "click",
 *                                 without the prefix "on"
 * @param {function}    listener   The callback function to be executed
 * @param {boolean}     [useCapture]
 */
exports.addEventListener = function(element, action, listener, useCapture) {
  if (element.addEventListener) {
    if (useCapture === undefined)
      useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll";  // For Firefox
    }

    element.addEventListener(action, listener, useCapture);
  } else {
    element.attachEvent("on" + action, listener);  // IE browsers
  }
};

/**
 * Remove an event listener from an element
 * @param {Element}     element         An html dom element
 * @param {string}      action          The name of the event, for example "mousedown"
 * @param {function}    listener        The listener function
 * @param {boolean}     [useCapture]
 */
exports.removeEventListener = function(element, action, listener, useCapture) {
  if (element.removeEventListener) {
    // non-IE browsers
    if (useCapture === undefined)
      useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll";  // For Firefox
    }

    element.removeEventListener(action, listener, useCapture);
  } else {
    // IE browsers
    element.detachEvent("on" + action, listener);
  }
};

/**
 * Cancels the event if it is cancelable, without stopping further propagation of the event.
 */
exports.preventDefault = function (event) {
  if (!event)
    event = window.event;

  if (event.preventDefault) {
    event.preventDefault();  // non-IE browsers
  }
  else {
    event.returnValue = false;  // IE browsers
  }
};

/**
 * Get HTML element which is the target of the event
 * @param {Event} event
 * @return {Element} target element
 */
exports.getTarget = function(event) {
  // code from http://www.quirksmode.org/js/events_properties.html
  if (!event) {
    event = window.event;
  }

  var target;

  if (event.target) {
    target = event.target;
  }
  else if (event.srcElement) {
    target = event.srcElement;
  }

  if (target.nodeType != undefined && target.nodeType == 3) {
    // defeat Safari bug
    target = target.parentNode;
  }

  return target;
};

exports.option = {};

/**
 * Convert a value into a boolean
 * @param {Boolean | function | undefined} value
 * @param {Boolean} [defaultValue]
 * @returns {Boolean} bool
 */
exports.option.asBoolean = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return (value != false);
  }

  return defaultValue || null;
};

/**
 * Convert a value into a number
 * @param {Boolean | function | undefined} value
 * @param {Number} [defaultValue]
 * @returns {Number} number
 */
exports.option.asNumber = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return Number(value) || defaultValue || null;
  }

  return defaultValue || null;
};

/**
 * Convert a value into a string
 * @param {String | function | undefined} value
 * @param {String} [defaultValue]
 * @returns {String} str
 */
exports.option.asString = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return String(value);
  }

  return defaultValue || null;
};

/**
 * Convert a size or location into a string with pixels or a percentage
 * @param {String | Number | function | undefined} value
 * @param {String} [defaultValue]
 * @returns {String} size
 */
exports.option.asSize = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (exports.isString(value)) {
    return value;
  }
  else if (exports.isNumber(value)) {
    return value + 'px';
  }
  else {
    return defaultValue || null;
  }
};

/**
 * Convert a value into a DOM element
 * @param {HTMLElement | function | undefined} value
 * @param {HTMLElement} [defaultValue]
 * @returns {HTMLElement | null} dom
 */
exports.option.asElement = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  return value || defaultValue || null;
};



exports.GiveDec = function(Hex) {
  var Value;

  if (Hex == "A")
    Value = 10;
  else if (Hex == "B")
    Value = 11;
  else if (Hex == "C")
    Value = 12;
  else if (Hex == "D")
    Value = 13;
  else if (Hex == "E")
    Value = 14;
  else if (Hex == "F")
    Value = 15;
  else
    Value = eval(Hex);

  return Value;
};

exports.GiveHex = function(Dec) {
  var Value;

  if(Dec == 10)
    Value = "A";
  else if (Dec == 11)
    Value = "B";
  else if (Dec == 12)
    Value = "C";
  else if (Dec == 13)
    Value = "D";
  else if (Dec == 14)
    Value = "E";
  else if (Dec == 15)
    Value = "F";
  else
    Value = "" + Dec;

  return Value;
};

/**
 * Parse a color property into an object with border, background, and
 * highlight colors
 * @param {Object | String} color
 * @return {Object} colorObject
 */
exports.parseColor = function(color) {
  var c;
  if (exports.isString(color)) {
    if (exports.isValidRGB(color)) {
      var rgb = color.substr(4).substr(0,color.length-5).split(',');
      color = exports.RGBToHex(rgb[0],rgb[1],rgb[2]);
    }
    if (exports.isValidHex(color)) {
      var hsv = exports.hexToHSV(color);
      var lighterColorHSV = {h:hsv.h,s:hsv.s * 0.45,v:Math.min(1,hsv.v * 1.05)};
      var darkerColorHSV  = {h:hsv.h,s:Math.min(1,hsv.v * 1.25),v:hsv.v*0.6};
      var darkerColorHex  = exports.HSVToHex(darkerColorHSV.h ,darkerColorHSV.h ,darkerColorHSV.v);
      var lighterColorHex = exports.HSVToHex(lighterColorHSV.h,lighterColorHSV.s,lighterColorHSV.v);

      c = {
        background: color,
        border:darkerColorHex,
        highlight: {
          background:lighterColorHex,
          border:darkerColorHex
        },
        hover: {
          background:lighterColorHex,
          border:darkerColorHex
        }
      };
    }
    else {
      c = {
        background:color,
        border:color,
        highlight: {
          background:color,
          border:color
        },
        hover: {
          background:color,
          border:color
        }
      };
    }
  }
  else {
    c = {};
    c.background = color.background || 'white';
    c.border = color.border || c.background;

    if (exports.isString(color.highlight)) {
      c.highlight = {
        border: color.highlight,
        background: color.highlight
      }
    }
    else {
      c.highlight = {};
      c.highlight.background = color.highlight && color.highlight.background || c.background;
      c.highlight.border = color.highlight && color.highlight.border || c.border;
    }

    if (exports.isString(color.hover)) {
      c.hover = {
        border: color.hover,
        background: color.hover
      }
    }
    else {
      c.hover = {};
      c.hover.background = color.hover && color.hover.background || c.background;
      c.hover.border = color.hover && color.hover.border || c.border;
    }
  }

  return c;
};

/**
 * http://www.yellowpipe.com/yis/tools/hex-to-rgb/color-converter.php
 *
 * @param {String} hex
 * @returns {{r: *, g: *, b: *}}
 */
exports.hexToRGB = function(hex) {
  hex = hex.replace("#","").toUpperCase();

  var a = exports.GiveDec(hex.substring(0, 1));
  var b = exports.GiveDec(hex.substring(1, 2));
  var c = exports.GiveDec(hex.substring(2, 3));
  var d = exports.GiveDec(hex.substring(3, 4));
  var e = exports.GiveDec(hex.substring(4, 5));
  var f = exports.GiveDec(hex.substring(5, 6));

  var r = (a * 16) + b;
  var g = (c * 16) + d;
  var b = (e * 16) + f;

  return {r:r,g:g,b:b};
};

exports.RGBToHex = function(red,green,blue) {
  var a = exports.GiveHex(Math.floor(red / 16));
  var b = exports.GiveHex(red % 16);
  var c = exports.GiveHex(Math.floor(green / 16));
  var d = exports.GiveHex(green % 16);
  var e = exports.GiveHex(Math.floor(blue / 16));
  var f = exports.GiveHex(blue % 16);

  var hex = a + b + c + d + e + f;
  return "#" + hex;
};


/**
 * http://www.javascripter.net/faq/rgb2hsv.htm
 *
 * @param red
 * @param green
 * @param blue
 * @returns {*}
 * @constructor
 */
exports.RGBToHSV = function(red,green,blue) {
  red=red/255; green=green/255; blue=blue/255;
  var minRGB = Math.min(red,Math.min(green,blue));
  var maxRGB = Math.max(red,Math.max(green,blue));

  // Black-gray-white
  if (minRGB == maxRGB) {
    return {h:0,s:0,v:minRGB};
  }

  // Colors other than black-gray-white:
  var d = (red==minRGB) ? green-blue : ((blue==minRGB) ? red-green : blue-red);
  var h = (red==minRGB) ? 3 : ((blue==minRGB) ? 1 : 5);
  var hue = 60*(h - d/(maxRGB - minRGB))/360;
  var saturation = (maxRGB - minRGB)/maxRGB;
  var value = maxRGB;
  return {h:hue,s:saturation,v:value};
};


/**
 * https://gist.github.com/mjijackson/5311256
 * @param h
 * @param s
 * @param v
 * @returns {{r: number, g: number, b: number}}
 * @constructor
 */
exports.HSVToRGB = function(h, s, v) {
  var r, g, b;

  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0: r = v, g = t, b = p; break;
    case 1: r = q, g = v, b = p; break;
    case 2: r = p, g = v, b = t; break;
    case 3: r = p, g = q, b = v; break;
    case 4: r = t, g = p, b = v; break;
    case 5: r = v, g = p, b = q; break;
  }

  return {r:Math.floor(r * 255), g:Math.floor(g * 255), b:Math.floor(b * 255) };
};

exports.HSVToHex = function(h, s, v) {
  var rgb = exports.HSVToRGB(h, s, v);
  return exports.RGBToHex(rgb.r, rgb.g, rgb.b);
};

exports.hexToHSV = function(hex) {
  var rgb = exports.hexToRGB(hex);
  return exports.RGBToHSV(rgb.r, rgb.g, rgb.b);
};

exports.isValidHex = function(hex) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  return isOk;
};

exports.isValidRGB = function(rgb) {
  rgb = rgb.replace(" ","");
  var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
  return isOk;
}

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param referenceObject
 * @returns {*}
 */
exports.selectiveBridgeObject = function(fields, referenceObject) {
  if (typeof referenceObject == "object") {
    var objectTo = Object.create(referenceObject);
    for (var i = 0; i < fields.length; i++) {
      if (referenceObject.hasOwnProperty(fields[i])) {
        if (typeof referenceObject[fields[i]] == "object") {
          objectTo[fields[i]] = exports.bridgeObject(referenceObject[fields[i]]);
        }
      }
    }
    return objectTo;
  }
  else {
    return null;
  }
};

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param referenceObject
 * @returns {*}
 */
exports.bridgeObject = function(referenceObject) {
  if (typeof referenceObject == "object") {
    var objectTo = Object.create(referenceObject);
    for (var i in referenceObject) {
      if (referenceObject.hasOwnProperty(i)) {
        if (typeof referenceObject[i] == "object") {
          objectTo[i] = exports.bridgeObject(referenceObject[i]);
        }
      }
    }
    return objectTo;
  }
  else {
    return null;
  }
};


/**
 * this is used to set the options of subobjects in the options object. A requirement of these subobjects
 * is that they have an 'enabled' element which is optional for the user but mandatory for the program.
 *
 * @param [object] mergeTarget | this is either this.options or the options used for the groups.
 * @param [object] options     | options
 * @param [String] option      | this is the option key in the options argument
 * @private
 */
exports.mergeOptions = function (mergeTarget, options, option) {
  if (options[option] !== undefined) {
    if (typeof options[option] == 'boolean') {
      mergeTarget[option].enabled = options[option];
    }
    else {
      mergeTarget[option].enabled = true;
      for (prop in options[option]) {
        if (options[option].hasOwnProperty(prop)) {
          mergeTarget[option][prop] = options[option][prop];
        }
      }
    }
  }
}


/**
 * this is used to set the options of subobjects in the options object. A requirement of these subobjects
 * is that they have an 'enabled' element which is optional for the user but mandatory for the program.
 *
 * @param [object] mergeTarget | this is either this.options or the options used for the groups.
 * @param [object] options     | options
 * @param [String] option      | this is the option key in the options argument
 * @private
 */
exports.mergeOptions = function (mergeTarget, options, option) {
  if (options[option] !== undefined) {
    if (typeof options[option] == 'boolean') {
      mergeTarget[option].enabled = options[option];
    }
    else {
      mergeTarget[option].enabled = true;
      for (prop in options[option]) {
        if (options[option].hasOwnProperty(prop)) {
          mergeTarget[option][prop] = options[option][prop];
        }
      }
    }
  }
}




/**
 * This function does a binary search for a visible item. The user can select either the this.orderedItems.byStart or .byEnd
 * arrays. This is done by giving a boolean value true if you want to use the byEnd.
 * This is done to be able to select the correct if statement (we do not want to check if an item is visible, we want to check
 * if the time we selected (start or end) is within the current range).
 *
 * The trick is that every interval has to either enter the screen at the initial load or by dragging. The case of the RangeItem that is
 * before and after the current range is handled by simply checking if it was in view before and if it is again. For all the rest,
 * either the start OR end time has to be in the range.
 *
 * @param {Item[]} orderedItems  Items ordered by start
 * @param {{start: number, end: number}} range
 * @param {String} field
 * @param {String} field2
 * @returns {number}
 * @private
 */
exports.binarySearch = function(orderedItems, range, field, field2) {
  var array = orderedItems;

  var maxIterations = 10000;
  var iteration = 0;
  var found = false;
  var low = 0;
  var high = array.length;
  var newLow = low;
  var newHigh = high;
  var guess = Math.floor(0.5*(high+low));
  var value;

  if (high == 0) {
    guess = -1;
  }
  else if (high == 1) {
    if (array[guess].isVisible(range)) {
      guess =  0;
    }
    else {
      guess = -1;
    }
  }
  else {
    high -= 1;

    while (found == false && iteration < maxIterations) {
      value = field2 === undefined ? array[guess][field] : array[guess][field][field2];

      if (array[guess].isVisible(range)) {
        found = true;
      }
      else {
        if (value < range.start) { // it is too small --> increase low
          newLow = Math.floor(0.5*(high+low));
        }
        else {  // it is too big --> decrease high
          newHigh = Math.floor(0.5*(high+low));
        }
        // not in list;
        if (low == newLow && high == newHigh) {
          guess = -1;
          found = true;
        }
        else {
          high = newHigh; low = newLow;
          guess = Math.floor(0.5*(high+low));
        }
      }
      iteration++;
    }
    if (iteration >= maxIterations) {
      console.log("BinarySearch too many iterations. Aborting.");
    }
  }
  return guess;
};

/**
 * This function does a binary search for a visible item. The user can select either the this.orderedItems.byStart or .byEnd
 * arrays. This is done by giving a boolean value true if you want to use the byEnd.
 * This is done to be able to select the correct if statement (we do not want to check if an item is visible, we want to check
 * if the time we selected (start or end) is within the current range).
 *
 * The trick is that every interval has to either enter the screen at the initial load or by dragging. The case of the RangeItem that is
 * before and after the current range is handled by simply checking if it was in view before and if it is again. For all the rest,
 * either the start OR end time has to be in the range.
 *
 * @param {Array} orderedItems
 * @param {{start: number, end: number}} target
 * @param {String} field
 * @param {String} sidePreference   'before' or 'after'
 * @returns {number}
 * @private
 */
exports.binarySearchGeneric = function(orderedItems, target, field, sidePreference) {
  var maxIterations = 10000;
  var iteration = 0;
  var array = orderedItems;
  var found = false;
  var low = 0;
  var high = array.length;
  var newLow = low;
  var newHigh = high;
  var guess = Math.floor(0.5*(high+low));
  var newGuess;
  var prevValue, value, nextValue;

  if (high == 0) {guess = -1;}
  else if (high == 1) {
    value = array[guess][field];
    if (value == target) {
      guess =  0;
    }
    else {
      guess = -1;
    }
  }
  else {
    high -= 1;
    while (found == false && iteration < maxIterations) {
      prevValue = array[Math.max(0,guess - 1)][field];
      value = array[guess][field];
      nextValue = array[Math.min(array.length-1,guess + 1)][field];

      if (value == target || prevValue < target && value > target || value < target && nextValue > target) {
        found = true;
        if (value != target) {
          if (sidePreference == 'before') {
            if (prevValue < target && value > target) {
              guess = Math.max(0,guess - 1);
            }
          }
          else {
            if (value < target && nextValue > target) {
              guess = Math.min(array.length-1,guess + 1);
            }
          }
        }
      }
      else {
        if (value < target) { // it is too small --> increase low
          newLow = Math.floor(0.5*(high+low));
        }
        else {  // it is too big --> decrease high
          newHigh = Math.floor(0.5*(high+low));
        }
        newGuess = Math.floor(0.5*(high+low));
        // not in list;
        if (low == newLow && high == newHigh) {
          guess = -1;
          found = true;
        }
        else {
          high = newHigh; low = newLow;
          guess = Math.floor(0.5*(high+low));
        }
      }
      iteration++;
    }
    if (iteration >= maxIterations) {
      console.log("BinarySearch too many iterations. Aborting.");
    }
  }
  return guess;
};

/**
 * Quadratic ease-in-out
 * http://gizma.com/easing/
 * @param {number} t        Current time
 * @param {number} start    Start value
 * @param {number} end      End value
 * @param {number} duration Duration
 * @returns {number} Value corresponding with current time
 */
exports.easeInOutQuad = function (t, start, end, duration) {
  var change = end - start;
  t /= duration/2;
  if (t < 1) return change/2*t*t + start;
  t--;
  return -change/2 * (t*(t-2) - 1) + start;
};



/*
 * Easing Functions - inspired from http://gizma.com/easing/
 * only considering the t value for the range [0, 1] => [0, 1]
 * https://gist.github.com/gre/1650294
 */
exports.easingFunctions = {
  // no easing, no acceleration
  linear: function (t) {
    return t
  },
  // accelerating from zero velocity
  easeInQuad: function (t) {
    return t * t
  },
  // decelerating to zero velocity
  easeOutQuad: function (t) {
    return t * (2 - t)
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function (t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t
  },
  // accelerating from zero velocity
  easeInCubic: function (t) {
    return t * t * t
  },
  // decelerating to zero velocity
  easeOutCubic: function (t) {
    return (--t) * t * t + 1
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function (t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
  },
  // accelerating from zero velocity
  easeInQuart: function (t) {
    return t * t * t * t
  },
  // decelerating to zero velocity
  easeOutQuart: function (t) {
    return 1 - (--t) * t * t * t
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function (t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t
  },
  // accelerating from zero velocity
  easeInQuint: function (t) {
    return t * t * t * t * t
  },
  // decelerating to zero velocity
  easeOutQuint: function (t) {
    return 1 + (--t) * t * t * t * t
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function (t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t
  }
};
},{"./module/moment":33}],53:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],54:[function(require,module,exports){
/*! Hammer.JS - v1.1.3 - 2014-05-20
 * http://eightmedia.github.io/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

(function(window, undefined) {
  'use strict';

/**
 * @main
 * @module hammer
 *
 * @class Hammer
 * @static
 */

/**
 * Hammer, use this to create instances
 * ````
 * var hammertime = new Hammer(myElement);
 * ````
 *
 * @method Hammer
 * @param {HTMLElement} element
 * @param {Object} [options={}]
 * @return {Hammer.Instance}
 */
var Hammer = function Hammer(element, options) {
    return new Hammer.Instance(element, options || {});
};

/**
 * version, as defined in package.json
 * the value will be set at each build
 * @property VERSION
 * @final
 * @type {String}
 */
Hammer.VERSION = '1.1.3';

/**
 * default settings.
 * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
 * by setting it's name (like `swipe`) to false.
 * You can set the defaults for all instances by changing this object before creating an instance.
 * @example
 * ````
 *  Hammer.defaults.drag = false;
 *  Hammer.defaults.behavior.touchAction = 'pan-y';
 *  delete Hammer.defaults.behavior.userSelect;
 * ````
 * @property defaults
 * @type {Object}
 */
Hammer.defaults = {
    /**
     * this setting object adds styles and attributes to the element to prevent the browser from doing
     * its native behavior. The css properties are auto prefixed for the browsers when needed.
     * @property defaults.behavior
     * @type {Object}
     */
    behavior: {
        /**
         * Disables text selection to improve the dragging gesture. When the value is `none` it also sets
         * `onselectstart=false` for IE on the element. Mainly for desktop browsers.
         * @property defaults.behavior.userSelect
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Specifies whether and how a given region can be manipulated by the user (for instance, by panning or zooming).
         * Used by Chrome 35> and IE10>. By default this makes the element blocking any touch event.
         * @property defaults.behavior.touchAction
         * @type {String}
         * @default: 'pan-y'
         */
        touchAction: 'pan-y',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @property defaults.behavior.touchCallout
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @property defaults.behavior.contentZooming
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents.
         * Mainly for desktop browsers.
         * @property defaults.behavior.userDrag
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in Safari on iPhone. This property obeys the alpha value, if specified.
         *
         * If you don't specify an alpha value, Safari on iPhone applies a default alpha value
         * to the color. To disable tap highlighting, set the alpha value to 0 (invisible).
         * If you set the alpha value to 1.0 (opaque), the element is not visible when tapped.
         * @property defaults.behavior.tapHighlightColor
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

/**
 * hammer document where the base events are added at
 * @property DOCUMENT
 * @type {HTMLElement}
 * @default window.document
 */
Hammer.DOCUMENT = document;

/**
 * detect support for pointer events
 * @property HAS_POINTEREVENTS
 * @type {Boolean}
 */
Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

/**
 * detect support for touch events
 * @property HAS_TOUCHEVENTS
 * @type {Boolean}
 */
Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

/**
 * detect mobile browsers
 * @property IS_MOBILE
 * @type {Boolean}
 */
Hammer.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

/**
 * detect if we want to support mouseevents at all
 * @property NO_MOUSEEVENTS
 * @type {Boolean}
 */
Hammer.NO_MOUSEEVENTS = (Hammer.HAS_TOUCHEVENTS && Hammer.IS_MOBILE) || Hammer.HAS_POINTEREVENTS;

/**
 * interval in which Hammer recalculates current velocity/direction/angle in ms
 * @property CALCULATE_INTERVAL
 * @type {Number}
 * @default 25
 */
Hammer.CALCULATE_INTERVAL = 25;

/**
 * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
 * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
 * @property EVENT_TYPES
 * @private
 * @writeOnce
 * @type {Object}
 */
var EVENT_TYPES = {};

/**
 * direction strings, for safe comparisons
 * @property DIRECTION_DOWN|LEFT|UP|RIGHT
 * @final
 * @type {String}
 * @default 'down' 'left' 'up' 'right'
 */
var DIRECTION_DOWN = Hammer.DIRECTION_DOWN = 'down';
var DIRECTION_LEFT = Hammer.DIRECTION_LEFT = 'left';
var DIRECTION_UP = Hammer.DIRECTION_UP = 'up';
var DIRECTION_RIGHT = Hammer.DIRECTION_RIGHT = 'right';

/**
 * pointertype strings, for safe comparisons
 * @property POINTER_MOUSE|TOUCH|PEN
 * @final
 * @type {String}
 * @default 'mouse' 'touch' 'pen'
 */
var POINTER_MOUSE = Hammer.POINTER_MOUSE = 'mouse';
var POINTER_TOUCH = Hammer.POINTER_TOUCH = 'touch';
var POINTER_PEN = Hammer.POINTER_PEN = 'pen';

/**
 * eventtypes
 * @property EVENT_START|MOVE|END|RELEASE|TOUCH
 * @final
 * @type {String}
 * @default 'start' 'change' 'move' 'end' 'release' 'touch'
 */
var EVENT_START = Hammer.EVENT_START = 'start';
var EVENT_MOVE = Hammer.EVENT_MOVE = 'move';
var EVENT_END = Hammer.EVENT_END = 'end';
var EVENT_RELEASE = Hammer.EVENT_RELEASE = 'release';
var EVENT_TOUCH = Hammer.EVENT_TOUCH = 'touch';

/**
 * if the window events are set...
 * @property READY
 * @writeOnce
 * @type {Boolean}
 * @default false
 */
Hammer.READY = false;

/**
 * plugins namespace
 * @property plugins
 * @type {Object}
 */
Hammer.plugins = Hammer.plugins || {};

/**
 * gestures namespace
 * see `/gestures` for the definitions
 * @property gestures
 * @type {Object}
 */
Hammer.gestures = Hammer.gestures || {};

/**
 * setup events to detect gestures on the document
 * this function is called when creating an new instance
 * @private
 */
function setup() {
    if(Hammer.READY) {
        return;
    }

    // find what eventtypes we add listeners to
    Event.determineEventTypes();

    // Register all gestures inside Hammer.gestures
    Utils.each(Hammer.gestures, function(gesture) {
        Detection.register(gesture);
    });

    // Add touch events on the document
    Event.onTouch(Hammer.DOCUMENT, EVENT_MOVE, Detection.detect);
    Event.onTouch(Hammer.DOCUMENT, EVENT_END, Detection.detect);

    // Hammer is ready...!
    Hammer.READY = true;
}

/**
 * @module hammer
 *
 * @class Utils
 * @static
 */
var Utils = Hammer.utils = {
    /**
     * extend method, could also be used for cloning when `dest` is an empty object.
     * changes the dest object
     * @method extend
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge=false]  do a merge
     * @return {Object} dest
     */
    extend: function extend(dest, src, merge) {
        for(var key in src) {
            if(!src.hasOwnProperty(key) || (dest[key] !== undefined && merge)) {
                continue;
            }
            dest[key] = src[key];
        }
        return dest;
    },

    /**
     * simple addEventListener wrapper
     * @method on
     * @param {HTMLElement} element
     * @param {String} type
     * @param {Function} handler
     */
    on: function on(element, type, handler) {
        element.addEventListener(type, handler, false);
    },

    /**
     * simple removeEventListener wrapper
     * @method off
     * @param {HTMLElement} element
     * @param {String} type
     * @param {Function} handler
     */
    off: function off(element, type, handler) {
        element.removeEventListener(type, handler, false);
    },

    /**
     * forEach over arrays and objects
     * @method each
     * @param {Object|Array} obj
     * @param {Function} iterator
     * @param {any} iterator.item
     * @param {Number} iterator.index
     * @param {Object|Array} iterator.obj the source object
     * @param {Object} context value to use as `this` in the iterator
     */
    each: function each(obj, iterator, context) {
        var i, len;

        // native forEach on arrays
        if('forEach' in obj) {
            obj.forEach(iterator, context);
        // arrays
        } else if(obj.length !== undefined) {
            for(i = 0, len = obj.length; i < len; i++) {
                if(iterator.call(context, obj[i], i, obj) === false) {
                    return;
                }
            }
        // objects
        } else {
            for(i in obj) {
                if(obj.hasOwnProperty(i) &&
                    iterator.call(context, obj[i], i, obj) === false) {
                    return;
                }
            }
        }
    },

    /**
     * find if a string contains the string using indexOf
     * @method inStr
     * @param {String} src
     * @param {String} find
     * @return {Boolean} found
     */
    inStr: function inStr(src, find) {
        return src.indexOf(find) > -1;
    },

    /**
     * find if a array contains the object using indexOf or a simple polyfill
     * @method inArray
     * @param {String} src
     * @param {String} find
     * @return {Boolean|Number} false when not found, or the index
     */
    inArray: function inArray(src, find) {
        if(src.indexOf) {
            var index = src.indexOf(find);
            return (index === -1) ? false : index;
        } else {
            for(var i = 0, len = src.length; i < len; i++) {
                if(src[i] === find) {
                    return i;
                }
            }
            return false;
        }
    },

    /**
     * convert an array-like object (`arguments`, `touchlist`) to an array
     * @method toArray
     * @param {Object} obj
     * @return {Array}
     */
    toArray: function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    },

    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    hasParent: function hasParent(node, parent) {
        while(node) {
            if(node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    },

    /**
     * get the center of all the touches
     * @method getCenter
     * @param {Array} touches
     * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
     */
    getCenter: function getCenter(touches) {
        var pageX = [],
            pageY = [],
            clientX = [],
            clientY = [],
            min = Math.min,
            max = Math.max;

        // no need to loop when only one touch
        if(touches.length === 1) {
            return {
                pageX: touches[0].pageX,
                pageY: touches[0].pageY,
                clientX: touches[0].clientX,
                clientY: touches[0].clientY
            };
        }

        Utils.each(touches, function(touch) {
            pageX.push(touch.pageX);
            pageY.push(touch.pageY);
            clientX.push(touch.clientX);
            clientY.push(touch.clientY);
        });

        return {
            pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
            pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
            clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
            clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
        };
    },

    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @method getVelocity
     * @param {Number} deltaTime
     * @param {Number} deltaX
     * @param {Number} deltaY
     * @return {Object} velocity `x` and `y`
     */
    getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
        return {
            x: Math.abs(deltaX / deltaTime) || 0,
            y: Math.abs(deltaY / deltaTime) || 0
        };
    },

    /**
     * calculate the angle between two coordinates
     * @method getAngle
     * @param {Touch} touch1
     * @param {Touch} touch2
     * @return {Number} angle
     */
    getAngle: function getAngle(touch1, touch2) {
        var x = touch2.clientX - touch1.clientX,
            y = touch2.clientY - touch1.clientY;

        return Math.atan2(y, x) * 180 / Math.PI;
    },

    /**
     * do a small comparision to get the direction between two touches.
     * @method getDirection
     * @param {Touch} touch1
     * @param {Touch} touch2
     * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
     */
    getDirection: function getDirection(touch1, touch2) {
        var x = Math.abs(touch1.clientX - touch2.clientX),
            y = Math.abs(touch1.clientY - touch2.clientY);

        if(x >= y) {
            return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
    },

    /**
     * calculate the distance between two touches
     * @method getDistance
     * @param {Touch}touch1
     * @param {Touch} touch2
     * @return {Number} distance
     */
    getDistance: function getDistance(touch1, touch2) {
        var x = touch2.clientX - touch1.clientX,
            y = touch2.clientY - touch1.clientY;

        return Math.sqrt((x * x) + (y * y));
    },

    /**
     * calculate the scale factor between two touchLists
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @method getScale
     * @param {Array} start array of touches
     * @param {Array} end array of touches
     * @return {Number} scale
     */
    getScale: function getScale(start, end) {
        // need two fingers...
        if(start.length >= 2 && end.length >= 2) {
            return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
        }
        return 1;
    },

    /**
     * calculate the rotation degrees between two touchLists
     * @method getRotation
     * @param {Array} start array of touches
     * @param {Array} end array of touches
     * @return {Number} rotation
     */
    getRotation: function getRotation(start, end) {
        // need two fingers
        if(start.length >= 2 && end.length >= 2) {
            return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
        }
        return 0;
    },

    /**
     * find out if the direction is vertical   *
     * @method isVertical
     * @param {String} direction matches `DIRECTION_UP|DOWN`
     * @return {Boolean} is_vertical
     */
    isVertical: function isVertical(direction) {
        return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
    },

    /**
     * set css properties with their prefixes
     * @param {HTMLElement} element
     * @param {String} prop
     * @param {String} value
     * @param {Boolean} [toggle=true]
     * @return {Boolean}
     */
    setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
        var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
        prop = Utils.toCamelCase(prop);

        for(var i = 0; i < prefixes.length; i++) {
            var p = prop;
            // prefixes
            if(prefixes[i]) {
                p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
            }

            // test the style
            if(p in element.style) {
                element.style[p] = (toggle == null || toggle) && value || '';
                break;
            }
        }
    },

    /**
     * toggle browser default behavior by setting css properties.
     * `userSelect='none'` also sets `element.onselectstart` to false
     * `userDrag='none'` also sets `element.ondragstart` to false
     *
     * @method toggleBehavior
     * @param {HtmlElement} element
     * @param {Object} props
     * @param {Boolean} [toggle=true]
     */
    toggleBehavior: function toggleBehavior(element, props, toggle) {
        if(!props || !element || !element.style) {
            return;
        }

        // set the css properties
        Utils.each(props, function(value, prop) {
            Utils.setPrefixedCss(element, prop, value, toggle);
        });

        var falseFn = toggle && function() {
            return false;
        };

        // also the disable onselectstart
        if(props.userSelect == 'none') {
            element.onselectstart = falseFn;
        }
        // and disable ondragstart
        if(props.userDrag == 'none') {
            element.ondragstart = falseFn;
        }
    },

    /**
     * convert a string with underscores to camelCase
     * so prevent_default becomes preventDefault
     * @param {String} str
     * @return {String} camelCaseStr
     */
    toCamelCase: function toCamelCase(str) {
        return str.replace(/[_-]([a-z])/g, function(s) {
            return s[1].toUpperCase();
        });
    }
};


/**
 * @module hammer
 */
/**
 * @class Event
 * @static
 */
var Event = Hammer.event = {
    /**
     * when touch events have been fired, this is true
     * this is used to stop mouse events
     * @property prevent_mouseevents
     * @private
     * @type {Boolean}
     */
    preventMouseEvents: false,

    /**
     * if EVENT_START has been fired
     * @property started
     * @private
     * @type {Boolean}
     */
    started: false,

    /**
     * when the mouse is hold down, this is true
     * @property should_detect
     * @private
     * @type {Boolean}
     */
    shouldDetect: false,

    /**
     * simple event binder with a hook and support for multiple types
     * @method on
     * @param {HTMLElement} element
     * @param {String} type
     * @param {Function} handler
     * @param {Function} [hook]
     * @param {Object} hook.type
     */
    on: function on(element, type, handler, hook) {
        var types = type.split(' ');
        Utils.each(types, function(type) {
            Utils.on(element, type, handler);
            hook && hook(type);
        });
    },

    /**
     * simple event unbinder with a hook and support for multiple types
     * @method off
     * @param {HTMLElement} element
     * @param {String} type
     * @param {Function} handler
     * @param {Function} [hook]
     * @param {Object} hook.type
     */
    off: function off(element, type, handler, hook) {
        var types = type.split(' ');
        Utils.each(types, function(type) {
            Utils.off(element, type, handler);
            hook && hook(type);
        });
    },

    /**
     * the core touch event handler.
     * this finds out if we should to detect gestures
     * @method onTouch
     * @param {HTMLElement} element
     * @param {String} eventType matches `EVENT_START|MOVE|END`
     * @param {Function} handler
     * @return onTouchHandler {Function} the core event handler
     */
    onTouch: function onTouch(element, eventType, handler) {
        var self = this;

        var onTouchHandler = function onTouchHandler(ev) {
            var srcType = ev.type.toLowerCase(),
                isPointer = Hammer.HAS_POINTEREVENTS,
                isMouse = Utils.inStr(srcType, 'mouse'),
                triggerType;

            // if we are in a mouseevent, but there has been a touchevent triggered in this session
            // we want to do nothing. simply break out of the event.
            if(isMouse && self.preventMouseEvents) {
                return;

            // mousebutton must be down
            } else if(isMouse && eventType == EVENT_START && ev.button === 0) {
                self.preventMouseEvents = false;
                self.shouldDetect = true;
            } else if(isPointer && eventType == EVENT_START) {
                self.shouldDetect = (ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev));
            // just a valid start event, but no mouse
            } else if(!isMouse && eventType == EVENT_START) {
                self.preventMouseEvents = true;
                self.shouldDetect = true;
            }

            // update the pointer event before entering the detection
            if(isPointer && eventType != EVENT_END) {
                PointerEvent.updatePointer(eventType, ev);
            }

            // we are in a touch/down state, so allowed detection of gestures
            if(self.shouldDetect) {
                triggerType = self.doDetect.call(self, ev, eventType, element, handler);
            }

            // ...and we are done with the detection
            // so reset everything to start each detection totally fresh
            if(triggerType == EVENT_END) {
                self.preventMouseEvents = false;
                self.shouldDetect = false;
                PointerEvent.reset();
            // update the pointerevent object after the detection
            }

            if(isPointer && eventType == EVENT_END) {
                PointerEvent.updatePointer(eventType, ev);
            }
        };

        this.on(element, EVENT_TYPES[eventType], onTouchHandler);
        return onTouchHandler;
    },

    /**
     * the core detection method
     * this finds out what hammer-touch-events to trigger
     * @method doDetect
     * @param {Object} ev
     * @param {String} eventType matches `EVENT_START|MOVE|END`
     * @param {HTMLElement} element
     * @param {Function} handler
     * @return {String} triggerType matches `EVENT_START|MOVE|END`
     */
    doDetect: function doDetect(ev, eventType, element, handler) {
        var touchList = this.getTouchList(ev, eventType);
        var touchListLength = touchList.length;
        var triggerType = eventType;
        var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
        var changedLength = touchListLength;

        // at each touchstart-like event we want also want to trigger a TOUCH event...
        if(eventType == EVENT_START) {
            triggerChange = EVENT_TOUCH;
        // ...the same for a touchend-like event
        } else if(eventType == EVENT_END) {
            triggerChange = EVENT_RELEASE;

            // keep track of how many touches have been removed
            changedLength = touchList.length - ((ev.changedTouches) ? ev.changedTouches.length : 1);
        }

        // after there are still touches on the screen,
        // we just want to trigger a MOVE event. so change the START or END to a MOVE
        // but only after detection has been started, the first time we actualy want a START
        if(changedLength > 0 && this.started) {
            triggerType = EVENT_MOVE;
        }

        // detection has been started, we keep track of this, see above
        this.started = true;

        // generate some event data, some basic information
        var evData = this.collectEventData(element, triggerType, touchList, ev);

        // trigger the triggerType event before the change (TOUCH, RELEASE) events
        // but the END event should be at last
        if(eventType != EVENT_END) {
            handler.call(Detection, evData);
        }

        // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
        if(triggerChange) {
            evData.changedLength = changedLength;
            evData.eventType = triggerChange;

            handler.call(Detection, evData);

            evData.eventType = triggerType;
            delete evData.changedLength;
        }

        // trigger the END event
        if(triggerType == EVENT_END) {
            handler.call(Detection, evData);

            // ...and we are done with the detection
            // so reset everything to start each detection totally fresh
            this.started = false;
        }

        return triggerType;
    },

    /**
     * we have different events for each device/browser
     * determine what we need and set them in the EVENT_TYPES constant
     * the `onTouch` method is bind to these properties.
     * @method determineEventTypes
     * @return {Object} events
     */
    determineEventTypes: function determineEventTypes() {
        var types;
        if(Hammer.HAS_POINTEREVENTS) {
            if(window.PointerEvent) {
                types = [
                    'pointerdown',
                    'pointermove',
                    'pointerup pointercancel lostpointercapture'
                ];
            } else {
                types = [
                    'MSPointerDown',
                    'MSPointerMove',
                    'MSPointerUp MSPointerCancel MSLostPointerCapture'
                ];
            }
        } else if(Hammer.NO_MOUSEEVENTS) {
            types = [
                'touchstart',
                'touchmove',
                'touchend touchcancel'
            ];
        } else {
            types = [
                'touchstart mousedown',
                'touchmove mousemove',
                'touchend touchcancel mouseup'
            ];
        }

        EVENT_TYPES[EVENT_START] = types[0];
        EVENT_TYPES[EVENT_MOVE] = types[1];
        EVENT_TYPES[EVENT_END] = types[2];
        return EVENT_TYPES;
    },

    /**
     * create touchList depending on the event
     * @method getTouchList
     * @param {Object} ev
     * @param {String} eventType
     * @return {Array} touches
     */
    getTouchList: function getTouchList(ev, eventType) {
        // get the fake pointerEvent touchlist
        if(Hammer.HAS_POINTEREVENTS) {
            return PointerEvent.getTouchList();
        }

        // get the touchlist
        if(ev.touches) {
            if(eventType == EVENT_MOVE) {
                return ev.touches;
            }

            var identifiers = [];
            var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
            var touchList = [];

            Utils.each(concat, function(touch) {
                if(Utils.inArray(identifiers, touch.identifier) === false) {
                    touchList.push(touch);
                }
                identifiers.push(touch.identifier);
            });

            return touchList;
        }

        // make fake touchList from mouse position
        ev.identifier = 1;
        return [ev];
    },

    /**
     * collect basic event data
     * @method collectEventData
     * @param {HTMLElement} element
     * @param {String} eventType matches `EVENT_START|MOVE|END`
     * @param {Array} touches
     * @param {Object} ev
     * @return {Object} ev
     */
    collectEventData: function collectEventData(element, eventType, touches, ev) {
        // find out pointerType
        var pointerType = POINTER_TOUCH;
        if(Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
            pointerType = POINTER_MOUSE;
        } else if(PointerEvent.matchType(POINTER_PEN, ev)) {
            pointerType = POINTER_PEN;
        }

        return {
            center: Utils.getCenter(touches),
            timeStamp: Date.now(),
            target: ev.target,
            touches: touches,
            eventType: eventType,
            pointerType: pointerType,
            srcEvent: ev,

            /**
             * prevent the browser default actions
             * mostly used to disable scrolling of the browser
             */
            preventDefault: function() {
                var srcEvent = this.srcEvent;
                srcEvent.preventManipulation && srcEvent.preventManipulation();
                srcEvent.preventDefault && srcEvent.preventDefault();
            },

            /**
             * stop bubbling the event up to its parents
             */
            stopPropagation: function() {
                this.srcEvent.stopPropagation();
            },

            /**
             * immediately stop gesture detection
             * might be useful after a swipe was detected
             * @return {*}
             */
            stopDetect: function() {
                return Detection.stopDetect();
            }
        };
    }
};


/**
 * @module hammer
 *
 * @class PointerEvent
 * @static
 */
var PointerEvent = Hammer.PointerEvent = {
    /**
     * holds all pointers, by `identifier`
     * @property pointers
     * @type {Object}
     */
    pointers: {},

    /**
     * get the pointers as an array
     * @method getTouchList
     * @return {Array} touchlist
     */
    getTouchList: function getTouchList() {
        var touchlist = [];
        // we can use forEach since pointerEvents only is in IE10
        Utils.each(this.pointers, function(pointer) {
            touchlist.push(pointer);
        });
        return touchlist;
    },

    /**
     * update the position of a pointer
     * @method updatePointer
     * @param {String} eventType matches `EVENT_START|MOVE|END`
     * @param {Object} pointerEvent
     */
    updatePointer: function updatePointer(eventType, pointerEvent) {
        if(eventType == EVENT_END || (eventType != EVENT_END && pointerEvent.buttons !== 1)) {
            delete this.pointers[pointerEvent.pointerId];
        } else {
            pointerEvent.identifier = pointerEvent.pointerId;
            this.pointers[pointerEvent.pointerId] = pointerEvent;
        }
    },

    /**
     * check if ev matches pointertype
     * @method matchType
     * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
     * @param {PointerEvent} ev
     */
    matchType: function matchType(pointerType, ev) {
        if(!ev.pointerType) {
            return false;
        }

        var pt = ev.pointerType,
            types = {};

        types[POINTER_MOUSE] = (pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE));
        types[POINTER_TOUCH] = (pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH));
        types[POINTER_PEN] = (pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN));
        return types[pointerType];
    },

    /**
     * reset the stored pointers
     * @method reset
     */
    reset: function resetList() {
        this.pointers = {};
    }
};


/**
 * @module hammer
 *
 * @class Detection
 * @static
 */
var Detection = Hammer.detection = {
    // contains all registred Hammer.gestures in the correct order
    gestures: [],

    // data of the current Hammer.gesture detection session
    current: null,

    // the previous Hammer.gesture session data
    // is a full clone of the previous gesture.current object
    previous: null,

    // when this becomes true, no gestures are fired
    stopped: false,

    /**
     * start Hammer.gesture detection
     * @method startDetect
     * @param {Hammer.Instance} inst
     * @param {Object} eventData
     */
    startDetect: function startDetect(inst, eventData) {
        // already busy with a Hammer.gesture detection on an element
        if(this.current) {
            return;
        }

        this.stopped = false;

        // holds current session
        this.current = {
            inst: inst, // reference to HammerInstance we're working for
            startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
            lastEvent: false, // last eventData
            lastCalcEvent: false, // last eventData for calculations.
            futureCalcEvent: false, // last eventData for calculations.
            lastCalcData: {}, // last lastCalcData
            name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
        };

        this.detect(eventData);
    },

    /**
     * Hammer.gesture detection
     * @method detect
     * @param {Object} eventData
     * @return {any}
     */
    detect: function detect(eventData) {
        if(!this.current || this.stopped) {
            return;
        }

        // extend event data with calculations about scale, distance etc
        eventData = this.extendEventData(eventData);

        // hammer instance and instance options
        var inst = this.current.inst,
            instOptions = inst.options;

        // call Hammer.gesture handlers
        Utils.each(this.gestures, function triggerGesture(gesture) {
            // only when the instance options have enabled this gesture
            if(!this.stopped && inst.enabled && instOptions[gesture.name]) {
                gesture.handler.call(gesture, eventData, inst);
            }
        }, this);

        // store as previous event event
        if(this.current) {
            this.current.lastEvent = eventData;
        }

        if(eventData.eventType == EVENT_END) {
            this.stopDetect();
        }

        return eventData;
    },

    /**
     * clear the Hammer.gesture vars
     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
     * to stop other Hammer.gestures from being fired
     * @method stopDetect
     */
    stopDetect: function stopDetect() {
        // clone current data to the store as the previous gesture
        // used for the double tap gesture, since this is an other gesture detect session
        this.previous = Utils.extend({}, this.current);

        // reset the current
        this.current = null;
        this.stopped = true;
    },

    /**
     * calculate velocity, angle and direction
     * @method getVelocityData
     * @param {Object} ev
     * @param {Object} center
     * @param {Number} deltaTime
     * @param {Number} deltaX
     * @param {Number} deltaY
     */
    getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
        var cur = this.current,
            recalc = false,
            calcEv = cur.lastCalcEvent,
            calcData = cur.lastCalcData;

        if(calcEv && ev.timeStamp - calcEv.timeStamp > Hammer.CALCULATE_INTERVAL) {
            center = calcEv.center;
            deltaTime = ev.timeStamp - calcEv.timeStamp;
            deltaX = ev.center.clientX - calcEv.center.clientX;
            deltaY = ev.center.clientY - calcEv.center.clientY;
            recalc = true;
        }

        if(ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
            cur.futureCalcEvent = ev;
        }

        if(!cur.lastCalcEvent || recalc) {
            calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
            calcData.angle = Utils.getAngle(center, ev.center);
            calcData.direction = Utils.getDirection(center, ev.center);

            cur.lastCalcEvent = cur.futureCalcEvent || ev;
            cur.futureCalcEvent = ev;
        }

        ev.velocityX = calcData.velocity.x;
        ev.velocityY = calcData.velocity.y;
        ev.interimAngle = calcData.angle;
        ev.interimDirection = calcData.direction;
    },

    /**
     * extend eventData for Hammer.gestures
     * @method extendEventData
     * @param {Object} ev
     * @return {Object} ev
     */
    extendEventData: function extendEventData(ev) {
        var cur = this.current,
            startEv = cur.startEvent,
            lastEv = cur.lastEvent || startEv;

        // update the start touchlist to calculate the scale/rotation
        if(ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
            startEv.touches = [];
            Utils.each(ev.touches, function(touch) {
                startEv.touches.push({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
            });
        }

        var deltaTime = ev.timeStamp - startEv.timeStamp,
            deltaX = ev.center.clientX - startEv.center.clientX,
            deltaY = ev.center.clientY - startEv.center.clientY;

        this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

        Utils.extend(ev, {
            startEvent: startEv,

            deltaTime: deltaTime,
            deltaX: deltaX,
            deltaY: deltaY,

            distance: Utils.getDistance(startEv.center, ev.center),
            angle: Utils.getAngle(startEv.center, ev.center),
            direction: Utils.getDirection(startEv.center, ev.center),
            scale: Utils.getScale(startEv.touches, ev.touches),
            rotation: Utils.getRotation(startEv.touches, ev.touches)
        });

        return ev;
    },

    /**
     * register new gesture
     * @method register
     * @param {Object} gesture object, see `gestures/` for documentation
     * @return {Array} gestures
     */
    register: function register(gesture) {
        // add an enable gesture options if there is no given
        var options = gesture.defaults || {};
        if(options[gesture.name] === undefined) {
            options[gesture.name] = true;
        }

        // extend Hammer default options with the Hammer.gesture options
        Utils.extend(Hammer.defaults, options, true);

        // set its index
        gesture.index = gesture.index || 1000;

        // add Hammer.gesture to the list
        this.gestures.push(gesture);

        // sort the list by index
        this.gestures.sort(function(a, b) {
            if(a.index < b.index) {
                return -1;
            }
            if(a.index > b.index) {
                return 1;
            }
            return 0;
        });

        return this.gestures;
    }
};


/**
 * @module hammer
 */

/**
 * create new hammer instance
 * all methods should return the instance itself, so it is chainable.
 *
 * @class Instance
 * @constructor
 * @param {HTMLElement} element
 * @param {Object} [options={}] options are merged with `Hammer.defaults`
 * @return {Hammer.Instance}
 */
Hammer.Instance = function(element, options) {
    var self = this;

    // setup HammerJS window events and register all gestures
    // this also sets up the default options
    setup();

    /**
     * @property element
     * @type {HTMLElement}
     */
    this.element = element;

    /**
     * @property enabled
     * @type {Boolean}
     * @protected
     */
    this.enabled = true;

    /**
     * options, merged with the defaults
     * options with an _ are converted to camelCase
     * @property options
     * @type {Object}
     */
    Utils.each(options, function(value, name) {
        delete options[name];
        options[Utils.toCamelCase(name)] = value;
    });

    this.options = Utils.extend(Utils.extend({}, Hammer.defaults), options || {});

    // add some css to the element to prevent the browser from doing its native behavoir
    if(this.options.behavior) {
        Utils.toggleBehavior(this.element, this.options.behavior, true);
    }

    /**
     * event start handler on the element to start the detection
     * @property eventStartHandler
     * @type {Object}
     */
    this.eventStartHandler = Event.onTouch(element, EVENT_START, function(ev) {
        if(self.enabled && ev.eventType == EVENT_START) {
            Detection.startDetect(self, ev);
        } else if(ev.eventType == EVENT_TOUCH) {
            Detection.detect(ev);
        }
    });

    /**
     * keep a list of user event handlers which needs to be removed when calling 'dispose'
     * @property eventHandlers
     * @type {Array}
     */
    this.eventHandlers = [];
};

Hammer.Instance.prototype = {
    /**
     * bind events to the instance
     * @method on
     * @chainable
     * @param {String} gestures multiple gestures by splitting with a space
     * @param {Function} handler
     * @param {Object} handler.ev event object
     */
    on: function onEvent(gestures, handler) {
        var self = this;
        Event.on(self.element, gestures, handler, function(type) {
            self.eventHandlers.push({ gesture: type, handler: handler });
        });
        return self;
    },

    /**
     * unbind events to the instance
     * @method off
     * @chainable
     * @param {String} gestures
     * @param {Function} handler
     */
    off: function offEvent(gestures, handler) {
        var self = this;

        Event.off(self.element, gestures, handler, function(type) {
            var index = Utils.inArray({ gesture: type, handler: handler });
            if(index !== false) {
                self.eventHandlers.splice(index, 1);
            }
        });
        return self;
    },

    /**
     * trigger gesture event
     * @method trigger
     * @chainable
     * @param {String} gesture
     * @param {Object} [eventData]
     */
    trigger: function triggerEvent(gesture, eventData) {
        // optional
        if(!eventData) {
            eventData = {};
        }

        // create DOM event
        var event = Hammer.DOCUMENT.createEvent('Event');
        event.initEvent(gesture, true, true);
        event.gesture = eventData;

        // trigger on the target if it is in the instance element,
        // this is for event delegation tricks
        var element = this.element;
        if(Utils.hasParent(eventData.target, element)) {
            element = eventData.target;
        }

        element.dispatchEvent(event);
        return this;
    },

    /**
     * enable of disable hammer.js detection
     * @method enable
     * @chainable
     * @param {Boolean} state
     */
    enable: function enable(state) {
        this.enabled = state;
        return this;
    },

    /**
     * dispose this hammer instance
     * @method dispose
     * @return {Null}
     */
    dispose: function dispose() {
        var i, eh;

        // undo all changes made by stop_browser_behavior
        Utils.toggleBehavior(this.element, this.options.behavior, false);

        // unbind all custom event handlers
        for(i = -1; (eh = this.eventHandlers[++i]);) {
            Utils.off(this.element, eh.gesture, eh.handler);
        }

        this.eventHandlers = [];

        // unbind the start event listener
        Event.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

        return null;
    }
};


/**
 * @module gestures
 */
/**
 * Move with x fingers (default 1) around on the page.
 * Preventing the default browser behavior is a good way to improve feel and working.
 * ````
 *  hammertime.on("drag", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Drag
 * @static
 */
/**
 * @event drag
 * @param {Object} ev
 */
/**
 * @event dragstart
 * @param {Object} ev
 */
/**
 * @event dragend
 * @param {Object} ev
 */
/**
 * @event drapleft
 * @param {Object} ev
 */
/**
 * @event dragright
 * @param {Object} ev
 */
/**
 * @event dragup
 * @param {Object} ev
 */
/**
 * @event dragdown
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function(name) {
    var triggered = false;

    function dragGesture(ev, inst) {
        var cur = Detection.current;

        // max touches
        if(inst.options.dragMaxTouches > 0 &&
            ev.touches.length > inst.options.dragMaxTouches) {
            return;
        }

        switch(ev.eventType) {
            case EVENT_START:
                triggered = false;
                break;

            case EVENT_MOVE:
                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(ev.distance < inst.options.dragMinDistance &&
                    cur.name != name) {
                    return;
                }

                var startCenter = cur.startEvent.center;

                // we are dragging!
                if(cur.name != name) {
                    cur.name = name;
                    if(inst.options.dragDistanceCorrection && ev.distance > 0) {
                        // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
                        // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
                        // It might be useful to save the original start point somewhere
                        var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
                        startCenter.pageX += ev.deltaX * factor;
                        startCenter.pageY += ev.deltaY * factor;
                        startCenter.clientX += ev.deltaX * factor;
                        startCenter.clientY += ev.deltaY * factor;

                        // recalculate event data using new start point
                        ev = Detection.extendEventData(ev);
                    }
                }

                // lock drag to axis?
                if(cur.lastEvent.dragLockToAxis ||
                    ( inst.options.dragLockToAxis &&
                        inst.options.dragLockMinDistance <= ev.distance
                        )) {
                    ev.dragLockToAxis = true;
                }

                // keep direction on the axis that the drag gesture started on
                var lastDirection = cur.lastEvent.direction;
                if(ev.dragLockToAxis && lastDirection !== ev.direction) {
                    if(Utils.isVertical(lastDirection)) {
                        ev.direction = (ev.deltaY < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                    } else {
                        ev.direction = (ev.deltaX < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    }
                }

                // first time, trigger dragstart event
                if(!triggered) {
                    inst.trigger(name + 'start', ev);
                    triggered = true;
                }

                // trigger events
                inst.trigger(name, ev);
                inst.trigger(name + ev.direction, ev);

                var isVertical = Utils.isVertical(ev.direction);

                // block the browser events
                if((inst.options.dragBlockVertical && isVertical) ||
                    (inst.options.dragBlockHorizontal && !isVertical)) {
                    ev.preventDefault();
                }
                break;

            case EVENT_RELEASE:
                if(triggered && ev.changedLength <= inst.options.dragMaxTouches) {
                    inst.trigger(name + 'end', ev);
                    triggered = false;
                }
                break;

            case EVENT_END:
                triggered = false;
                break;
        }
    }

    Hammer.gestures.Drag = {
        name: name,
        index: 50,
        handler: dragGesture,
        defaults: {
            /**
             * minimal movement that have to be made before the drag event gets triggered
             * @property dragMinDistance
             * @type {Number}
             * @default 10
             */
            dragMinDistance: 10,

            /**
             * Set dragDistanceCorrection to true to make the starting point of the drag
             * be calculated from where the drag was triggered, not from where the touch started.
             * Useful to avoid a jerk-starting drag, which can make fine-adjustments
             * through dragging difficult, and be visually unappealing.
             * @property dragDistanceCorrection
             * @type {Boolean}
             * @default true
             */
            dragDistanceCorrection: true,

            /**
             * set 0 for unlimited, but this can conflict with transform
             * @property dragMaxTouches
             * @type {Number}
             * @default 1
             */
            dragMaxTouches: 1,

            /**
             * prevent default browser behavior when dragging occurs
             * be careful with it, it makes the element a blocking element
             * when you are using the drag gesture, it is a good practice to set this true
             * @property dragBlockHorizontal
             * @type {Boolean}
             * @default false
             */
            dragBlockHorizontal: false,

            /**
             * same as `dragBlockHorizontal`, but for vertical movement
             * @property dragBlockVertical
             * @type {Boolean}
             * @default false
             */
            dragBlockVertical: false,

            /**
             * dragLockToAxis keeps the drag gesture on the axis that it started on,
             * It disallows vertical directions if the initial direction was horizontal, and vice versa.
             * @property dragLockToAxis
             * @type {Boolean}
             * @default false
             */
            dragLockToAxis: false,

            /**
             * drag lock only kicks in when distance > dragLockMinDistance
             * This way, locking occurs only when the distance has become large enough to reliably determine the direction
             * @property dragLockMinDistance
             * @type {Number}
             * @default 25
             */
            dragLockMinDistance: 25
        }
    };
})('drag');

/**
 * @module gestures
 */
/**
 * trigger a simple gesture event, so you can do anything in your handler.
 * only usable if you know what your doing...
 *
 * @class Gesture
 * @static
 */
/**
 * @event gesture
 * @param {Object} ev
 */
Hammer.gestures.Gesture = {
    name: 'gesture',
    index: 1337,
    handler: function releaseGesture(ev, inst) {
        inst.trigger(this.name, ev);
    }
};

/**
 * @module gestures
 */
/**
 * Touch stays at the same place for x time
 *
 * @class Hold
 * @static
 */
/**
 * @event hold
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function(name) {
    var timer;

    function holdGesture(ev, inst) {
        var options = inst.options,
            current = Detection.current;

        switch(ev.eventType) {
            case EVENT_START:
                clearTimeout(timer);

                // set the gesture so we can check in the timeout if it still is
                current.name = name;

                // set timer and if after the timeout it still is hold,
                // we trigger the hold event
                timer = setTimeout(function() {
                    if(current && current.name == name) {
                        inst.trigger(name, ev);
                    }
                }, options.holdTimeout);
                break;

            case EVENT_MOVE:
                if(ev.distance > options.holdThreshold) {
                    clearTimeout(timer);
                }
                break;

            case EVENT_RELEASE:
                clearTimeout(timer);
                break;
        }
    }

    Hammer.gestures.Hold = {
        name: name,
        index: 10,
        defaults: {
            /**
             * @property holdTimeout
             * @type {Number}
             * @default 500
             */
            holdTimeout: 500,

            /**
             * movement allowed while holding
             * @property holdThreshold
             * @type {Number}
             * @default 2
             */
            holdThreshold: 2
        },
        handler: holdGesture
    };
})('hold');

/**
 * @module gestures
 */
/**
 * when a touch is being released from the page
 *
 * @class Release
 * @static
 */
/**
 * @event release
 * @param {Object} ev
 */
Hammer.gestures.Release = {
    name: 'release',
    index: Infinity,
    handler: function releaseGesture(ev, inst) {
        if(ev.eventType == EVENT_RELEASE) {
            inst.trigger(this.name, ev);
        }
    }
};

/**
 * @module gestures
 */
/**
 * triggers swipe events when the end velocity is above the threshold
 * for best usage, set `preventDefault` (on the drag gesture) to `true`
 * ````
 *  hammertime.on("dragleft swipeleft", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Swipe
 * @static
 */
/**
 * @event swipe
 * @param {Object} ev
 */
/**
 * @event swipeleft
 * @param {Object} ev
 */
/**
 * @event swiperight
 * @param {Object} ev
 */
/**
 * @event swipeup
 * @param {Object} ev
 */
/**
 * @event swipedown
 * @param {Object} ev
 */
Hammer.gestures.Swipe = {
    name: 'swipe',
    index: 40,
    defaults: {
        /**
         * @property swipeMinTouches
         * @type {Number}
         * @default 1
         */
        swipeMinTouches: 1,

        /**
         * @property swipeMaxTouches
         * @type {Number}
         * @default 1
         */
        swipeMaxTouches: 1,

        /**
         * horizontal swipe velocity
         * @property swipeVelocityX
         * @type {Number}
         * @default 0.6
         */
        swipeVelocityX: 0.6,

        /**
         * vertical swipe velocity
         * @property swipeVelocityY
         * @type {Number}
         * @default 0.6
         */
        swipeVelocityY: 0.6
    },

    handler: function swipeGesture(ev, inst) {
        if(ev.eventType == EVENT_RELEASE) {
            var touches = ev.touches.length,
                options = inst.options;

            // max touches
            if(touches < options.swipeMinTouches ||
                touches > options.swipeMaxTouches) {
                return;
            }

            // when the distance we moved is too small we skip this gesture
            // or we can be already in dragging
            if(ev.velocityX > options.swipeVelocityX ||
                ev.velocityY > options.swipeVelocityY) {
                // trigger swipe events
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
            }
        }
    }
};

/**
 * @module gestures
 */
/**
 * Single tap and a double tap on a place
 *
 * @class Tap
 * @static
 */
/**
 * @event tap
 * @param {Object} ev
 */
/**
 * @event doubletap
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function(name) {
    var hasMoved = false;

    function tapGesture(ev, inst) {
        var options = inst.options,
            current = Detection.current,
            prev = Detection.previous,
            sincePrev,
            didDoubleTap;

        switch(ev.eventType) {
            case EVENT_START:
                hasMoved = false;
                break;

            case EVENT_MOVE:
                hasMoved = hasMoved || (ev.distance > options.tapMaxDistance);
                break;

            case EVENT_END:
                if(!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
                    // previous gesture, for the double tap since these are two different gesture detections
                    sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
                    didDoubleTap = false;

                    // check if double tap
                    if(prev && prev.name == name &&
                        (sincePrev && sincePrev < options.doubleTapInterval) &&
                        ev.distance < options.doubleTapDistance) {
                        inst.trigger('doubletap', ev);
                        didDoubleTap = true;
                    }

                    // do a single tap
                    if(!didDoubleTap || options.tapAlways) {
                        current.name = name;
                        inst.trigger(current.name, ev);
                    }
                }
                break;
        }
    }

    Hammer.gestures.Tap = {
        name: name,
        index: 100,
        handler: tapGesture,
        defaults: {
            /**
             * max time of a tap, this is for the slow tappers
             * @property tapMaxTime
             * @type {Number}
             * @default 250
             */
            tapMaxTime: 250,

            /**
             * max distance of movement of a tap, this is for the slow tappers
             * @property tapMaxDistance
             * @type {Number}
             * @default 10
             */
            tapMaxDistance: 10,

            /**
             * always trigger the `tap` event, even while double-tapping
             * @property tapAlways
             * @type {Boolean}
             * @default true
             */
            tapAlways: true,

            /**
             * max distance between two taps
             * @property doubleTapDistance
             * @type {Number}
             * @default 20
             */
            doubleTapDistance: 20,

            /**
             * max time between two taps
             * @property doubleTapInterval
             * @type {Number}
             * @default 300
             */
            doubleTapInterval: 300
        }
    };
})('tap');

/**
 * @module gestures
 */
/**
 * when a touch is being touched at the page
 *
 * @class Touch
 * @static
 */
/**
 * @event touch
 * @param {Object} ev
 */
Hammer.gestures.Touch = {
    name: 'touch',
    index: -Infinity,
    defaults: {
        /**
         * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
         * but it improves gestures like transforming and dragging.
         * be careful with using this, it can be very annoying for users to be stuck on the page
         * @property preventDefault
         * @type {Boolean}
         * @default false
         */
        preventDefault: false,

        /**
         * disable mouse events, so only touch (or pen!) input triggers events
         * @property preventMouse
         * @type {Boolean}
         * @default false
         */
        preventMouse: false
    },
    handler: function touchGesture(ev, inst) {
        if(inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
            ev.stopDetect();
            return;
        }

        if(inst.options.preventDefault) {
            ev.preventDefault();
        }

        if(ev.eventType == EVENT_TOUCH) {
            inst.trigger('touch', ev);
        }
    }
};

/**
 * @module gestures
 */
/**
 * User want to scale or rotate with 2 fingers
 * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
 * `preventDefault` option.
 *
 * @class Transform
 * @static
 */
/**
 * @event transform
 * @param {Object} ev
 */
/**
 * @event transformstart
 * @param {Object} ev
 */
/**
 * @event transformend
 * @param {Object} ev
 */
/**
 * @event pinchin
 * @param {Object} ev
 */
/**
 * @event pinchout
 * @param {Object} ev
 */
/**
 * @event rotate
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function(name) {
    var triggered = false;

    function transformGesture(ev, inst) {
        switch(ev.eventType) {
            case EVENT_START:
                triggered = false;
                break;

            case EVENT_MOVE:
                // at least multitouch
                if(ev.touches.length < 2) {
                    return;
                }

                var scaleThreshold = Math.abs(1 - ev.scale);
                var rotationThreshold = Math.abs(ev.rotation);

                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(scaleThreshold < inst.options.transformMinScale &&
                    rotationThreshold < inst.options.transformMinRotation) {
                    return;
                }

                // we are transforming!
                Detection.current.name = name;

                // first time, trigger dragstart event
                if(!triggered) {
                    inst.trigger(name + 'start', ev);
                    triggered = true;
                }

                inst.trigger(name, ev); // basic transform event

                // trigger rotate event
                if(rotationThreshold > inst.options.transformMinRotation) {
                    inst.trigger('rotate', ev);
                }

                // trigger pinch event
                if(scaleThreshold > inst.options.transformMinScale) {
                    inst.trigger('pinch', ev);
                    inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
                }
                break;

            case EVENT_RELEASE:
                if(triggered && ev.changedLength < 2) {
                    inst.trigger(name + 'end', ev);
                    triggered = false;
                }
                break;
        }
    }

    Hammer.gestures.Transform = {
        name: name,
        index: 45,
        defaults: {
            /**
             * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
             * @property transformMinScale
             * @type {Number}
             * @default 0.01
             */
            transformMinScale: 0.01,

            /**
             * rotation in degrees
             * @property transformMinRotation
             * @type {Number}
             * @default 1
             */
            transformMinRotation: 1
        },

        handler: transformGesture
    };
})('transform');

/**
 * @module hammer
 */

// AMD export
if(typeof define == 'function' && define.amd) {
    define(function() {
        return Hammer;
    });
// commonjs export
} else if(typeof module !== 'undefined' && module.exports) {
    module.exports = Hammer;
// browser export
} else {
    window.Hammer = Hammer;
}

})(window);
},{}],55:[function(require,module,exports){
//! moment.js
//! version : 2.16.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isNumber(input) {
    return typeof value === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

function isUndefined(input) {
    return input === void 0;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i in momentProperties) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _ordinalParseLenient.
    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return this._months;
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return this._monthsShort;
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    //can't just apply() to create a date:
    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
    var date = new Date(y, m, d, h, M, s, ms);

    //the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    //the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return this._weekdays;
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    ordinalParse: defaultOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
        hooks.createFromInputFallback(config);
    }
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse)) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }

    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (input === undefined) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (typeof(input) === 'object') {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString () {
    var m = this.clone().utc();
    if (0 < m.year() && m.year() <= 9999) {
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            return this.toDate().toISOString();
        } else {
            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    } else {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 < this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$1 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$1;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this[units + 's']();
}

function makeGetter(name) {
    return function () {
        return this._data[name];
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    s: 45,  // seconds to minute
    m: 45,  // minutes to hour
    h: 22,  // hours to day
    d: 26,  // days to month
    M: 11   // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds < thresholds.s && ['s', seconds]  ||
            minutes <= 1           && ['m']           ||
            minutes < thresholds.m && ['mm', minutes] ||
            hours   <= 1           && ['h']           ||
            hours   < thresholds.h && ['hh', hours]   ||
            days    <= 1           && ['d']           ||
            days    < thresholds.d && ['dd', days]    ||
            months  <= 1           && ['M']           ||
            months  < thresholds.M && ['MM', months]  ||
            years   <= 1           && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    return true;
}

function humanize (withSuffix) {
    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.16.0';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],56:[function(require,module,exports){
/**
 * Copyright 2012 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.1.2
 * @url craig.is/killing/mice
 */

  /**
   * mapping of special keycodes to their corresponding keys
   *
   * everything in this dictionary cannot use keypress events
   * so it has to be here to map to the correct keycodes for
   * keyup/keydown events
   *
   * @type {Object}
   */
  var _MAP = {
          8: 'backspace',
          9: 'tab',
          13: 'enter',
          16: 'shift',
          17: 'ctrl',
          18: 'alt',
          20: 'capslock',
          27: 'esc',
          32: 'space',
          33: 'pageup',
          34: 'pagedown',
          35: 'end',
          36: 'home',
          37: 'left',
          38: 'up',
          39: 'right',
          40: 'down',
          45: 'ins',
          46: 'del',
          91: 'meta',
          93: 'meta',
          224: 'meta'
      },

      /**
       * mapping for special characters so they can support
       *
       * this dictionary is only used incase you want to bind a
       * keyup or keydown event to one of these keys
       *
       * @type {Object}
       */
      _KEYCODE_MAP = {
          106: '*',
          107: '+',
          109: '-',
          110: '.',
          111 : '/',
          186: ';',
          187: '=',
          188: ',',
          189: '-',
          190: '.',
          191: '/',
          192: '`',
          219: '[',
          220: '\\',
          221: ']',
          222: '\''
      },

      /**
       * this is a mapping of keys that require shift on a US keypad
       * back to the non shift equivelents
       *
       * this is so you can use keyup events with these keys
       *
       * note that this will only work reliably on US keyboards
       *
       * @type {Object}
       */
      _SHIFT_MAP = {
          '~': '`',
          '!': '1',
          '@': '2',
          '#': '3',
          '$': '4',
          '%': '5',
          '^': '6',
          '&': '7',
          '*': '8',
          '(': '9',
          ')': '0',
          '_': '-',
          '+': '=',
          ':': ';',
          '\"': '\'',
          '<': ',',
          '>': '.',
          '?': '/',
          '|': '\\'
      },

      /**
       * this is a list of special strings you can use to map
       * to modifier keys when you specify your keyboard shortcuts
       *
       * @type {Object}
       */
      _SPECIAL_ALIASES = {
          'option': 'alt',
          'command': 'meta',
          'return': 'enter',
          'escape': 'esc'
      },

      /**
       * variable to store the flipped version of _MAP from above
       * needed to check if we should use keypress or not when no action
       * is specified
       *
       * @type {Object|undefined}
       */
      _REVERSE_MAP,

      /**
       * a list of all the callbacks setup via Mousetrap.bind()
       *
       * @type {Object}
       */
      _callbacks = {},

      /**
       * direct map of string combinations to callbacks used for trigger()
       *
       * @type {Object}
       */
      _direct_map = {},

      /**
       * keeps track of what level each sequence is at since multiple
       * sequences can start out with the same sequence
       *
       * @type {Object}
       */
      _sequence_levels = {},

      /**
       * variable to store the setTimeout call
       *
       * @type {null|number}
       */
      _reset_timer,

      /**
       * temporary state where we will ignore the next keyup
       *
       * @type {boolean|string}
       */
      _ignore_next_keyup = false,

      /**
       * are we currently inside of a sequence?
       * type of action ("keyup" or "keydown" or "keypress") or false
       *
       * @type {boolean|string}
       */
      _inside_sequence = false;

  /**
   * loop through the f keys, f1 to f19 and add them to the map
   * programatically
   */
  for (var i = 1; i < 20; ++i) {
      _MAP[111 + i] = 'f' + i;
  }

  /**
   * loop through to map numbers on the numeric keypad
   */
  for (i = 0; i <= 9; ++i) {
      _MAP[i + 96] = i;
  }

  /**
   * cross browser add event method
   *
   * @param {Element|HTMLDocument} object
   * @param {string} type
   * @param {Function} callback
   * @returns void
   */
  function _addEvent(object, type, callback) {
      if (object.addEventListener) {
          return object.addEventListener(type, callback, false);
      }

      object.attachEvent('on' + type, callback);
  }

  /**
   * takes the event and returns the key character
   *
   * @param {Event} e
   * @return {string}
   */
  function _characterFromEvent(e) {

      // for keypress events we should return the character as is
      if (e.type == 'keypress') {
          return String.fromCharCode(e.which);
      }

      // for non keypress events the special maps are needed
      if (_MAP[e.which]) {
          return _MAP[e.which];
      }

      if (_KEYCODE_MAP[e.which]) {
          return _KEYCODE_MAP[e.which];
      }

      // if it is not in the special map
      return String.fromCharCode(e.which).toLowerCase();
  }

  /**
   * should we stop this event before firing off callbacks
   *
   * @param {Event} e
   * @return {boolean}
   */
  function _stop(e) {
      var element = e.target || e.srcElement,
          tag_name = element.tagName;

      // if the element has the class "mousetrap" then no need to stop
      if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
          return false;
      }

      // stop for input, select, and textarea
      return tag_name == 'INPUT' || tag_name == 'SELECT' || tag_name == 'TEXTAREA' || (element.contentEditable && element.contentEditable == 'true');
  }

  /**
   * checks if two arrays are equal
   *
   * @param {Array} modifiers1
   * @param {Array} modifiers2
   * @returns {boolean}
   */
  function _modifiersMatch(modifiers1, modifiers2) {
      return modifiers1.sort().join(',') === modifiers2.sort().join(',');
  }

  /**
   * resets all sequence counters except for the ones passed in
   *
   * @param {Object} do_not_reset
   * @returns void
   */
  function _resetSequences(do_not_reset) {
      do_not_reset = do_not_reset || {};

      var active_sequences = false,
          key;

      for (key in _sequence_levels) {
          if (do_not_reset[key]) {
              active_sequences = true;
              continue;
          }
          _sequence_levels[key] = 0;
      }

      if (!active_sequences) {
          _inside_sequence = false;
      }
  }

  /**
   * finds all callbacks that match based on the keycode, modifiers,
   * and action
   *
   * @param {string} character
   * @param {Array} modifiers
   * @param {string} action
   * @param {boolean=} remove - should we remove any matches
   * @param {string=} combination
   * @returns {Array}
   */
  function _getMatches(character, modifiers, action, remove, combination) {
      var i,
          callback,
          matches = [];

      // if there are no events related to this keycode
      if (!_callbacks[character]) {
          return [];
      }

      // if a modifier key is coming up on its own we should allow it
      if (action == 'keyup' && _isModifier(character)) {
          modifiers = [character];
      }

      // loop through all callbacks for the key that was pressed
      // and see if any of them match
      for (i = 0; i < _callbacks[character].length; ++i) {
          callback = _callbacks[character][i];

          // if this is a sequence but it is not at the right level
          // then move onto the next match
          if (callback.seq && _sequence_levels[callback.seq] != callback.level) {
              continue;
          }

          // if the action we are looking for doesn't match the action we got
          // then we should keep going
          if (action != callback.action) {
              continue;
          }

          // if this is a keypress event that means that we need to only
          // look at the character, otherwise check the modifiers as
          // well
          if (action == 'keypress' || _modifiersMatch(modifiers, callback.modifiers)) {

              // remove is used so if you change your mind and call bind a
              // second time with a new function the first one is overwritten
              if (remove && callback.combo == combination) {
                  _callbacks[character].splice(i, 1);
              }

              matches.push(callback);
          }
      }

      return matches;
  }

  /**
   * takes a key event and figures out what the modifiers are
   *
   * @param {Event} e
   * @returns {Array}
   */
  function _eventModifiers(e) {
      var modifiers = [];

      if (e.shiftKey) {
          modifiers.push('shift');
      }

      if (e.altKey) {
          modifiers.push('alt');
      }

      if (e.ctrlKey) {
          modifiers.push('ctrl');
      }

      if (e.metaKey) {
          modifiers.push('meta');
      }

      return modifiers;
  }

  /**
   * actually calls the callback function
   *
   * if your callback function returns false this will use the jquery
   * convention - prevent default and stop propogation on the event
   *
   * @param {Function} callback
   * @param {Event} e
   * @returns void
   */
  function _fireCallback(callback, e) {
      if (callback(e) === false) {
          if (e.preventDefault) {
              e.preventDefault();
          }

          if (e.stopPropagation) {
              e.stopPropagation();
          }

          e.returnValue = false;
          e.cancelBubble = true;
      }
  }

  /**
   * handles a character key event
   *
   * @param {string} character
   * @param {Event} e
   * @returns void
   */
  function _handleCharacter(character, e) {

      // if this event should not happen stop here
      if (_stop(e)) {
          return;
      }

      var callbacks = _getMatches(character, _eventModifiers(e), e.type),
          i,
          do_not_reset = {},
          processed_sequence_callback = false;

      // loop through matching callbacks for this key event
      for (i = 0; i < callbacks.length; ++i) {

          // fire for all sequence callbacks
          // this is because if for example you have multiple sequences
          // bound such as "g i" and "g t" they both need to fire the
          // callback for matching g cause otherwise you can only ever
          // match the first one
          if (callbacks[i].seq) {
              processed_sequence_callback = true;

              // keep a list of which sequences were matches for later
              do_not_reset[callbacks[i].seq] = 1;
              _fireCallback(callbacks[i].callback, e);
              continue;
          }

          // if there were no sequence matches but we are still here
          // that means this is a regular match so we should fire that
          if (!processed_sequence_callback && !_inside_sequence) {
              _fireCallback(callbacks[i].callback, e);
          }
      }

      // if you are inside of a sequence and the key you are pressing
      // is not a modifier key then we should reset all sequences
      // that were not matched by this key event
      if (e.type == _inside_sequence && !_isModifier(character)) {
          _resetSequences(do_not_reset);
      }
  }

  /**
   * handles a keydown event
   *
   * @param {Event} e
   * @returns void
   */
  function _handleKey(e) {

      // normalize e.which for key events
      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
      e.which = typeof e.which == "number" ? e.which : e.keyCode;

      var character = _characterFromEvent(e);

      // no character found then stop
      if (!character) {
          return;
      }

      if (e.type == 'keyup' && _ignore_next_keyup == character) {
          _ignore_next_keyup = false;
          return;
      }

      _handleCharacter(character, e);
  }

  /**
   * determines if the keycode specified is a modifier key or not
   *
   * @param {string} key
   * @returns {boolean}
   */
  function _isModifier(key) {
      return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
  }

  /**
   * called to set a 1 second timeout on the specified sequence
   *
   * this is so after each key press in the sequence you have 1 second
   * to press the next key before you have to start over
   *
   * @returns void
   */
  function _resetSequenceTimer() {
      clearTimeout(_reset_timer);
      _reset_timer = setTimeout(_resetSequences, 1000);
  }

  /**
   * reverses the map lookup so that we can look for specific keys
   * to see what can and can't use keypress
   *
   * @return {Object}
   */
  function _getReverseMap() {
      if (!_REVERSE_MAP) {
          _REVERSE_MAP = {};
          for (var key in _MAP) {

              // pull out the numeric keypad from here cause keypress should
              // be able to detect the keys from the character
              if (key > 95 && key < 112) {
                  continue;
              }

              if (_MAP.hasOwnProperty(key)) {
                  _REVERSE_MAP[_MAP[key]] = key;
              }
          }
      }
      return _REVERSE_MAP;
  }

  /**
   * picks the best action based on the key combination
   *
   * @param {string} key - character for key
   * @param {Array} modifiers
   * @param {string=} action passed in
   */
  function _pickBestAction(key, modifiers, action) {

      // if no action was picked in we should try to pick the one
      // that we think would work best for this key
      if (!action) {
          action = _getReverseMap()[key] ? 'keydown' : 'keypress';
      }

      // modifier keys don't work as expected with keypress,
      // switch to keydown
      if (action == 'keypress' && modifiers.length) {
          action = 'keydown';
      }

      return action;
  }

  /**
   * binds a key sequence to an event
   *
   * @param {string} combo - combo specified in bind call
   * @param {Array} keys
   * @param {Function} callback
   * @param {string=} action
   * @returns void
   */
  function _bindSequence(combo, keys, callback, action) {

      // start off by adding a sequence level record for this combination
      // and setting the level to 0
      _sequence_levels[combo] = 0;

      // if there is no action pick the best one for the first key
      // in the sequence
      if (!action) {
          action = _pickBestAction(keys[0], []);
      }

      /**
       * callback to increase the sequence level for this sequence and reset
       * all other sequences that were active
       *
       * @param {Event} e
       * @returns void
       */
      var _increaseSequence = function(e) {
              _inside_sequence = action;
              ++_sequence_levels[combo];
              _resetSequenceTimer();
          },

          /**
           * wraps the specified callback inside of another function in order
           * to reset all sequence counters as soon as this sequence is done
           *
           * @param {Event} e
           * @returns void
           */
          _callbackAndReset = function(e) {
              _fireCallback(callback, e);

              // we should ignore the next key up if the action is key down
              // or keypress.  this is so if you finish a sequence and
              // release the key the final key will not trigger a keyup
              if (action !== 'keyup') {
                  _ignore_next_keyup = _characterFromEvent(e);
              }

              // weird race condition if a sequence ends with the key
              // another sequence begins with
              setTimeout(_resetSequences, 10);
          },
          i;

      // loop through keys one at a time and bind the appropriate callback
      // function.  for any key leading up to the final one it should
      // increase the sequence. after the final, it should reset all sequences
      for (i = 0; i < keys.length; ++i) {
          _bindSingle(keys[i], i < keys.length - 1 ? _increaseSequence : _callbackAndReset, action, combo, i);
      }
  }

  /**
   * binds a single keyboard combination
   *
   * @param {string} combination
   * @param {Function} callback
   * @param {string=} action
   * @param {string=} sequence_name - name of sequence if part of sequence
   * @param {number=} level - what part of the sequence the command is
   * @returns void
   */
  function _bindSingle(combination, callback, action, sequence_name, level) {

      // make sure multiple spaces in a row become a single space
      combination = combination.replace(/\s+/g, ' ');

      var sequence = combination.split(' '),
          i,
          key,
          keys,
          modifiers = [];

      // if this pattern is a sequence of keys then run through this method
      // to reprocess each pattern one key at a time
      if (sequence.length > 1) {
          return _bindSequence(combination, sequence, callback, action);
      }

      // take the keys from this pattern and figure out what the actual
      // pattern is all about
      keys = combination === '+' ? ['+'] : combination.split('+');

      for (i = 0; i < keys.length; ++i) {
          key = keys[i];

          // normalize key names
          if (_SPECIAL_ALIASES[key]) {
              key = _SPECIAL_ALIASES[key];
          }

          // if this is not a keypress event then we should
          // be smart about using shift keys
          // this will only work for US keyboards however
          if (action && action != 'keypress' && _SHIFT_MAP[key]) {
              key = _SHIFT_MAP[key];
              modifiers.push('shift');
          }

          // if this key is a modifier then add it to the list of modifiers
          if (_isModifier(key)) {
              modifiers.push(key);
          }
      }

      // depending on what the key combination is
      // we will try to pick the best event for it
      action = _pickBestAction(key, modifiers, action);

      // make sure to initialize array if this is the first time
      // a callback is added for this key
      if (!_callbacks[key]) {
          _callbacks[key] = [];
      }

      // remove an existing match if there is one
      _getMatches(key, modifiers, action, !sequence_name, combination);

      // add this call back to the array
      // if it is a sequence put it at the beginning
      // if not put it at the end
      //
      // this is important because the way these are processed expects
      // the sequence ones to come first
      _callbacks[key][sequence_name ? 'unshift' : 'push']({
          callback: callback,
          modifiers: modifiers,
          action: action,
          seq: sequence_name,
          level: level,
          combo: combination
      });
  }

  /**
   * binds multiple combinations to the same callback
   *
   * @param {Array} combinations
   * @param {Function} callback
   * @param {string|undefined} action
   * @returns void
   */
  function _bindMultiple(combinations, callback, action) {
      for (var i = 0; i < combinations.length; ++i) {
          _bindSingle(combinations[i], callback, action);
      }
  }

  // start!
  _addEvent(document, 'keypress', _handleKey);
  _addEvent(document, 'keydown', _handleKey);
  _addEvent(document, 'keyup', _handleKey);

  var mousetrap = {

      /**
       * binds an event to mousetrap
       *
       * can be a single key, a combination of keys separated with +,
       * a comma separated list of keys, an array of keys, or
       * a sequence of keys separated by spaces
       *
       * be sure to list the modifier keys first to make sure that the
       * correct key ends up getting bound (the last key in the pattern)
       *
       * @param {string|Array} keys
       * @param {Function} callback
       * @param {string=} action - 'keypress', 'keydown', or 'keyup'
       * @returns void
       */
      bind: function(keys, callback, action) {
          _bindMultiple(keys instanceof Array ? keys : [keys], callback, action);
          _direct_map[keys + ':' + action] = callback;
          return this;
      },

      /**
       * unbinds an event to mousetrap
       *
       * the unbinding sets the callback function of the specified key combo
       * to an empty function and deletes the corresponding key in the
       * _direct_map dict.
       *
       * the keycombo+action has to be exactly the same as
       * it was defined in the bind method
       *
       * TODO: actually remove this from the _callbacks dictionary instead
       * of binding an empty function
       *
       * @param {string|Array} keys
       * @param {string} action
       * @returns void
       */
      unbind: function(keys, action) {
          if (_direct_map[keys + ':' + action]) {
              delete _direct_map[keys + ':' + action];
              this.bind(keys, function() {}, action);
          }
          return this;
      },

      /**
       * triggers an event that has already been bound
       *
       * @param {string} keys
       * @param {string=} action
       * @returns void
       */
      trigger: function(keys, action) {
          _direct_map[keys + ':' + action]();
          return this;
      },

      /**
       * resets the library back to its initial state.  this is useful
       * if you want to clear out the current keyboard shortcuts and bind
       * new ones - for example if you switch to another page
       *
       * @returns void
       */
      reset: function() {
          _callbacks = {};
          _direct_map = {};
          return this;
      }
  };

module.exports = mousetrap;


},{}],57:[function(require,module,exports){
$ = require('../bower_components/jquery/dist/jquery.js');

function setInputValue(el, val) {
    el.val(val);
    // tiggerHandler only works with angular element (not jquery)?
    angular.element(el).triggerHandler(sniffer.hasEvent('input') ? 'input' : 'change');
    return el;
}

function click(el) {
    angular.element(el).triggerHandler('click');
}

function compile(html, contents) {
    var scope = $rootScope.$new();
    var el = $compile(html)(scope);
    angular.extend(scope, contents);
    scope.$digest();
    return $(el);
}

function getScope(el) {
    return angular.element(el).scope();
}

exports.inject = function() {
    inject(function(_$compile_, _$rootScope_, $sniffer) {
        $compile = _$compile_;
        $rootScope = _$rootScope_;
        sniffer = $sniffer;
    });
};
exports.setInputValue = setInputValue;
exports.click = click;
exports.compile = compile;
exports.getScope = getScope;
},{"../bower_components/jquery/dist/jquery.js":2}],58:[function(require,module,exports){
var MapConfigTransformer = require('../lib/mapstory/MapConfigTransformer.js').MapConfigTransformer;

describe('MapConfigTransformer', function() {
    it('should transform map id 1193', function() {
        var data = JSON.parse('{"sources": {"1": {"hidden": true, "ptype": "gxp_mapquestsource", "id": "1"}, "0": {"ptype": "gx_olsource", "id": "0"}, "2": {"hidden": true, "ptype": "gxp_mapboxsource", "id": "2"}, "local": {"title": "My GeoServer WMS", "url": "/geoserver/geonode/Breweries0/wms", "baseParams": {"VERSION": "1.1.1", "REQUEST": "GetCapabilities", "TILED": true, "SERVICE": "WMS"}, "ptype": "gxp_wmscsource", "restUrl": "/gs/rest", "hidden": true, "id": "local"}}, "about": {"abstract": "This map shows the evolution and development of the  brewing industry in the United States. The information is obtained from the book American Breweries II by Dale P. Van Wieren. The same information could also be accessed at www.beerbooks.com", "title": "Chronology of the American Brewing Industry"}, "localGeoServerBaseUrl": "http://mapstory.org/geoserver/", "map": {"layers": [{"opacity": 1.0, "args": ["No background"], "group": "background", "name": "No background", "title": "No background", "selected": false, "visibility": false, "source": "0", "fixed": true, "type": "OpenLayers.Layer"}, {"opacity": 1.0, "args": ["OpenStreetMap"], "group": "background", "name": "OpenStreetMap", "title": "OpenStreetMap", "selected": false, "visibility": true, "source": "0", "fixed": true, "type": "OpenLayers.Layer.OSM"}, {"opacity": 1.0, "args": ["Humanitarian OpenStreetMap", ["http://a.tile.openstreetmap.fr/hot/${z}/${x}/${y}.png", "http://b.tile.openstreetmap.fr/hot/${z}/${x}/${y}.png", "http://c.tile.openstreetmap.fr/hot/${z}/${x}/${y}.png"], {"tileOptions": {"crossOriginKeyword": null}}], "group": "background", "name": "Humanitarian OpenStreetMap", "title": "Humanitarian OpenStreetMap", "selected": false, "visibility": false, "source": "0", "fixed": true, "type": "OpenLayers.Layer.OSM"}, {"opacity": 1.0, "args": ["Naked Earth", "http://maps.opengeo.org/geowebcache/service/wms", {"layers": ["Wayne"], "tiled": true, "tilesOrigin": [-20037508.34, -20037508.34], "format": "image/png"}, {"buffer": 0}], "group": "background", "name": "Naked Earth", "title": "Naked Earth", "selected": false, "visibility": false, "source": "0", "fixed": true, "type": "OpenLayers.Layer.WMS"}, {"opacity": 1.0, "group": "background", "name": "naip", "title": "Satellite Imagery", "selected": false, "visibility": false, "source": "1", "fixed": true}, {"opacity": 1.0, "group": "background", "name": "natural-earth-1", "title": "Natural Earth", "selected": false, "visibility": false, "source": "2", "fixed": false}, {"opacity": 1.0, "group": "background", "name": "natural-earth-2", "title": "Natural Earth 2", "selected": false, "visibility": false, "source": "2", "fixed": false}, {"opacity": 1.0, "group": "background", "name": "geography-class", "title": "Geography Class", "selected": false, "visibility": false, "source": "2", "fixed": false}, {"opacity": 1.0, "group": "background", "name": "world-light", "title": "World Light", "selected": false, "visibility": false, "source": "2", "fixed": false}, {"opacity": 1.0, "styles": "geonode_Breweries", "name": "Breweries0", "format": "image/png", "cached": true, "selected": true, "visibility": true, "capability": {"abstract": "", "nestedLayers": [], "cascaded": 0, "fixedHeight": 0, "prefix": "Breweries0", "keywords": [], "noSubsets": false, "dimensions": {"time": {"nearestVal": false, "multipleVal": false, "name": "time", "default": "current", "current": false, "units": "ISO8601", "values": ["1587-01-01T00:00:00.000Z", "1607-01-01T00:00:00.000Z", "1609-01-01T00:00:00.000Z", "1612-01-01T00:00:00.000Z", "1614-01-01T00:00:00.000Z", "1620-01-01T00:00:00.000Z", "1632-01-01T00:00:00.000Z", "1633-01-01T00:00:00.000Z", "1634-01-01T00:00:00.000Z", "1637-01-01T00:00:00.000Z", "1639-01-01T00:00:00.000Z", "1670-01-01T00:00:00.000Z", "1683-01-01T00:00:00.000Z", "1734-01-01T00:00:00.000Z", "1738-01-01T00:00:00.000Z", "1765-01-01T00:00:00.000Z", "1774-01-01T00:00:00.000Z", "1789-01-01T00:00:00.000Z", "1792-01-01T00:00:00.000Z", "1793-01-01T00:00:00.000Z", "1808-01-01T00:00:00.000Z", "1810-01-01T00:00:00.000Z", "1819-01-01T00:00:00.000Z", "1826-01-01T00:00:00.000Z", "1829-01-01T00:00:00.000Z", "1830-01-01T00:00:00.000Z", "1833-01-01T00:00:00.000Z", "1836-01-01T00:00:00.000Z", "1837-01-01T00:00:00.000Z", "1840-01-01T00:00:00.000Z", "1844-01-01T00:00:00.000Z", "1846-01-01T00:00:00.000Z", "1847-01-01T00:00:00.000Z", "1848-01-01T00:00:00.000Z", "1849-01-01T00:00:00.000Z", "1850-01-01T00:00:00.000Z", "1852-01-01T00:00:00.000Z", "1853-01-01T00:00:00.000Z", "1854-01-01T00:00:00.000Z", "1855-01-01T00:00:00.000Z", "1856-01-01T00:00:00.000Z", "1857-01-01T00:00:00.000Z", "1859-01-01T00:00:00.000Z", "1862-01-01T00:00:00.000Z", "1865-01-01T00:00:00.000Z", "1866-01-01T00:00:00.000Z", "1867-01-01T00:00:00.000Z", "1868-01-01T00:00:00.000Z", "1869-01-01T00:00:00.000Z", "1871-01-01T00:00:00.000Z", "1872-01-01T00:00:00.000Z", "1873-01-01T00:00:00.000Z", "1875-01-01T00:00:00.000Z", "1877-01-01T00:00:00.000Z", "1884-01-01T00:00:00.000Z", "1885-01-01T00:00:00.000Z", "1887-01-01T00:00:00.000Z", "1888-01-01T00:00:00.000Z", "1889-01-01T00:00:00.000Z", "1890-01-01T00:00:00.000Z", "1892-01-01T00:00:00.000Z", "1898-01-01T00:00:00.000Z", "1899-01-01T00:00:00.000Z", "1900-01-01T00:00:00.000Z", "1901-01-01T00:00:00.000Z", "1905-01-01T00:00:00.000Z", "1916-01-01T00:00:00.000Z", "1922-01-01T00:00:00.000Z", "1926-01-01T00:00:00.000Z", "1935-01-01T00:00:00.000Z", "1951-01-01T00:00:00.000Z", "1953-01-01T00:00:00.000Z", "1959-01-01T00:00:00.000Z", "1962-01-01T00:00:00.000Z", "1969-01-01T00:00:00.000Z", "1972-01-01T00:00:00.000Z", "1977-01-01T00:00:00.000Z", "1982-01-01T00:00:00.000Z", "1984-01-01T00:00:00.000Z", "1990-01-01T00:00:00.000Z"], "unitsymbol": null}}, "opaque": false, "tileSets": [{"layers": "Breweries0", "styles": "", "format": "image/png", "height": 256, "srs": {"EPSG:900913": true}, "bbox": {"EPSG:900913": {"srs": "EPSG:900913", "bbox": [-20037508.34, 0, 0, 20037508.34]}}, "resolutions": [156543.03390625, 78271.516953124999, 39135.7584765625, 19567.87923828125, 9783.9396191406249, 4891.9698095703125, 2445.9849047851562, 1222.9924523925781, 611.49622619628906, 305.74811309814453, 152.87405654907226, 76.437028274536132, 38.218514137268066, 19.109257068634033, 9.5546285343170165, 4.7773142671585083, 2.3886571335792541, 1.1943285667896271, 0.59716428339481353, 0.29858214169740677, 0.14929107084870338, 0.074645535424351692, 0.037322767712175846, 0.018661383856087923, 0.0093306919280439615, 0.0046653459640219807, 0.0023326729820109904, 0.0011663364910054952, 0.00058316824550274759, 0.0002915841227513738, 0.0001457920613756869], "width": 256}], "infoFormats": ["text/plain", "application/vnd.ogc.gml", "application/vnd.ogc.gml/3.1.1", "text/html", "application/json"], "styles": [{"abstract": "", "title": "azure square point style", "legend": {"height": "20", "width": "20", "href": "http://mapstory.org:80/geoserver/geonode/Breweries0/wms?request=GetLegendGraphic&format=image%2Fpng&width=20&height=20&layer=Breweries0", "format": "image/png"}, "name": "geonode_Breweries"}], "attribution": {"title": "admin"}, "authorityURLs": {}, "bbox": {"EPSG:4326": {"srs": "EPSG:4326", "bbox": [-157.816667, 21.300000000000001, -69.780000000000001, 46.601944000000003]}}, "fixedWidth": 0, "metadataURLs": [], "name": "Breweries0", "identifiers": {}, "srs": {"EPSG:900913": true}, "formats": ["image/png", "application/atom xml", "application/atom+xml", "application/openlayers", "application/pdf", "application/rss xml", "application/rss+xml", "application/vnd.google-earth.kml", "application/vnd.google-earth.kml xml", "application/vnd.google-earth.kml+xml", "application/vnd.google-earth.kml+xml;mode=networklink", "application/vnd.google-earth.kmz", "application/vnd.google-earth.kmz xml", "application/vnd.google-earth.kmz+xml", "application/vnd.google-earth.kmz;mode=networklink", "atom", "image/geotiff", "image/geotiff8", "image/gif", "image/gif;subtype=animated", "image/jpeg", "image/png8", "image/png; mode=8bit", "image/svg", "image/svg xml", "image/svg+xml", "image/tiff", "image/tiff8", "kml", "kmz", "openlayers", "rss"], "title": "Breweries0", "queryable": true, "llbbox": [-157.816667, 21.300000000000001, -69.780000000000001, 46.601944000000003]}, "source": "local", "tiled": false, "title": "Breweries0", "fixed": false, "transparent": true}], "wrapDateLine": false, "projection": "EPSG:900913", "center": [-12667972.53658, 4152514.0300837001], "zoom": 4, "units": "m", "maxResolution": 156543.03390625, "maxExtent": [-20037508.34, -20037508.34, 20037508.34, 20037508.34], "numZoomLevels": 22}, "defaultSourceType": "gxp_wmscsource", "apiKeys": {"google": "ABQIAAAAkofooZxTfcCv9Wi3zzGTVxTnme5EwnLVtEDGnh-lFVzRJhbdQhQgAhB1eT_2muZtc0dl-ZSWrtzmrw"}, "tools": [{"outputConfig": {"looped": true, "layout": "toolbar", "xtype": "app_playbacktoolbar", "hideParent": true, "controlConfig": {"timeStep": null, "animationRange": [-12086323200000, 631152000000], "snapToList": true, "model": {"range": [-12086323200000, 631152000000], "values": [-12086323200000, -11455171200000, -11392012800000, -11297404800000, -11234246400000, -11044944000000, -10666252800000, -10634630400000, -10603094400000, -10508400000000, -10445328000000, -9467020800000, -9056793600000, -7447420800000, -7321190400000, -6469113600000, -6185116800000, -5711731200000, -5617123200000, -5585500800000, -5112288000000, -5049129600000, -4765132800000, -4544208000000, -4449513600000, -4417977600000, -4323283200000, -4228675200000, -4197052800000, -4102444800000, -3976214400000, -3913056000000, -3881520000000, -3849984000000, -3818361600000, -3786825600000, -3723753600000, -3692131200000, -3660595200000, -3629059200000, -3597523200000, -3565900800000, -3502828800000, -3408134400000, -3313440000000, -3281904000000, -3250368000000, -3218832000000, -3187209600000, -3124137600000, -3092601600000, -3060979200000, -2997907200000, -2934748800000, -2713910400000, -2682288000000, -2619216000000, -2587680000000, -2556057600000, -2524521600000, -2461449600000, -2272060800000, -2240524800000, -2208988800000, -2177452800000, -2051222400000, -1704153600000, -1514764800000, -1388534400000, -1104537600000, -599616000000, -536457600000, -347155200000, -252460800000, -31536000000, 63072000000, 220924800000, 378691200000, 441763200000, 631152000000], "dimension": "time"}, "dimension": "time", "loop": true}, "listeners": {"single": true}, "removeMode": "container", "playbackMode": "cumulative", "defaults": {"scale": "medium"}, "autoPlay": false}, "looped": true, "outputTarget": "map-bbar", "ptype": "gxp_playback", "id": "playback-tool"}, {"bgColor": "#454238", "wrapDateLine": false, "ptype": "ms-tool-bar", "numZoomLevels": 22}, {"playbackTool": "playback-tool", "outputConfig": {"title": null}, "outputTarget": "timeline-container", "ptype": "gxp_timeline", "id": "timeline-tool"}], "authorizedRoles": ["ROLE_ANONYMOUS"], "id": 1193}');
        var config = MapConfigTransformer(data);
        expect(JSON.stringify(config)).toBe('{"id":1193,"playbackMode":"cumulative","map":{"center":[-12667972.53658,4152514.0300837],"projection":"EPSG:900913","zoom":4,"layers":[{"visibility":true,"group":"background","type":"OSM","title":"OpenStreetMap"},{"visibility":true,"type":"WMS","singleTile":true,"id":"Breweries0","name":"Breweries0","title":"Breweries0","url":"/geoserver/geonode/Breweries0/wms","params":{"LAYERS":"Breweries0","STYLES":"geonode_Breweries","TILED":"TRUE","FORMAT":"image/png","TRANSPARENT":true,"VERSION":"1.1.1"},"latlonBBOX":[-157.816667,21.3,-69.78,46.601944],"times":[-12086323200000,-11455171200000,-11392012800000,-11297404800000,-11234246400000,-11044944000000,-10666252800000,-10634630400000,-10603094400000,-10508486400000,-10445414400000,-9467107200000,-9056880000000,-7447420800000,-7321190400000,-6469113600000,-6185203200000,-5711817600000,-5617209600000,-5585587200000,-5112288000000,-5049129600000,-4765132800000,-4544208000000,-4449513600000,-4417977600000,-4323283200000,-4228675200000,-4197052800000,-4102444800000,-3976214400000,-3913056000000,-3881520000000,-3849984000000,-3818361600000,-3786825600000,-3723753600000,-3692131200000,-3660595200000,-3629059200000,-3597523200000,-3565900800000,-3502828800000,-3408134400000,-3313440000000,-3281904000000,-3250368000000,-3218832000000,-3187209600000,-3124137600000,-3092601600000,-3060979200000,-2997907200000,-2934748800000,-2713910400000,-2682288000000,-2619216000000,-2587680000000,-2556057600000,-2524521600000,-2461449600000,-2272060800000,-2240524800000,-2208988800000,-2177452800000,-2051222400000,-1704153600000,-1514764800000,-1388534400000,-1104537600000,-599616000000,-536457600000,-347155200000,-252460800000,-31536000000,63072000000,220924800000,378691200000,441763200000,631152000000],"bbox":[-20037508.34,0,0,20037508.34],"resolutions":[156543.03390625,78271.516953125,39135.7584765625,19567.87923828125,9783.939619140625,4891.9698095703125,2445.9849047851562,1222.9924523925781,611.4962261962891,305.74811309814453,152.87405654907226,76.43702827453613,38.218514137268066,19.109257068634033,9.554628534317017,4.777314267158508,2.388657133579254,1.194328566789627,0.5971642833948135,0.29858214169740677,0.14929107084870338,0.07464553542435169,0.037322767712175846,0.018661383856087923,0.009330691928043961,0.004665345964021981,0.0023326729820109904,0.0011663364910054952,0.0005831682455027476,0.0002915841227513738,0.0001457920613756869]}]}}');
    });
});

},{"../lib/mapstory/MapConfigTransformer.js":16}],59:[function(require,module,exports){
var SLDStyleConverter = require('../lib/edit/style/SLDStyleConverter.js').SLDStyleConverter;
var instance = new SLDStyleConverter();

describe('SLDStyleConverter', function() {

    beforeEach(function() {
        jasmine.addMatchers(customMatchers);
    });

    it('should convert simple types (point)', function() {
        var styleConfig = {
            "typeName": "simple",
            "symbol": {
                "size": 10,
                "shape": "circle",
                "graphic": null,
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "dotted",
                "strokeOpacity": 90
            },
            "geomType": "point"
        };
        var style = instance.generateStyle(styleConfig, 'simple');
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:Name>simple</sld:Name><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff0000</sld:CssParameter><sld:CssParameter name="fill-opacity">0.8</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray">1 2</sld:CssParameter></sld:Stroke></sld:Mark><sld:Opacity>0.8</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
        // svg symbol (graphic)
        styleConfig = {
            "typeName": "simple",
            "symbol": {
                "size": 10,
                "shape": null,
                "graphic": "icon.svg",
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "solid",
                "strokeOpacity": 90
            },
            "geomType": "point"
        };
        style = instance.generateStyle(styleConfig, 'simple');
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:Name>simple</sld:Name><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PointSymbolizer><sld:Graphic><sld:ExternalGraphic><sld:OnlineResource xlink:href="http://localhost:9876/icon.svg?fill=%23ff0000&amp;stroke=%23ffff00"/><sld:Format>image/svg+xml</sld:Format></sld:ExternalGraphic><sld:Opacity>0.8</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert simple types (line)', function() {
        var styleConfig = {
            "typeName": "simple line",
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "dashed",
                "strokeOpacity": 90
            },
            "geomType": "line"
        };
        var style = instance.generateStyle(styleConfig, 'simple line');
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:Name>simple line</sld:Name><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:LineSymbolizer><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray">5</sld:CssParameter></sld:Stroke></sld:LineSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert simple types (polygon)', function() {
        var styleConfig = {
            "typeName": "simple polygon",
            "symbol": {
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "dashed",
                "strokeOpacity": 90
            },
            "geomType": "polygon"
        };
        var style = instance.generateStyle(styleConfig, 'simple polygon');
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:Name>simple polygon</sld:Name><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PolygonSymbolizer><sld:Fill><sld:CssParameter name="fill">#ff0000</sld:CssParameter><sld:CssParameter name="fill-opacity">0.8</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray">5</sld:CssParameter></sld:Stroke></sld:PolygonSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert labels', function() {
        var styleConfig = {
            "typeName": "simple",
            "symbol": {
                "size": 10,
                "shape": "circle",
                "graphic": null,
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "solid",
                "strokeOpacity": 90
            },
            "label": {
                "attribute": "foo",
                "fillColor": "#000000",
                "fontFamily": "serif",
                "fontSize": 10,
                "fontStyle": "normal",
                "fontWeight": "normal"
            },
            "geomType": "point"
        };
        var style = instance.generateStyle(styleConfig, 'simple');
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:Name>simple</sld:Name><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff0000</sld:CssParameter><sld:CssParameter name="fill-opacity">0.8</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:Mark><sld:Opacity>0.8</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer><sld:TextSymbolizer><sld:Label><ogc:PropertyName>foo</ogc:PropertyName></sld:Label><sld:Font><sld:CssParameter name="font-family">Serif</sld:CssParameter><sld:CssParameter name="font-size">10</sld:CssParameter><sld:CssParameter name="font-style">normal</sld:CssParameter><sld:CssParameter name="font-weight">normal</sld:CssParameter></sld:Font><sld:LabelPlacement><sld:LinePlacement/></sld:LabelPlacement><sld:Halo><sld:Radius>1</sld:Radius><sld:Fill><sld:CssParameter name="fill">#FFFFFF</sld:CssParameter></sld:Fill></sld:Halo><sld:Fill><sld:CssParameter name="fill">#000000</sld:CssParameter></sld:Fill><sld:VendorOption name="maxDisplacement">40</sld:VendorOption><sld:VendorOption name="autoWrap">40</sld:VendorOption><sld:VendorOption name="spaceAround">0</sld:VendorOption><sld:VendorOption name="followLine">false</sld:VendorOption><sld:VendorOption name="group">yes</sld:VendorOption><sld:VendorOption name="goodnessOfFit">0.2</sld:VendorOption><sld:VendorOption name="conflictResolution">true</sld:VendorOption></sld:TextSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert unique classification', function() {
        var styleConfig = {
            "stroke": {
                "strokeColor": "#ffff00"
            },
            "geomType": "point",
            "classify": {
                "attribute": "foo"
            },
            "rules": [{
                "value": "bar",
                "style": {
                    "symbol": {
                        "fillColor": "#ff9900"
                    },
                    "stroke": {
                        "strokeColor": "#ff9900"
                    }
                }
            }, {
                "value": "baz",
                "style": {
                    "symbol": {
                        "fillColor": "#b36b00"
                    },
                    "stroke": {
                        "strokeColor": "#b36b00"
                    }
                }
            }]
        };
        var style = instance.generateStyle(styleConfig);
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>bar</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff9900</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:Mark><sld:Opacity>1</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>baz</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#b36b00</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:Mark><sld:Opacity>1</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
        styleConfig.geomType = "line";
        style = instance.generateStyle(styleConfig);
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>bar</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:LineSymbolizer><sld:Stroke><sld:CssParameter name="stroke">#ff9900</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:LineSymbolizer></sld:Rule><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>baz</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:LineSymbolizer><sld:Stroke><sld:CssParameter name="stroke">#b36b00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:LineSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
        styleConfig.geomType = "polygon";
        style = instance.generateStyle(styleConfig);
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>bar</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:PolygonSymbolizer><sld:Fill><sld:CssParameter name="fill">#ff9900</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:PolygonSymbolizer></sld:Rule><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>baz</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:PolygonSymbolizer><sld:Fill><sld:CssParameter name="fill">#b36b00</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:PolygonSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert ranges of a classification', function() {
        var styleConfig = {
            "stroke": {
                "strokeColor": "#ffff00"
            },  
            "geomType": "point",
            "classify": {
                "attribute": "foo"
            },      
            "rules": [{
                "range": {
                    "min": 0,
                    "max": 10
                },  
                "style": {
                    "symbol": {
                        "fillColor": "#ff9900"
                    }   
                }   
            }, {
                "range": {
                    "min": 10,
                    "max": 20
                },
                "style": {
                    "symbol": {
                        "fillColor": "#b36b00"
                    }
                }
            }]
        };  
        var style = instance.generateStyle(styleConfig);
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><ogc:Filter><ogc:PropertyIsBetween><ogc:PropertyName>foo</ogc:PropertyName><ogc:LowerBoundary><ogc:Literal>0</ogc:Literal></ogc:LowerBoundary><ogc:UpperBoundary><ogc:Literal>10</ogc:Literal></ogc:UpperBoundary></ogc:PropertyIsBetween></ogc:Filter><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff9900</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:Mark><sld:Opacity>1</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule><sld:Rule><ogc:Filter><ogc:PropertyIsBetween><ogc:PropertyName>foo</ogc:PropertyName><ogc:LowerBoundary><ogc:Literal>10</ogc:Literal></ogc:LowerBoundary><ogc:UpperBoundary><ogc:Literal>20</ogc:Literal></ogc:UpperBoundary></ogc:PropertyIsBetween></ogc:Filter><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#b36b00</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:Mark><sld:Opacity>1</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert rotation', function() {
        var styleConfig = {
            "typeName": "simple",
            "symbol": {
                "size": 10,
                "shape": "triangle",
                "graphic": null,
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80,
                "rotationAttribute": "rotation",
                "rotationUnits": "degrees"
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "dotted",
                "strokeOpacity": 90
            },
            "geomType": "point"
        };
        var style = instance.generateStyle(styleConfig);
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>triangle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff0000</sld:CssParameter><sld:CssParameter name="fill-opacity">0.8</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray">1 2</sld:CssParameter></sld:Stroke></sld:Mark><sld:Opacity>0.8</sld:Opacity><sld:Size>10</sld:Size><sld:Rotation><ogc:PropertyName>rotation</ogc:PropertyName></sld:Rotation></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');

         // now use radians
         styleConfig.symbol.rotationUnits = "radians";
         style = instance.generateStyle(styleConfig);
         expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>triangle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff0000</sld:CssParameter><sld:CssParameter name="fill-opacity">0.8</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray">1 2</sld:CssParameter></sld:Stroke></sld:Mark><sld:Opacity>0.8</sld:Opacity><sld:Size>10</sld:Size><sld:Rotation><ogc:Div><ogc:PropertyName>rotation</ogc:PropertyName><ogc:Div><ogc:Function name="pi"/><ogc:Literal>360</ogc:Literal></ogc:Div></ogc:Div></sld:Rotation></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

});

},{"../lib/edit/style/SLDStyleConverter.js":12}],60:[function(require,module,exports){
var StyleComplete = require('../lib/edit/style/StyleComplete.js').StyleComplete;
var instance = new StyleComplete();

describe('StyleComplete', function() {

    it('unique classification needs attribute, maxClasses and colorPalette', function() {
        var style = {
            "classify": {
                "method": "unique",
                "maxClasses": null,
                "attribute": null
            }
        };
        var result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.classify.attribute = 'foo';
        result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.classify.maxClasses = 10;
        expect(result).toBeFalsy();
        style.classify.colorPalette = true;
        result = instance.isComplete(style);
        expect(result).toBeTruthy();
    });

    it('other classifcation types need to have all info', function() {
        var style = {
            "classify": {
                "method": null,
                "attribute": null,
                "colorRamp": null
            },
            rules: []
        };
        var result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.classify.method = 'foo';
        result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.classify.attribute = 'bar';
        result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.classify.colorRamp = true;
        result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.rules.push({});
        result = instance.isComplete(style);
        expect(result).toBeTruthy();
    });

});


},{"../lib/edit/style/StyleComplete.js":13}],61:[function(require,module,exports){
var WFS_DFT = require('../lib/edit/style/WFSDescribeFeatureType.js').WFSDescribeFeatureType;
var instance = new WFS_DFT();

describe('WFSDescribeFeatureType', function() {
    it('should parse a WFS DescribeFeatureType response', function() {
        var xml = '<?xml version="1.0" encoding="UTF-8"?><xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:geonode="http://geonode.org/" xmlns:gml="http://www.opengis.net/gml" elementFormDefault="qualified" targetNamespace="http://geonode.org/">' +
'  <xsd:import namespace="http://www.opengis.net/gml" schemaLocation="http://mapstory.org:80/geoserver/schemas/gml/2.1.2/feature.xsd"/>' +
'  <xsd:complexType name="african_bees_2009Type">' +
'    <xsd:complexContent>' +
'      <xsd:extension base="gml:AbstractFeatureType">' +
'        <xsd:sequence>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="the_geom" nillable="true" type="gml:MultiPolygonPropertyType"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="AREA" nillable="true" type="xsd:double"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="PERIMETER" nillable="true" type="xsd:double"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="AFRBEEP020" nillable="true" type="xsd:long"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="STATE" nillable="true" type="xsd:string"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="COUNTY" nillable="true" type="xsd:string"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="FIPS" nillable="true" type="xsd:string"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="STATE_FIPS" nillable="true" type="xsd:string"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="FIRST_YR" nillable="true" type="xsd:dateTime"/>' +
'        </xsd:sequence>' +
'      </xsd:extension>' +
'    </xsd:complexContent>' +
'  </xsd:complexType>' +
'  <xsd:element name="african_bees_2009" substitutionGroup="gml:_Feature" type="geonode:african_bees_2009Type"/>' +
'</xsd:schema>';
        expect(JSON.stringify(instance.parseResult(xml))).toBe('{"timeAttribute":"FIRST_YR","featureNS":"http://geonode.org/","geomType":"polygon","attributes":[{"name":"the_geom","type":"MultiPolygonPropertyType","typeNS":"http://www.opengis.net/gml"},{"name":"AREA","type":"double","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"PERIMETER","type":"double","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"AFRBEEP020","type":"long","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"STATE","type":"string","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"COUNTY","type":"string","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"FIPS","type":"string","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"STATE_FIPS","type":"string","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"FIRST_YR","type":"dateTime","typeNS":"http://www.w3.org/2001/XMLSchema"}]}');
    });
});

},{"../lib/edit/style/WFSDescribeFeatureType.js":14}],62:[function(require,module,exports){
var WPSClassify = require('../lib/edit/style/WPSClassify.js').WPSClassify;
var instance = new WPSClassify();

describe('WPSClassify', function() {

    beforeEach(function() {
        jasmine.addMatchers(customMatchers);
    });

    it('should create the correct WPS request', function() {
        var data = {
            typeName: 'cite:states',
            featureNS: 'http://www.opengeospatial.net/cite',
            featurePrefix: 'cite',
            attribute: 'POPULATION',
            numClasses: 10,
            method: 'EQUAL_INTERVAL'
        };
        var request = instance.classifyVector(data);
        expect(request).toBeXML('<wps:Execute xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:wfs="http://www.opengis.net/wfs" service="WPS" version="1.0.0"><ows:Identifier>vec:FeatureClassStats</ows:Identifier><wps:DataInputs><wps:Input><ows:Identifier>features</ows:Identifier><wps:Reference xlink:href="http://geoserver/wfs" method="POST" mimeType="text/xml"><wps:Body><wfs:GetFeature service="WFS" version="1.1.0" outputFormat="GML2"><wfs:Query xmlns:cite="http://www.opengeospatial.net/cite" typeName="cite:states"/></wfs:GetFeature></wps:Body></wps:Reference></wps:Input><wps:Input><ows:Identifier>attribute</ows:Identifier><wps:Data><wps:LiteralData>POPULATION</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>classes</ows:Identifier><wps:Data><wps:LiteralData>10</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>method</ows:Identifier><wps:Data><wps:LiteralData>EQUAL_INTERVAL</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>stats</ows:Identifier><wps:Data><wps:LiteralData>mean</wps:LiteralData></wps:Data></wps:Input></wps:DataInputs><wps:ResponseForm><wps:RawDataOutput><ows:Identifier>results</ows:Identifier></wps:RawDataOutput></wps:ResponseForm></wps:Execute>');
    });

});

},{"../lib/edit/style/WPSClassify.js":15}],63:[function(require,module,exports){
var boxes = require('../lib/core/time/boxes.js');
var utils = require('../lib/core/time/utils.js');
var Box = boxes.Box;
var BoxModel = boxes.BoxModel;

describe("test boxes", function() {
    it("finds the right box by index", function() {
        function expectBoxOffset(data, idx) {
            return expect(boxes.findBox(data, idx)._offset);
        }
        ;
        var data = [{_offset: 0}];
        expectBoxOffset(data, 0).toBe(0);
        expectBoxOffset(data, 1).toBe(0);

        data = [{_offset: 0}, {_offset: 10}];
        expectBoxOffset(data, 0).toBe(0);
        expectBoxOffset(data, 5).toBe(0);
        expectBoxOffset(data, 10).toBe(10);
        expectBoxOffset(data, 11).toBe(10);
    });
    it("box steps works", function() {
        //expect(new Box({data: [1, 2, 3]}).getSteps()).toBe(3);
        expect(new Box({range: utils.createRange(10000, 20000), speed: {interval: 1000}}).getSteps()).toBe(11);
        expect(new Box({range: utils.createRange(10000, 11000), speed: {interval: 333}}).getSteps()).toBe(4);
    });
    it("box getIndex works", function() {
        var box = new Box({data: [1, 5, 10]});
        expect(box.getIndex(0)).toBe(0);
        expect(box.getIndex(1)).toBe(0);
        expect(box.getIndex(3)).toBe(0);
        expect(box.getIndex(10)).toBe(2);

        box = new Box({range: utils.createRange(10, 20), speed: {interval: 5}});
        expect(box.getIndex(5)).toBe(0);
        expect(box.getIndex(10)).toBe(0);
        expect(box.getIndex(12)).toBe(0);
        expect(box.getIndex(15)).toBe(1);
        expect(box.getIndex(18)).toBe(1);
        expect(box.getIndex(20)).toBe(2);
        expect(box.getIndex(25)).toBe(2);
    });
    it("box getDate works", function() {
        var box = new Box({data: [1, 5, 10]});
        box._offset = 0;
        expect(box.getDate(0)).toBe(1);
        box._offset = 10;
        expect(box.getDate(11)).toBe(5);

        box = new Box({range: utils.createRange(10, 20), speed: {interval: 5}});
        box._offset = 0;
        expect(box.getDate(0)).toBe(10);
        box._offset = 10;
        expect(box.getDate(11)).toBe(15);
    });
});

describe("test box model", function() {
    it("should work with a single box of list data", function() {
        var controller = new BoxModel([{data: [1, 2, 3]}]);
        var range = controller.getRange();
        expect(range.start).toBe(1);
        expect(range.end).toBe(3);
        //expect(controller.getSteps()).toBe(3);
        range = controller.getRangeAt(0, 1);
        expect(range.start).toBe(1);
        expect(range.end).toBe(2);
        expect(controller.getIndex(1)).toBe(0);
    });
    it("should work with two list boxes", function() {
        var controller = new BoxModel([{data: [1, 2, 3]}, {data: [4, 5, 6]}]);
        var range = controller.getRange();
        expect(range.start).toBe(1);
        expect(range.end).toBe(6);
        //expect(controller.getSteps()).toBe(6);
        range = controller.getRangeAt(2, 3);
        //expect(range.start).toBe(3);
        //expect(range.end).toBe(4);
        expect(controller.getIndex(0)).toBe(0);
        expect(controller.getIndex(3)).toBe(2);
        //expect(controller.getIndex(4)).toBe(3);
        //expect(controller.getIndex(7)).toBe(6);
    });
    it("should work with one range box", function() {
        var controller = new BoxModel([{range: utils.createRange(10, 20), speed: {interval: 5}}]);
        var range = controller.getRange();
        expect(range.start).toBe(10);
        expect(range.end).toBe(20);
        //expect(controller.getSteps()).toBe(3);
        range = controller.getRangeAt(0, 1);
        expect(range.start).toBe(10);
        expect(range.end).toBe(15);
        expect(controller.getIndex(1)).toBe(0);
        
    });
    it("should work with two range boxes", function() {
        var controller = new BoxModel([
            {range: utils.createRange(10, 20), speed: {interval: 5}},
            {range: utils.createRange(30, 50), speed: {interval: 10}}
        ]);
        var range = controller.getRange();
        expect(range.start).toBe(10);
        expect(range.end).toBe(50);
        expect(controller.getSteps()).toBe(6);
        range = controller.getRangeAt(2, 3);
        expect(range.start).toBe(20);
        expect(range.end).toBe(30);
        expect(controller.getIndex(40)).toBe(4);
    });
});

},{"../lib/core/time/boxes.js":4,"../lib/core/time/utils.js":11}],64:[function(require,module,exports){
var maps = require('../lib/core/time/maps.js');
require('../lib/ng/core/ogc/module.js');

describe("test maps", function() {
    it("readCapabilitiesTimeDimensions works", function() {
        function makeCaps(config) {
            return {
                value: {
                    capability: {
                        layer: {
                            layer: Object.getOwnPropertyNames(config).map(function(lyr) {
                                return {name: lyr, dimension: {}, extent: [{value: config[lyr]}]};
                            })
                        }
                    }
                }
            };
        }
        function expectData(args) {
            return expect(maps.readCapabilitiesTimeDimensions(makeCaps(args)));
        }
        function read(values) {
            return maps.readCapabilitiesTimeDimensions(makeCaps({data:values})).data;
        }
        function time(str) {
            return new Date(str).getTime();
        }
        var r = read('1990-01-01T00:00:00.000Z/2009-01-01T00:00:00.000Z/P1Y');
        expect(r.start).toBe(time('1990-01-01T00:00:00.000Z'));
        expect(r.end).toBe(time('2009-01-01T00:00:00.000Z'));
        expect(r.interval).toBe(31536000000);

        expectData({list: '1990'}).toEqual(
                {list: [time('1990')]}
        );
        expectData({list: '1990,1991,1992'}).toEqual(
                {list: [time('1990'),time('1991'),time('1992')]}
        );

        r = read('2000/2001');
        expect(r.start).toBe(time('2000'));
        expect(r.end).toBe(time('2001'));
    });
    it("readCapabilitiesTimeDimensions works for OpenLayers 2 config", function() {
        function makeCaps() {
            return {
                dimensions: {
                    'time': {
                        values: ["-3000-01-01T00:00:00.000Z", "1989-01-01T00:00:00.000Z", "1990-01-01T00:00:00.000Z", "1991-01-01T00:00:00.000Z", "1992-01-01T00:00:00.000Z", "1993-01-01T00:00:00.000Z", "1994-01-01T00:00:00.000Z", "1995-01-01T00:00:00.000Z", "1996-01-01T00:00:00.000Z", "1997-01-01T00:00:00.000Z", "1998-01-01T00:00:00.000Z", "1999-01-01T00:00:00.000Z", "2000-01-01T00:00:00.000Z", "2001-01-01T00:00:00.000Z", "2002-01-01T00:00:00.000Z", "2003-01-01T00:00:00.000Z", "2004-01-01T00:00:00.000Z", "2005-01-01T00:00:00.000Z", "2006-01-01T00:00:00.000Z", "2007-01-01T00:00:00.000Z", "2008-01-01T00:00:00.000Z", "2009-01-01T00:00:00.000Z", "2010-01-01T00:00:00.000Z", "2011-01-01T00:00:00.000Z", "2012-01-01T00:00:00.000Z", "2013-01-01T00:00:00.000Z"]
                    }
                }
            };
        }
        var data = maps.readCapabilitiesTimeDimensions(makeCaps(), true);
        expect(data.length).toBe(26);
        expect(data[0]).toBe(-156838032000000);
        expect(data[1]).toBe(599616000000);
        expect(data[25]).toBe(1356998400000);
    });
    describe('computeVectorRange works', function() {
        var storyLayer, features, range, StoryLayer;

        beforeEach(function() {
            // window.angular.mock.module is work around browserify conflict
            window.angular.mock.module('storytools.core.ogc');

            inject(function($injector) {
                StoryLayer = $injector.get('StoryLayer');
            });

            storyLayer = new StoryLayer({
                timeAttribute: "time",
                type: "VECTOR"
            });
            storyLayer.getLayer().setSource(new ol.source.Vector());

            features = [
                new ol.Feature({time: 1000})
            ];
            storyLayer.set('features', features);
        });

        it('using features as property', function() {
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(1000);
            expect(range.end).toBe(1000);
        });
        it('using features from source', function() {
            storyLayer.set('features', null);
            storyLayer.getLayer().getSource().addFeatures(features);
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(1000);
            expect(range.end).toBe(1000);
        });
        it('when empty endTimeAttribute', function() {
            storyLayer.set('endTimeAttribute', 'endTime');
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(1000);
            expect(range.end).toBe(1000);
        });
        it('when unsorted mixed data', function() {
            storyLayer.set('endTimeAttribute', 'endTime');
            features.push(new ol.Feature({time: 500}));
            features.push(new ol.Feature({time: 100, endTime: 900}));
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(100);
            expect(range.end).toBe(1000);
        });
        it('with single endAttribute', function() {
            storyLayer.set('endTimeAttribute', 'endTime');
            storyLayer.set('features', [new ol.Feature({endTime: 678})]);
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(678);
            expect(range.end).toBe(678);
        });
        it('when text', function() {
            // works with text
            storyLayer.set('features', [new ol.Feature({time: '2001'})]);
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(Date.parse('2001'));
            expect(range.end).toBe(Date.parse('2001'));
        });
    });
    describe('filterVectorLayer works', function() {
        var storyLayer, features, StoryLayer;

        function ids() {
            var layer = storyLayer.getLayer();
            var ids = layer.getSource().getFeatures().map(function(f) {
                return f.get('id');
            });
            ids.sort();
            return ids;
        }

        beforeEach(function() {
            // window.angular.mock.module is work around browserify conflict
            window.angular.mock.module('storytools.core.ogc');
                
            inject(function($injector) {
                StoryLayer = $injector.get('StoryLayer');
            });

            storyLayer = new StoryLayer({
              timeAttribute: "time",
              endTimeAttribute: "endTime",
              type: "VECTOR"
            });
            storyLayer.getLayer().setSource(new ol.source.Vector());
            var id = 1;
            features = [
                new ol.Feature({id:id++, time: 1000}),
                new ol.Feature({id:id++, time: 1000, endTime: 2000}),
                new ol.Feature({id:id++, time: 2000}),
                new ol.Feature({id:id++, time: 2000, endTime: 3000})
            ];
            storyLayer.set('features', features);
        });
        it('filters instants', function() {
            storyLayer.set('endTimeAttribute', null);
            // range before everything
            maps.filterVectorLayer(storyLayer, {start:500, end: 501});
            expect(ids()).toEqual([]);
            // range after everything
            maps.filterVectorLayer(storyLayer, {start:2500, end: 2600});
            expect(ids()).toEqual([]);
            // direct hit (ignores end exclusion)
            maps.filterVectorLayer(storyLayer, {start:2000, end: 2000});
            expect(ids()).toEqual([3,4]);
        });
        it('filters extents', function() {
            // range before everything
            maps.filterVectorLayer(storyLayer, {start:500, end: 501});
            expect(ids()).toEqual([]);
            // range before and after everything
            maps.filterVectorLayer(storyLayer, {start:500, end: 4000});
            expect(ids()).toEqual([1,2,3,4]);
            // excludes 3 due to intersection rules with end
            maps.filterVectorLayer(storyLayer, {start:1000, end:2000});
            expect(ids()).toEqual([1,2]);
            // 1 and 3 included as they are open ended and before
            maps.filterVectorLayer(storyLayer, {start:3000, end:4000});
            expect(ids()).toEqual([1,3,4]);
        });
    });

    describe('MapConfig', function() {

       beforeEach(function() {
              // window.angular.mock.module is work around browserify conflict
              window.angular.mock.module('storytools.core.ogc');
  
              inject(function($injector) {
                  StoryMap = $injector.get('StoryMap');
                  EditableStoryMap = $injector.get('EditableStoryMap');
                  stStoryMapBuilder = $injector.get('stStoryMapBuilder');
                  stStoryMapBaseBuilder = $injector.get('stStoryMapBaseBuilder');
                  stLayerBuilder = $injector.get('stLayerBuilder');
                  $timeout = $injector.get('$timeout');
              });
        });

        /*it('should transform to Interval object', function(done) {
            var data = JSON.parse('{"id":214,"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"id":"foo","name":"foo","title":"My layer","geomType":"point","attributes": ["attr1", "attr2"],"timeAttribute":"attr1","resolutions":[0,10, 20],"bbox": [0,100,100,200],"latlonBBOX":[-10,-10,10,10],"times":{"start": 631152000000, "end": 1230768000000, "duration": "P1Y"},"singleTile":false,"type":"WMS","url":"http://myserver","params":{"LAYERS":"x"}}]}}');
            var storyMap = new StoryMap({target: 'foo'});
            storyMap.getStoryLayers().on('change:length', function() {
              expect(storyMap.getStoryLayers().item(0).get('times').interval).toBe(31536000000);
              done();
            });
            stStoryMapBuilder.modifyStoryMap(storyMap, data);
            $timeout.flush();
        });
        */

        it('should convert extent, zoom and projection', function() {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 215);
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            var config = storyMap.getState();
            var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[]},"id":215}';
            expect(JSON.stringify(config)).toBe(expected);
        });

        it('should convert a tiled WMS layer', function(done) {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 216); 
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            stLayerBuilder.buildLayer({
              type: 'WMS',
              id: 'foo',
              name: 'x',
              title: 'My layer',
              geomType: 'point',
              timeAttribute: 'attr1',
              times: ['2001', '2002', '2003'],
              url: 'http://myserver',
              latlonBBOX: [-90,-180,90,180],
              bbox: [0,0,1,1],
              resolutions: [100,50,10],
              attributes: ['foo','bar']
            }, storyMap.getMap()).then(function(sl) {
              storyMap.addStoryLayer(sl);
              expect(sl.getLayer() instanceof ol.layer.Tile).toBe(true);
              expect(sl.getLayer().getSource() instanceof ol.source.TileWMS).toBe(true);
              var config = storyMap.getState();
              var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"type":"WMS","id":"foo","name":"x","title":"My layer","geomType":"point","timeAttribute":"attr1","times":["2001","2002","2003"],"url":"http://myserver","latlonBBOX":[-90,-180,90,180],"bbox":[0,0,1,1],"resolutions":[100,50,10],"attributes":["foo","bar"]}]},"id":216}';
              expect(JSON.stringify(config)).toBe(expected);
              done();
            });
            $timeout.flush();
        });

        it('should convert an untiled WMS layer', function(done) {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 217);
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            stLayerBuilder.buildLayer({
                type: 'WMS',
                singleTile: true,
                title: 'My layer',
                id: 'foo',
                name: 'x',
                geomType: 'point',
                timeAttr: 'attr1',
                times: ['2001', '2002', '2003'],
                url: 'http://myserver',
                latlonBBOX: [-90,-180,90,180],
                bbox: [0,0,1,1],
                resolutions: [100,50,10],
                attributes: ['foo','bar']
            }, storyMap.getMap()).then(function(sl) {
                storyMap.addStoryLayer(sl);
                expect(sl.getLayer() instanceof ol.layer.Image).toBe(true);
                expect(sl.getLayer().getSource() instanceof ol.source.ImageWMS).toBe(true);
                var config = storyMap.getState();
                var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"type":"WMS","singleTile":true,"title":"My layer","id":"foo","name":"x","geomType":"point","timeAttr":"attr1","times":["2001","2002","2003"],"url":"http://myserver","latlonBBOX":[-90,-180,90,180],"bbox":[0,0,1,1],"resolutions":[100,50,10],"attributes":["foo","bar"]}]},"id":217}';
                expect(JSON.stringify(config)).toBe(expected);
                done();
            });
            $timeout.flush();
        });

        it('should convert a vector layer', function(done) {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 227);
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            stLayerBuilder.buildLayer({
                type: 'VECTOR',
                id: 'foo',
                title: 'My layer',
                url: '/geoserver/wfs',
                geomType: 'point',
                timeAttr: 'attr1',
                typeName: 'foo',
                times: ['2001', '2002', '2003'],
                latlonBBOX: [-90,-180,90,180],
                bbox: [0,0,1,1],
                resolutions: [100,50,10],
                attributes: ['foo','bar']
            }, storyMap.getMap()).then(function(sl) {
                storyMap.addStoryLayer(sl);
                expect(sl.getLayer() instanceof ol.layer.Vector).toBe(true);
                var config = storyMap.getState();
                var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"type":"VECTOR","id":"foo","title":"My layer","url":"/geoserver/wfs","geomType":"point","timeAttr":"attr1","typeName":"foo","times":["2001","2002","2003"],"latlonBBOX":[-90,-180,90,180],"bbox":[0,0,1,1],"resolutions":[100,50,10],"attributes":["foo","bar"]}]},"id":227}';
                expect(JSON.stringify(config)).toBe(expected);
                done();
            });
            $timeout.flush();
        });

        it('should convert an OSM layer', function() {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 218);
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            stStoryMapBaseBuilder.setBaseLayer(storyMap, {
                type: 'OSM'
            });
            var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"type":"OSM","group":"background","visibility":true}]},"id":218}';
            expect(JSON.stringify(storyMap.getState())).toBe(expected);
        });

        it('should convert an MapQuest layer', function() {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 219);
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            stStoryMapBaseBuilder.setBaseLayer(storyMap, {
                type: 'MapQuest',
                layer: 'sat'
            });
            var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"type":"MapQuest","layer":"sat","group":"background","visibility":true}]},"id":219}';
            expect(JSON.stringify(storyMap.getState())).toBe(expected);
        });

    });

});

},{"../lib/core/time/maps.js":7,"../lib/ng/core/ogc/module.js":17}],65:[function(require,module,exports){
require('../lib/ng/core/style/ol3StyleConverter.js');
require('../lib/ng/core/style/svgIcon.js');

describe('ol3StyleConverter', function() {

    beforeEach(function() {
        // window.angular.mock.module is work around browserify conflict
        window.angular.mock.module('storytools.core.style.ol3StyleConverter');
        window.angular.mock.module('storytools.core.style.svgIcon');

        inject(function(ol3StyleConverter) {
            this.ol3StyleConverter = ol3StyleConverter;
        });
    });

    it('should convert simple stypes', inject(function(ol3StyleConverter) {
        var styleConfig = {
            "symbol": {
                "size": 10,
                "shape": "circle",
                "graphic": null,
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "solid",
                "strokeOpacity": 90
            }
        };
        var style = ol3StyleConverter.generateStyle(styleConfig);
        expect(style.length).toBe(1);
        expect(style[0] instanceof ol.style.Style).toBeTruthy();
        var image = style[0].getImage();
        expect(image instanceof ol.style.Circle).toBeTruthy();
        expect(image.getRadius()).toBe(10/2);
        expect(image.getFill().getColor()).toBe('rgba(255,0,0,0.8)');
        expect(image.getStroke().getColor()).toBe('rgba(255,255,0,0.9)');
        expect(image.getStroke().getWidth()).toBe(3);
        var newStyle = ol3StyleConverter.generateStyle(styleConfig);
        expect(style === newStyle).toBeTruthy();
    }));

    it('should convert to square', inject(function(ol3StyleConverter) {
        var shapeConfig = ol3StyleConverter.generateShapeConfig({
            "symbol": {
                "size": 10,
                "shape": "square"
            }
        });
        expect(shapeConfig.points).toBe(4);
        expect(shapeConfig.radius).toBe(10/2);
        expect(shapeConfig.angle).toBe(Math.PI / 4);
    }));

    it('should convert to triangle', inject(function(ol3StyleConverter) {
        var shapeConfig = ol3StyleConverter.generateShapeConfig({
            "symbol": {
                "size": 10,
                "shape": "triangle"
            }
        });
        expect(shapeConfig.points).toBe(3);
        expect(shapeConfig.radius).toBe(10/2);
        expect(shapeConfig.angle).toBe(0);
    }));

    it('should convert to star', inject(function(ol3StyleConverter) {
        var shapeConfig = ol3StyleConverter.generateShapeConfig({
            "symbol": {
                "size": 10,
                "shape": "star"
            }
        });
        expect(shapeConfig.points).toBe(5);
        expect(shapeConfig.radius).toBe(10/2);
        expect(shapeConfig.radius2).toBe(10/4);
        expect(shapeConfig.angle).toBe(0);
    }));

    it('should convert to cross', inject(function(ol3StyleConverter) {
        var shapeConfig = ol3StyleConverter.generateShapeConfig({
            "symbol": {
                "size": 10,
                "shape": "cross"
            }
        });
        expect(shapeConfig.points).toBe(4);
        expect(shapeConfig.radius).toBe(10/2);
        expect(shapeConfig.radius2).toBe(0);
        expect(shapeConfig.angle).toBe(0);
    }));

    it('should convert to x', inject(function(ol3StyleConverter) {
        var shapeConfig = ol3StyleConverter.generateShapeConfig({
            "symbol": {
                "size": 10,
                "shape": "x"
            }
        });
        expect(shapeConfig.points).toBe(4);
        expect(shapeConfig.radius).toBe(10/2);
        expect(shapeConfig.radius2).toBe(0);
        expect(shapeConfig.angle).toBe(Math.PI / 4);
    }));

    it('should convert labels', inject(function(ol3StyleConverter) {
        var style = ol3StyleConverter.generateStyle({
            "symbol": {
                "size": 10,
                "shape": "circle",
                "graphic": null,
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "solid",
                "strokeOpacity": 90
            },
            "label": {
                "attribute": "foo",
                "fontStyle": "italic",
                "fontWeight": "bold",
                "fontSize": 12,
                "fontFamily": "Serif",
                "fillColor": "#0000ff"
            }
        }, new ol.Feature({'foo': 'bar'}));
        expect(style.length).toBe(1);
        var text = style[0].getText();
        expect(text instanceof ol.style.Text).toBeTruthy();
        expect(text.getText()).toBe('bar');
        expect(text.getFont()).toBe('italic bold 12px Serif');
        expect(text.getFill().getColor()).toBe('#0000ff');
    }));

    it('should take rotation into account', inject(function(ol3StyleConverter) {
        var style = ol3StyleConverter.generateStyle({
            "symbol": {
                "size": 10,
                "shape": "triangle",
                "fillColor": "#ff0000",
                "rotationAttribute": 'rotation',
                "rotationUnits": 'radians'
            }
        }, new ol.Feature({'rotation': Math.PI/4}));
        expect(style[0].getImage().getRotation()).toBe(Math.PI/4);
        var newStyle = ol3StyleConverter.generateStyle({
            "symbol": {
                "size": 10,
                "shape": "triangle",
                "fillColor": "#ff0000",
                "rotationAttribute": 'rotation',
                "rotationUnits": 'radians'
            }
        }, new ol.Feature({'rotation': Math.PI/4}));
        // taken from style cache
        expect(newStyle === style).toBeTruthy();
        style = ol3StyleConverter.generateStyle({
            "symbol": {
                "size": 10,
                "shape": "triangle",
                "fillColor": "#ff0000",
                "rotationAttribute": 'rotation',
                "rotationUnits": 'degrees'
            }
        }, new ol.Feature({'rotation': 180}));
        expect(style[0].getImage().getRotation()).toBe(Math.PI/2);
    }));

    it('should convert unique classification', inject(function(ol3StyleConverter) {
        var styleConfig = {
            "stroke": {
                "strokeColor": "#ffff00"
            },
            "symbol": {
                "size": 10,
                "shape": "circle"
            },
            "geomType": "point",
            "classify": {
                "attribute": "foo"
            },
            "rules": [{
                "value": "bar",
                "style": {
                    "symbol": {
                        "fillColor": "#ff9900"
                    },
                    "stroke": {
                        "strokeColor": "#ff9900"
                    }
                }
            }, {
                "value": "baz",
                "style": {
                    "symbol": {
                        "fillColor": "#b36b00"
                    },
                    "stroke": {
                        "strokeColor": "#b36b00"
                    }
                }
            }]    
        };
        var style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'bar'}));
        expect(style[0].getImage().getFill().getColor()).toBe('#ff9900');
        expect(style[0].getImage().getStroke().getColor()).toBe('rgba(255,255,0,1)');
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        expect(style[0].getImage().getFill().getColor()).toBe('#b36b00'); 

        styleConfig.geomType = "line";
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'bar'}));
        expect(style[0].getStroke().getColor()).toBe('#ff9900');
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        expect(style[0].getStroke().getColor()).toBe('#b36b00');

        styleConfig.geomType = "polygon";
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'bar'}));
        expect(style[0].getFill().getColor()).toBe('#ff9900');
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        expect(style[0].getFill().getColor()).toBe('#b36b00');
    }));

    it('should convert ranges of a classification', inject(function(ol3StyleConverter) {
        var styleConfig = {
            "stroke": {
                "strokeColor": "#ffff00"
            },
            "symbol": {
                "size": 10,
                "shape": "circle"
            },
            "geomType": "point",
            "classify": {
                "attribute": "foo"
            },
            "rules": [{
                "range": {
                    "min": 0,
                    "max": 10
                },
                "style": {
                    "symbol": {
                        "fillColor": "#ff9900"
                    },
                    "stroke": {
                        "strokeColor": "#ff9900"
                    }
                }
            }, {
                "range": {
                    "min": 10,
                    "max": 20
                },
                "style": {
                    "symbol": {
                        "fillColor": "#b36b00"
                    },
                    "stroke": {
                        "strokeColor": "#b36b00"
                    }
                }
            }]
        };
        // this tests for being inclusive on the lower boundary
        var style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 0}));
        expect(style[0].getImage().getFill().getColor()).toBe('#ff9900');
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 15}));
        expect(style[0].getImage().getFill().getColor()).toBe('#b36b00');

        styleConfig.geomType = "line";
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 5}));
        expect(style[0].getStroke().getColor()).toBe('#ff9900');
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 15}));
        expect(style[0].getStroke().getColor()).toBe('#b36b00');

        styleConfig.geomType = "polygon";
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 5}));
        expect(style[0].getFill().getColor()).toBe('#ff9900');
        // this tests for being inclusive on the upper bondary
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 20}));
        expect(style[0].getFill().getColor()).toBe('#b36b00');

    }));

    it('should convert unique classification with label', inject(function(ol3StyleConverter) {
        var styleConfig = {
            "stroke": {
                "strokeColor": "#ffff00"
            },
            "symbol": {
                "size": 10,
                "shape": "circle"
            },
            "geomType": "point",
            "classify": {
                "attribute": "foo"
            },
            "label": {
                "attribute": "foo",
                "fontWeight": "bold",
                "fontSize": 12,
                "fontFamily": "Serif",
                "fillColor": "#0000ff"
            },
            "rules": [{
                "value": "bar",
                "style": {
                    "symbol": {
                        "fillColor": "#ff9900"
                    }
                }
            }, {
                "value": "baz",
                "style": {
                    "symbol": {
                        "fillColor": "#b36b00"
                    }
                }
            }]
        };
        var style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        expect(style[0].getText().getText()).toBe('baz');
        var newStyle = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        // taken from style cache
        expect(newStyle === style).toBeTruthy();
        newStyle = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'bar'}));
        // not taken from style cache
        expect(newStyle === style).toBeFalsy();
        styleConfig.stroke.strokeColor = "#ff0000";
        newStyle = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        // not taken from style cache since strokeColor changed
        expect(newStyle === style).toBeFalsy();
    }));

});

},{"../lib/ng/core/style/ol3StyleConverter.js":19,"../lib/ng/core/style/svgIcon.js":20}],66:[function(require,module,exports){
pins = require('../lib/core/time/pins.js');

describe('test storyPins', function() {
    
    describe('StoryPin class', function() {
        it('constructor', function() {
            var sp = new pins.StoryPin({
                title: 'test',
                the_geom: '{"type":"Point","coordinates":[123,321]}',
                id: 22
            });
            expect(sp.get('title')).toBe('test');
            expect(sp.title).toBe('test');
            expect(sp.getId()).toBe(22);
            expect(sp.id).toBe(22);
            var coords = sp.getGeometry().getCoordinates();
            expect(coords[0]).toBe(123);
            expect(coords[1]).toBe(321);
        });
        it('update', function() {
            var sp = new pins.StoryPin({
                title: 'test',
                the_geom: '{"type":"Point","coordinates":[123,321]}'
            });
            expect(sp.content).toBe(null);
            expect(sp.title).toBe('test');
            sp.setProperties({
                title: null,
                content: 'content'
            });
            expect(sp.content).toBe('content');
            expect(sp.title).toBe(null);
            var coords = sp.getGeometry().getCoordinates();
            expect(coords[0]).toBe(123);
            expect(coords[1]).toBe(321);
        });
        it('empty', function() {
            var sp = new pins.StoryPin();
            expect(sp.content).toBe(null);
            expect(sp.title).toBe(null);
        });
    });

    geojson = {
        features: [
            {
                id: 24,
                geometry: { type:'Point', coordinates:[-90,45] },
                properties: {
                    title: 'test',
                    start_time: 1000000
                }
            }
        ]
    };
    describe('loadFromGeoJSON', function() {
        it('works', function() {
            var loaded = pins.loadFromGeoJSON(geojson);
            expect(loaded.length).toBe(1);
            var sp = loaded[0];
            expect(sp.id).toBe(24);
            expect(sp.getGeometry().getCoordinates()[0]).toBe(-90);
            expect(sp.getGeometry().getCoordinates()[1]).toBe(45);
            expect(sp.start_time).toBe(1000000000);
            expect(sp.end_time).toBe(null);
        });
        it('works with projection', function() {
            var loaded = pins.loadFromGeoJSON(geojson, ol.proj.get('EPSG:3857'));
            var sp = loaded[0];
            expect(sp.getGeometry().getCoordinates()[0]).toBe(-10018754.171394622);
            expect(sp.getGeometry().getCoordinates()[1]).toBe(5621521.486192066);
        });
    });
    describe('toGeoJSON', function() {
        it('works', function() {
            // to do this correctly, we need to understand the current projection
            // this test just verifies the ol3 format works properly
            var format = new ol.format.GeoJSON({
                defaultDataProjection: 'EPSG:4326'
            });
            var sp = new pins.StoryPin({
                title: 'test',
                the_geom: '{"type":"Point","coordinates":[123,321]}',
                id: 22
            });
            var sp = format.readFeature(format.writeFeature(sp));
            expect(sp.get('title')).toBe('test');
            expect(sp.getId()).toBe(22);
            var coords = sp.getGeometry().getCoordinates();
            expect(coords[0]).toBe(123);
            expect(coords[1]).toBe(321);
        });
    });
});

},{"../lib/core/time/pins.js":9}],67:[function(require,module,exports){
storytools = {
    core: require('../lib/core/index.js')
};
require('../lib/ng/core/pins/module.js');

describe('test storyPins', function() {
    var StoryPin;
    beforeEach(function() {
        // window.angular.mock.module is work around browserify conflict
        window.angular.mock.module('storytools.core.pins');

        inject(function($injector) {
            StoryPin = $injector.get('StoryPin');
        });
    });

    describe('StoryPinLayerManager', function() {

    });

});
},{"../lib/core/index.js":3,"../lib/ng/core/pins/module.js":18}],68:[function(require,module,exports){
require('../lib/ng/edit/style/services/styleChoices.js');

describe('test styleChoices', function() {

    beforeEach(function() {
        window.angular.mock.module('storytools.edit.style.styleChoices');
    });

    describe('stRecentChoices works', function() {
        beforeEach(function() {

            inject(function($injector) {
                stRecentChoices = $injector.get('stRecentChoices');
            });
        });
        it('should store recent icons', function() {
            var icons = stRecentChoices.icons;
            icons.clear();
            icons.add('a');
            expect(icons.recent).toEqual(['a']);
            icons.add('b');
            expect(icons.recent).toEqual(['a', 'b']);
            icons.add('b');
            expect(icons.recent).toEqual(['a', 'b']);
            var others = 'cdefghijklmonpqrstuvxyz';
            for (var i=0; i<others.length;i++) {
                icons.add(others[i]);
            }
            expect(icons.recent.length).toBe(icons._max);
            // this assertion is based on the assumption of _max=24...
            expect(icons.recent[0]).toBe('b');
        });
    });
});
},{"../lib/ng/edit/style/services/styleChoices.js":24}],69:[function(require,module,exports){
require('../lib/ng/edit/style/directives/directives.js');
require('../lib/ng/edit/style/services/iconCommons.js');
require('../lib/ng/edit/style/services/styleChoices.js');
require('../lib/ng/core/style/ol3StyleConverter.js');
require('../lib/ng/core/style/svgIcon.js');
helpers = require('./helpers.js');
$ = require('../bower_components/jquery/dist/jquery.js');

describe('test style directives', function() {

    beforeEach(function() {
        // @todo mock dependency for now - used by graphicEditor
        window.angular.mock.module(function($provide) {
            $provide.value('$modal', {open: new Function()});
        });

        // window.angular.mock.module is work around browserify conflict
        window.angular.mock.module('storytools.edit.style.directives');
        window.angular.mock.module('storytools.allTemplates');
        window.angular.mock.module('storytools.edit.style.styleChoices');
        window.angular.mock.module('storytools.edit.style.iconCommons');
        window.angular.mock.module('storytools.core.style.ol3StyleConverter');
        window.angular.mock.module('storytools.core.style.svgIcon');

        inject(helpers.inject);
    });

    describe('attribute-combo', function() {
        it('should filter attributes', function() {
            var attributes = [
                {name: 's', type: 'string'},
                {name: 'i', type: 'integer'},
                {name: 'd', type: 'double'},
                {name: 't', type: 'dateTime'},
                {name: 'g', type: 'geom', typeNS:'http://www.opengis.net/gml'}
            ];
            var scope = {
                layer: {
                    get: function() {
                        return attributes;
                    }
                }
            };
            function attributeText(el) {
                // extract attribute text from elements disregarding the first
                return angular.element(el.find('li').splice(1)).text();
            }
            // expecting all attributes
            var el = helpers.compile("<attribute-combo layer=layer></attribute-combo>", scope);
            expect(attributeText(el)).toBe('dgist');
            // exclude geom
            el = helpers.compile("<attribute-combo filter=nogeom layer=layer></attribute-combo>", scope);
            expect(attributeText(el)).toBe('dist');
            // include string and integer
            el = helpers.compile("<attribute-combo include='string,integer' layer=layer></attribute-combo>", scope);
            expect(attributeText(el)).toBe('is');
        });
    });

    describe('number editor', function() {
        it('should bind and edit', function() {
            var el = helpers.compile("<number-editor st-model='thing' property='value'></number-editor>", {thing: {value: 42}});
            expect(el.find('button').text().trim()).toBe('42');
            helpers.setInputValue(el.find('input'), '13');
            expect(helpers.getScope(el).thing.value).toBe(13);
        });
    });

    describe('color editor', function() {
        it('should bind and edit', function() {
            var el = helpers.compile("<color-editor st-model='thing' property='value'></color-editor>", {thing: {value: '#faa'}});
            expect(el.find('i').css('backgroundColor')).toBe('rgb(255, 170, 170)');
            helpers.setInputValue(el.find('input'), '#aaa');
            expect(helpers.getScope(el).thing.value).toBe('#aaa');
            expect(el.find('i').css('backgroundColor')).toBe('rgb(170, 170, 170)');
        });
    });

    describe('graphic-editor', function() {
        beforeEach(inject(function($injector) {
            stRecentChoices = $injector.get('stRecentChoices');
            // clear these as they may trigger http requests
            stRecentChoices.icons.clear();
        }));
        it('should bind and edit marks', function() {
            var el = helpers.compile("<graphic-editor symbol='thing'></graphic-editor>", {thing: {shape: 'circle'}});
            // @todo not a great test - instead of using a canvas, this could be an image w/ data URI
            expect(el.find('span canvas').attr('mark')).toBe('circle');
            angular.forEach(el.find('canvas'), function(e) {
                e = angular.element(e);
                if (e.attr('mark') == 'square') {
                    e.triggerHandler('click');
                }
            });
            expect(el.find('span canvas').attr('mark')).toBe('square');
        });
        describe('works with icon commons', function() {
            // extra gnarl - rendering of the recent-icons requires some
            // mock http to talk to the iconCommons and wait until the
            // directive updates itself - see whenReady
            beforeEach(inject(function($injector) {
                $httpBackend = $injector.get('$httpBackend');
                stRecentChoices = $injector.get('stRecentChoices');
                $q = $injector.get('$q');
                $timeout = $injector.get('$timeout');

                stRecentChoices.icons.add('/item1.svg');
                stRecentChoices.icons.add('/item2.svg');
                // mock requests for the icons
                $httpBackend.when('GET', '/item1.svg').respond('<svg></svg>', {'Content-Type': 'text/xml'});
                $httpBackend.when('GET', '/item2.svg').respond('<svg></svg>', {'Content-Type': 'text/xml'});
            }));
            // return a promise that will resolve once the http requests have
            // completed and the recent icons have been set in the scope
            function whenReady(el, $httpBackend) {
                // grab the directive scope and watch for svg icons to resolve before running tests
                var scope = helpers.getScope(el.children());
                var loaded = $q.defer();
                scope.$watch('recent', function() {
                    loaded.resolve(true);
                });
                // flush pending requests
                $httpBackend.flush();
                return loaded.promise;
            }
            // IMPORTANT : for all tests here, if `done` is not called, jasmine will timeout -
            // this will cover the failure case. see: http://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support
            // IMPORTANT: $timeout.flush() is required to trigger promise resolution
            it('should bind to recent choices', function(done) {
                var el = helpers.compile("<graphic-editor symbol='thing'></graphic-editor>", {thing: {}});
                whenReady(el, $httpBackend).then(function() {
                    var img = el.find('.recent-icons img');
                    expect(img.length).toBe(2);
                    done();
                });
                $timeout.flush();
            });
            it('should update with change in recent choices', function(done) {
                var el = helpers.compile("<graphic-editor symbol='thing'></graphic-editor>", {thing: {}});

                whenReady(el, $httpBackend).then(function() {
                    var img = el.find('.recent-icons img');
                    expect(img.length).toBe(2);
                    expect(img.attr('src').indexOf('data:image/svg+xml;base64,')).toBe(0);

                    // because we're already in the digest, call this with a timeout
                    $timeout(function() {
                        // queue up expected request
                        $httpBackend.when('GET', '/item3.svg').respond('<svg></svg>', {'Content-Type': 'text/xml'});
                        // and add this recent choice (normally would be from user selecting from icon-commons dialog
                        stRecentChoices.icons.add('/item3.svg');
                        // this triggers an update as if user used the dialog
                        helpers.getScope(el.children())._updateRecent();
                        // there should be 3 icons now
                        whenReady(el, $httpBackend).then(function() {
                            var img = el.find('.recent-icons img');
                            expect(img.length).toBe(3);
                            done();
                        });
                    });
                });
                $timeout.flush();
            });
            it('should bind and edit svg', function(done) {
                var el = helpers.compile("<graphic-editor symbol='thing'></graphic-editor>", {thing: {graphic: '/item1.svg'}});
                whenReady(el, $httpBackend).then(function() {
                    var img = el.find('.recent-icons img');
                    expect(img.length).toBe(2);
                    expect(img.attr('src').indexOf('data:image/svg+xml;base64,')).toBe(0);
                    done();
                });
                $timeout.flush();
            });

        });
    });

    describe('label-editor', function() {
        it('should bind and edit attribute', function() {
            var label = {
                "attribute": null,
                "fillColor": "#000000",
                "fontFamily": "Serif",
                "fontSize": 10,
                "fontStyle": "normal",
                "fontWeight": "normal"
            };
            var attributes = [
                {name: 'a', type: 'string'},
                {name: 'b', type: 'integer'}
            ];
            var el = helpers.compile("<label-editor layer=layer st-model='thing'></graphic-editor>", {
                thing: {label: label},
                layer: {
                    get: function() {
                        // mock attributes
                        return attributes;
                    }
                }
            });
            expect(el.find('.dropdown-toggle').eq(0).text().trim()).toBe('Select Attribute');
            helpers.click(el.find('.dropdown-menu').eq(0).find('li').eq(1));
            expect(label.attribute).toBe('a');
        });
    });

    describe('classify-editor', function() {
        var classify, el;
        beforeEach(function() {
            classify = {
                method: null,
                attribute: null,
                maxClasses: 5,
                range: {
                    min: 0,
                    max: 16
                }
            };
            var attributes = [
                {name: 'a', type: 'string'},
                {name: 'b', type: 'integer'}
            ];
            el = helpers.compile("<classify-editor show-max-classes=true show-fixed-classes></classify-editor>", {
                layer: {
                    get: function() {
                        return attributes;
                    }
                },
                activeStyle: {classify: classify},
                changeClassifyProperty: function(prop, val) {
                    classify[prop] = val;
                },
                showMaxClasses: true,
                showFixedClasses: true
            });
        });
        it('should bind and edit attribute', function() {
            helpers.click(el.find('ul.dropdown-menu li').get(1));
            expect(classify.attribute).toBe('a');
        });
        it('should bind and edit maxClasses', function() {
            helpers.setInputValue(el.find('[ng-if=showMaxClasses] input').eq(0), '7');
            expect(classify.maxClasses).toBe(7);
        });
    });

    describe('stroke-editor', function() {
        it('has a smoke test', function() {
            var el = helpers.compile("<stroke-editor st-model='thing'></stroke-editor>", {thing: {stroke: {}}});
            expect(el.children().length).toBe(1);
        });
    });

    describe('rules-editor', function() {
        it('has a smoke test', function() {
            var el = helpers.compile("<rules-editor></rules-editor>", {});
            expect(el.children().length).toBe(1);
        });
    });

    describe('symbol-editor', function() {
        it('has a smoke test', function() {
            var el = helpers.compile("<symbol-editor st-model='thing'></symbol-editor>", {thing: {symbol: {}}});
            expect(el.children().length).toBe(1);
        });
    });
});

},{"../bower_components/jquery/dist/jquery.js":2,"../lib/ng/core/style/ol3StyleConverter.js":19,"../lib/ng/core/style/svgIcon.js":20,"../lib/ng/edit/style/directives/directives.js":22,"../lib/ng/edit/style/services/iconCommons.js":23,"../lib/ng/edit/style/services/styleChoices.js":24,"./helpers.js":57}],70:[function(require,module,exports){
require('../lib/ng/edit/style/services/styleRuleBuilder.js');
require('../lib/ng/edit/style/services/styleChoices.js');
require('../lib/ng/edit/style/services/styleTypes.js');

describe('styleRuleBuilder', function() {

    beforeEach(function() {
        // window.angular.mock.module is work around browserify conflict
        window.angular.mock.module('storytools.edit.style.styleRuleBuilder');
        window.angular.mock.module('storytools.edit.style.styleChoices');
        window.angular.mock.module('storytools.edit.style.styleTypes');

        inject(function(stStyleRuleBuilder) {
            this.stStyleRuleBuilder = stStyleRuleBuilder;
        });
    });

    it('should pick values from a 2-stop color ramp', inject(function(stStyleRuleBuilder) {
        vals = stStyleRuleBuilder._colorRampValues({0:'#ff0000',1:'#0000ff'},2);
        expect(vals.length).toBe(2);
        expect(vals).toEqual(['#ff0000','#0000ff']);
    }));

    it('should pick values from a 3-stop color ramp', inject(function(stStyleRuleBuilder) {
        vals = stStyleRuleBuilder._colorRampValues({0:'#ff0000',1:'#0000ff'},3);
        expect(vals.length).toBe(3);
        expect(vals).toEqual(['#ff0000', '#7f007f', '#0000ff']);
    }));
});
},{"../lib/ng/edit/style/services/styleChoices.js":24,"../lib/ng/edit/style/services/styleRuleBuilder.js":25,"../lib/ng/edit/style/services/styleTypes.js":26}],71:[function(require,module,exports){
require('../lib/ng/edit/time/directives.js');
helpers = require('./helpers.js');

describe('test time directives', function() {

    beforeEach(function() {
        // window.angular.mock.module is work around browserify conflict
        window.angular.mock.module('storytools.edit.time.directives');
        window.angular.mock.module('storytools.allTemplates');

        inject(helpers.inject);
    });

    describe('st-date-time-field directive', function() {
        it('should handle epoch properly', function() {
            var el = helpers.compile('<st-date-time-field date-time="value"></st-date-time-field>', {
                value: 0
            });
            input = el.find('input');
            expect(input.val()).toBe('1970-01-01T00:00:00.000Z');
        });
    });
});
},{"../lib/ng/edit/time/directives.js":27,"./helpers.js":57}],72:[function(require,module,exports){
storytools = {
    core: require('../lib/core/index.js')
};
require('../lib/ng/core/time/services.js');

describe('test time services', function() {

    beforeEach(function() {
        window.angular.mock.module('storytools.core.time.services');
    });

    describe('TimeMachine works', function() {
        function timeLayers() {
            var layers = [];
            Array.prototype.slice.call(arguments).forEach(function(data) {
                layers.push({
                    get: function() {
                        return data;
                    }
                });
            });
            return layers;
        }
        beforeEach(function() {

            inject(function($injector) {
                TimeMachine = $injector.get('TimeMachine');
            });
        });
        it('should compute ticks', function() {
            layers = timeLayers(
                [1, 10, 1000],
                [10000, 10, 10]
            );
            expect(TimeMachine.computeTicks(layers)).toEqual([ 1, 10, 1000, 10000 ]);

            layers = timeLayers(
                [10000, 40000],
                [20000, 30000],
                new storytools.core.time.utils.Interval({start: 5000, end: 50000, duration:'P5S'})
            );
            var results = [];
            for (var i = 5000; i <= 50000; i+= 5000 ) {
                results.push(i);
            }
            expect(TimeMachine.computeTicks(layers)).toEqual(results);
        });
    });
});

},{"../lib/core/index.js":3,"../lib/ng/core/time/services.js":21}],73:[function(require,module,exports){
var utils = require('../lib/core/time/utils.js');
var moment = require('moment');

/*
NOTE - numeric values in these tests (and the API) are all milliseconds
       despite looking like years - party like it's "1970-01-01T00:00:01.999Z"!
*/
describe("test utils", function() {
    it("tests finding", function() {
        var data = [1,5,10];
        expect(utils.find(data, 0)).toBe(0);
        expect(utils.find(data, 1)).toBe(0);
        expect(utils.find(data, 2)).toBe(0);
        expect(utils.find(data, 5)).toBe(1);
        expect(utils.find(data, 6)).toBe(1);
        expect(utils.find(data, 10)).toBe(2);
        expect(utils.find(data, 11)).toBe(2);
    });
    describe("range", function() {
        it("createRange works", function() {
            var r;
            // text
            r = utils.createRange('2000', '2001');
            expect(r.start).toBe(Date.parse('2000'));
            expect(r.end).toBe(Date.parse('2001'));
            // numbers (millis)
            r = utils.createRange(2000, 2003);
            expect(r.start).toBe(2000);
            expect(r.end).toBe(2003);
            // copy
            r = utils.createRange(r);
            expect(r.start).toBe(2000);
            expect(r.end).toBe(2003);
            // single arg
            r = utils.createRange(1999);
            expect(r.start).toBe(1999);
            expect(r.end).toBe(1999);
            // null 1st arg (open range)
            r = utils.createRange(1999, null);
            expect(r.start).toBe(1999);
            expect(r.end).toBe(null);
            // null 2nd arg (open range)
            r = utils.createRange(null, 6789);
            expect(r.start).toBe(null);
            expect(r.end).toBe(6789);
        });
        it("basics work", function() {
            var r = utils.createRange(2000, 2003);
            expect(r.center()).toBe(2001);
            expect(r.width()).toBe(3);
        });
        it("extend works", function() {
            var r = utils.createRange(2000, 2003);
            // idempotent
            r.extend(r);
            expect(r.start).toBe(2000);
            expect(r.end).toBe(2003);
            // single left
            r.extend(1995);
            expect(r.start).toBe(1995);
            expect(r.end).toBe(2003);
            // single right
            r.extend(2004);
            expect(r.start).toBe(1995);
            expect(r.end).toBe(2004);
            // both sides
            r.extend(utils.createRange(1900, 2010));
            expect(r.start).toBe(1900);
            expect(r.end).toBe(2010);
            // start with nothing, extend w/ nothing
            r = utils.createRange(null, null);
            r.extend(r = utils.createRange(null, null));
            expect(r.isEmpty()).toBe(true);
            // starting with nothing, extend open-ended start
            r = utils.createRange(null, null);
            r.extend(utils.createRange(1234, null));
            expect(r.start).toBe(1234);
            expect(r.end).toBe(1234);
            // starting with nothing, extend open-ended end
            r = utils.createRange(null, null);
            r.extend(utils.createRange(null, 5678));
            expect(r.start).toBe(5678);
            expect(r.end).toBe(5678);
        });
        it("intersects works with instants", function() {
            var r = utils.createRange(2000, 2003);
            expect(r.intersects(1999)).toBe(false);
            expect(r.intersects(2000)).toBe(true);
            expect(r.intersects(2001)).toBe(true);
            expect(r.intersects(2003)).toBe(false);
            // instant range, too
            r = utils.createRange(2000, 2000);
            expect(r.intersects(2000)).toBe(true);
        });
        it("intersects works on open range with instants", function() {
            var r = utils.createRange(null, 2003);
            expect(r.intersects(1999)).toBe(true);
            expect(r.intersects(2004)).toBe(false);
            r = utils.createRange(2003, null);
            expect(r.intersects(1999)).toBe(false);
            expect(r.intersects(2004)).toBe(true);
        });
        it("intersects works on instant range with open ranges", function() {
            var r = utils.createRange(2003, 2003);
            expect(r.intersects(utils.createRange(1999, null))).toBe(true);
            expect(r.intersects(utils.createRange(null, 2004))).toBe(true);
            expect(r.intersects(utils.createRange(2004, null))).toBe(false);
            expect(r.intersects(utils.createRange(null, 2002))).toBe(false);
        });
        it("intersects works with extents", function() {
            var r = utils.createRange(2000, 2003);
            expect(r.intersects(utils.createRange(1999, 2000))).toBe(true);
            expect(r.intersects(utils.createRange(2000, 2001))).toBe(true);
            expect(r.intersects(utils.createRange(2002, 2003))).toBe(true);
            expect(r.intersects(utils.createRange(1999, 2003))).toBe(true);
            expect(r.intersects(utils.createRange(1999, 2004))).toBe(true);
            expect(r.intersects(utils.createRange(2004, 2005))).toBe(false);
            expect(r.intersects(utils.createRange(1998, 1999))).toBe(false);
        });
        it("isRangeLike works", function() {
            expect(utils.isRangeLike(null)).toBe(false);
            expect(utils.isRangeLike(undefined)).toBe(false);
            expect(utils.isRangeLike('x')).toBe(false);
            expect(utils.isRangeLike(22)).toBe(false);
            expect(utils.isRangeLike({start:1})).toBe(true);
            expect(utils.isRangeLike({end:1})).toBe(true);
            expect(utils.isRangeLike({start:1, end:1})).toBe(true);
        });
    });
    it("tests interval picking", function() {
        expect(utils.pickInterval(utils.createRange('2000','2001'))).toBe(
            moment.duration(1, 'months').asMilliseconds()
        );
        expect(utils.pickInterval(utils.createRange('2000-01-01','2000-02-01'))).toBe(
            moment.duration(1, 'weeks').asMilliseconds()
        );
    });
    it("tests compute range works", function() {
        var r = utils.computeRange([utils.createRange(100,200)]);
        expect(r.start).toBe(100);
        expect(r.end).toBe(200);
        r = utils.computeRange([utils.createRange(100,400), utils.createRange(100,300)]);
        expect(r.start).toBe(100);
        expect(r.end).toBe(400);
        r = utils.computeRange([20,10,50]);
        expect(r.start).toBe(10);
        expect(r.end).toBe(50);
    });
    it("tests createOffsetter works", function() {
        function offsetAsISO(timestamp, duration) {
            return new Date(utils.createOffsetter(duration)(timestamp)).toISOString();
        }
        expect(offsetAsISO('1970', 'P1Y')).toBe('1971-01-01T00:00:00.000Z');
        expect(offsetAsISO('1970-06-01', 'P1Y1M')).toBe('1971-07-01T00:00:00.000Z');
        expect(offsetAsISO('1974-02-28T12:24', 'P2Y2M')).toBe('1976-04-28T12:24:00.000Z');
        expect(offsetAsISO('1974-02-28T12:24', 'P2Y2M')).toBe('1976-04-28T12:24:00.000Z');
        // verify current algorithm fails - jan 31st + 1month wraps into march
        expect(offsetAsISO('1974-01-31T12:24', 'P2Y1M')).toBe('1976-03-02T12:24:00.000Z');
    });
        it("parseISODuration should throw sometimes", function() {
        expect(function() {
            utils.parseISODuration('TP1M');
        }).toThrowError('expected P as starting duration : TP1M');
        expect(function() {
            utils.parseISODuration('P1X');
        }).toThrowError('unknown duration specifier : X');
    });
    it("parseISODuration should parse correctly", function() {
        expect(utils.parseISODuration('PT1S')).toBe(1000);
        expect(utils.parseISODuration('PT1M')).toBe(60000);
        expect(utils.parseISODuration('PT1H')).toBe(3600000);
        expect(utils.parseISODuration('P1D')).toBe(86400000);
        expect(utils.parseISODuration('P1W')).toBe(604800000);
        expect(utils.parseISODuration('P1M')).toBe(2592000000);
        expect(utils.parseISODuration('P1Y')).toBe(31536000000);
        expect(utils.parseISODuration('P1MT1M')).toBe(2592000000 + 60000);
    });
});

},{"../lib/core/time/utils.js":11,"moment":28}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJ0ZXN0L3Rlc3RzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJsaWIvY29yZS9pbmRleC5qcyIsImxpYi9jb3JlL3RpbWUvYm94ZXMuanMiLCJsaWIvY29yZS90aW1lL2NvbnRyb2xzLmpzIiwibGliL2NvcmUvdGltZS9saW5lLmpzIiwibGliL2NvcmUvdGltZS9tYXBzLmpzIiwibGliL2NvcmUvdGltZS9tb2RlbHMuanMiLCJsaWIvY29yZS90aW1lL3BpbnMuanMiLCJsaWIvY29yZS90aW1lL3NsaWRlci5qcyIsImxpYi9jb3JlL3RpbWUvdXRpbHMuanMiLCJsaWIvZWRpdC9zdHlsZS9TTERTdHlsZUNvbnZlcnRlci5qcyIsImxpYi9lZGl0L3N0eWxlL1N0eWxlQ29tcGxldGUuanMiLCJsaWIvZWRpdC9zdHlsZS9XRlNEZXNjcmliZUZlYXR1cmVUeXBlLmpzIiwibGliL2VkaXQvc3R5bGUvV1BTQ2xhc3NpZnkuanMiLCJsaWIvbWFwc3RvcnkvTWFwQ29uZmlnVHJhbnNmb3JtZXIuanMiLCJsaWIvbmcvY29yZS9vZ2MvbW9kdWxlLmpzIiwibGliL25nL2NvcmUvcGlucy9tb2R1bGUuanMiLCJsaWIvbmcvY29yZS9zdHlsZS9vbDNTdHlsZUNvbnZlcnRlci5qcyIsImxpYi9uZy9jb3JlL3N0eWxlL3N2Z0ljb24uanMiLCJsaWIvbmcvY29yZS90aW1lL3NlcnZpY2VzLmpzIiwibGliL25nL2VkaXQvc3R5bGUvZGlyZWN0aXZlcy9kaXJlY3RpdmVzLmpzIiwibGliL25nL2VkaXQvc3R5bGUvc2VydmljZXMvaWNvbkNvbW1vbnMuanMiLCJsaWIvbmcvZWRpdC9zdHlsZS9zZXJ2aWNlcy9zdHlsZUNob2ljZXMuanMiLCJsaWIvbmcvZWRpdC9zdHlsZS9zZXJ2aWNlcy9zdHlsZVJ1bGVCdWlsZGVyLmpzIiwibGliL25nL2VkaXQvc3R5bGUvc2VydmljZXMvc3R5bGVUeXBlcy5qcyIsImxpYi9uZy9lZGl0L3RpbWUvZGlyZWN0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9saWIvRGF0YVNldC5qcyIsIm5vZGVfbW9kdWxlcy92aXMvbGliL0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9saWIvaGFtbWVyVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy92aXMvbGliL21vZHVsZS9oYW1tZXIuanMiLCJub2RlX21vZHVsZXMvdmlzL2xpYi9tb2R1bGUvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9saWIvc2hhcmVkL0FjdGl2YXRvci5qcyIsIm5vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL0NvcmUuanMiLCJub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9SYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvVGltZVN0ZXAuanMiLCJub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9UaW1lbGluZS5qcyIsIm5vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9Db21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQ3VycmVudFRpbWUuanMiLCJub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQ3VzdG9tVGltZS5qcyIsIm5vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9Hcm91cC5qcyIsIm5vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9JdGVtU2V0LmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L1RpbWVBeGlzLmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vQmFja2dyb3VuZEl0ZW0uanMiLCJub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9Cb3hJdGVtLmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vSXRlbS5qcyIsIm5vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL1BvaW50SXRlbS5qcyIsIm5vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL1JhbmdlSXRlbS5qcyIsIm5vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2xvY2FsZXMuanMiLCJub2RlX21vZHVsZXMvdmlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9ub2RlX21vZHVsZXMvZW1pdHRlci1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlzL25vZGVfbW9kdWxlcy9oYW1tZXJqcy9oYW1tZXIuanMiLCJub2RlX21vZHVsZXMvdmlzL25vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9ub2RlX21vZHVsZXMvbW91c2V0cmFwL21vdXNldHJhcC5qcyIsInRlc3QvaGVscGVycy5qcyIsInRlc3QvdGVzdC1NYXBDb25maWdUcmFuc2Zvcm1lci5qcyIsInRlc3QvdGVzdC1TTERTdHlsZUNvbnZlcnRlci5qcyIsInRlc3QvdGVzdC1TdHlsZUNvbXBsZXRlLmpzIiwidGVzdC90ZXN0LVdGU0Rlc2NyaWJlRmVhdHVyZVR5cGUuanMiLCJ0ZXN0L3Rlc3QtV1BTQ2xhc3NpZnkuanMiLCJ0ZXN0L3Rlc3QtYm94ZXMuanMiLCJ0ZXN0L3Rlc3QtbWFwcy5qcyIsInRlc3QvdGVzdC1vbDNTdHlsZUNvbnZlcnRlci5qcyIsInRlc3QvdGVzdC1waW5zLmpzIiwidGVzdC90ZXN0LXN0b3J5UGlucy5qcyIsInRlc3QvdGVzdC1zdHlsZUNob2ljZXMuanMiLCJ0ZXN0L3Rlc3Qtc3R5bGVEaXJlY3RpdmVzLmpzIiwidGVzdC90ZXN0LXN0eWxlUnVsZUJ1aWxkZXIuanMiLCJ0ZXN0L3Rlc3QtdGltZURpcmVjdGl2ZXMuanMiLCJ0ZXN0L3Rlc3QtdGltZVNlcnZpY2VzLmpzIiwidGVzdC90ZXN0LXV0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMTFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsbUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbDdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3phQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5NENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDam5FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy94QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJyZXF1aXJlKCcuL3Rlc3QtdXRpbHMnKTtcbnJlcXVpcmUoJy4vdGVzdC1tYXBzJyk7XG5yZXF1aXJlKCcuL3Rlc3QtYm94ZXMnKTtcbnJlcXVpcmUoJy4vdGVzdC1zdHlsZVJ1bGVCdWlsZGVyJyk7XG5yZXF1aXJlKCcuL3Rlc3Qtb2wzU3R5bGVDb252ZXJ0ZXInKTtcbnJlcXVpcmUoJy4vdGVzdC1TTERTdHlsZUNvbnZlcnRlcicpO1xucmVxdWlyZSgnLi90ZXN0LVdQU0NsYXNzaWZ5Jyk7XG5yZXF1aXJlKCcuL3Rlc3Qtc3R5bGVEaXJlY3RpdmVzLmpzJyk7XG5yZXF1aXJlKCcuL3Rlc3QtdGltZURpcmVjdGl2ZXMuanMnKTtcbnJlcXVpcmUoJy4vdGVzdC1zdHlsZUNob2ljZXMuanMnKTtcbnJlcXVpcmUoJy4vdGVzdC1TdHlsZUNvbXBsZXRlLmpzJyk7XG5yZXF1aXJlKCcuL3Rlc3Qtc3RvcnlQaW5zLmpzJyk7XG5yZXF1aXJlKCcuL3Rlc3QtdGltZVNlcnZpY2VzLmpzJyk7XG5yZXF1aXJlKCcuL3Rlc3QtTWFwQ29uZmlnVHJhbnNmb3JtZXIuanMnKTtcbnJlcXVpcmUoJy4vdGVzdC1XRlNEZXNjcmliZUZlYXR1cmVUeXBlLmpzJyk7XG5yZXF1aXJlKCcuL3Rlc3QtcGlucy5qcycpO1xuIiwiLyplc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyovXG4vKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMS4wXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDctMDdUMjE6NDRaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMgd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4xLjBcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0cmV0dXJuIG51bSAhPSBudWxsID9cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOlxuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0XHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdFx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0XHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdERPTUV2YWwoIGNvZGUgKTtcblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuMFxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDEtMDRcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFx4ODAtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOlxuXHQvLyBJRTogKltkaXNhYmxlZF06bm90KGJ1dHRvbiwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIG9wdGdyb3VwLCBvcHRpb24sIG1lbnVpdGVtLCBmaWVsZHNldClcblx0Ly8gbm90IElFOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9ybSBlbGVtZW50cyBhbmQgb3B0aW9uIGVsZW1lbnRzIGZvciBleHBsaWNpdCBkaXNhYmxpbmdcblx0XHRyZXR1cm4gXCJsYWJlbFwiIGluIGVsZW0gJiYgZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblx0XHRcdFwiZm9ybVwiIGluIGVsZW0gJiYgZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0Ly8gQ2hlY2sgbm9uLWRpc2FibGVkIGZvcm0gZWxlbWVudHMgZm9yIGZpZWxkc2V0W2Rpc2FibGVkXSBhbmNlc3RvcnNcblx0XHRcdFwiZm9ybVwiIGluIGVsZW0gJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgJiYgKFxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTYtMTErXG5cdFx0XHRcdC8vIEFuY2VzdHJ5IGlzIGNvdmVyZWQgZm9yIHVzXG5cdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGFzc3VtZSBhbnkgbm9uLTxvcHRpb24+IHVuZGVyIGZpZWxkc2V0W2Rpc2FibGVkXSBpcyBkaXNhYmxlZFxuXHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHQoXCJsYWJlbFwiIGluIGVsZW0gfHwgIWRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSkgIT09IGRpc2FibGVkXG5cdFx0XHQpO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbmQgYW5kIGZpbHRlclxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIG0gPyBbIG0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIFN1cHBvcnQ6IElFNi83XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdGRlbGV0ZSBFeHByLmZpbmRbXCJJRFwiXTtcblxuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdFx0XHRFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdCAmJiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdHdoaXRlID0gKCAvXFxTKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIGpRdWVyeS50eXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0XHRyZXNvbHZlLmNhbGwoIHVuZGVmaW5lZCwgdmFsdWUgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuY2FsbCggdW5kZWZpbmVkLCB2YWx1ZSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0ICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGpRdWVyeS5jYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBKU09OLnBhcnNlKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICksXG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBtYXRjaGVzLCBzZWwsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MClcblx0XHQvL1xuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGluIEZGIGJ1dCBkb24ndCBibG9jayBJRSByYWRpbyBldmVudHMgKCMzODYxLCBnaC0yMzQzKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiZcblx0XHRcdCggZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiIHx8IGlzTmFOKCBldmVudC5idXR0b24gKSB8fCBldmVudC5idXR0b24gPCAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgKCBjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogdGhpcywgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGpRdWVyeS5pc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdGpRdWVyeS5ub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcImJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwidG9wOjElO3dpZHRoOjUwJVwiO1xuXHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IGRpdlN0eWxlLm1hcmdpbkxlZnQgPT09IFwiMnB4XCI7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjUwJVwiO1xuXHRcdHBpeGVsTWFyZ2luUmlnaHRWYWwgPSBkaXZTdHlsZS5tYXJnaW5SaWdodCA9PT0gXCI0cHhcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHBpeGVsTWFyZ2luUmlnaHRWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O1wiICtcblx0XHRcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbE1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxNYXJnaW5SaWdodFZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgKCMxMjUzNylcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGkgPSBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApID9cblxuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbCxcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRpZiAoIGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0dmFsID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVsgbmFtZSBdO1xuXHR9XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiByYWYoKSB7XG5cdGlmICggdGltZXJJZCApIHtcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByYWYgKTtcblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1lcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdGpRdWVyeS5wcm94eSggcmVzdWx0LnN0b3AsIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmIG9yIGlmIGRvY3VtZW50IGlzIGhpZGRlblxuXHRpZiAoIGpRdWVyeS5meC5vZmYgfHwgZG9jdW1lbnQuaGlkZGVuICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRvcHQuZHVyYXRpb24gPSB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID9cblx0XHRcdG9wdC5kdXJhdGlvbiA6IG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID9cblx0XHRcdFx0alF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgP1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmFmICkgOlxuXHRcdFx0d2luZG93LnNldEludGVydmFsKCBqUXVlcnkuZngudGljaywgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGlmICggd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSggdGltZXJJZCApO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cdH1cblxuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGFiaW5kZXggP1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG52YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIFwiIFwiICsgY3VyVmFsdWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBnZXRDbGFzcyggZWxlbSApICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZyxcblx0cnNwYWNlcyA9IC9bXFx4MjBcXHRcXHJcXG5cXGZdKy9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApIDpcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0alF1ZXJ5LnRyaW0oIGpRdWVyeS50ZXh0KCBlbGVtICkgKS5yZXBsYWNlKCByc3BhY2VzLCBcIiBcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0cmV0dXJuIHZhbCA9PSBudWxsID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVuY2FjaGVkIHVybCBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIlwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbiwgcmVjdCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBlbGVtZW50IGlzIG5vdCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpXG5cdFx0aWYgKCByZWN0LndpZHRoIHx8IHJlY3QuaGVpZ2h0ICkge1xuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0d2luID0gZ2V0V2luZG93KCBkb2MgKTtcblx0XHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdHJldHVybiByZWN0O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LFxuXHRcdC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0ID0ge1xuXHRcdFx0XHR0b3A6IHBhcmVudE9mZnNldC50b3AgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICksXG5cdFx0XHRcdGxlZnQ6IHBhcmVudE9mZnNldC5sZWZ0ICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsImV4cG9ydHMudGltZSA9IHJlcXVpcmUoJy4vdGltZS9jb250cm9scycpO1xuZXhwb3J0cy5tYXBzID0gcmVxdWlyZSgnLi90aW1lL21hcHMnKTtcbmV4cG9ydHMubWFwcy5waW5zID0gcmVxdWlyZSgnLi90aW1lL3BpbnMnKTtcbmV4cG9ydHMubWFwcy5ib3hlcyA9IHJlcXVpcmUoJy4vdGltZS9ib3hlcycpO1xuZXhwb3J0cy51dGlscyA9IHJlcXVpcmUoJy4vdGltZS91dGlscycpO1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBCb3gob3B0aW9ucykge1xuICAgIHRoaXMucmFuZ2UgPSBvcHRpb25zLnJhbmdlIHx8IG51bGw7XG4gICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhIHx8IG51bGw7XG4gICAgdGhpcy5sYXllcklkcyA9IG9wdGlvbnMubGF5ZXJJZHMgfHwgbnVsbDtcbiAgICB0aGlzLmNlbnRlciA9IG9wdGlvbnMuY2VudGVyIHx8IG51bGw7IC8vIG9sLkNvb3JkaW5hdGVcbiAgICB0aGlzLnJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb24gfHwgbnVsbDtcbiAgICB0aGlzLmFsbG93UGFuID0gb3B0aW9ucy5hbGxvd1BhbjtcbiAgICB0aGlzLmFsbG93Wm9vbSA9IG9wdGlvbnMuYWxsb3dab29tO1xuICAgIHRoaXMuc3BlZWQgPSBvcHRpb25zLnNwZWVkOyAgLy8gaW50ZXJ2YWwsIHNlY29uZHNcbiAgICB0aGlzLnRpdGxlID0gb3B0aW9ucy50aXRsZSB8fCAnJztcbiAgICB0aGlzLmlkID0gb3B0aW9ucy5pZCB8fCBuZXcgRGF0ZSgpLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgIHRoaXMuem9vbSA9IG9wdGlvbnMuem9vbSB8fCBudWxsO1xuICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgaWYgKHRoaXMucmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgaWYodGhpcy5kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdXRpbHMuY3JlYXRlUmFuZ2UodGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdXRpbHMuY3JlYXRlUmFuZ2Uob3B0aW9ucy5zdGFydF90aW1lLCBvcHRpb25zLmVuZF90aW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAdG9kbyBwb3NzaWJsZSBkaXZpZGUgYnkgemVybyBpZiBzcGVlZC5pbnRlcnZhbCBub3Qgc2V0IVxuICAgIHRoaXMuX3N0ZXBzID0gdGhpcy5kYXRhID09PSBudWxsID8gTWF0aC5mbG9vcih0aGlzLnJhbmdlLndpZHRoKCkgLyB0aGlzLnNwZWVkLmludGVydmFsKSArIDE6IHRoaXMuZGF0YS5sZW5ndGg7XG59XG5Cb3gucHJvdG90eXBlLmdldFN0ZXBzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXBzO1xufTtcbkJveC5wcm90b3R5cGUuZ2V0UmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZTtcbn07XG5Cb3gucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24oaW5zdGFudCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEgPyB1dGlscy5maW5kKHRoaXMuZGF0YSwgaW5zdGFudCkgOlxuICAgICAgICBNYXRoLmZsb29yKE1hdGgubWluKHRoaXMucmFuZ2Uud2lkdGgoKSwgTWF0aC5tYXgoMCwgaW5zdGFudCAtIHRoaXMucmFuZ2Uuc3RhcnQpKSAvIHRoaXMuc3BlZWQuaW50ZXJ2YWwpO1xufTtcbkJveC5wcm90b3R5cGUuZ2V0RGF0ZSA9IGZ1bmN0aW9uKGlkeCkge1xuICAgIGlkeCA9IGlkeCAtIHRoaXMuX29mZnNldDtcbiAgICByZXR1cm4gdGhpcy5kYXRhID8gdGhpcy5kYXRhW2lkeF0gOiB0aGlzLnJhbmdlLnN0YXJ0ICsgKGlkeCAqIHRoaXMuc3BlZWQuaW50ZXJ2YWwpO1xufTtcblxuXG5mdW5jdGlvbiBnZXRUaW1lKHByb3BzLCBwcm9wKSB7XG4gICAgdmFyIHZhbCA9IHByb3BzW3Byb3BdO1xuICAgIGlmICh0eXBlb2YgdmFsICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB2YWwgKj0gMTAwMDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogTG9hZCBCb3ggZnJvbSBnZW9qc29uLCByZXByb2plY3RpbmcgZnJvbSA0MzI2IHRvIHRoZSBwcm92aWRlZFxuICogcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBnZW9qc29uXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvamVjdGlvblxuICogQHJldHVybnMgYXJyYXkgb2YgQm94IGZlYXR1cmVzXG4gKi9cbmV4cG9ydHMubG9hZEZyb21HZW9KU09OID0gZnVuY3Rpb24oZ2VvanNvbiwgcHJvamVjdGlvbikge1xuICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgIHByb2plY3Rpb24gPSBvbC5wcm9qLmdldChwcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlb2pzb24uZmVhdHVyZXMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIHByb3BzID0gZi5wcm9wZXJ0aWVzO1xuICAgICAgICAvL3Byb3BzLnRoZV9nZW9tID0gZi5nZW9tZXRyeTtcbiAgICAgICAgcHJvcHMuaWQgPSBmLmlkO1xuICAgICAgICBwcm9wcy5zdGFydF90aW1lID0gZ2V0VGltZShwcm9wcywgJ3N0YXJ0X3RpbWUnKTtcbiAgICAgICAgcHJvcHMuZW5kX3RpbWUgPSBnZXRUaW1lKHByb3BzLCAnZW5kX3RpbWUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3gocHJvcHMsIHByb2plY3Rpb24pO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gZmluZEJveChib3hlcywgaWR4KSB7XG4gICAgdmFyIGksIGlpO1xuICAgIHZhciBib3g7XG4gICAgZm9yIChpID0gMCwgaWkgPSBib3hlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGJveCA9IGJveGVzW2ldO1xuICAgICAgICBpZiAoaWR4ID49IGJveC5fb2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAoaSArIDEgPCBpaSkge1xuICAgICAgICAgICAgICAgIGlmIChpZHggPCBib3hlc1tpICsgMV0uX29mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3g7XG59XG5cbmV4cG9ydHMuQm94TW9kZWwgPSBmdW5jdGlvbihib3hBcnJheSkge1xuICAgIHZhciBib3hlcyxcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIHN0ZXBzO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUJveGVzKG5ldSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgYm94ZXMgPSBuZXUubWFwKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSBuZXcgQm94KGIpO1xuICAgICAgICAgICAgYm94Ll9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgKz0gYm94LmdldFN0ZXBzKCk7XG4gICAgICAgICAgICByZXR1cm4gYm94O1xuICAgICAgICB9KTtcbiAgICAgICAgcmFuZ2UgPSB1dGlscy5jb21wdXRlUmFuZ2UoYm94ZXMsICdyYW5nZScpO1xuICAgICAgICBzdGVwcyA9IG9mZnNldDtcbiAgICB9XG4gICAgdXBkYXRlQm94ZXMoYm94QXJyYXkpO1xuICAgIHRoaXMuZ2V0UmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgdGhpcy5nZXRTdGVwcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RlcHM7XG4gICAgfTtcbiAgICB0aGlzLmdldFJhbmdlQXQgPSBmdW5jdGlvbihzLCBlKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGZpbmRCb3goYm94ZXMsIHMpO1xuICAgICAgICB2YXIgZW5kID0gZmluZEJveChib3hlcywgZSk7XG4gICAgICAgIHJldHVybiB1dGlscy5jcmVhdGVSYW5nZShzdGFydC5nZXREYXRlKHMpLCBlbmQuZ2V0RGF0ZShlKSk7XG4gICAgfTtcbiAgICB0aGlzLmdldEluZGV4ID0gZnVuY3Rpb24oaW5zdGFudCkge1xuICAgICAgICB2YXIgaWR4ID0gMCwgaTtcbiAgICAgICAgaWYgKGluc3RhbnQgPCBib3hlc1swXS5nZXRSYW5nZSgpLnN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGJveC5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGluc3RhbnQgPj0gcmFuZ2Uuc3RhcnQgJiYgaW5zdGFudCA8PSByYW5nZS5lbmQpIHtcbiAgICAgICAgICAgICAgICBpZHggKz0gYm94LmdldEluZGV4KGluc3RhbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZHggKz0gYm94LmdldFN0ZXBzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9O1xuICAgIHRoaXMuc2V0UmFuZ2UgPSBmdW5jdGlvbihuZXdSYW5nZSkge1xuICAgICAgICBpZiAoYm94ZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIC8vIEB0b2RvIHN1cHBvcnQgZm9yIHJhbmdlXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNSYW5nZUxpa2UobmV3UmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm94ZXNbMF0uZGF0YSA9IG5ld1JhbmdlO1xuICAgICAgICAgICAgLy8gQHRvZG8gbXVzdCBzZXQgaGVyZSBvciBjb25zdHJ1Y3RvciBpcyBkdW1iIGFuZCBkb2Vzbid0IHJlY29tcHV0ZVxuICAgICAgICAgICAgYm94ZXNbMF0ucmFuZ2UgPSB1dGlscy5jb21wdXRlUmFuZ2UobmV3UmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQHRvZG8gZmluaXNoXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbW9yZSB0aGFuIG9uZSBzdG9yeSBib3ggdG8gdXBkYXRlIHJhbmdlIHdpdGghJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQm94ZXMoYm94ZXMpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICB9O1xufTtcblxuZXhwb3J0cy5maW5kQm94ID0gZmluZEJveDtcbmV4cG9ydHMuQm94ID0gQm94O1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG1vZGVscyA9IHJlcXVpcmUoJy4vbW9kZWxzJyk7XG52YXIgdGltZXNsaWRlciA9IHJlcXVpcmUoJy4vc2xpZGVyJyk7XG52YXIgbGluZSA9IHJlcXVpcmUoJy4vbGluZScpO1xudmFyIG1hcHMgPSByZXF1aXJlKCcuL21hcHMnKTtcblxuLyoqXG4gKiBGYWNhZGUgb2JqZWN0IGFuZCBndXRzIG9mIHNsaWRlci90aW1lbGluZS9wbGF5YmFjayBsb2dpYy5cbiAqXG4gKiBTaW5jZSBwbGF5YmFjayBpcyBkcml2ZW4gYnkgYSB0aW1lb3V0LCBhbGwgb3RoZXIgcG90ZW50aWFsIGV2ZW50c1xuICogYXJlIGZpcmVkIGluIGFuIGFzeW5jIG1hbm5lciB0byBlbnN1cmUgYSB1bmlmb3JtIEFQSS5cbiAqL1xuZnVuY3Rpb24gVGltZUNvbnRyb2xsZXIobW9kZWwsIHNsaWRlciwgdGltZWxpbmUsIGNvbnRyb2xzLCBjaGFwdGVyQ291bnQpIHtcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgdGhpcy5zbGlkZXIgPSBzbGlkZXI7XG4gICAgdGhpcy50aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgIHRoaXMubG9vcCA9ICdub25lJztcblxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY3VycmVudFRpbWVsaW5lV2luZG93ID0gZ2V0VGltZWxpbmVXaW5kb3coKSxcbiAgICAgICAgaXNBZGp1c3RpbmcgPSBmYWxzZSxcbiAgICAgICAgc3RhcnRlZCA9IGZhbHNlLFxuICAgICAgICB0aW1lb3V0ID0gbnVsbCxcbiAgICAgICAgZXZlbnRzID0gbmV3IHV0aWxzLkV2ZW50cygpLFxuICAgICAgICBkZWZlcnJlZCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gZ2V0VGltZWxpbmVXaW5kb3coKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5jcmVhdGVSYW5nZSh0aW1lbGluZS5nZXRXaW5kb3coKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRqdXN0KGZ1biwgYSwgYikge1xuICAgICAgICBpZiAoaXNBZGp1c3RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpc0FkanVzdGluZyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdW4oYSwgYik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpc0FkanVzdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2VudGVyVGltZWxpbmUocmFuZ2UpIHtcbiAgICAgICAgdmFyIGMgPSBtb2RlbC5tb2RlID09PSAnY3VtdWxhdGl2ZScgPyByYW5nZS5lbmQgOiByYW5nZS5jZW50ZXIoKTtcbiAgICAgICAgdGltZWxpbmUubW92ZVRvKGMpO1xuICAgICAgICBwdWJsaXNoUmFuZ2VDaGFuZ2UocmFuZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdFNsaWRlcihyYW5nZSkge1xuICAgICAgICBpZiAodGltZWxpbmUuaXNXaW5kb3dNYXgoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNlbnRlciA9IHJhbmdlLmNlbnRlcigpO1xuICAgICAgICB2YXIgaWR4ID0gbW9kZWwuZ2V0SW5kZXgoY2VudGVyKTtcbiAgICAgICAgaWYgKG1vZGVsLm1vZGUgPT09ICdjdW11bGF0aXZlJykge1xuICAgICAgICAgICAgc2xpZGVyLmdyb3dUbyhpZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xpZGVyLmNlbnRlcihpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVsaW5lLnNldFRpbWUoY2VudGVyKTtcbiAgICAgICAgcHVibGlzaFJhbmdlQ2hhbmdlKHNsaWRlci5nZXRSYW5nZSgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTbGlkZXIocmFuZ2UpIHtcbiAgICAgICAgaWYgKHV0aWxzLnJhbmdlc0VxdWFsKHJhbmdlLCBjdXJyZW50VGltZWxpbmVXaW5kb3cpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UgPSB1dGlscy5jcmVhdGVSYW5nZShyYW5nZSk7XG4gICAgICAgIC8vIHpvb20gb3Igc2Nyb2xsIGV2ZW50P1xuICAgICAgICBpZiAocmFuZ2Uud2lkdGgoKSAhPT0gY3VycmVudFRpbWVsaW5lV2luZG93LndpZHRoKCkpIHtcbiAgICAgICAgICAgIHRpbWVsaW5lLm1vdmVUb0N1cnJlbnRUaW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGp1c3RTbGlkZXIocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRUaW1lbGluZVdpbmRvdyA9IHJhbmdlO1xuICAgIH1cblxuICAgIHNsaWRlci5vbigncmFuZ2VDaGFuZ2VkJywgZnVuY3Rpb24oZXYsIHJhbmdlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCgpO1xuICAgICAgICBhZGp1c3QoY2VudGVyVGltZWxpbmUsIHJhbmdlKTtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICB9KTtcbiAgICB0aW1lbGluZS5vbigncmFuZ2VjaGFuZ2VkJywgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgYWRqdXN0KHVwZGF0ZVNsaWRlciwgcmFuZ2UpO1xuICAgIH0pO1xuICAgIHRpbWVsaW5lLm9uKCdzZWxlY3QnLCBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2VsZWN0ZWQgaXRlbXM6IFwiLCBwcm9wZXJ0aWVzLml0ZW1zKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjbGVhclRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdmUoYW10KSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB2YXIgYXRFbmQ7XG4gICAgICAgIGlmIChtb2RlbC5tb2RlID09PSAnY3VtdWxhdGl2ZScpIHtcbiAgICAgICAgICAgIGF0RW5kID0gc2xpZGVyLmdyb3coYW10KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0RW5kID0gc2xpZGVyLm1vdmUoYW10KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRFbmQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmxvb3AgPT09ICdjaGFwdGVyJykge1xuICAgICAgICAgICAgICAgIHNsaWRlci5qdW1wKDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmxvb3AgPT09ICdzdG9yeScpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFwdGVyID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3BsaXQoXCIvXCIpWzJdO1xuICAgICAgICAgICAgICB2YXIgbmV4dENoYXB0ZXIgPSBjdXJyZW50Q2hhcHRlciA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRDaGFwdGVyID09PSBudWxsID8gMiA6IHBhcnNlSW50KGN1cnJlbnRDaGFwdGVyKSArIDE7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNoYXB0ZXJDb3VudCk7XG4gICAgICAgICAgICAgIGlmKG5leHRDaGFwdGVyIDw9IGNoYXB0ZXJDb3VudCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJHb2luZyB0byBDaGFwdGVyIFwiLCBuZXh0Q2hhcHRlcik7XG4gICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcjL2NoYXB0ZXIvJyArIG5leHRDaGFwdGVyO1xuICAgICAgICAgICAgICAgICAgc2xpZGVyLmp1bXAoMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJHb2luZyB0byBDaGFwdGVyIDFcIik7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnIy9jaGFwdGVyLzEnO1xuICAgICAgICAgICAgICAgIHNsaWRlci5qdW1wKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjZW50ZXJUaW1lbGluZShzbGlkZXIuZ2V0UmFuZ2UoKSk7XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBzY2hlZHVsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAvLyBAdG9kbyByZXNwZWN0IHBsYXliYWNrIGludGVydmFsIG9wdGlvbnMuLi5cbiAgICAgICAgICAgIHZhciB3YWl0ID0gbW9kZWwuaW50ZXJ2YWw7XG4gICAgICAgICAgICAkLndoZW4uYXBwbHkoJCwgZGVmZXJyZWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KG1vdmUsIHdhaXQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZlcnJlZCB3YXMgcmVqZWN0ZWQsIGlmIGFyZ3VtZW50cyBwcm92aWRlZCwgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHJlcHJlc2VudHMgYW4gZXJyb3Igc3RhdGUgc28gZG9uJ3QgY29udGludWUgcGxheWluZ1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwICYmIHN0YXJ0ZWQgJiYgdGltZW91dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQobW92ZSwgd2FpdCwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWZlcnJlZCA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgICBwdWJsaXNoU3RhdGVDaGFuZ2UoXCJydW5uaW5nXCIpO1xuICAgICAgICBtb3ZlKDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1Ymxpc2hSYW5nZUNoYW5nZShkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRhdGEgPSBzbGlkZXIuZ2V0UmFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBwdWJsaXNoKFwicmFuZ2VDaGFuZ2VcIiwgZGF0YSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaFN0YXRlQ2hhbmdlKHN0YXRlKSB7XG4gICAgICAgIHB1Ymxpc2goXCJzdGF0ZUNoYW5nZVwiLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaChldmVudCwgZGF0YSkge1xuICAgICAgICBldmVudHMuZXZlbnQoZXZlbnQpLnB1Ymxpc2goZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWZlciA9IGZ1bmN0aW9uKGRlZmVyKSB7XG4gICAgICAgIGRlZmVycmVkLnB1c2goZGVmZXIpO1xuICAgIH07XG4gICAgdGhpcy5nZXRDdXJyZW50UmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNsaWRlci5nZXRSYW5nZSgpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG1vZGVsLnVwZGF0ZShvcHRpb25zKTtcbiAgICAgICAgc2xpZGVyLnVwZGF0ZShtb2RlbCk7XG4gICAgICAgIHRpbWVsaW5lLnVwZGF0ZShtb2RlbCk7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHB1Ymxpc2hSYW5nZUNoYW5nZSwgMCk7XG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVmZXJyZWQgPSBbXTtcbiAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHJ1biwgMCk7XG4gICAgfTtcbiAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVmZXJyZWQgPSBbXTtcbiAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBjbGVhclRpbWVvdXQoKTtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQocHVibGlzaFN0YXRlQ2hhbmdlLCAwLCAnc3RvcHBlZCcpO1xuICAgIH07XG4gICAgdGhpcy5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCgpO1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChtb3ZlLCAwLCAxKTtcbiAgICB9O1xuICAgIHRoaXMucHJldiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoKTtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQobW92ZSwgMCwgLTEpO1xuICAgIH07XG4gICAgdGhpcy5pc1N0YXJ0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ZWQ7XG4gICAgfTtcbiAgICB0aGlzLm9uID0gZnVuY3Rpb24oZXZlbnQsIGYpIHtcbiAgICAgICAgZXZlbnRzLmV2ZW50KGV2ZW50KS5zdWJzY3JpYmUoZik7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBhbm5vdGF0aW9uIG1vZGVsOlxuICogdGl0bGVcbiAqIGNvbnRlbnRcbiAqIHRoZV9nZW9tXG4gKiBzdGFydF90aW1lXG4gKiBlbmRfdGltZVxuICogaW5fdGltZWxpbmVcbiAqIGluX21hcFxuICogYXBwZWFyYW5jZVxuICovXG5mdW5jdGlvbiBBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucykge1xuICAgIHZhciBhbm4gPSBhbm5vdGF0aW9ucyB8fCBbXTtcbiAgICBmdW5jdGlvbiBpblRpbWVsaW5lKCkge1xuICAgICAgICByZXR1cm4gYW5uLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5pbl90aW1lbGluZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZ2V0VGltZUxpbmVBbm5vdGF0b25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpblRpbWVsaW5lKHRydWUpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihhbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLmFubiA9IGFubm90YXRpb25zO1xuICAgIH07XG59XG5cbi8qKlxuICogYm94IG1vZGVsOlxuICogdGl0bGVcbiAqIGNvbnRlbnRcbiAqIHRoZV9nZW9tXG4gKiBzdGFydF90aW1lXG4gKiBlbmRfdGltZVxuICogaW5fdGltZWxpbmVcbiAqIGluX21hcFxuICogYXBwZWFyYW5jZVxuICovXG5mdW5jdGlvbiBCb3hlcyhib3hlcykge1xuICAgIHZhciBib3ggPSBib3hlcyB8fCBbXTtcbiAgICBmdW5jdGlvbiBpblRpbWVsaW5lKCkge1xuICAgICAgICByZXR1cm4gYm94LmZpbHRlcihmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsvL2IuaW5fdGltZWxpbmU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmdldFRpbWVMaW5lQm94ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGluVGltZWxpbmUodHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKGJveGVzKSB7XG4gICAgICAgIHRoaXMuYm94ID0gYm94ZXM7XG4gICAgfTtcbn1cblxuXG4vKipcbiAqIGNvbW1vbiBsaW5nbzpcbiAqIGluc3RhbnQ6IGEgc2luZ2xlIHBvaW50IGluIHRpbWVcbiAqIGV4dGVudCwgcmFuZ2U6IGhhcyBwcm9wZXJ0eSBzdGFydCBhbmQgZW5kXG4gKiBzdGFydCwgZW5kOiBsb25nIHZhbHVlcyByZXByZXNlbnRpbmcgVVRDIChpbnRlcm5hbCkgYnV0IGdlbmVyYWxseSxcbiAqICAgICAgICAgICAgIGEgZGF0ZVxuICogaW50ZXJ2YWw6IG11bHRpcGllciAqIHByZWNpc2lvblxuICogcHJlY2lzaW9uOiB0aWNrLCBzZWNvbmQsIG1pbnV0ZSwgaG91ciwgZGF5LCB3ZWVrLCBtb250aCwgeWVhclxuICogICAgICAgICAgICBub3RlOiB0aWNrIGltcGxpZXMgYSBtdWx0aXBpZXIgb2YgMVxuICogc3BlZWQ6IG9iamVjdCB3aXRoIHByb3BlcnR5IHNlY29uZHMgKGZyYW1lcmF0ZSkgYW5kIG9wdGlvbmFsIGludGVydmFsXG4gKlxuICogb3B0aW9ucyA9IHtcbiAqICAgYW5ub3RhdGlvbnM6IFsge1xuICogICAgICB0aXRsZSxcbiAqICAgICAgY29udGVudCxcbiAqICAgICAgdGhlX2dlb20sXG4gKiAgICAgIHN0YXJ0X3RpbWUsXG4gKiAgICAgIGVuZF90aW1lLFxuICogICAgICBpbl90aW1lbGluZSxcbiAqICAgICAgaW5fbWFwLFxuICogICAgICBhcHBlYXJhbmNlXG4gKiAgICAgIH0gLi4uIF0sXG4gKiAgIG1hcDogb2wuTWFwLFxuICogICBib3hlcyA6IFsge1xuICogICAgICByYW5nZSA6IHtcbiAqICAgICAgICAgIHN0YXJ0LCBlbmRcbiAqICAgICAgfSxcbiAqICAgICAgY2VudGVyOiBvbC5Db29yZGluYXRlLFxuICogICAgICByZXNvbHV0aW9uOiBmbG9hdCxcbiAqICAgICAgc3RhdGljOiBib29sZWFuLFxuICogICAgICBzcGVlZDogeyBpbnRlcnZhbCwgc2Vjb25kcyB9XG4gKiAgICAgIH0gLi4uIF0sXG4gKiAgIGRhdGEgOiBbIGRhdGUgLi4uXSB8IHJhbmdlV2l0aEludGVydmFsLFxuICogICBwbGF5YmFjayA6IHtcbiAqICAgICAgbW9kZTogaW5zdGFudCB8IHJhbmdlIHwgY3VtdWxhdGl2ZSxcbiAqICAgICAgZml4ZWQ6IGJvb2xlYW5cbiAqICAgfSxcbiAqICAgdGltZUxpbmVJZCA6IGVsZW1lbnQgaWQsXG4gKiAgIHRpbWVTbGlkZXJJZCA6IGVsZW1lbnQgaWQsXG4gKiAgIGNvbnRyb2xzSWQ6IGVsZW1lbnQgaWRcbiAqXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgLy8gQHRvZG8gZm9yIGxheWVycywgYW5ub3RhdGlvbnMgd29uJ3QgZXhpc3QgYW5kLCBpbnRpYWxseSwgd2Ugd29uJ3RcbiAgICAvLyAgICAgICBoYXZlIHBsYXliYWNrIHNldHRpbmdzIGZvciBsYXllcnMuLi5cbiAgICB2YXIgbW9kZWwsXG4gICAgICAgIGFubm90YXRpb25zID0gbmV3IEFubm90YXRpb25zKG9wdGlvbnMuYW5ub3RhdGlvbnMpLFxuICAgICAgICBib3hlcyA9IG9wdGlvbnMuYm94ZXMsXG4gICAgICAgIGNoYXB0ZXJDb3VudCA9IG9wdGlvbnMuY2hhcHRlckNvdW50LFxuICAgICAgICB0b3RhbFJhbmdlLFxuICAgICAgICBzbGlkZXIsXG4gICAgICAgIHRpbWVsaW5lLFxuICAgICAgICBtYXBDb250cm9sbGVyLFxuICAgICAgICBjb250cm9scztcbiAgICBvcHRpb25zLmJveHkgPSBuZXcgQm94ZXMob3B0aW9ucy5ib3hlcyk7XG4gICAgLy8gbWFrZSBhIGRlZmF1bHQgYm94IGlmIG5vbmUgcHJvdmlkZWRcbiAgICBpZiAodHlwZW9mIGJveGVzID09ICd1bmRlZmluZWQnIHx8IGJveGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAwLCBkYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5kYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgICAgIHRvdGFsUmFuZ2UgPSB1dGlscy5jb21wdXRlUmFuZ2Uob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVydmFsID0gb3B0aW9ucy5kYXRhLmludGVydmFsIHx8IHV0aWxzLnBpY2tJbnRlcnZhbChvcHRpb25zLmRhdGEpO1xuICAgICAgICAgICAgdG90YWxSYW5nZSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBib3hlcyA9IFt7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICByYW5nZTogdG90YWxSYW5nZSxcbiAgICAgICAgICAgICAgICBzcGVlZDoge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbDogaW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHM6IDNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XTtcbiAgICB9XG5cbiAgICBtb2RlbCA9IG5ldyBtb2RlbHMuVGltZU1vZGVsKG9wdGlvbnMsIGJveGVzLCBhbm5vdGF0aW9ucyk7XG4gICAgc2xpZGVyID0gbmV3IHRpbWVzbGlkZXIuVGltZVNsaWRlcihvcHRpb25zLnRpbWVTbGlkZXJJZCB8fCAnc2xpZGVyJywgbW9kZWwpO1xuICAgIHRpbWVsaW5lID0gbmV3IGxpbmUuVGltZUxpbmUob3B0aW9ucy50aW1lTGluZUlkIHx8ICd0aW1lbGluZScsIG1vZGVsKTtcblxuICAgIHZhciB0aW1lQ29udHJvbHMgPSBuZXcgVGltZUNvbnRyb2xsZXIobW9kZWwsIHNsaWRlciwgdGltZWxpbmUsIGNvbnRyb2xzLCBjaGFwdGVyQ291bnQpO1xuICAgIG1hcENvbnRyb2xsZXIgPSBuZXcgbWFwcy5NYXBDb250cm9sbGVyKG9wdGlvbnMsIHRpbWVDb250cm9scyk7XG4gICAgcmV0dXJuIHRpbWVDb250cm9scztcbn1cblxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLm1hcHMgPSBtYXBzO1xuZXhwb3J0cy51dGlscyA9IHV0aWxzO1xuIiwidmFyIFRpbWVsaW5lID0gcmVxdWlyZSgndmlzL2xpYi90aW1lbGluZS9UaW1lbGluZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIERpc3BsYXkgYW5ub3RhdGlvbnMgb3Igb3RoZXIgdGVtcG9yYWwgaW5zdGFudC9leHRlbnQuIEFsbG93IGFkanVzdGluZ1xuICogdGltZSAoZWl0aGVyIGluc3RhbnQgb3IgZXh0ZW50KSBieSBkcmFnZ2luZy5cbiAqIEBwYXJhbSB7dHlwZX0gaWRcbiAqIEBwYXJhbSB7dHlwZX0gbW9kZWxcbiAqIEByZXR1cm5zIHtfTDEuVGltZUxpbmV9XG4gKi9cbmV4cG9ydHMuVGltZUxpbmUgPSBmdW5jdGlvbihpZCwgbW9kZWwpIHtcbiAgICB2YXIgZG9tID0gJChcIiNcIiArIGlkKTtcbiAgICB2YXIgdGltZWxpbmUgPSBudWxsO1xuICAgIC8vIEByZXZpc2l0IC0gaW50ZXJuYWxseSB0aGUgdGltZWxpbmUgc2VlbXMgdG8gYXBwbHkgdGhlIG9mZnNldCB3aGVuXG4gICAgLy8gICAgICAgICAgICBjcmVhdGluZyBhIHRvb2wgdGlwLCBkb2VzIHRoaXMgY2F1c2UgcHJvYmxlbXMgZWxzZXdoZXJlP1xuICAgIHZhciBvZmZzZXQgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCAqIDEwMDA7XG5cbiAgICBmdW5jdGlvbiBpbml0KG1vZGVsKSB7XG4gICAgICAgIHZhciBzdG9yeV9waW5fbGFiZWwgPSAnU3RvcnkgUGluJztcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW10sIGxheWVyX2dyb3VwcyA9IFtdLCBncm91cHMgPSBbe2lkOiBzdG9yeV9waW5fbGFiZWwsIHRpdGxlOiBzdG9yeV9waW5fbGFiZWwsIHRpbWU6IFtdfV0sIG9wdGlvbnM7XG4gICAgICAgIHZhciByYW5nZSA9IG1vZGVsLmdldFJhbmdlKCk7XG4gICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJhbmdlID0gdXRpbHMuY3JlYXRlUmFuZ2UoRGF0ZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMgPSBtb2RlbC5hbm5vdGF0aW9ucy5nZXRUaW1lTGluZUFubm90YXRvbnMoKS5tYXAoZnVuY3Rpb24oYW5uLCBpKSB7XG4gICAgICAgICAgICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYW5uLnN0YXJ0X3RpbWUgIT0gbnVsbCA/IGFubi5zdGFydF90aW1lIDogcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB2YXIgZW5kID0gYW5uLmVuZF90aW1lICE9IG51bGwgPyBhbm4uZW5kX3RpbWUgOiByYW5nZS5lbmQ7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHN0YXJ0ID09PSBlbmQgPyAnYm94JyA6ICdyYW5nZSc7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBhbm4uaWQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFubi5jb250ZW50IHx8IGFubi50aXRsZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogYW5uLnRpdGxlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IHN0b3J5X3Bpbl9sYWJlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtb2RlbC5ib3h5LmJveCkge1xuICAgICAgICAgICAgZWxlbWVudHNzID0gbW9kZWwuYm94eS5ib3gubWFwKGZ1bmN0aW9uKGJveCwgaSkge1xuICAgICAgICAgICAgICAgIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYm94LnJhbmdlICE9IG51bGwgPyBib3gucmFuZ2Uuc3RhcnQgOiByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gYm94LnJhbmdlICE9IG51bGwgPyBib3gucmFuZ2UuZW5kIDogcmFuZ2UuZW5kO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gJ2JhY2tncm91bmQnO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnc2InICsgYm94LmlkLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBib3guY29udGVudCB8fCBib3gudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLmNvbmNhdChlbGVtZW50c3MpO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyX2dyb3VwcyA9ICQubWFwKG1vZGVsLnN0b3J5TGF5ZXJzLCBmdW5jdGlvbihseXIsIGkpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGx5ci5nZXQoJ2lkJyk7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBseXIuZ2V0KCd0aXRsZScpO1xuICAgICAgICAgICAgdmFyIHRpbWVzID0gbHlyLmdldCgndGltZXMnKSB8fCBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQgKyAnOicgKyBpICsgJzonICsgaixcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGlkLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGltZXNbal0sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib3gnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpdGxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBncm91cHMgPSBncm91cHMuY29uY2F0KGxheWVyX2dyb3Vwcyk7XG5cbiAgICAgICAgdmFyIGhlaWdodCA9ICQoIGRvY3VtZW50ICkuaGVpZ2h0KCkgKiAwLjM1O1xuXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtaW46IHJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgbWF4OiByYW5nZS5lbmQsXG4gICAgICAgICAgICBzdGFydDogcmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHJhbmdlLmVuZCxcbiAgICAgICAgICAgIGhlaWdodDogKGhlaWdodCA8IDMwMCk/IDEzODogaGVpZ2h0LFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiA0MDAsXG4gICAgICAgICAgICBzaG93Q3VycmVudFRpbWU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aW1lbGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgVGltZWxpbmUoZG9tLmdldCgwKSwgZWxlbWVudHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGltZWxpbmUuc2V0R3JvdXBzKGdyb3Vwcyk7XG4gICAgICAgICAgICB0aW1lbGluZS5zZXRDdXJyZW50VGltZShyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB0aW1lbGluZS5hZGRDdXN0b21UaW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lbGluZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGltZWxpbmUuc2V0SXRlbXMoZWxlbWVudHMpO1xuICAgICAgICAgICAgdGltZWxpbmUuc2V0R3JvdXBzKGdyb3Vwcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdChtb2RlbCk7XG5cbiAgICAvLyB1cGRhdGVzIGZyb20gdXNlciBkcmFnZ2luZyBjdXN0b210aW1lIGJhclxuICAgIC8vIEB0b2RvIHdpbGwgbm90IHVwZGF0ZSBzbGlkZXIgY3VycmVudGx5IGF0IG1pbiB0aW1lbGluZSB6b29tIGFzIGl0XG4gICAgLy8gaXMgZGlmZmljdWx0IHRvIGRldGVybWluZSB3aGV0aGVyIGFuIGV2ZW50IGlzIGZyb20gem9vbWluZyBvciBkcmFnZ2luZ1xuICAgIC8vIG5lZWQgdG8gd3JhcCBldmVudCBoYW5kbGluZyB0byBiZXR0ZXIgZGlmZmVyZW50aWF0ZVxuICAgIHRpbWVsaW5lLm9uKCd0aW1lY2hhbmdlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lbGluZS5tb3ZlVG8odGltZWxpbmUuZ2V0Q3VzdG9tVGltZSgpLCB7YW5pbWF0ZTogZmFsc2V9KTtcbiAgICB9KTtcblxuICAgIHRoaXMubW92ZVRvID0gZnVuY3Rpb24odGltZSkge1xuICAgICAgICB0aW1lbGluZS5tb3ZlVG8odGltZSwge2FuaW1hdGU6IGZhbHNlfSk7XG4gICAgICAgIHRoaXMuc2V0VGltZSh0aW1lKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0VGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgdGltZWxpbmUuc2V0Q3VzdG9tVGltZSh0aW1lICsgb2Zmc2V0KTtcbiAgICB9O1xuICAgIHRoaXMuaXNXaW5kb3dNYXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnJhbmdlc0VxdWFsKHRpbWVsaW5lLmdldFdpbmRvdygpLCBtb2RlbC5nZXRSYW5nZSgpKTtcbiAgICB9O1xuICAgIHRoaXMubW92ZVRvQ3VycmVudFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aW1lbGluZS5nZXRDdXN0b21UaW1lKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgd2lkdGggPSB1dGlscy5jcmVhdGVSYW5nZSh0aW1lbGluZS5nZXRXaW5kb3coKSkud2lkdGgoKTtcbiAgICAgICAgdmFyIHJhbmdlID0gbW9kZWwuZ2V0UmFuZ2UoKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aW1lbGluZS5zZXRXaW5kb3cocmFuZ2Uuc3RhcnQsIHJhbmdlLnN0YXJ0ICsgd2lkdGgsIHthbmltYXRlOiBmYWxzZX0pO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IHJhbmdlLmVuZCkge1xuICAgICAgICAgICAgdGltZWxpbmUuc2V0V2luZG93KHJhbmdlLmVuZCAtIHdpZHRoLCByYW5nZS5lbmQsIHthbmltYXRlOiBmYWxzZX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZWxpbmUubW92ZVRvKGN1cnJlbnQsIHthbmltYXRlOiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldFdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGltZWxpbmUuZ2V0V2luZG93KCk7XG4gICAgfTtcbiAgICB0aGlzLm9uID0gZnVuY3Rpb24oZXYsIGNiKSB7XG4gICAgICAgIHRpbWVsaW5lLm9uKGV2LCBjYik7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZSA9IGluaXQ7XG4gICAgLy8gQHRvZG8gZGV0ZWN0IGNsaWNrIG9yIGRibGNsaWNrIGV2ZW50IGFuZCBwb3NpdGlvbiBiYXNlZCBvbiAlIG9mIHRvdGFsIHdpZHRoXG59O1xuIiwiLypqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxuLyoqXG4gKiBSZWFkIHRoZSBwcm92aWRlIG9sMyBXTVMgY2FwYWJpbGl0aWVzIGRvY3VtZW50XG4gKiBAcGFyYW0ge3R5cGV9IGNhcHNcbiAqIEByZXR1cm5zIGFuIG9iamVjdCBvZiBuYW1lLT5bZGF0ZXxpbnRlcnZhbF18aW50ZXJ2YWwtcmFuZ2UgbWFwcGluZ3NcbiAqL1xuZXhwb3J0cy5yZWFkQ2FwYWJpbGl0aWVzVGltZURpbWVuc2lvbnMgPSBmdW5jdGlvbihjYXBzLCBvcGVubGF5ZXJzMikge1xuICAgIHZhciBkaW1lbnNpb25zID0ge307XG4gICAgZnVuY3Rpb24gcmVhZFJhbmdlKHN1YnBhcnRzKSB7XG4gICAgICAgIGlmIChzdWJwYXJ0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIDIgcGFydHMgZm9yIHJhbmdlIDogJyArIHN1YnBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSB1dGlscy5jcmVhdGVSYW5nZShzdWJwYXJ0c1swXSwgc3VicGFydHNbMV0pO1xuICAgICAgICBpZiAoc3VicGFydHMubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgIHJhbmdlLmR1cmF0aW9uID0gc3VicGFydHNbMl07XG4gICAgICAgICAgICByYW5nZSA9IG5ldyB1dGlscy5JbnRlcnZhbChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkUGFydChwYXJ0KSB7XG4gICAgICAgIHZhciBzdWJwYXJ0cyA9IHBhcnQuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKHN1YnBhcnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuZ2V0VGltZShzdWJwYXJ0c1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZFJhbmdlKHN1YnBhcnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZShkaW1lbnNpb24pIHtcbiAgICAgICAgdmFyIGRpbXMgPSBvcGVubGF5ZXJzMiA/IGRpbWVuc2lvbiA6IGRpbWVuc2lvbi5zcGxpdCgnLCcpO1xuICAgICAgICBpZiAoZGltcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgdmFyIHJlYWQgPSByZWFkUGFydChkaW1zWzBdKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcmVhZCA9PT0gJ251bWJlcicgPyBbcmVhZF0gOiByZWFkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaW1zLm1hcChyZWFkUGFydCk7XG4gICAgfVxuICAgIGlmIChvcGVubGF5ZXJzMiA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoY2Fwcy5kaW1lbnNpb25zICYmIGNhcHMuZGltZW5zaW9ucy50aW1lKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gcGFyc2UoY2Fwcy5kaW1lbnNpb25zLnRpbWUudmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBAdG9kbyBuZWVkIHRvIG1ha2UgbGF5ZXIgc2Nhbm5pbmcgcmVjdXJzaXZlP1xuICAgICAgICBjYXBzLnZhbHVlLmNhcGFiaWxpdHkubGF5ZXIubGF5ZXIuZm9yRWFjaChmdW5jdGlvbihseXIpIHtcbiAgICAgICAgICAgIGlmIChseXIuZGltZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uc1tseXIubmFtZV0gPSBwYXJzZShseXIuZXh0ZW50WzBdLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb25zO1xufTtcblxuZnVuY3Rpb24gVGlsZUxvYWRMaXN0ZW5lcih0aWxlU3RhdHVzQ2FsbGJhY2spIHtcbiAgICB2YXIgdGlsZXNMb2FkaW5nID0ge307XG4gICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICAgIGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1RpbGVzKCkge1xuICAgICAgICB2YXIgdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGlsZXNMb2FkaW5nKSB7XG4gICAgICAgICAgICB0ICs9IHRpbGVzTG9hZGluZ1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgdmFyIGxpc3RlbmVyID0ge1xuICAgICAgICBkZWZlcnJlZDogZGVmZXJyZWQsXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgcyBpbiB0aWxlc0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aWxlc0xvYWRpbmdbc10gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7IC8vIG5vdGlmeSB3ZSd2ZSBhYm9ydGVkIGJ1dCB3L291dCBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbGVTdGF0dXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRpbGVTdGF0dXNDYWxsYmFjaygwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGlsZVF1ZXVlZDogZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBvbC5zb3VyY2UuVGlsZVdNUykge1xuICAgICAgICAgICAgICAgIGtleSA9IHNvdXJjZS5nZXRVcmxzKClbMF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIG9sLnNvdXJjZS5JbWFnZVdNUykge1xuICAgICAgICAgICAgICAgIGtleSA9IHNvdXJjZS5nZXRVcmwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbGVzTG9hZGluZ1trZXldID0gKHRpbGVzTG9hZGluZ1trZXldIHx8IDApICsgMTtcbiAgICAgICAgICAgIGlmICh0aWxlU3RhdHVzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aWxlU3RhdHVzQ2FsbGJhY2socmVtYWluaW5nVGlsZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRpbGVMb2FkZWQ6IGZ1bmN0aW9uKGV2ZW50LCBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIG9sLnNvdXJjZS5UaWxlV01TKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc291cmNlLmdldFVybHMoKVswXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2Ygb2wuc291cmNlLkltYWdlV01TKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc291cmNlLmdldFVybCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGlsZXNMb2FkaW5nW2tleV0gLT0gMTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSByZW1haW5pbmdUaWxlcygpO1xuICAgICAgICAgICAgaWYgKHRpbGVTdGF0dXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRpbGVTdGF0dXNDYWxsYmFjayhyZW1haW5pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA9PT0gMCAmJiBkZWZlcnJlZCkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gd29ya2Fyb3VuZCBmb3Igd2hlbiB0aGUgdGlsZXMgYXJlIGNhY2hlZCBhbmQgbm8gZXZlbnRzIGFyZSB0cmlnZ2VyZWRcbiAgICAvLyB0aGlzIGFkZHMgYSBjb25zdGFudCAoc21hbGwpIGFkZGl0aW9uYWwgZGVsYXkgdG8gdGhlIGN1cnJlbnQgcGxheSByYXRlXG4gICAgLy8gdW5kZXIgb3B0aW1hbCAoY2FjaGVkKSBjb25kaXRpb25zXG4gICAgLy8gQHRvZG8gY2FuIHRoaXMgc2FmZWx5IGJlIHNob3J0ZW5lZD9cbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRpbGVzTG9hZGluZykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH0sMTAwKTtcbiAgICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclZlY3RvckxheWVyKHN0b3J5TGF5ZXIsIHJhbmdlKSB7XG4gICAgdmFyIHRpbWVBdHRyID0gc3RvcnlMYXllci5nZXQoJ3RpbWVBdHRyaWJ1dGUnKSwgbF9mZWF0dXJlcyA9IHN0b3J5TGF5ZXIuZ2V0KCdmZWF0dXJlcycpO1xuICAgIGlmICh0aW1lQXR0ciA9PT0gdW5kZWZpbmVkIHx8IGxfZmVhdHVyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJhbmdlID0gdXRpbHMuY3JlYXRlUmFuZ2UocmFuZ2UpO1xuICAgIC8vIGxvb3Agb3ZlciBhbGwgb3JpZ2luYWwgZmVhdHVyZXMgYW5kIGZpbHRlciB0aGVtXG4gICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgdmFyIGxheWVyID0gc3RvcnlMYXllci5nZXRMYXllcigpO1xuICAgIHZpc2l0QWxsTGF5ZXJGZWF0dXJlVGltZXMoc3RvcnlMYXllciwgZnVuY3Rpb24oZixyKSB7XG4gICAgICAgIGlmIChyYW5nZS5pbnRlcnNlY3RzKHIpKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGYpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGF5ZXIuZ2V0U291cmNlKCkuY2xlYXIodHJ1ZSk7XG4gICAgbGF5ZXIuZ2V0U291cmNlKCkuYWRkRmVhdHVyZXMoZmVhdHVyZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZpbHRlclZlY3RvckJveExheWVyKHN0b3J5TGF5ZXIsIHJhbmdlKSB7XG4gICAgdmFyIHRpbWVBdHRyID0gc3RvcnlMYXllci5nZXQoJ3RpbWVBdHRyaWJ1dGUnKSwgbF9mZWF0dXJlcyA9IHN0b3J5TGF5ZXIuZ2V0KCdmZWF0dXJlcycpO1xuICAgIGlmICh0aW1lQXR0ciA9PT0gdW5kZWZpbmVkIHx8IGxfZmVhdHVyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJhbmdlID0gdXRpbHMuY3JlYXRlUmFuZ2UocmFuZ2UpO1xuICAgIC8vIGxvb3Agb3ZlciBhbGwgb3JpZ2luYWwgZmVhdHVyZXMgYW5kIGZpbHRlciB0aGVtXG4gICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgdmlzaXRBbGxMYXllckZlYXR1cmVUaW1lcyhzdG9yeUxheWVyLCBmdW5jdGlvbihmLHIpIHtcbiAgICAgICAgaWYgKHJhbmdlLmludGVyc2VjdHMocikpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmZWF0dXJlcztcbn1cbi8qKlxuICogQ2FsbCB0aGUgcHJvdmlkZWQgdmlzaXRvciBmdW5jdGlvbiBvbiB0aGUgc3BlY2lmaWVkIGZlYXR1cmVzIHVzaW5nIHRoZVxuICogY29uZmlndXJhdGlvbiBwcm92aWRlZCBpbiB0aGUgbGF5ZXIuIFRoZSB2aXNpdG9yIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkXG4gKiB3aXRoIHRoZSBmZWF0dXJlLCBhbmQgc3RhcnQgYW5kIGVuZCB0aW1lLCBpZiBhbnkuIFRoZSBmZWF0dXJlcyB2aXNpdGVkIHdpbGxcbiAqIGJlLCBpbiBvcmRlciBvZiBwcmlvcml0eTogdGhlIHByb3ZpZGVkIChvcHRpb25hbCkgZmVhdHVyZXMgYXJndW1lbnQsIHRoZVxuICogbGF5ZXIgcHJvcGVydHkgJ2ZlYXR1cmVzJywgdGhlIGxheWVyJ3Mgc291cmNlIGZlYXR1cmVzLlxuICogQHBhcmFtIHtTdG9yeUxheWVyfSBzdG9yeSBsYXllclxuICogQHBhcmFtIHtmdW5jdGlvbn0gdmlzaXRvciBmdW5jdGlvbihmZWF0dXJlLCBzdGFydCwgZW5kKVxuICogQHBhcmFtIHthcnJheX0gZmVhdHVyZXMgKG9waXRvbmFsKVxuICovXG5mdW5jdGlvbiB2aXNpdEFsbExheWVyRmVhdHVyZVRpbWVzKHN0b3J5TGF5ZXIsIHZpc2l0b3IsIGZlYXR1cmVzKSB7XG4gICAgdmFyIHN0YXJ0QXR0ID0gc3RvcnlMYXllci5nZXQoJ3RpbWVBdHRyaWJ1dGUnKTtcbiAgICB2YXIgZW5kQXR0ID0gc3RvcnlMYXllci5nZXQoJ2VuZFRpbWVBdHRyaWJ1dGUnKTtcbiAgICB2YXIgcmFuZ2VHZXR0ZXI7XG4gICAgdmFyIGxheWVyID0gc3RvcnlMYXllci5nZXRMYXllcigpO1xuICAgIGZlYXR1cmVzID0gZmVhdHVyZXMgfHwgc3RvcnlMYXllci5nZXQoJ2ZlYXR1cmVzJykgfHwgbGF5ZXIuZ2V0U291cmNlKCkuZ2V0RmVhdHVyZXMoKTtcbiAgICBpZiAoZW5kQXR0KSB7XG4gICAgICAgIHJhbmdlR2V0dGVyID0gZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgaWYoZi5yYW5nZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYucmFuZ2U7XG4gICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZi5nZXQoc3RhcnRBdHQpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBmLmdldChlbmRBdHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5jcmVhdGVSYW5nZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZUdldHRlciA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIGlmKGYucmFuZ2Upe1xuICAgICAgICAgICAgICAgIHJldHVybiBmLnJhbmdlO1xuICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGYuZ2V0KHN0YXJ0QXR0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuY3JlYXRlUmFuZ2Uoc3RhcnQsIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXRpbHMudmlzaXRSYW5nZXMoZmVhdHVyZXMsIHJhbmdlR2V0dGVyLCB2aXNpdG9yKTtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSByYW5nZSBvZiB0aGUgcHJvdmlkZWQgZmVhdHVyZXMgdXNpbmcgdGhlIGxheWVyJ3MgY29uZmlndXJlZFxuICogdGltZWF0dHJpYnV0ZXMuIElmIHRoZSBvcHRpb25hbCBmZWF0dXJlcyBhcnJheSBpcyBvbWl0dGVkLCB0aGUgZmVhdHVyZXNcbiAqIHdpbGwgY29tZSBmcm9tIHRoZSBsYXllci5cbiAqIEBwYXJhbSB7U3RvcnlMYXllcn0gc3RvcnlMYXllclxuICogQHBhcmFtIHthcnJheX0gZmVhdHVyZXMgKG9wdGlvbmFsKVxuICogQHJldHVybnMge3N0b3J5dG9vbHMuY29yZS50aW1lLlJhbmdlfSByYW5nZSBvZiBmZWF0dXJlc1xuICovXG5leHBvcnRzLmNvbXB1dGVWZWN0b3JSYW5nZSA9IGZ1bmN0aW9uKHN0b3J5TGF5ZXIsIGZlYXR1cmVzKSB7XG4gICAgdmFyIHN0YXJ0QXR0ID0gc3RvcnlMYXllci5nZXQoJ3RpbWVBdHRyaWJ1dGUnKTtcbiAgICB2YXIgZW5kQXR0ID0gc3RvcnlMYXllci5nZXQoJ2VuZFRpbWVBdHRyaWJ1dGUnKTtcbiAgICB2YXIgbGF5ZXIgPSBzdG9yeUxheWVyLmdldExheWVyKCk7XG4gICAgZmVhdHVyZXMgPSBmZWF0dXJlcyB8fCBzdG9yeUxheWVyLmdldCgnZmVhdHVyZXMnKSB8fCBsYXllci5nZXRTb3VyY2UoKS5nZXRGZWF0dXJlcygpO1xuICAgIHJldHVybiB1dGlscy5jb21wdXRlUmFuZ2UoZmVhdHVyZXMsIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmNyZWF0ZVJhbmdlKGYuZ2V0KHN0YXJ0QXR0KSwgZi5nZXQoZW5kQXR0KSk7XG4gICAgfSk7XG59O1xuXG5leHBvcnRzLmZpbHRlclZlY3RvckxheWVyID0gZmlsdGVyVmVjdG9yTGF5ZXI7XG5leHBvcnRzLmZpbHRlclZlY3RvckJveExheWVyID0gZmlsdGVyVmVjdG9yQm94TGF5ZXI7XG5cbmV4cG9ydHMuTWFwQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9wdGlvbnMsIHRpbWVDb250cm9scykge1xuICAgIHZhciBsb2FkTGlzdGVuZXIgPSBudWxsLFxuICAgICAgICAgIHRpbGVTdGF0dXNDYWxsYmFjayA9IG9wdGlvbnMudGlsZVN0YXR1c0NhbGxiYWNrLFxuICAgICAgICAgIHN0b3J5TWFwID0gb3B0aW9ucy5zdG9yeU1hcDtcbiAgICBmdW5jdGlvbiBsYXllckFkZGVkKGxheWVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UsIGltYWdlO1xuICAgICAgICB2YXIgbG9hZGVkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGdyYWIgdGhlIGFjdGl2ZSBsb2FkTGlzdGVuZXIgdG8gYXZvaWQgcGhhbnRvbSBvbmxvYWRzXG4gICAgICAgICAgICAvLyB3aGVuIGxpc3RlbmVyIGlzIGNhbmNlbGxlZFxuICAgICAgICAgICAgdmFyIGN1cnJlbnRMaXN0ZW5lciA9IGxvYWRMaXN0ZW5lcjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGlzdGVuZXIudGlsZUxvYWRlZChldmVudCwgc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxvYWRzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gZ3JhYiB0aGUgYWN0aXZlIGxvYWRMaXN0ZW5lciB0byBhdm9pZCBwaGFudG9tIG9ubG9hZHNcbiAgICAgICAgICAgIC8vIHdoZW4gbGlzdGVuZXIgaXMgY2FuY2VsbGVkXG4gICAgICAgICAgICB2YXIgY3VycmVudExpc3RlbmVyID0gbG9hZExpc3RlbmVyO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaXN0ZW5lci50aWxlUXVldWVkKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChsYXllciBpbnN0YW5jZW9mIG9sLmxheWVyLlRpbGUgJiYgbGF5ZXIuZ2V0U291cmNlKCkgaW5zdGFuY2VvZiBvbC5zb3VyY2UuVGlsZVdNUykge1xuICAgICAgICAgICAgc291cmNlID0gbGF5ZXIuZ2V0U291cmNlKCk7XG4gICAgICAgICAgICBzb3VyY2Uub24oJ3RpbGVsb2Fkc3RhcnQnLCBsb2Fkc3RhcnQpO1xuICAgICAgICAgICAgc291cmNlLm9uKCd0aWxlbG9hZGVuZCcsIGxvYWRlZCk7XG4gICAgICAgICAgICAvLyBAdG9kbyBoYW5kbGUgb25lcnJvciBhbmQgY2FuY2VsIGRlZmVycmVkIHdpdGggYW4gZXhhbXBsZVxuICAgICAgICAgICAgLy8gdG8gc3RvcCBhdXRvbWF0aWMgcGxheWJhY2tcbiAgICAgICAgICAgIHNvdXJjZS5vbigndGlsZWxvYWRlcnJvcicsIGxvYWRlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5ZXIgaW5zdGFuY2VvZiBvbC5sYXllci5JbWFnZSAmJiBsYXllci5nZXRTb3VyY2UoKSBpbnN0YW5jZW9mIG9sLnNvdXJjZS5JbWFnZVdNUykge1xuICAgICAgICAgICAgc291cmNlID0gbGF5ZXIuZ2V0U291cmNlKCk7XG4gICAgICAgICAgICBzb3VyY2Uub24oJ2ltYWdlbG9hZHN0YXJ0JywgbG9hZHN0YXJ0KTtcbiAgICAgICAgICAgIHNvdXJjZS5vbignaW1hZ2Vsb2FkZW5kJywgbG9hZGVkKTtcbiAgICAgICAgICAgIHNvdXJjZS5vbignaW1hZ2Vsb2FkZXJyb3InLCBsb2FkZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvYWRMaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKGxvYWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9hZExpc3RlbmVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRMaXN0ZW5lciA9IG5ldyBUaWxlTG9hZExpc3RlbmVyKHRpbGVTdGF0dXNDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBsb2FkTGlzdGVuZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ2VudGVyQW5kWm9vbShyYW5nZSl7XG4gICAgICAgIHZhciBjdXJyZW50Qm94ZXMgPSBmaWx0ZXJWZWN0b3JCb3hMYXllcihzdG9yeU1hcC5zdG9yeUJveGVzTGF5ZXIsIHJhbmdlKTtcblxuICAgICAgICBpZihjdXJyZW50Qm94ZXMgJiYgY3VycmVudEJveGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Qm94ID0gY3VycmVudEJveGVzWzBdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoY3VycmVudEJveC5jZW50ZXIpIHtcbiAgICAgICAgICAgICAgICBzdG9yeU1hcC5hbmltYXRlQ2VudGVyQW5kWm9vbShjdXJyZW50Qm94LmNlbnRlciwgY3VycmVudEJveC56b29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBpZiAoc3RvcnlNYXAucmV0dXJuVG9FeHRlbnQpIHtcbiAgICAgICAgICAgICAgICBzdG9yeU1hcC5hbmltYXRlQ2VudGVyQW5kWm9vbShzdG9yeU1hcC5nZXRDZW50ZXIoKSwgc3RvcnlNYXAuZ2V0Wm9vbSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxheWVycyhyYW5nZSkge1xuICAgICAgICB2YXIgc3RvcnlMYXllcnMgPSBzdG9yeU1hcC5nZXRTdG9yeUxheWVycygpO1xuICAgICAgICB2YXIgdGltZSA9IG5ldyBEYXRlKHJhbmdlLnN0YXJ0KS50b0lTT1N0cmluZygpO1xuICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gcmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICB0aW1lICs9IFwiL1wiICsgbmV3IERhdGUocmFuZ2UuZW5kKS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcnlMYXllcnMuZ2V0TGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0b3J5TGF5ZXIgPSBzdG9yeUxheWVycy5pdGVtKGkpLCBsYXllciA9IHN0b3J5TGF5ZXIuZ2V0TGF5ZXIoKTtcbiAgICAgICAgICAgIGlmICgobGF5ZXIgaW5zdGFuY2VvZiBvbC5sYXllci5UaWxlICYmIGxheWVyLmdldFNvdXJjZSgpIGluc3RhbmNlb2Ygb2wuc291cmNlLlRpbGVXTVMpIHx8XG4gICAgICAgICAgICAgICAgICAobGF5ZXIgaW5zdGFuY2VvZiBvbC5sYXllci5JbWFnZSAmJiBsYXllci5nZXRTb3VyY2UoKSBpbnN0YW5jZW9mIG9sLnNvdXJjZS5JbWFnZVdNUykpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcnlMYXllci5nZXQoJ3RpbWVzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZ2V0U291cmNlKCkudXBkYXRlUGFyYW1zKHtUSU1FOiB0aW1lfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXllciBpbnN0YW5jZW9mIG9sLmxheWVyLlZlY3Rvcikge1xuICAgICAgICAgICAgICAgIGZpbHRlclZlY3RvckxheWVyKHN0b3J5TGF5ZXIsIHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIGlzIGEgbm9uLXN0b3J5IGxheWVyIC0gbm90IHBhcnQgb2YgdGhlIG1haW4gY29sbGVjdGlvblxuICAgICAgICBmaWx0ZXJWZWN0b3JMYXllcihzdG9yeU1hcC5zdG9yeVBpbnNMYXllciwgcmFuZ2UpO1xuICAgICAgICBpZiAoc3RvcnlMYXllcnMuZ2V0TGVuZ3RoKCkgPj0gMSkge1xuICAgICAgICAgICAgdGltZUNvbnRyb2xzLmRlZmVyKGNyZWF0ZUxvYWRMaXN0ZW5lcigpLmRlZmVycmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIG1lLmxheWVycyA9IHt9O1xuICAgIHN0b3J5TWFwLmdldFN0b3J5TGF5ZXJzKCkub24oJ2FkZCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHZhciBseXIgPSBldi5lbGVtZW50LCBpZCA9IGx5ci5nZXQoJ2lkJyk7XG4gICAgICAgIGlmIChtZS5sYXllcnNbaWRdICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBsYXllckFkZGVkKGx5ci5nZXRMYXllcigpKTtcbiAgICAgICAgICAgIG1lLmxheWVyc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgc3RvcnlNYXAuZ2V0U3RvcnlMYXllcnMoKS5mb3JFYWNoKGZ1bmN0aW9uKGx5cikge1xuICAgICAgICB2YXIgaWQgPSBseXIuZ2V0KCdpZCcpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiBtZS5sYXllcnNbaWRdICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBsYXllckFkZGVkKGx5ci5nZXRMYXllcigpKTtcbiAgICAgICAgICAgIG1lLmxheWVyc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGltZUNvbnRyb2xzLm9uKCdyYW5nZUNoYW5nZScsIHVwZGF0ZUNlbnRlckFuZFpvb20pO1xuICAgIHRpbWVDb250cm9scy5vbigncmFuZ2VDaGFuZ2UnLCB1cGRhdGVMYXllcnMpO1xufTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBCb3hNb2RlbCA9IHJlcXVpcmUoJy4vYm94ZXMnKS5Cb3hNb2RlbDtcblxuLyoqXG4gKiBAdG9kbyBkb2N1bWVudCBtZVxuICovXG5leHBvcnRzLlRpbWVNb2RlbCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGJveGVzLCBhbm5vdGF0aW9ucykge1xuICAgIFxuICAgIHZhciBldmVudHMgPSBuZXcgdXRpbHMuRXZlbnRzKCksXG4gICAgICAgIGJveE1vZGVsID0gbmV3IEJveE1vZGVsKGJveGVzKTtcblxuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICB0aGlzLmJveGVzID0gYm94ZXM7XG4gICAgdGhpcy5ib3h5ID0gb3B0aW9ucy5ib3h5O1xuICAgIHRoaXMuc3RvcnlMYXllcnMgPSBbXTtcbiAgICB0aGlzLmZpeGVkID0gZmFsc2U7XG4gICAgdGhpcy5tb2RlID0gJ2luc3RhbnQnO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSAxMDAwO1xuXG4gICAgZnVuY3Rpb24gaW5pdChvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KCdmaXhlZCcpKSB7XG4gICAgICAgICAgICB0aGlzLmZpeGVkID0gb3B0cy5maXhlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KCdzcGVlZCcpICYmIG9wdHMuc3BlZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IG9wdHMuc3BlZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eSgnbW9kZScpICYmIG9wdHMubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBvcHRzLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoJ2Fubm90YXRpb25zJykpIHtcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnMudXBkYXRlKG9wdHMuYW5ub3RhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KCdib3hlcycpKSB7XG4gICAgICAgICAgICB0aGlzLmJveHkudXBkYXRlKG9wdHMuYm94ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoJ3N0b3J5TGF5ZXJzJykpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcnlMYXllcnMgPSBvcHRzLnN0b3J5TGF5ZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQHRvZG8gaXMgdGhlIGJlc3QgbmFtZSBmb3IgdGhpc1xuICAgICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpKSB7XG4gICAgICAgICAgICBib3hNb2RlbC5zZXRSYW5nZShvcHRzLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuZ2V0UmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJveE1vZGVsLmdldFJhbmdlKCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFRvdGFsUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQHRvZG8gbmVlZCB0byBhY2Nlc3MgbGF5ZXJzIGFuZCBjYWNoZWQgZGltZW5zaW9uIGRhdGFcbiAgICAgICAgLy8gICAgICAgYW5kIGNvbnNpZGVyIGFubm90YXRpb25zP1xuICAgICAgICB0aHJvdyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZSA9IGluaXQ7XG4gICAgdGhpcy5nZXRTdGVwcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYm94TW9kZWwuZ2V0U3RlcHMoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0SW5kZXggPSBmdW5jdGlvbihpbnN0YW50KSB7XG4gICAgICAgIHJldHVybiBib3hNb2RlbC5nZXRJbmRleChpbnN0YW50KTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0UmFuZ2VBdCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgICAgICAgcmV0dXJuIGJveE1vZGVsLmdldFJhbmdlQXQoaSwgaik7XG4gICAgfTtcbn07XG4iLCJ2YXIgZm9ybWF0ID0gbmV3IG9sLmZvcm1hdC5HZW9KU09OKCk7XG5cblxudmFyIFN0b3J5UGluID0gZnVuY3Rpb24oZGF0YSwgcHJvamVjdGlvbikge1xuICAgIG9sLkZlYXR1cmUuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS50aGVfZ2VvbSkge1xuICAgICAgICAgICAgdmFyIGdlb20gPSBkYXRhLnRoZV9nZW9tO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW9tID09PSAnc3RyaW5nJyB8fCAndHlwZScgaW4gZ2VvbSkge1xuICAgICAgICAgICAgICAgIGdlb20gPSBmb3JtYXQucmVhZEdlb21ldHJ5KGdlb20sIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZVByb2plY3Rpb246IHByb2plY3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0R2VvbWV0cnkoZ2VvbSk7XG4gICAgICAgICAgICBkZWxldGUgZGF0YS50aGVfZ2VvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldElkKGRhdGEuaWQpO1xuICAgIH1cbn07XG5TdG9yeVBpbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG9sLkZlYXR1cmUucHJvdG90eXBlKTtcblN0b3J5UGluLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0b3J5UGluO1xuLy8gZXhwb3NlIHRoZXNlIHNpbXBseSBmb3IgdGhlIHRpbWVsaW5lIC0gaXQgZG9lc24ndCBrbm93IHRoZXkncmUgZmVhdHVyZXNcblsnaWQnLCdzdGFydF90aW1lJywnZW5kX3RpbWUnLCdjb250ZW50JywndGl0bGUnLCdpbl90aW1lbGluZScsJ2luX21hcCcsICdhdXRvX3Nob3cnLCAncGF1c2VfcGxheWJhY2snXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcnlQaW4ucHJvdG90eXBlLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXQocHJvcCk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdmFsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQocHJvcCwgdmFsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbi8qXG4gdmFyIHN0YXJ0ID0gYW5uLnN0YXJ0X3RpbWUgIT0gbnVsbCA/IGFubi5zdGFydF90aW1lIDogcmFuZ2Uuc3RhcnQ7XG4gdmFyIGVuZCA9IGFubi5lbmRfdGltZSAhPSBudWxsID8gYW5uLmVuZF90aW1lIDogcmFuZ2UuZW5kO1xuIHZhciB0eXBlID0gc3RhcnQgPT09IGVuZCA/ICdib3gnIDogJ3JhbmdlJztcbiByZXR1cm4ge1xuIGlkOiBhbm4uaWQsXG4gc3RhcnQ6IHN0YXJ0LFxuIGVuZDogZW5kLFxuIGNvbnRlbnQ6IGFubi5jb250ZW50IHx8IGFubi50aXRsZSxcbiB0aXRsZTogYW5uLnRpdGxlLFxuIHR5cGU6IHR5cGVcbiB9O1xuICovXG5cbmZ1bmN0aW9uIGdldFRpbWUocHJvcHMsIHByb3ApIHtcbiAgICB2YXIgdmFsID0gcHJvcHNbcHJvcF07XG4gICAgaWYgKHR5cGVvZiB2YWwgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbCAqPSAxMDAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBMb2FkIFN0b3J5UGlucyBmcm9tIGdlb2pzb24sIHJlcHJvamVjdGluZyBmcm9tIDQzMjYgdG8gdGhlIHByb3ZpZGVkXG4gKiBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGdlb2pzb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9qZWN0aW9uXG4gKiBAcmV0dXJucyBhcnJheSBvZiBTdG9yeVBpbiBmZWF0dXJlc1xuICovXG5leHBvcnRzLmxvYWRGcm9tR2VvSlNPTiA9IGZ1bmN0aW9uKGdlb2pzb24sIHByb2plY3Rpb24pIHtcbiAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgICBwcm9qZWN0aW9uID0gb2wucHJvai5nZXQocHJvamVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBnZW9qc29uLmZlYXR1cmVzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGYucHJvcGVydGllcztcbiAgICAgICAgcHJvcHMudGhlX2dlb20gPSBmLmdlb21ldHJ5O1xuICAgICAgICBwcm9wcy5pZCA9IGYuaWQ7XG4gICAgICAgIHByb3BzLnN0YXJ0X3RpbWUgPSBnZXRUaW1lKHByb3BzLCAnc3RhcnRfdGltZScpO1xuICAgICAgICBwcm9wcy5lbmRfdGltZSA9IGdldFRpbWUocHJvcHMsICdlbmRfdGltZScpO1xuICAgICAgICByZXR1cm4gbmV3IFN0b3J5UGluKHByb3BzLCBwcm9qZWN0aW9uKTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydHMuU3RvcnlQaW4gPSBTdG9yeVBpbjtcbiIsIi8qKlxuICogVmlzdWFsIGZlZWRiYWNrIG9mIGNvbXBsZXRlIHN0b3J5IGxpbmUuIEFsbG93IGRyYWdnaW5nIG9mIHJhbmdlLCBjbGlja1xuICogdG8gcG9zaXRpb24uXG4gKlxuICogUGxheWJhY2sgTW9kZXNcbiAqIC0gZml4ZWQgY3VtdWxhdGl2ZSAobWluIGZpeGVkIGF0IDAsIG1heCBhZGp1c3RzIHdpdGggdGljaylcbiAqIC0gZml4ZWQgcmFuZ2UgcGxheWJhY2sgKHJhbmdlIGZpeGVkLCB3aW5kb3cgYWRqdXN0cyB3aXRoIHRpY2spXG4gKiAtIGZpeGVkIGluc3RhbnQgKGxpa2UgZml4ZWQgcmFuZ2UgYnV0IHJhbmdlIG9mIDApXG4gKiAtIG9wZW4gcmFuZ2UgcGxheWJhY2sgKGZ1bGx5IGFkanVzdGFibGUgbWluL21heCwgd2luZG93IGFkanVzdHMgd2l0aCB0aWNrKVxuICpcbiAqIEludGVybmFsIG1vZGVsXG4gKiAtIDAtTiB3aGVyZSBOIGlzIGVpdGhlciB0aGUgbnVtYmVyIG9mIGluc3RhbnRzIG9yIHRoZSB0b3RhbCBudW1iZXIgb2YgZXh0ZW50c1xuICpcbiAqIEBwYXJhbSB7dHlwZX0gaWRcbiAqIEBwYXJhbSB7dHlwZX0gbW9kZWxcbiAqIEByZXR1cm5zIHtUaW1lU2xpZGVyfVxuICovXG5leHBvcnRzLlRpbWVTbGlkZXIgPSBmdW5jdGlvbihpZCwgbW9kZWwpIHtcbiAgICB2YXIgc2xpZGVyID0gJChcIiNcIiArIGlkKTtcbiAgICB2YXIgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB2YXIgc2luZ2xlU2xpZGVyO1xuXG4gICAgZnVuY3Rpb24gaW5pdChtb2RlbCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHN0ZXA6IDEsXG4gICAgICAgICAgICBzdGFydDogWzAsIDBdLFxuICAgICAgICAgICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgICAgICAgICBjb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgbWF4OiBtb2RlbC5nZXRTdGVwcygpIC0gMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJlaGF2aW91cjogJ2RyYWctc25hcCdcbiAgICAgICAgfTtcbiAgICAgICAgc2luZ2xlU2xpZGVyID0gZmFsc2U7XG5cbiAgICAgICAgLyppZiAobW9kZWwuZml4ZWQpIHtcbiAgICAgICAgICAgIC8vIEB0b2RvIG5lZWQgbW9kZWwgaW50ZXJ2YWxcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKG1vZGVsLm1vZGUgPT09ICdjdW11bGF0aXZlJykge1xuICAgICAgICAgICAgc2luZ2xlU2xpZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wdGlvbnMuY29ubmVjdCA9ICdsb3dlcic7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWwubW9kZSA9PT0gJ2luc3RhbnQnKSB7XG4gICAgICAgICAgICBzaW5nbGVTbGlkZXIgPSB0cnVlO1xuICAgICAgICAgICAgb3B0aW9ucy5jb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWwubW9kZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICAgICAgaWYgKG1vZGVsLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaWRlYWxseSB3ZSdkIHN1cHBvcnQgc25hcCBidXQgaXQgYnJlYWtzIGZpeGVkXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5iZWhhdmlvdXIgPSAnZHJhZy1maXhlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcImludmFsaWQgbW9kZWwgbW9kZSA6IFwiICsgbW9kZWwubW9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgLy8gaGF2ZSB0byB1cGRhdGUgdmFsdWVzIGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGdldFNsaWRlclJhbmdlSW50ZXJuYWwoKTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVTbGlkZXIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXJ0ID0gcmFuZ2VbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZVswXSA9PT0gcmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0gKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdGFydCA9IHJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNpbmdsZVNsaWRlcikge1xuICAgICAgICAgICAgb3B0aW9ucy5zdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc2xpZGVyLm5vVWlTbGlkZXIob3B0aW9ucywgaW5pdGlhbGl6ZWQpO1xuICAgICAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBzbGlkZXIuYmluZCgnc2xpZGUnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdldFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgc2xpZGVyLnRyaWdnZXIoJ3JhbmdlQ2hhbmdlZCcsIHJhbmdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpbml0KG1vZGVsKTtcblxuICAgIGZ1bmN0aW9uIGdldFNsaWRlclJhbmdlSW50ZXJuYWwoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHNsaWRlci52YWwoKTtcbiAgICAgICAgaWYgKCEgQXJyYXkuaXNBcnJheShyYW5nZSkpIHtcbiAgICAgICAgICAgIHJhbmdlID0gcGFyc2VJbnQocmFuZ2UsIDEwKTtcbiAgICAgICAgICAgIHJhbmdlID0gW21vZGVsLm1vZGUgPT09ICdjdW11bGF0aXZlJyA/IDAgOiByYW5nZSwgcmFuZ2VdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UgPSByYW5nZS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gcGFyc2VJbnQoaSwgMTApOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmFuZ2UoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGdldFNsaWRlclJhbmdlSW50ZXJuYWwoKTtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmdldFJhbmdlQXQocmFuZ2VbMF0sIHJhbmdlWzFdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aWR0aCgpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZ2V0U2xpZGVyUmFuZ2VJbnRlcm5hbCgpO1xuICAgICAgICByZXR1cm4gcmFuZ2VbMV0gLSByYW5nZVswXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0F0RW5kKGxlZnQpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZ2V0U2xpZGVyUmFuZ2VJbnRlcm5hbCgpO1xuICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzBdID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZVsxXSA9PT0gbW9kZWwuZ2V0U3RlcHMoKS0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlKHZhbCkge1xuICAgICAgICAvLyBub3JtYWxpemUgbm91aXNsaWRlci52YWwgdG8gaGFuZGxlIGFycmF5XG4gICAgICAgIGlmIChzaW5nbGVTbGlkZXIpIHtcbiAgICAgICAgICAgIHNsaWRlci52YWwodmFsWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNsaWRlci52YWwodmFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2xpZGVyID0gc2xpZGVyO1xuICAgIHRoaXMub24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2xpZGVyLm9uLmFwcGx5KHNsaWRlciwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2xpZGVyUmFuZ2VJbnRlcm5hbCA9IGdldFNsaWRlclJhbmdlSW50ZXJuYWw7XG4gICAgdGhpcy5jZW50ZXIgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgaGFsZiA9IE1hdGguZmxvb3Iod2lkdGgoKSAvIDIpO1xuICAgICAgICBzZXRWYWx1ZShbaW5kZXggLSBoYWxmLCBpbmRleCArIGhhbGZdKTtcbiAgICB9O1xuICAgIHRoaXMubW92ZSA9IGZ1bmN0aW9uKGFtdCkge1xuICAgICAgICB2YXIgdmFscyAgPSBnZXRTbGlkZXJSYW5nZUludGVybmFsKCk7XG4gICAgICAgIHZhbHNbMF0gKz0gYW10O1xuICAgICAgICB2YWxzWzFdICs9IGFtdDtcbiAgICAgICAgc2V0VmFsdWUodmFscyk7XG4gICAgICAgIHJldHVybiBpc0F0RW5kKGFtdCA8IDApO1xuICAgIH07XG4gICAgdGhpcy5ncm93ID0gZnVuY3Rpb24oYW10KSB7XG4gICAgICAgIHZhciB2YWxzID0gZ2V0U2xpZGVyUmFuZ2VJbnRlcm5hbCgpO1xuICAgICAgICB2YWxzWzFdICs9IGFtdDtcbiAgICAgICAgc2V0VmFsdWUodmFscyk7XG4gICAgICAgIHJldHVybiBpc0F0RW5kKGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMuZ3Jvd1RvID0gZnVuY3Rpb24od2hlcmUpIHtcbiAgICAgICAgdmFyIHZhbHMgPSBnZXRTbGlkZXJSYW5nZUludGVybmFsKCk7XG4gICAgICAgIHZhbHNbMV0gPSB3aGVyZTtcbiAgICAgICAgc2V0VmFsdWUodmFscyk7XG4gICAgICAgIHJldHVybiBpc0F0RW5kKGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMuanVtcCA9IGZ1bmN0aW9uKHRvKSB7XG4gICAgICAgIHNldFZhbHVlKFt0bywgdG8gKyB3aWR0aCgpXSk7XG4gICAgfTtcbiAgICB0aGlzLmdldFJhbmdlID0gZ2V0UmFuZ2U7XG4gICAgdGhpcy51cGRhdGUgPSBpbml0O1xufTtcbiIsInZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgcHJvdmlkZWQgYXJnLlxuICogQHBhcmFtIGFyZyAtIGVpdGhlciBEYXRlLCByYW5nZSAocmV0dXJucyBzdGFydCksIHN0cmluZyBvciBudW1iZXJcbiAqIEByZXR1cm5zIG1pbGxpc2Vjb25kcyBvciBudWxsIGlmIG5vdGhpbmcgcHJvdmlkZWRcbiAqL1xuZ2V0VGltZSA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGFyZztcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFyc2VEYXRlKGFyZykuZ2V0VGltZSgpO1xuICAgIH1cbiAgICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlzUmFuZ2VMaWtlKGFyZykpIHtcbiAgICAgICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIGdldFRpbWUoYXJnLnN0YXJ0ICE9IG51bGwgPyBhcmcuc3RhcnQgOiBhcmcuZW5kKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2FsbCBnZXRUaW1lIHdpdGggJyArIHR5cGUgKyBcIiwgOiBcIiArIGFyZyk7XG59O1xuXG5pc1JhbmdlTGlrZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIChvYmplY3QuaGFzT3duUHJvcGVydHkoJ3N0YXJ0JykgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KCdlbmQnKSk7XG59O1xuXG5leHBvcnRzLmlzUmFuZ2VMaWtlID0gaXNSYW5nZUxpa2U7XG5cbmV4cG9ydHMuY3JlYXRlUmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIG90aGVyID0gc3RhcnQ7XG4gICAgICAgIGlmIChpc1JhbmdlTGlrZShvdGhlcikpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gb3RoZXIuc3RhcnQ7XG4gICAgICAgICAgICBlbmQgPSBvdGhlci5lbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgIGlmIChzdGFydCAhPSBudWxsICYmIGVuZCAhPSBudWxsICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgPiBlbmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSYW5nZShnZXRUaW1lKHN0YXJ0KSwgZ2V0VGltZShlbmQpKTtcbn07XG5cbmV4cG9ydHMucmFuZ2VzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGdldFRpbWUoYS5zdGFydCkgPT09IGdldFRpbWUoYi5zdGFydCkgJiZcbiAgICAgICAgZ2V0VGltZShhLmVuZCkgPT09IGdldFRpbWUoYi5lbmQpO1xufTtcblxuZnVuY3Rpb24gcmFuZ2VDb250YWlucyhyYW5nZSwgdGltZSkge1xuICAgIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgaWYgKHRpbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGltZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgIHJldHVybiAoKHJhbmdlLnN0YXJ0ICE9IG51bGwgPyB0aW1lID49IHJhbmdlLnN0YXJ0IDogdHJ1ZSkgJiZcbiAgICAgICAgICAgKHJhbmdlLmVuZCAhPSBudWxsID8gdGltZSA8IHJhbmdlLmVuZCA6IHRydWUpKSB8fFxuICAgICAgICAgICByYW5nZS5zdGFydCA9PT0gcmFuZ2UuZW5kICYmIHRpbWUgPT09IHJhbmdlLnN0YXJ0O1xufVxuXG5leHBvcnRzLnBhcnNlSVNPRHVyYXRpb24gPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgIHZhciB2YWx1ZXMgPSBleHBvcnRzLmlzb0R1cmF0aW9uVG9Nb21lbnQoZHVyYXRpb24pO1xuICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24odmFsdWVzKS5hc01pbGxpc2Vjb25kcygpO1xufTtcblxuZXhwb3J0cy5JbnRlcnZhbCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGR1cmF0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSBvcHRzLnN0YXJ0O1xuICAgICAgICBlbmQgPSBvcHRzLmVuZDtcbiAgICAgICAgZHVyYXRpb24gPSBvcHRzLmR1cmF0aW9uO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVydmFsIHNob3VsZCBoYXZlIHdpZHRoJyk7XG4gICAgfVxuICAgIFJhbmdlLmNhbGwodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBleHBvcnRzLnBhcnNlSVNPRHVyYXRpb24odGhpcy5kdXJhdGlvbik7XG4gICAgdGhpcy5vZmZzZXQgPSBleHBvcnRzLmNyZWF0ZU9mZnNldHRlcih0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoaXNOYU4oc3RhcnQpIHx8IGlzTmFOKGVuZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXJ0IGFuZC9vciBlbmQnKTtcbiAgICB9XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xufVxuLyoqXG4gKiBleHRlbmQgdGhpcyBSYW5nZSBieSBhbm90aGVyLiBUaGlzIGFsZ29yaXRobSB3aWxsIGNvbnNpZGVyIGFuIG9wZW4tZW5kZWRcbiAqIHJhbmdlIHRvIHJlcHJlc2VudCBhIG1pbmltdW0gb2Ygc3RhcnQgYW5kIG1heGltdW0gb2YgZW5kLlxuICogQHBhcmFtIHt0eXBlfSBvdGhlclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUmFuZ2UucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICBpZiAoIWlzUmFuZ2VMaWtlKG90aGVyKSkge1xuICAgICAgICBvdGhlciA9IGV4cG9ydHMuY3JlYXRlUmFuZ2Uob3RoZXIpO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBnZXRUaW1lKG90aGVyLnN0YXJ0KTtcbiAgICB2YXIgZW5kID0gZ2V0VGltZShvdGhlci5lbmQpO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgIH1cbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBNYXRoLm1pbih0aGlzLnN0YXJ0LCBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gTWF0aC5tYXgodGhpcy5lbmQsIGVuZCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmIChpc1JhbmdlTGlrZShvdGhlcikpIHtcbiAgICAgICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgdmFyIGVzID0gb3RoZXIuc3RhcnQgPT0gbnVsbCA/IE51bWJlci5NSU5fVkFMVUUgOiBvdGhlci5zdGFydDtcbiAgICAgICAgdmFyIGVlID0gb3RoZXIuZW5kID09IG51bGwgPyBOdW1iZXIuTUFYX1ZBTFVFIDogb3RoZXIuZW5kO1xuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gaWYgKGFueSlcbiAgICAgICAgLy8gZWZmZWN0aXZlIGVuZCBpbiB0aGlzIHJhbmdlXG4gICAgICAgIC8vIGVmZmVjdGl2ZSBzdGFydCBpbiB0aGlzIHJhbmdlXG4gICAgICAgIC8vIGVmZmVjdGl2ZSBzdGFydCBiZWZvcmUgYW5kIGVmZmVjdGl2ZSBlbmQgYWZ0ZXJcbiAgICAgICAgcmV0dXJuIHJhbmdlQ29udGFpbnModGhpcywgZXMpIHx8XG4gICAgICAgICAgICByYW5nZUNvbnRhaW5zKHRoaXMsIGVlKSB8fFxuICAgICAgICAgICAgZXMgPD0gdGhpcy5zdGFydCAmJiBlZSA+PSB0aGlzLmVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmFuZ2VDb250YWlucyh0aGlzLCBnZXRUaW1lKG90aGVyKSk7XG4gICAgfVxufTtcblJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnN0YXJ0KS50b1VUQ1N0cmluZygpICsgXCIgOiBcIiArIG5ldyBEYXRlKHRoaXMuZW5kKS50b1VUQ1N0cmluZygpO1xufTtcblJhbmdlLnByb3RvdHlwZS5jZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnN0YXJ0ICsgKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgLyAyKTtcbn07XG5SYW5nZS5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbmQgLSB0aGlzLnN0YXJ0O1xufTtcblJhbmdlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICByZXR1cm4gdGhpcy5lbmQgPT0gbnVsbCAmJiB0aGlzLnN0YXJ0ID09IG51bGw7XG59O1xuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuXG5cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBvdmVyYWxsIHJhbmdlIG9mIHByb3ZpZGVkIGFyZ3MuIEFyZ3MgbWF5IGJlIGFuIGFycmF5IG9mOlxuICogZGF0ZSBvciBsb25nLCByYW5nZSwgb2JqZWN0IHdpdGggcHJvcGVydHkvZnVuY3Rpb24geWllbGRpbmcgcmFuZ2UgZm9yIHRoZVxuICogb2JqZWN0LlxuICogQHBhcmFtIHt0eXBlfSBhcmdzXG4gKiBAcmV0dXJucyByYW5nZSB3aWxsIGhhdmUgc3RhcnQvZW5kIGV2ZW4gaWYgdGhlIHNhbWUgdGltZS5cbiAqL1xuZXhwb3J0cy5jb21wdXRlUmFuZ2UgPSBmdW5jdGlvbihhcmdzLCByYW5nZUdldHRlcikge1xuICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShudWxsLCBudWxsKTtcbiAgICBleHBvcnRzLnZpc2l0UmFuZ2VzKGFyZ3MsIHJhbmdlR2V0dGVyLCBmdW5jdGlvbihhcmcsIHIpIHtcbiAgICAgICAgcmFuZ2UuZXh0ZW5kKHIpO1xuICAgIH0pO1xuICAgIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgaWYgKHJhbmdlLnN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgcmFuZ2Uuc3RhcnQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgPT0gbnVsbCkge1xuICAgICAgICByYW5nZS5lbmQgPSByYW5nZS5zdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcblxuZXhwb3J0cy52aXNpdFJhbmdlcyA9IGZ1bmN0aW9uKG9iamVjdHMsIHJhbmdlR2V0dGVyLCB2aXNpdG9yKSB7XG4gICAgdmFyIGdldFJhbmdlO1xuICAgIGlmICh0eXBlb2YgcmFuZ2VHZXR0ZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ2V0UmFuZ2UgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbcmFuZ2VHZXR0ZXJdO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhbmdlR2V0dGVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZ2V0UmFuZ2UgPSByYW5nZUdldHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRSYW5nZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUmFuZ2VMaWtlKG9iamVjdCkgPyBvYmplY3QgOiBleHBvcnRzLmNyZWF0ZVJhbmdlKG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG9iamVjdHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0c1tpXTtcbiAgICAgICAgdmlzaXRvcihvYmplY3QsIGdldFJhbmdlKG9iamVjdCkpO1xuICAgIH1cbn07XG5cbi8qKiBmb3IgdGhlIGdpdmVuIHdoYXQsIGZpbmQgdGhlIGluZGV4IGluIHRoZSBpdGVtcyB0aGF0IHdoYXQgaXMgY2xvc2VzdFxuICogdG8uIGl0ZW1zIG11c3QgYmUgc29ydGVkLiBUaGUgbG93ZXN0IGNsb3Nlc3QgdmFsdWUgcG9zc2libGUgaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydHMuYmluYXJ5U2VhcmNoID0gZnVuY3Rpb24oaXRlbXMsIHdoYXQpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIHZhciBzdG9wID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbWlkID0gc3RvcCArIHN0YXJ0IC8gMiB8IDA7XG4gICAgdmFyIHZhbDtcbiAgICBpZiAod2hhdCA8IGl0ZW1zWzBdKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAod2hhdCA+IGl0ZW1zW3N0b3BdKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICB3aGlsZSAoKHZhbCA9IGl0ZW1zW21pZF0pICE9PSB3aGF0ICYmIHN0YXJ0IDwgc3RvcCkge1xuICAgICAgICBpZiAod2hhdCA+IHZhbCkge1xuICAgICAgICAgICAgaWYgKHdoYXQgPCBpdGVtc1ttaWQgKyAxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2hhdCA8IHZhbCkge1xuICAgICAgICAgICAgaWYgKHdoYXQgPiBpdGVtc1ttaWQgLSAxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcCA9IG1pZCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgbWlkID0gc3RvcCArIHN0YXJ0IC8gMiB8IDA7XG4gICAgfVxuICAgIHJldHVybiBtaWQ7XG59O1xuXG5leHBvcnRzLmZpbmQgPSBmdW5jdGlvbihpdGVtcywgd2hhdCkge1xuICAgIGlmICh3aGF0IDwgaXRlbXNbMF0pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmICh3aGF0ID49IGl0ZW1zW2ldICYmIHdoYXQgPCBpdGVtc1tpICsgMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtcy5sZW5ndGggLSAxO1xufTtcblxuZXhwb3J0cy5FdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG9waWNzID0ge307XG5cbiAgICAvLyBAdG9kbyBpbnRyb2R1Y2Ugc2V0dGluZyB0b3BpY3Mgd2l0aCBhcmd1bWVudHMgYW5kIGxvZ2dpbmcvZXhjZXB0aW9uXG4gICAgLy8gb24gdW4tZmlyZWQgZXZlbnRcblxuICAgIGZ1bmN0aW9uIGV2ZW50KGlkKSB7XG4gICAgICAgIHZhciBjYWxsYmFja3MsIG1ldGhvZCxcbiAgICAgICAgICAgICAgICB0b3BpYyA9IGlkICYmIHRvcGljc1sgaWQgXTtcbiAgICAgICAgaWYgKCF0b3BpYykge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0galF1ZXJ5LkNhbGxiYWNrcygpO1xuICAgICAgICAgICAgdG9waWMgPSB7XG4gICAgICAgICAgICAgICAgcHVibGlzaDogY2FsbGJhY2tzLmZpcmUsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlOiBjYWxsYmFja3MuYWRkLFxuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBjYWxsYmFja3MucmVtb3ZlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzWyBpZCBdID0gdG9waWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50OiBldmVudFxuICAgIH07XG59O1xuXG5leHBvcnRzLnBpY2tJbnRlcnZhbCA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgdmFyIGludGVydmFscyA9IFtcbiAgICAgICAgbW9tZW50LmR1cmF0aW9uKDEsICdzZWNvbmRzJykuYXNNaWxsaXNlY29uZHMoKSxcbiAgICAgICAgbW9tZW50LmR1cmF0aW9uKDEsICdtaW51dGVzJykuYXNNaWxsaXNlY29uZHMoKSxcbiAgICAgICAgbW9tZW50LmR1cmF0aW9uKDEsICdob3VycycpLmFzTWlsbGlzZWNvbmRzKCksXG4gICAgICAgIG1vbWVudC5kdXJhdGlvbigxLCAnZGF5cycpLmFzTWlsbGlzZWNvbmRzKCksXG4gICAgICAgIG1vbWVudC5kdXJhdGlvbigxLCAnd2Vla3MnKS5hc01pbGxpc2Vjb25kcygpLFxuICAgICAgICBtb21lbnQuZHVyYXRpb24oMSwgJ21vbnRocycpLmFzTWlsbGlzZWNvbmRzKCksXG4gICAgICAgIG1vbWVudC5kdXJhdGlvbigxLCAneWVhcnMnKS5hc01pbGxpc2Vjb25kcygpXG4gICAgXTtcbiAgICByZXR1cm4gaW50ZXJ2YWxzW01hdGgubWF4KGV4cG9ydHMuZmluZChpbnRlcnZhbHMsIHJhbmdlLndpZHRoKCkpIC0gMSwgMCldO1xufTtcblxuZXhwb3J0cy5nZXRUaW1lID0gZ2V0VGltZTtcblxuLyoqXG4gKiBSZWFkIGFuIGlzbyBkdXJhdGlvbiBpbnRvIGEgbW9tZW50LmpzIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkdXJhdGlvblxuICogQHJldHVybnMge29iamVjdH0gd2l0aCBtb21lbnQuanMgaW5mb1xuICovXG5leHBvcnRzLmlzb0R1cmF0aW9uVG9Nb21lbnQgPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbi5jaGFyQXQoMCkgIT0gJ1AnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgUCBhcyBzdGFydGluZyBkdXJhdGlvbiA6ICcgKyBkdXJhdGlvbik7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gLyhcXGQrKShcXHcpL2c7XG4gICAgdmFyIGRhdGUgPSBudWxsLCB0aW1lID0gbnVsbCwgdmFsdWVzID0ge307XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbi5zdWJzdHJpbmcoMSk7XG4gICAgaWYgKGR1cmF0aW9uLmluZGV4T2YoJ1QnKSA+PSAwKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGR1cmF0aW9uLnNwbGl0KCdUJyk7XG4gICAgICAgIGRhdGUgPSBwYXJ0c1swXTtcbiAgICAgICAgdGltZSA9IHBhcnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUgPSBkdXJhdGlvbjtcbiAgICB9XG4gICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICdZJzogJ3llYXJzJyxcbiAgICAgICAgJ00nOiAnbW9udGhzJyxcbiAgICAgICAgJ1cnOiAnd2Vla3MnLFxuICAgICAgICAnRCc6ICdkYXlzJyxcbiAgICAgICAgJ0gnOiAnaG91cnMnLFxuICAgICAgICAnbSc6ICdtaW51dGVzJyxcbiAgICAgICAgJ1MnOiAnc2Vjb25kcydcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhcnNlKGNodW5rLCB0aW1lKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJlYWQoYW1vdW50LCBwYXJ0KSB7XG4gICAgICAgICAgICBpZiAodGltZSAmJiBwYXJ0ID09ICdNJykge1xuICAgICAgICAgICAgICAgIHBhcnQgPSAnbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWFwcGVkVG8gPSBtYXBwaW5nW3BhcnRdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXBwZWRUbyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCd1bmtub3duIGR1cmF0aW9uIHNwZWNpZmllciA6ICcgKyBwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1ttYXBwZWRUb10gPSBwYXJzZUZsb2F0KGFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHdoaWxlICgobmV4dCA9IHBhdHRlcm4uZXhlYyhjaHVuaykpICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkKG5leHRbMV0sIG5leHRbMl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRlICE9PSBudWxsKSB7XG4gICAgICAgIHBhcnNlKGRhdGUsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKHRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgcGFyc2UodGltZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuXG4vKipcbiAqIEdldCBhIGZ1bmN0aW9uIGZvciB0aGUgcHJvdmlkZWQgZHVyYXRpb24gdGhhdCBjb21wdXRlcyBhIG5ldyB0aW1lc3RhbXAgYmFzZWQgb24gYVxuICogcHJvdmlkZWQgZGF0ZSBhbmQgb3B0aW9uYWwgbXVsdGlwbGllciAobmVnYXRpdmUgZm9yIHJldmVyc2UpLlxuICogQHBhcmFtIHtzdHJpbmd9IGlzbyBkdXJhdGlvblxuICogQHJldHVybnMge2Z1bmN0aW9ufSBvZmZzZXR0ZXIodGltZXN0YW1wLCBtdWx0aXBsaWVyPTEpXG4gKi9cbmV4cG9ydHMuY3JlYXRlT2Zmc2V0dGVyID0gZnVuY3Rpb24oaW50ZXJ2YWxPckR1cmF0aW9uKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gdHlwZW9mIGludGVydmFsT3JEdXJhdGlvbiA9PT0gJ3N0cmluZycgPyBpbnRlcnZhbE9yRHVyYXRpb246IGludGVydmFsT3JEdXJhdGlvbi5kdXJhdGlvbjtcbiAgICB2YXIgdmFsdWVzID0gZXhwb3J0cy5pc29EdXJhdGlvblRvTW9tZW50KGR1cmF0aW9uKTtcbiAgICAvLyBhcyBvZiB3cml0aW5nLCBtb21lbnQgYXNzdW1lcyB5PTM2NWQgYW5kIG09MzBkIHJlc3VsdGluZyBpbiBzbG93XG4gICAgLy8gZGF5IG9mIG1vbnRoIHNoaWZ0cyB0aGF0IGJyZWFrIHRpY2tzIGZyb20gbWF0Y2hpbmdcbiAgICAvLyBzbyB3ZSB0YWtlIGNhcmUgb2YgdGhpcyB1c2luZyBhIG1vcmUgYWNjdXJhdGUgYXBwcm9hY2hcbiAgICAvLyAqKiB0aGUgY3VycmVudCBhcHByb2FjaCBicmVha3MgZG93biBpZiB0aGUgZGF5IG9mIG1vbnRoIGlzIGdyZWF0ZXIgdGhhblxuICAgIC8vIDI4IGFuZCBkYXkgb2YgbW9udGggd2lsbCBubyBsb25nZXIgYmUgcmV0YWluZWQgKHdpbGwgc2hpZnQpXG4gICAgaWYgKCd5ZWFycycgaW4gdmFsdWVzIHx8ICdtb250aHMnIGluIHZhbHVlcykge1xuICAgICAgICB2YXIgeWVhcnMgPSB2YWx1ZXMueWVhcnM7XG4gICAgICAgIHZhciBtb250aHMgPSB2YWx1ZXMubW9udGhzO1xuICAgICAgICB2YWx1ZXMueWVhcnMgPSAwO1xuICAgICAgICB2YWx1ZXMubW9udGhzID0gMDtcbiAgICAgICAgdmFyIG1pbGxpcyA9IG1vbWVudC5kdXJhdGlvbih2YWx1ZXMpLmFzTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0cywgbXVsdCkge1xuICAgICAgICAgICAgbXVsdCA9IG11bHQgfHwgMTtcbiAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUodHMpO1xuICAgICAgICAgICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICAgIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgaWYgKHllYXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB5ICs9IG11bHQgKiB5ZWFycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtID0gZC5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgaWYgKG1vbnRocyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbSArPSBtdWx0ICogbW9udGhzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5zZXRVVENGdWxsWWVhcih5LCBtKTtcbiAgICAgICAgICAgIHJldHVybiBkLmdldFRpbWUoKSArIChtdWx0ICogbWlsbGlzKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbW9tZW50LmR1cmF0aW9uKHZhbHVlcykuYXNNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRzLCBtdWx0KSB7XG4gICAgICAgICAgICBtdWx0ID0gbXVsdCB8fCAxO1xuICAgICAgICAgICAgcmV0dXJuIHRzICsgKG11bHQgKiBvZmZzZXQpO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBDb250YWlucyBpbXBsZW1lbnRhdGlvbnMgb2YgRGF0ZS5wYXJzZSBhbmQgZGF0ZS50b0lTT1N0cmluZyB0aGF0IG1hdGNoIHRoZVxuICogICAgIEVDTUFTY3JpcHQgNSBzcGVjaWZpY2F0aW9uIGZvciBwYXJzaW5nIFJGQyAzMzM5IGRhdGVzLlxuICogICAgIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzlcbiAqL1xuXG5cbi8qKlxuICogVGhlIHJlZ2V4IHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpbmcgZGF0ZXMuIFlvdSBjYW4gcHJvdmlkZSB5b3VyIG93blxuICogcmVnZXggZm9yIGluc3RhbmNlIGZvciBhZGRpbmcgc3VwcG9ydCBmb3IgeWVhcnMgYmVmb3JlIEJDLiBEZWZhdWx0XG4gKiB2YWx1ZSBpczogL14oPzooXFxkezR9KSg/Oi0oXFxkezJ9KSg/Oi0oXFxkezJ9KSk/KT8pPyg/Oig/OlQoXFxkezEsMn0pOihcXGR7Mn0pOihcXGR7Mn0oPzpcXC5cXGQrKT8pKFp8KD86WystXVxcZHsxLDJ9KD86OihcXGR7Mn0pKT8pKSl8Wik/JC9cbiAqL1xudmFyIGRhdGVSZWdFeCA9IC9eKC0/KSg/OihcXGR7NH0pKD86LShcXGR7Mn0pKD86LShcXGR7Mn0pKT8pPyk/KD86KD86VChcXGR7MSwyfSk6KFxcZHsyfSk6KFxcZHsyfSg/OlxcLlxcZCspPykoWnwoPzpbKy1dXFxkezEsMn0oPzo6KFxcZHsyfSkpPykpKXxaKT8kLztcblxuXG4vKipcbiAqIEdlbmVyYXRlIGEgZGF0ZSBvYmplY3QgZnJvbSBhIHN0cmluZy4gIFRoZSBmb3JtYXQgZm9yIHRoZSBzdHJpbmcgZm9sbG93c1xuICogICAgIHRoZSBwcm9maWxlIG9mIElTTyA4NjAxIGZvciBkYXRlIGFuZCB0aW1lIG9uIHRoZSBJbnRlcm5ldCAoc2VlXG4gKiAgICAgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSkuICBXZSBkb24ndCBjYWxsIHRoZSBuYXRpdmVcbiAqICAgICBEYXRlLnBhcnNlIGJlY2F1c2Ugb2YgaW5jb25zaXN0ZW5jeSBiZXR3ZWVuIGltcGxtZW50YXRpb25zLiAgSW5cbiAqICAgICBDaHJvbWUsIGNhbGxpbmcgRGF0ZS5wYXJzZSB3aXRoIGEgc3RyaW5nIHRoYXQgZG9lc24ndCBjb250YWluIGFueVxuICogICAgIGluZGljYXRpb24gb2YgdGhlIHRpbWV6b25lIChlLmcuIFwiMjAxMVwiKSwgdGhlIGRhdGUgaXMgaW50ZXJwcmV0ZWRcbiAqICAgICBpbiBsb2NhbCB0aW1lLiAgT24gRmlyZWZveCwgdGhlIGFzc3VtcHRpb24gaXMgVVRDLlxuICpcbiAqIFBhcmFtZXRlcnM6XG4gKiBzdHIgLSB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRhdGUgKGUuZy5cbiAqICAgICBcIjIwMTBcIiwgXCIyMDEwLTA4XCIsIFwiMjAxMC0wOC0wN1wiLCBcIjIwMTAtMDgtMDdUMTY6NTg6MjMuMTIzWlwiLFxuICogICAgIFwiMjAxMC0wOC0wN1QxMTo1ODoyMy4xMjMtMDZcIiwgXCItMzAwMC0wOC0wN1QxNjo1ODoyMy4xMjNaXCIpLlxuICpcbiAqIFJldHVybnM6XG4gKiB7RGF0ZX0gQSBkYXRlIG9iamVjdC4gIElmIHRoZSBzdHJpbmcgY291bGQgbm90IGJlIHBhcnNlZCwgYW4gaW52YWxpZFxuICogICAgIGRhdGUgaXMgcmV0dXJuZWQgKGkuZS4gaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKS5cbiAqL1xucGFyc2VEYXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBkYXRlO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goZGF0ZVJlZ0V4KTtcbiAgaWYgKG1hdGNoICYmIChtYXRjaFsyXSB8fCBtYXRjaFs4XSkpIHsgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHllYXIgb3IgdGltZVxuICAgIHZhciB5ZWFyID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSB8fCAwO1xuICAgIGlmIChtYXRjaFsxXSl7XG4gICAgICB5ZWFyID0geWVhciAqIC0xO1xuICAgIH1cbiAgICB2YXIgbW9udGggPSAocGFyc2VJbnQobWF0Y2hbM10sIDEwKSAtIDEpIHx8IDA7XG4gICAgdmFyIGRheSA9IHBhcnNlSW50KG1hdGNoWzRdLCAxMCkgfHwgMTtcbiAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICAgIC8vIG9wdGlvbmFsIHRpbWVcbiAgICB2YXIgdHlwZSA9IG1hdGNoWzhdO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICB2YXIgaG91cnMgPSBwYXJzZUludChtYXRjaFs1XSwgMTApO1xuICAgICAgdmFyIG1pbnV0ZXMgPSBwYXJzZUludChtYXRjaFs2XSwgMTApO1xuICAgICAgdmFyIHNlY0ZyYWMgPSBwYXJzZUZsb2F0KG1hdGNoWzddKTtcbiAgICAgIHZhciBzZWNvbmRzID0gc2VjRnJhYyB8IDA7XG4gICAgICB2YXIgbWlsbGlzZWNvbmRzID0gTWF0aC5yb3VuZCgxMDAwICogKHNlY0ZyYWMgLSBzZWNvbmRzKSk7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMpO1xuICAgICAgLy8gY2hlY2sgb2Zmc2V0XG4gICAgICBpZiAodHlwZSAhPT0gXCJaXCIpIHtcbiAgICAgICAgdmFyIGhvdXJzT2Zmc2V0ID0gcGFyc2VJbnQodHlwZSwgMTApO1xuICAgICAgICB2YXIgbWludXRlc09mZnNldCA9IHBhcnNlSW50KG1hdGNoWzldLCAxMCkgfHwgMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IC0xMDAwICogKDYwICogKGhvdXJzT2Zmc2V0ICogNjApICsgbWludXRlc09mZnNldCAqIDYwKTtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKFwiaW52YWxpZFwiKTtcbiAgfVxuICByZXR1cm4gZGF0ZTtcbn07XG4iLCIvLyd1c2Ugc3RyaWN0JztcbmV4cG9ydHMuU0xEU3R5bGVDb252ZXJ0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW5lcmF0ZVN0eWxlOiBmdW5jdGlvbihzdHlsZSwgbGF5ZXJOYW1lLCBhc1N0cmluZykge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29udmVydEpTT04oc3R5bGUsIGxheWVyTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBvd3Nqcy5Kc29uaXguQ29udGV4dChbb3dzanMubWFwcGluZ3MuWExpbmtfMV8wLCBvd3Nqcy5tYXBwaW5ncy5GaWx0ZXJfMV8wXzAsIG93c2pzLm1hcHBpbmdzLkdNTF8yXzFfMiwgb3dzanMubWFwcGluZ3MuU0xEXzFfMF8wXSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VQcmVmaXhlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnOiAneGxpbmsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvc2xkJzogJ3NsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2MnOiAnb2djJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJzaGFsbGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1hcnNoYWxsZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc1N0cmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcnNoYWxsZXIubWFyc2hhbFN0cmluZyhjb25maWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXJzaGFsbGVyLm1hcnNoYWxEb2N1bWVudChjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVGaWxsOiBmdW5jdGlvbihzdHlsZSwgc3R5bGVSdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNzc1BhcmFtZXRlcjogW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZpbGwnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbKHN0eWxlUnVsZSAmJiBzdHlsZVJ1bGUuc3R5bGUuc3ltYm9sLmZpbGxDb2xvcikgPyBzdHlsZVJ1bGUuc3R5bGUuc3ltYm9sLmZpbGxDb2xvciA6IHN0eWxlLnN5bWJvbC5maWxsQ29sb3JdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZmlsbC1vcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1N0cmluZyhzdHlsZVJ1bGUgPyAoc3R5bGVSdWxlLnN0eWxlLnN5bWJvbC5maWxsT3BhY2l0eSB8fCAxMDApIC8gMTAwIDogKHN0eWxlLnN5bWJvbC5maWxsT3BhY2l0eSB8fCAxMDApIC8gMTAwKV1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU3Ryb2tlOiBmdW5jdGlvbihzdHlsZSwgc3R5bGVSdWxlKSB7XG4gICAgICAgICAgICB2YXIgZGFzaEFycmF5O1xuICAgICAgICAgICAgaWYgKHN0eWxlLnN0cm9rZS5zdHJva2VTdHlsZSA9PT0gJ2Rhc2hlZCcpIHtcbiAgICAgICAgICAgICAgICBkYXNoQXJyYXkgPSAnNSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLnN0cm9rZS5zdHJva2VTdHlsZSA9PT0nZG90dGVkJykge1xuICAgICAgICAgICAgICAgIGRhc2hBcnJheSA9ICcxIDInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjc3NQYXJhbWV0ZXI6IFt7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzdHJva2UnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbKHN0eWxlUnVsZSAmJiBzdHlsZVJ1bGUuc3R5bGUuc3Ryb2tlLnN0cm9rZUNvbG9yKSA/IHN0eWxlUnVsZS5zdHlsZS5zdHJva2Uuc3Ryb2tlQ29sb3IgOiBzdHlsZS5zdHJva2Uuc3Ryb2tlQ29sb3JdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc3Ryb2tlLXdpZHRoJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogc3R5bGUuc3Ryb2tlLnN0cm9rZVdpZHRoID8gW1N0cmluZyhzdHlsZS5zdHJva2Uuc3Ryb2tlV2lkdGgpXSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogc3R5bGUuc3Ryb2tlLnN0cm9rZU9wYWNpdHkgPyBbU3RyaW5nKHN0eWxlLnN0cm9rZS5zdHJva2VPcGFjaXR5IC8gMTAwKV0gOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogZGFzaEFycmF5ID8gW2Rhc2hBcnJheV0gOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlUG9seWdvblN5bWJvbGl6ZXI6IGZ1bmN0aW9uKHN0eWxlLCBzdHlsZVJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gdGhpcy5jcmVhdGVGaWxsKHN0eWxlLCBzdHlsZVJ1bGUpO1xuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuY3JlYXRlU3Ryb2tlKHN0eWxlKTtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiAnUG9seWdvblN5bWJvbGl6ZXInLFxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGRcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVBvaW50U3ltYm9saXplcjogZnVuY3Rpb24oc3R5bGUsIHN0eWxlUnVsZSkge1xuICAgICAgICAgICAgdmFyIGZpbGwgPSB0aGlzLmNyZWF0ZUZpbGwoc3R5bGUsIHN0eWxlUnVsZSk7IFxuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuY3JlYXRlU3Ryb2tlKHN0eWxlKTtcbiAgICAgICAgICAgIHZhciBncmFwaGljT3JNYXJrO1xuICAgICAgICAgICAgaWYgKHN0eWxlLnN5bWJvbCAmJiBzdHlsZS5zeW1ib2wuZ3JhcGhpYykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICAgICAgLy8gQHRvZG8gYXBwZW5kaW5nIGljb24gY29tbW9ucyBhdHRyaWJ1dGVzIHNob3VsZCBnbyBlbHNld2hlcmVcbiAgICAgICAgICAgICAgICBhLmhyZWYgPSBzdHlsZS5zeW1ib2wuZ3JhcGhpYyArICc/JyArXG4gICAgICAgICAgICAgICAgICAgICdmaWxsPScgKyBlbmNvZGVVUklDb21wb25lbnQoKHN0eWxlUnVsZSAmJiBzdHlsZVJ1bGUuc3R5bGUuc3ltYm9sLmZpbGxDb2xvcikgPyBzdHlsZVJ1bGUuc3R5bGUuc3ltYm9sLmZpbGxDb2xvciA6IHN0eWxlLnN5bWJvbC5maWxsQ29sb3IpICtcbiAgICAgICAgICAgICAgICAgICAgXCImc3Ryb2tlPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0eWxlLnN0cm9rZS5zdHJva2VDb2xvcik7XG4gICAgICAgICAgICAgICAgZ3JhcGhpY09yTWFyayA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBUWVBFX05BTUU6IFwiU0xEXzFfMF8wLkV4dGVybmFsR3JhcGhpY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcImltYWdlL3N2Zyt4bWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubGluZVJlc291cmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogYS5ocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmFwaGljT3JNYXJrID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIFRZUEVfTkFNRTogXCJTTERfMV8wXzAuTWFya1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2VsbEtub3duTmFtZTogc3R5bGUuc3ltYm9sICYmIHN0eWxlLnN5bWJvbC5zaGFwZSB8fCAnY2lyY2xlJ1xuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5zeW1ib2wgJiYgYW5ndWxhci5pc0RlZmluZWQoc3R5bGUuc3ltYm9sLmZpbGxPcGFjaXR5KSkge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBNYXRoLm1heCgwLjAxLCBzdHlsZS5zeW1ib2wuZmlsbE9wYWNpdHkpIC8gMTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogJ1BvaW50U3ltYm9saXplcicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3NsZFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbEdyYXBoaWNPck1hcms6IGdyYXBoaWNPck1hcmssXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1N0cmluZyhvcGFjaXR5KV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1N0cmluZyhzdHlsZVJ1bGUgJiYgc3R5bGVSdWxlLnN0eWxlLnN5bWJvbCAmJiBzdHlsZVJ1bGUuc3R5bGUuc3ltYm9sLnNpemUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5zeW1ib2wgJiYgc3R5bGUuc3ltYm9sLnNpemUgfHwgMTApXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBzdHlsZS5zeW1ib2wgJiYgc3R5bGUuc3ltYm9sLnJvdGF0aW9uQXR0cmlidXRlID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtzdHlsZS5zeW1ib2wucm90YXRpb25Vbml0cyA9PT0gJ2RlZ3JlZXMnID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6IFwiUHJvcGVydHlOYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3N0eWxlLnN5bWJvbC5yb3RhdGlvbkF0dHJpYnV0ZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJEaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiBcIlByb3BlcnR5TmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3N0eWxlLnN5bWJvbC5yb3RhdGlvbkF0dHJpYnV0ZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6IFwiRGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJGdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInBpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJMaXRlcmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtcIjM2MFwiXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlTGluZVN5bWJvbGl6ZXI6IGZ1bmN0aW9uKHN0eWxlLCBzdHlsZVJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6ICdMaW5lU3ltYm9saXplcicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3NsZFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuY3JlYXRlU3Ryb2tlKHN0eWxlLCBzdHlsZVJ1bGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlVGV4dFN5bWJvbGl6ZXI6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgZm9udEZhbWlseTtcbiAgICAgICAgICAgIHZhciBzdHlsZUZvbnRGYW1pbHkgPSBzdHlsZS5sYWJlbC5mb250RmFtaWx5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoc3R5bGVGb250RmFtaWx5ID09PSAnc2VyaWYnKSB7XG4gICAgICAgICAgICAgICAgZm9udEZhbWlseSAgPSAnU2VyaWYnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZUZvbnRGYW1pbHkgPT09ICdzYW5zLXNlcmlmJykge1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgPSAnU2Fuc1NlcmlmJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVGb250RmFtaWx5ID09PSAnY3Vyc2l2ZScpIHtcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5ID0gJ0NvbWljIFNhbnMgTVMnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZUZvbnRGYW1pbHkgPT09ICdtb25vc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgZm9udEZhbWlseSA9ICdDb3VyaWVyIE5ldyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiAnVGV4dFN5bWJvbGl6ZXInLFxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGRcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzUGFyYW1ldGVyOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZmlsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtzdHlsZS5sYWJlbC5maWxsQ29sb3JdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGFsbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1BhcmFtZXRlcjogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZpbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbJyNGRkZGRkYnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogWycxJ11cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxQbGFjZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVQbGFjZW1lbnQ6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1BhcmFtZXRlcjogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZvbnQtZmFtaWx5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogZm9udEZhbWlseSA/IFtmb250RmFtaWx5XTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZm9udC1zaXplJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1N0cmluZyhzdHlsZS5sYWJlbC5mb250U2l6ZSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZm9udC1zdHlsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtzdHlsZS5sYWJlbC5mb250U3R5bGVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZm9udC13ZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbc3R5bGUubGFiZWwuZm9udFdlaWdodF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiBcIlByb3BlcnR5TmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtzdHlsZS5sYWJlbC5hdHRyaWJ1dGVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB2ZW5kb3JPcHRpb246IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbWF4RGlzcGxhY2VtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICc0MCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2F1dG9XcmFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICc0MCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NwYWNlQXJvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcwJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZm9sbG93TGluZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnZmFsc2UnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdncm91cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAneWVzJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZ29vZG5lc3NPZkZpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnMC4yJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29uZmxpY3RSZXNvbHV0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnZlcnRKU09OOiBmdW5jdGlvbihzdHlsZSwgbGF5ZXJOYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6ICdTdHlsZWRMYXllckRlc2NyaXB0b3InXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjEuMC4wXCIsXG4gICAgICAgICAgICAgICAgbmFtZWRMYXllck9yVXNlckxheWVyOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgVFlQRV9OQU1FOiBcIlNMRF8xXzBfMC5OYW1lZExheWVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBsYXllck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lZFN0eWxlT3JVc2VyU3R5bGU6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRZUEVfTkFNRTogXCJTTERfMV8wXzAuVXNlclN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVUeXBlU3R5bGU6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcnVsZSwgcnVsZUNvbnRhaW5lciA9IHJlc3VsdC52YWx1ZS5uYW1lZExheWVyT3JVc2VyTGF5ZXJbMF0ubmFtZWRTdHlsZU9yVXNlclN0eWxlWzBdLmZlYXR1cmVUeXBlU3R5bGVbMF0ucnVsZTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5ydWxlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHN0eWxlLnJ1bGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlUnVsZSA9IHN0eWxlLnJ1bGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVSdWxlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyaXNvbk9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJQcm9wZXJ0eUlzRXF1YWxUb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJQcm9wZXJ0eU5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3N0eWxlLmNsYXNzaWZ5LmF0dHJpYnV0ZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6IFwiTGl0ZXJhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbU3RyaW5nKHN0eWxlUnVsZS52YWx1ZSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVJ1bGUucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJpc29uT3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiBcIlByb3BlcnR5SXNCZXR3ZWVuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6IFwiUHJvcGVydHlOYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtzdHlsZS5jbGFzc2lmeS5hdHRyaWJ1dGVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyQm91bmRhcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiBcIkxpdGVyYWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1N0cmluZyhzdHlsZVJ1bGUucmFuZ2UubWluKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckJvdW5kYXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJMaXRlcmFsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtTdHJpbmcoc3R5bGVSdWxlLnJhbmdlLm1heCldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogc3R5bGVSdWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdHlsZVJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9saXplcjogW11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmdlb21UeXBlID09PSBcInBvaW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuc3ltYm9saXplci5wdXNoKHRoaXMuY3JlYXRlUG9pbnRTeW1ib2xpemVyKHN0eWxlLCBzdHlsZVJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5nZW9tVHlwZSA9PT0gXCJsaW5lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuc3ltYm9saXplci5wdXNoKHRoaXMuY3JlYXRlTGluZVN5bWJvbGl6ZXIoc3R5bGUsIHN0eWxlUnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmdlb21UeXBlID09PSBcInBvbHlnb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5zeW1ib2xpemVyLnB1c2godGhpcy5jcmVhdGVQb2x5Z29uU3ltYm9saXplcihzdHlsZSwgc3R5bGVSdWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmxhYmVsICYmIHN0eWxlLmxhYmVsLmF0dHJpYnV0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5zeW1ib2xpemVyLnB1c2godGhpcy5jcmVhdGVUZXh0U3ltYm9saXplcihzdHlsZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVDb250YWluZXIucHVzaChydWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBydWxlLCBtdWx0aXBsZSBzeW1ib2xpemVyc1xuICAgICAgICAgICAgICAgIHJ1bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbGl6ZXI6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBydWxlQ29udGFpbmVyLnB1c2gocnVsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmdlb21UeXBlID09PSAncG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuc3ltYm9saXplci5wdXNoKHRoaXMuY3JlYXRlUG9pbnRTeW1ib2xpemVyKHN0eWxlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5nZW9tVHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuc3ltYm9saXplci5wdXNoKHRoaXMuY3JlYXRlTGluZVN5bWJvbGl6ZXIoc3R5bGUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmdlb21UeXBlID09PSAncG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5zeW1ib2xpemVyLnB1c2godGhpcy5jcmVhdGVQb2x5Z29uU3ltYm9saXplcihzdHlsZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUubGFiZWwgJiYgc3R5bGUubGFiZWwuYXR0cmlidXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuc3ltYm9saXplci5wdXNoKHRoaXMuY3JlYXRlVGV4dFN5bWJvbGl6ZXIoc3R5bGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCJleHBvcnRzLlN0eWxlQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgaWYgKHN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5jbGFzc2lmeSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5jbGFzc2lmeS5tZXRob2QgPT09IFwidW5pcXVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmNsYXNzaWZ5LmF0dHJpYnV0ZSA9PT0gbnVsbCB8fCBzdHlsZS5jbGFzc2lmeS5tYXhDbGFzc2VzID09PSBudWxsIHx8ICFzdHlsZS5jbGFzc2lmeS5jb2xvclBhbGV0dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuY2xhc3NpZnkubWV0aG9kID09PSBudWxsIHx8IHN0eWxlLmNsYXNzaWZ5LmF0dHJpYnV0ZSA9PT0gbnVsbCB8fCBzdHlsZS5jbGFzc2lmeS5jb2xvclJhbXAgPT09IG51bGwgfHwgc3R5bGUucnVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwiLy8ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuV0ZTRGVzY3JpYmVGZWF0dXJlVHlwZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5wYXJzZVJlc3VsdCA9IGZ1bmN0aW9uKHhtbCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IG93c2pzLkpzb25peC5Db250ZXh0KFtcbiAgICAgICAgICAgICAgICBvd3Nqcy5tYXBwaW5ncy5YU0RfMV8wXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHRoaXMudW5tYXJzaGFsbGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVVubWFyc2hhbGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2hlbWEgPSB0aGlzLnVubWFyc2hhbGxlci51bm1hcnNoYWxTdHJpbmcoeG1sKS52YWx1ZTtcbiAgICAgICAgdmFyIGZlYXR1cmVOUyA9IHNjaGVtYS50YXJnZXROYW1lc3BhY2U7XG4gICAgICAgIHZhciBlbGVtZW50ID0gc2NoZW1hLmNvbXBsZXhUeXBlWzBdLmNvbXBsZXhDb250ZW50LmV4dGVuc2lvbi5zZXF1ZW5jZS5lbGVtZW50O1xuICAgICAgICB2YXIgZmllbGRzID0gW107XG4gICAgICAgIHZhciBnZW9tZXRyeVR5cGUsIHRpbWVBdHRyO1xuICAgICAgICBmb3IgKHZhciBpPTAsIGlpPWVsZW1lbnQubGVuZ3RoOyBpPGlpOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRbaV07XG4gICAgICAgICAgICBpZiAoZWwudHlwZS5uYW1lc3BhY2VVUkkgPT09ICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbHAgPSBlbC50eXBlLmxvY2FsUGFydDtcbiAgICAgICAgICAgICAgICBpZiAobHAuaW5kZXhPZignUG9seWdvbicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeVR5cGUgPSAncG9seWdvbic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChscC5pbmRleE9mKCdMaW5lU3RyaW5nJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5VHlwZSA9ICdsaW5lJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxwLmluZGV4T2YoJ1BvaW50JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5VHlwZSA9ICdwb2ludCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbC50eXBlLmxvY2FsUGFydCA9PT0gJ2RhdGVUaW1lJykge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lQXR0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVBdHRyID0gZWwubmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aW1lQXR0ciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmllbGRzLnB1c2goe25hbWU6IGVsLm5hbWUsIHR5cGU6IGVsLnR5cGUubG9jYWxQYXJ0LCB0eXBlTlM6IGVsLnR5cGUubmFtZXNwYWNlVVJJfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWVBdHRyaWJ1dGU6IHRpbWVBdHRyLFxuICAgICAgICAgICAgZmVhdHVyZU5TOiBmZWF0dXJlTlMsXG4gICAgICAgICAgICBnZW9tVHlwZTogZ2VvbWV0cnlUeXBlLFxuICAgICAgICAgICAgYXR0cmlidXRlczogZmllbGRzXG4gICAgICAgIH07XG4gICAgfTtcblxufTtcbiIsIi8vJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLldQU0NsYXNzaWZ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLnBhcnNlUmVzdWx0ID0gZnVuY3Rpb24oeG1sKSB7XG4gICAgICAgIHZhciBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgICAgICB2YXIgZXhjZXB0aW9ucyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZU5TKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L293cy8xLjEnLCAnRXhjZXB0aW9uVGV4dCcpO1xuICAgICAgICBpZiAoZXhjZXB0aW9ucy5sZW5ndGggPT09MCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0NsYXNzJyk7XG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaWk9Y2xhc3Nlcy5sZW5ndGg7IGk8aWk7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBtaW4gPSBjbGFzc2VzW2ldLmdldEF0dHJpYnV0ZSgnbG93ZXJCb3VuZCcpO1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSBjbGFzc2VzW2ldLmdldEF0dHJpYnV0ZSgndXBwZXJCb3VuZCcpO1xuICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtaW4gKyAnLScgKyBtYXgsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46IG1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogbWF4XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBydWxlczogcnVsZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1zZzogZXhjZXB0aW9uc1swXS50ZXh0Q29udGVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IG93c2pzLkpzb25peC5Db250ZXh0KFtcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLlhMaW5rXzFfMCxcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLk9XU18xXzFfMCxcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLkZpbHRlcl8xXzFfMCxcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLk9XU18xXzBfMCxcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLlNNSUxfMl8wLFxuICAgICAgICAgICAgb3dzanMubWFwcGluZ3MuU01JTF8yXzBfTGFuZ3VhZ2UsXG4gICAgICAgICAgICBvd3Nqcy5tYXBwaW5ncy5HTUxfM18xXzEsXG4gICAgICAgICAgICBvd3Nqcy5tYXBwaW5ncy5XRlNfMV8xXzAsXG4gICAgICAgICAgICBvd3Nqcy5tYXBwaW5ncy5XUFNfMV8wXzBcbiAgICAgICAgXSwge1xuICAgICAgICAgICAgbmFtZXNwYWNlUHJlZml4ZXM6IHtcbiAgICAgICAgICAgICAgICAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc6ICd4bGluaycsXG4gICAgICAgICAgICAgICAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvd3BzLzEuMC4wJzogJ3dwcycsXG4gICAgICAgICAgICAgICAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvb3dzLzEuMSc6ICdvd3MnLFxuICAgICAgICAgICAgICAgICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcyc6ICd3ZnMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcnNoYWxsZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlTWFyc2hhbGxlcigpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFVuaXF1ZVZhbHVlcyA9IGZ1bmN0aW9uKGRhdGEsIGFzU3RyaW5nKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5nZW5lcmF0ZU1haW5Db25maWcoJ2dzOlVuaXF1ZScsIFwiYXBwbGljYXRpb24vanNvblwiLCBkYXRhKTtcbiAgICAgICAgY29uZmlnLnZhbHVlLmRhdGFJbnB1dHMuaW5wdXQucHVzaCh7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICdhdHRyaWJ1dGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGxpdGVyYWxEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLmF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhc1N0cmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFyc2hhbGxlci5tYXJzaGFsU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXJzaGFsbGVyLm1hcnNoYWxEb2N1bWVudChjb25maWcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZ2VuZXJhdGVNYWluQ29uZmlnID0gZnVuY3Rpb24ocHJvY2Vzc0lkLCBtaW1lVHlwZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJFeGVjdXRlXCIsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvd3BzLzEuMC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IFwiV1BTXCIsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByb2Nlc3NJZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VGb3JtOiB7XG4gICAgICAgICAgICAgICAgICAgIHJhd0RhdGFPdXRwdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJyZXN1bHRzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGF0YUlucHV0czoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnZmVhdHVyZXMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiAndGV4dC94bWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAnaHR0cDovL2dlb3NlcnZlci93ZnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93ZnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJHZXRGZWF0dXJlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZvcm1hdDogXCJHTUwyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlOiBcIldGU1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCIxLjEuMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBbe25zOiBkYXRhLmZlYXR1cmVOUywgbHA6IGRhdGEudHlwZU5hbWUuc3BsaXQoJzonKVsxXSB8fCBkYXRhLnR5cGVOYW1lLCBwOiBkYXRhLmZlYXR1cmVQcmVmaXh9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLmNsYXNzaWZ5VmVjdG9yID0gZnVuY3Rpb24oZGF0YSwgYXNTdHJpbmcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmdlbmVyYXRlTWFpbkNvbmZpZygndmVjOkZlYXR1cmVDbGFzc1N0YXRzJywgdW5kZWZpbmVkLCBkYXRhKTtcbiAgICAgICAgY29uZmlnLnZhbHVlLmRhdGFJbnB1dHMuaW5wdXQucHVzaCh7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICdhdHRyaWJ1dGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGxpdGVyYWxEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLmF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaWRlbnRpZmllcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnY2xhc3NlcydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbGl0ZXJhbERhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZyhkYXRhLm51bUNsYXNzZXMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICdtZXRob2QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGxpdGVyYWxEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLm1ldGhvZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaWRlbnRpZmllcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnc3RhdHMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGxpdGVyYWxEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnbWVhbicgLyogVE9ETyBjdXJyZW50bHkgd2UgbmVlZCB0byBzZW5kIGF0IGxlYXN0IDEgc3RhdHMgaW5wdXQgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXNTdHJpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcnNoYWxsZXIubWFyc2hhbFN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFyc2hhbGxlci5tYXJzaGFsRG9jdW1lbnQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwiZXhwb3J0cy5NYXBDb25maWdUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgbGF5ZXJzID0gW10sIGksIGlpLCBtb2RlID0gJ2luc3RhbnQnO1xuICAgIC8vIGxvb2sgZm9yIHBsYXliYWNrIG1vZGUgaW4gdG9vbHNcbiAgICBpZiAoZGF0YS50b29scykge1xuICAgICAgICBmb3IgKGk9MCwgaWk9ZGF0YS50b29scy5sZW5ndGg7IGk8aWk7ICsraSkge1xuICAgICAgICAgICAgdmFyIHRvb2wgPSBkYXRhLnRvb2xzW2ldO1xuICAgICAgICAgICAgaWYgKHRvb2wucHR5cGUgPT09IFwiZ3hwX3BsYXliYWNrXCIgJiYgdG9vbC5vdXRwdXRDb25maWcpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbC5vdXRwdXRDb25maWcucGxheWJhY2tNb2RlID09PSAnY3VtdWxhdGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9ICdjdW11bGF0aXZlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBvdGhlciBtb2Rlc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaT0wLCBpaT1kYXRhLm1hcC5sYXllcnMubGVuZ3RoOyBpPGlpOyArK2kpIHtcbiAgICAgICAgIHZhciBsYXllciA9IGRhdGEubWFwLmxheWVyc1tpXTtcbiAgICAgICAgIC8vIFRPRE8gZm9yIHRoZSBlZGl0b3Igd2UgYWxzbyBuZWVkIHRoZSBpbnZpc2libGUgbGF5ZXJzXG4gICAgICAgICBpZiAobGF5ZXIudmlzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBkYXRhLnNvdXJjZXNbbGF5ZXIuc291cmNlXTtcbiAgICAgICAgICAgICB2YXIgbGF5ZXJDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGxheWVyLnZpc2liaWxpdHksXG4gICAgICAgICAgICAgICAgIGdyb3VwOiBsYXllci5ncm91cFxuICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgaWYgKHNvdXJjZS5wdHlwZSA9PT0gXCJneHBfbWFwcXVlc3Rzb3VyY2VcIikge1xuICAgICAgICAgICAgICAgICBsYXllckNvbmZpZy50eXBlID0gJ01hcFF1ZXN0JztcbiAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcubGF5ZXIgPSBsYXllci5uYW1lID09PSAnbmFpcCcgPyAnc2F0JyA6ICdvc20nO1xuICAgICAgICAgICAgICAgICBsYXllckNvbmZpZy50aXRsZSA9IGxheWVyLnRpdGxlO1xuICAgICAgICAgICAgICAgICBsYXllcnMucHVzaChsYXllckNvbmZpZyk7XG4gICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UucHR5cGUgPT09IFwiZ3hwX21hcGJveHNvdXJjZVwiKSB7XG4gICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnR5cGUgPSAnTWFwQm94JztcbiAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcubmFtZSA9IGxheWVyLm5hbWU7XG4gICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnRpdGxlID0gbGF5ZXIudGl0bGU7XG4gICAgICAgICAgICAgICAgIGxheWVycy5wdXNoKGxheWVyQ29uZmlnKTtcbiAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5wdHlwZSA9PT0gXCJneF9vbHNvdXJjZVwiIHx8IHNvdXJjZS5wdHlwZSA9PT0gXCJneHBfd21zY3NvdXJjZVwiKSB7XG4gICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnR5cGUgPSAoc291cmNlLnB0eXBlID09PSBcImd4X29sc291cmNlXCIpID8gbGF5ZXIudHlwZS5yZXBsYWNlKCdPcGVuTGF5ZXJzLkxheWVyLicsICcnKSA6IFwiV01TXCI7XG4gICAgICAgICAgICAgICAgIGlmIChsYXllckNvbmZpZy50eXBlID09PSAnT1NNJykge1xuICAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyQ29uZmlnLmFyZ3MgJiYgbGF5ZXJDb25maWcuYXJnc1swXSA9PT0gJ0h1bWFuaXRhcmlhbiBPcGVuU3RyZWV0TWFwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnR5cGUgPSAnSE9UJztcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnRpdGxlID0gbGF5ZXIudGl0bGU7XG4gICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXJDb25maWcudHlwZSA9PT0gJ1dNUycpIHtcbiAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLnB0eXBlID09PSBcImd4X29sc291cmNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBsYXllci5hcmdzWzJdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtc1trZXldLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW2tleS50b1VwcGVyQ2FzZSgpXSA9IHBhcmFtc1trZXldLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZy51cmwgPSBsYXllci5hcmdzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIExBWUVSUzogbGF5ZXIubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1RZTEVTOiBsYXllci5zdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRJTEVEOiAnVFJVRScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZPUk1BVDogbGF5ZXIuZm9ybWF0IHx8ICdpbWFnZS9wbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUUkFOU1BBUkVOVDogbGF5ZXIudHJhbnNwYXJlbnQgfHwgJ1RSVUUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIudGlsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnNpbmdsZVRpbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZy5pZCA9IGxheWVyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcubmFtZSA9IGxheWVyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcudGl0bGUgPSBsYXllci50aXRsZUFsaWFzIHx8IGxheWVyLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLm1hc2tpbmdzID0gbGF5ZXIubWFza2luZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IHBsYWNlIHRvIGRvIHRoaXM/XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcudXJsID0gc291cmNlLnVybC5yZXBsYWNlKCdodHRwOi8vbWFwc3Rvcnkub3JnL2dlb3NlcnZlci8nLCAnL2dlb3NlcnZlci8nKTtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnBhcmFtcy5WRVJTSU9OID0gJzEuMS4xJztcbiAgICAgICAgICAgICAgICAgICAgIGlmIChsYXllci5jYXBhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcubGF0bG9uQkJPWCA9IGxheWVyLmNhcGFiaWxpdHkubGxiYm94O1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVxdWlyZSBkZXBlbmRlbmN5IGV4cGxpY2l0bHk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVzID0gc3Rvcnl0b29scy5jb3JlLnRpbWUubWFwcy5yZWFkQ2FwYWJpbGl0aWVzVGltZURpbWVuc2lvbnMobGF5ZXIuY2FwYWJpbGl0eSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcudGltZXMgPSB0aW1lcztcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5mbyBmb3IgY3VzdG9tIHRpbGVHcmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLmNhcGFiaWxpdHkudGlsZVNldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc3JzIGluIGxheWVyLmNhcGFiaWxpdHkudGlsZVNldHNbMF0uYmJveCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJib3ggPSBsYXllci5jYXBhYmlsaXR5LnRpbGVTZXRzWzBdLmJib3hbc3JzXS5iYm94O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcuYmJveCA9IGJib3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcucmVzb2x1dGlvbnMgPSBsYXllci5jYXBhYmlsaXR5LnRpbGVTZXRzWzBdLnJlc29sdXRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICBsYXllcnMucHVzaChsYXllckNvbmZpZyk7XG4gICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS53YXJuKCdVbmtub3duIHNvdXJjZSB0eXBlIGluIG1hcCBjb25maWc6ICcgKyBzb3VyY2UucHR5cGUpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgfVxuICAgICByZXR1cm4ge1xuICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICBwbGF5YmFja01vZGU6IG1vZGUsXG4gICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgICBjZW50ZXI6IGRhdGEubWFwLmNlbnRlcixcbiAgICAgICAgICAgICBwcm9qZWN0aW9uOiBkYXRhLm1hcC5wcm9qZWN0aW9uLFxuICAgICAgICAgICAgIHpvb206IGRhdGEubWFwLnpvb20sXG4gICAgICAgICAgICAgbGF5ZXJzOiBsYXllcnNcbiAgICAgICAgIH1cbiAgICAgfTtcbn07XG4iLCIoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbW9kdWxlID0gYW5ndWxhci5tb2R1bGUoJ3N0b3J5dG9vbHMuY29yZS5vZ2MnLCBbXG4gIF0pO1xuXG4gIC8vIEB0b2RvIC0gcHJvdmlzaW9uYWwgZGVmYXVsdCBzdG9yeSBwaW5zIHN0eWxlXG4gIHZhciBkZWZhdWx0U3R5bGUgPSBbbmV3IG9sLnN0eWxlLlN0eWxlKHtcbiAgICBmaWxsOiBuZXcgb2wuc3R5bGUuRmlsbCh7Y29sb3I6ICdyZ2JhKDI1NSwgMCwgMCwgMC4xKSd9KSxcbiAgICBzdHJva2U6IG5ldyBvbC5zdHlsZS5TdHJva2Uoe2NvbG9yOiAncmVkJywgd2lkdGg6IDF9KSxcbiAgICBpbWFnZTogbmV3IG9sLnN0eWxlLkNpcmNsZSh7XG4gICAgICByYWRpdXM6IDEwLFxuICAgICAgZmlsbDogbmV3IG9sLnN0eWxlLkZpbGwoe2NvbG9yOiAncmdiYSgyNTUsIDAsIDAsIDAuMSknfSksXG4gICAgICBzdHJva2U6IG5ldyBvbC5zdHlsZS5TdHJva2Uoe2NvbG9yOiAncmVkJywgd2lkdGg6IDF9KVxuICAgIH0pXG4gIH0pXTtcblxuICBmdW5jdGlvbiBTdG9yeU1hcChkYXRhKSB7XG4gICAgb2wuT2JqZWN0LmNhbGwodGhpcywgZGF0YSk7XG4gICAgdGhpcy5tYXBfID0gbmV3IG9sLk1hcCh7dGFyZ2V0OiBkYXRhLnRhcmdldCwgcGl4ZWxSYXRpbzogMX0pO1xuICAgIHRoaXMub3ZlcmxheSA9IG5ldyBvbC5GZWF0dXJlT3ZlcmxheSh7XG4gICAgICBtYXA6IHRoaXMubWFwXyxcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9KTtcbiAgICB0aGlzLnRpdGxlID0gXCJEZWZhdWx0IE1hcHN0b3J5XCI7XG4gICAgdGhpcy5hYnN0cmFjdCA9IFwiTm8gSW5mb3JtYXRpb24gU3VwcGxpZWQuXCI7XG4gICAgdGhpcy5vd25lciA9IFwiXCI7XG4gICAgdGhpcy5tb2RlID0gXCJpbnN0YW50XCI7XG4gICAgdGhpcy5yZXR1cm5Ub0V4dGVudCA9IGRhdGEucmV0dXJuVG9FeHRlbnQgfHwgZmFsc2U7XG4gICAgdGhpcy5jZW50ZXIgPSBbMCwwXTtcbiAgICB0aGlzLnpvb20gPSAyO1xuICAgIHRoaXMuc3RvcnlMYXllcnNfID0gbmV3IG9sLkNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uXyA9IGRhdGEuYW5pbWF0aW9uRHVyYXRpb24gfHwgNTAwO1xuICAgIHRoaXMuc3RvcnlCb3hlc0xheWVyID0gbmV3IFN0b3J5TGF5ZXIoe1xuICAgICAgdGltZUF0dHJpYnV0ZTogJ3N0YXJ0X3RpbWUnLFxuICAgICAgZW5kVGltZUF0dHJpYnV0ZTogJ2VuZF90aW1lJyxcbiAgICAgIGxheWVyOiBuZXcgb2wubGF5ZXIuVmVjdG9yKHtcbiAgICAgICAgc291cmNlOiBuZXcgb2wuc291cmNlLlZlY3RvcigpLFxuICAgICAgICBzdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHRoaXMuc3RvcnlQaW5zTGF5ZXIgPSBuZXcgU3RvcnlMYXllcih7XG4gICAgICB0aW1lQXR0cmlidXRlOiAnc3RhcnRfdGltZScsXG4gICAgICBlbmRUaW1lQXR0cmlidXRlOiAnZW5kX3RpbWUnLFxuICAgICAgbGF5ZXI6IG5ldyBvbC5sYXllci5WZWN0b3Ioe1xuICAgICAgICBzb3VyY2U6IG5ldyBvbC5zb3VyY2UuVmVjdG9yKCksXG4gICAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgdGhpcy5hZGRTdG9yeVBpbnNMYXllcigpO1xuICAgIHRoaXMuYWRkU3RvcnlCb3hlc0xheWVyKCk7XG4gIH1cblxuICBTdG9yeU1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG9sLk9iamVjdC5wcm90b3R5cGUpO1xuICBTdG9yeU1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdG9yeU1hcDtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuYWRkU3RvcnlQaW5zTGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1hcF8uYWRkTGF5ZXIodGhpcy5zdG9yeVBpbnNMYXllci5nZXRMYXllcigpKTtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuYWRkU3RvcnlCb3hlc0xheWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tYXBfLmFkZExheWVyKHRoaXMuc3RvcnlCb3hlc0xheWVyLmdldExheWVyKCkpO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5zZXRTdG9yeU93bmVyID0gZnVuY3Rpb24oc3RvcnlPd25lcikge1xuICAgIHRoaXMub3duZXIgPSAgc3RvcnlPd25lcjtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuZ2V0U3RvcnlPd25lciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jZW50ZXI7XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy56b29tO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5zZXRTdG9yeVRpdGxlID0gZnVuY3Rpb24oc3RvcnlUaXRsZSkge1xuICAgIHRoaXMudGl0bGUgPSAgc3RvcnlUaXRsZTtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgdGhpcy5jZW50ZXIgPSAgY2VudGVyO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24oem9vbSkge1xuICAgIHRoaXMuem9vbSA9ICB6b29tO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24ocGxheWJhY2tNb2RlKSB7XG4gICAgdGhpcy5tb2RlID0gIHBsYXliYWNrTW9kZTtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuc2V0U3RvcnlBYnN0cmFjdCA9IGZ1bmN0aW9uKHN0b3J5QWJzdHJhY3QpIHtcbiAgICB0aGlzLmFic3RyYWN0ID0gIHN0b3J5QWJzdHJhY3Q7XG4gIH07XG5cblxuICBTdG9yeU1hcC5wcm90b3R5cGUuZ2V0U3RvcnlUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5nZXRTdG9yeUFic3RyYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJzdHJhY3Q7XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLnNldEJhc2VMYXllciA9IGZ1bmN0aW9uKGJhc2VMYXllcikge1xuICAgIHRoaXMuc2V0KCdiYXNlbGF5ZXInLCBiYXNlTGF5ZXIpO1xuICAgIHRoaXMubWFwXy5nZXRMYXllcnMoKS5mb3JFYWNoKGZ1bmN0aW9uKGx5cikge1xuICAgICAgaWYgKGx5ci5nZXQoJ2dyb3VwJykgPT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICB0aGlzLm1hcF8ucmVtb3ZlTGF5ZXIobHlyKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLm1hcF8uZ2V0TGF5ZXJzKCkuaW5zZXJ0QXQoMCwgdGhpcy5nZXQoJ2Jhc2VsYXllcicpKTtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuYWRkU3RvcnlMYXllciA9IGZ1bmN0aW9uKHN0b3J5TGF5ZXIpIHtcbiAgICBzdG9yeUxheWVyLnN0b3J5TWFwXyA9IHRoaXM7XG4gICAgdGhpcy5zdG9yeUxheWVyc18ucHVzaChzdG9yeUxheWVyKTtcbiAgICAvLyBrZWVwIHBpbnMgbGF5ZXIgb24gdG9wXG4gICAgdmFyIGlkeCA9IHRoaXMubWFwXy5nZXRMYXllcnMoKS5nZXRMZW5ndGgoKSwgbWUgPSB0aGlzO1xuICAgIHRoaXMubWFwXy5nZXRMYXllcnMoKS5mb3JFYWNoKGZ1bmN0aW9uKHNsKSB7XG4gICAgICBpZiAoc2wgPT09IG1lLnN0b3J5UGluc0xheWVyKSB7XG4gICAgICAgIGlkeCAtPSAxO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubWFwXy5nZXRMYXllcnMoKS5pbnNlcnRBdChcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgc3RvcnlMYXllci5nZXRMYXllcigpXG4gICAgKTtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuZ2V0U3RvcnlMYXllcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yeUxheWVyc187XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF87XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tYXBfLmdldExheWVycygpLmNsZWFyKCk7XG4gICAgdGhpcy5zdG9yeUxheWVyc18uY2xlYXIoKTtcbiAgICB0aGlzLmFkZFN0b3J5UGluc0xheWVyKCk7XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLmFuaW1hdGVQYW5BbmRCb3VuY2UgPSBmdW5jdGlvbihjZW50ZXIsIHpvb20pe1xuXG4gICAgdmFyIGR1cmF0aW9uID0gMjAwMDtcbiAgICB2YXIgc3RhcnQgPSArbmV3IERhdGUoKTtcblxuICAgIHZhciB2aWV3ID0gdGhpcy5tYXBfLmdldFZpZXcoKTtcblxuICAgIGlmKHZpZXcuZ2V0Q2VudGVyKCkgIT0gY2VudGVyKXtcblxuICAgICAgdmFyIHBhbiA9IG9sLmFuaW1hdGlvbi5wYW4oe1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5hbmltYXRpb25EdXJhdGlvbl8sXG4gICAgICAgIHNvdXJjZTogdmlldy5nZXRDZW50ZXIoKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0XG4gICAgICB9KTtcblxuXG4gICAgICB2YXIgYm91bmNlID0gb2wuYW5pbWF0aW9uLmJvdW5jZSh7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgcmVzb2x1dGlvbjogMiAqIHZpZXcuZ2V0UmVzb2x1dGlvbigpLFxuICAgICAgICBzdGFydDogc3RhcnRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1hcF8uYmVmb3JlUmVuZGVyKHBhbiwgYm91bmNlKTtcblxuICAgICAgdmlldy5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgIHZpZXcuc2V0Wm9vbSh6b29tKTtcbiAgICB9XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLmFuaW1hdGVDZW50ZXJBbmRab29tID0gZnVuY3Rpb24oY2VudGVyLCB6b29tKSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLm1hcF8uZ2V0VmlldygpO1xuICAgIGlmICh2aWV3LmdldENlbnRlcigpICE9PSBjZW50ZXIgfHwgdmlldy5nZXRab29tKCkgIT09IHpvb20pIHtcbiAgICAgIHRoaXMubWFwXy5iZWZvcmVSZW5kZXIob2wuYW5pbWF0aW9uLnBhbih7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uXyxcbiAgICAgICAgc291cmNlOiB2aWV3LmdldENlbnRlcigpXG4gICAgICB9KSk7XG4gICAgICB2aWV3LnNldENlbnRlcihjZW50ZXIpO1xuICAgICAgdGhpcy5tYXBfLmJlZm9yZVJlbmRlcihvbC5hbmltYXRpb24uem9vbSh7XG4gICAgICAgIHJlc29sdXRpb246IHZpZXcuZ2V0UmVzb2x1dGlvbigpLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5hbmltYXRpb25EdXJhdGlvbl9cbiAgICAgIH0pKTtcbiAgICAgIHZpZXcuc2V0Wm9vbSh6b29tKTtcbiAgICB9XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLnNldEFsbG93UGFuID0gZnVuY3Rpb24oYWxsb3dQYW4pIHtcbiAgICB0aGlzLm1hcF8uZ2V0SW50ZXJhY3Rpb25zKCkuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBpZiAoaSBpbnN0YW5jZW9mIG9sLmludGVyYWN0aW9uLktleWJvYXJkUGFuIHx8XG4gICAgICAgICAgICBpIGluc3RhbmNlb2Ygb2wuaW50ZXJhY3Rpb24uRHJhZ1Bhbikge1xuICAgICAgICBpLnNldEFjdGl2ZShhbGxvd1Bhbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLnNldEFsbG93Wm9vbSA9IGZ1bmN0aW9uKGFsbG93Wm9vbSkge1xuICAgIHZhciB6b29tQ3RybDtcbiAgICB0aGlzLm1hcF8uZ2V0Q29udHJvbHMoKS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgIGlmIChjIGluc3RhbmNlb2Ygb2wuY29udHJvbC5ab29tKSB7XG4gICAgICAgIHpvb21DdHJsID0gYztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFsbG93Wm9vbSkge1xuICAgICAgdGhpcy5tYXBfLnJlbW92ZUNvbnRyb2woem9vbUN0cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcF8uYWRkQ29udHJvbChuZXcgb2wuY29udHJvbC5ab29tKCkpO1xuICAgIH1cbiAgICB0aGlzLm1hcF8uZ2V0SW50ZXJhY3Rpb25zKCkuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBpZiAoaSBpbnN0YW5jZW9mIG9sLmludGVyYWN0aW9uLkRvdWJsZUNsaWNrWm9vbSB8fFxuICAgICAgICAgICAgaSBpbnN0YW5jZW9mIG9sLmludGVyYWN0aW9uLlBpbmNoWm9vbSB8fFxuICAgICAgICAgICAgaSBpbnN0YW5jZW9mIG9sLmludGVyYWN0aW9uLkRyYWdab29tIHx8XG4gICAgICAgICAgICBpIGluc3RhbmNlb2Ygb2wuaW50ZXJhY3Rpb24uTW91c2VXaGVlbFpvb20pIHtcbiAgICAgICAgaS5zZXRBY3RpdmUoYWxsb3dab29tKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBtb2R1bGUuY29uc3RhbnQoJ1N0b3J5TWFwJywgU3RvcnlNYXApO1xuXG4gIGZ1bmN0aW9uIEVkaXRhYmxlU3RvcnlNYXAoZGF0YSkge1xuICAgIFN0b3J5TWFwLmNhbGwodGhpcywgZGF0YSk7XG4gIH1cblxuICBFZGl0YWJsZVN0b3J5TWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RvcnlNYXAucHJvdG90eXBlKTtcbiAgRWRpdGFibGVTdG9yeU1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFZGl0YWJsZVN0b3J5TWFwO1xuXG4gIG1vZHVsZS5jb25zdGFudCgnRWRpdGFibGVTdG9yeU1hcCcsIEVkaXRhYmxlU3RvcnlNYXApO1xuXG4gIEVkaXRhYmxlU3RvcnlNYXAucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbmZpZyA9IHt9O1xuICAgIGNvbmZpZy5tYXAgPSB7XG4gICAgICBjZW50ZXI6IHRoaXMubWFwXy5nZXRWaWV3KCkuZ2V0Q2VudGVyKCksXG4gICAgICBwcm9qZWN0aW9uOiB0aGlzLm1hcF8uZ2V0VmlldygpLmdldFByb2plY3Rpb24oKS5nZXRDb2RlKCksXG4gICAgICB6b29tOiB0aGlzLm1hcF8uZ2V0VmlldygpLmdldFpvb20oKSxcbiAgICAgIGxheWVyczogW11cbiAgICB9O1xuICAgIHZhciBtYXBJZCA9IHRoaXMuZ2V0KCdpZCcpO1xuICAgIGlmIChtYXBJZCA+PSAwKSB7XG4gICAgICBjb25maWcuaWQgPSBtYXBJZDtcbiAgICB9XG4gICAgdmFyIGJhc2VMYXllciA9IHRoaXMuZ2V0KCdiYXNlbGF5ZXInKTtcbiAgICBpZiAoYmFzZUxheWVyKSB7XG4gICAgICB2YXIgYmFzZUxheWVyU3RhdGUgPSB0aGlzLmdldCgnYmFzZWxheWVyJykuZ2V0KCdzdGF0ZScpO1xuICAgICAgYmFzZUxheWVyU3RhdGUuZ3JvdXAgPSAnYmFja2dyb3VuZCc7XG4gICAgICBiYXNlTGF5ZXJTdGF0ZS52aXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5tYXAubGF5ZXJzLnB1c2goYmFzZUxheWVyU3RhdGUpO1xuICAgIH1cbiAgICB0aGlzLnN0b3J5TGF5ZXJzXy5mb3JFYWNoKGZ1bmN0aW9uKHN0b3J5TGF5ZXIpIHtcbiAgICAgIGNvbmZpZy5tYXAubGF5ZXJzLnB1c2goc3RvcnlMYXllci5nZXRTdGF0ZSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9O1xuXG4gIEVkaXRhYmxlU3RvcnlNYXAucHJvdG90eXBlLnJlbW92ZVN0b3J5TGF5ZXIgPSBmdW5jdGlvbihzdG9yeUxheWVyKSB7XG4gICAgdGhpcy5zdG9yeUxheWVyc18ucmVtb3ZlKHN0b3J5TGF5ZXIpO1xuICAgIHRoaXMubWFwXy5yZW1vdmVMYXllcihzdG9yeUxheWVyLmdldExheWVyKCkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFN0b3J5TGF5ZXIoZGF0YSkge1xuICAgIGlmIChkYXRhLnRpbWVzICYmIHN0b3J5dG9vbHMuY29yZS50aW1lLnV0aWxzLmlzUmFuZ2VMaWtlKGRhdGEudGltZXMpKSB7XG4gICAgICBkYXRhLnRpbWVzID0gbmV3IHN0b3J5dG9vbHMuY29yZS50aW1lLnV0aWxzLkludGVydmFsKGRhdGEudGltZXMpO1xuICAgIH1cbiAgICBvbC5PYmplY3QuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB2YXIgbGF5ZXI7XG4gICAgaWYgKHRoaXMuZ2V0KCd0eXBlJykgPT09ICdWRUNUT1InKSB7XG4gICAgICBsYXllciA9IG5ldyBvbC5sYXllci5WZWN0b3Ioe3NvdXJjZTogbmV3IG9sLnNvdXJjZS5WZWN0b3IoKX0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5nZXQoJ3R5cGUnKSA9PT0gJ0hFQVRNQVAnKSB7XG4gICAgICBsYXllciA9IG5ldyBvbC5sYXllci5IZWF0bWFwKHtcbiAgICAgICAgcmFkaXVzOiBkYXRhLnN0eWxlLnJhZGl1cyxcbiAgICAgICAgb3BhY2l0eTogZGF0YS5zdHlsZS5vcGFjaXR5LFxuICAgICAgICBzb3VyY2U6IG5ldyBvbC5zb3VyY2UuVmVjdG9yKClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5nZXQoJ3R5cGUnKSA9PT0gJ1dNUycpIHtcbiAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIHVzZU9sZEFzSW50ZXJpbVRpbGVzOiB0cnVlXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZ2V0KCdzaW5nbGVUaWxlJykgPT09IHRydWUpIHtcbiAgICAgICAgbGF5ZXIgPSBuZXcgb2wubGF5ZXIuSW1hZ2UoY29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxheWVyID0gbmV3IG9sLmxheWVyLlRpbGUoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIgPSBkYXRhLmxheWVyO1xuICAgIH1cbiAgICB0aGlzLmxheWVyXyA9IGxheWVyO1xuICB9XG5cbiAgU3RvcnlMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG9sLk9iamVjdC5wcm90b3R5cGUpO1xuICBTdG9yeUxheWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0b3J5TGF5ZXI7XG5cbiAgU3RvcnlMYXllci5wcm90b3R5cGUuZ2V0U3RvcnlNYXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yeU1hcF87XG4gIH07XG5cbiAgU3RvcnlMYXllci5wcm90b3R5cGUuc2V0V01TU291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIHZhciBuYW1lID0gdGhpcy5nZXQoJ25hbWUnKTtcbiAgICB2YXIgdGltZXMgPSB0aGlzLmdldCgndGltZXMnKTtcbiAgICB2YXIgc2luZ2xlVGlsZSA9IHRoaXMuZ2V0KCdzaW5nbGVUaWxlJyk7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0KCdwYXJhbXMnKSB8fCB7XG4gICAgICAgICAgICAnTEFZRVJTJzogbmFtZSxcbiAgICAgICAgICAgICdWRVJTSU9OJzogJzEuMS4wJyxcbiAgICAgICAgICAgICdUSUxFRCc6IHRydWVcbiAgICAgICAgICB9O1xuICAgIGlmICh0aW1lcykge1xuICAgICAgcGFyYW1zLlRJTUUgPSBuZXcgRGF0ZSh0aW1lcy5zdGFydCB8fCB0aW1lc1swXSkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHNpbmdsZVRpbGUpIHtcbiAgICAgIGxheWVyLnNldFNvdXJjZShuZXcgb2wuc291cmNlLkltYWdlV01TKHtcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIHVybDogdGhpcy5nZXQoJ3VybCcpLFxuICAgICAgICBzZXJ2ZXJUeXBlOiAnZ2Vvc2VydmVyJ1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGlsZUdyaWQsIHJlc29sdXRpb25zID0gdGhpcy5nZXQoJ3Jlc29sdXRpb25zJyksXG4gICAgICAgICAgICBiYm94ID0gdGhpcy5nZXQoJ2Jib3gnKTtcbiAgICAgIGlmIChyZXNvbHV0aW9ucyAmJiBiYm94KSB7XG4gICAgICAgIHRpbGVHcmlkID0gbmV3IG9sLnRpbGVncmlkLlRpbGVHcmlkKHtcbiAgICAgICAgICBleHRlbnQ6IGJib3gsXG4gICAgICAgICAgcmVzb2x1dGlvbnM6IHJlc29sdXRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gQHRvZG8gdXNlIHVybHMgZm9yIHN1YmRvbWFpbiBsb2FkaW5nXG4gICAgICBsYXllci5zZXRTb3VyY2UobmV3IG9sLnNvdXJjZS5UaWxlV01TKHtcbiAgICAgICAgdXJsOiB0aGlzLmdldCgndXJsJyksXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICB0aWxlR3JpZDogdGlsZUdyaWQsXG4gICAgICAgIHNlcnZlclR5cGU6ICdnZW9zZXJ2ZXInXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIFN0b3J5TGF5ZXIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgZGVsZXRlIHN0YXRlLmZlYXR1cmVzO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcblxuICBTdG9yeUxheWVyLnByb3RvdHlwZS5nZXRMYXllciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyXztcbiAgfTtcblxuICBTdG9yeUxheWVyLnByb3RvdHlwZS5zZXRMYXllciA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJfICYmIHRoaXMuc3RvcnlNYXBfKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5zdG9yeU1hcF8ubWFwXztcbiAgICAgIHZhciBpZHggPSBtYXAuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKS5pbmRleE9mKHRoaXMubGF5ZXJfKTtcbiAgICAgIG1hcC5nZXRMYXllcnMoKS5zZXRBdChpZHgsIGxheWVyKTtcbiAgICB9XG4gICAgdGhpcy5sYXllcl8gPSBsYXllcjtcbiAgfTtcblxuICBtb2R1bGUuY29uc3RhbnQoJ1N0b3J5TGF5ZXInLCBTdG9yeUxheWVyKTtcblxuICBmdW5jdGlvbiBFZGl0YWJsZVN0b3J5TGF5ZXIoZGF0YSkge1xuICAgIFN0b3J5TGF5ZXIuY2FsbCh0aGlzLCBkYXRhKTtcbiAgfVxuXG4gIEVkaXRhYmxlU3RvcnlMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0b3J5TGF5ZXIucHJvdG90eXBlKTtcbiAgRWRpdGFibGVTdG9yeUxheWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVkaXRhYmxlU3RvcnlMYXllcjtcblxuICBtb2R1bGUuY29uc3RhbnQoJ0VkaXRhYmxlU3RvcnlMYXllcicsIEVkaXRhYmxlU3RvcnlMYXllcik7XG5cbiAgbW9kdWxlLnNlcnZpY2UoJ3N0QW5ub3RhdGVMYXllcicsIGZ1bmN0aW9uKCRodHRwLCAkcSkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2FkQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbihzdG9yeUxheWVyKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gJ0dldENhcGFiaWxpdGllcycsIHNlcnZpY2UgPSAnV01TJztcbiAgICAgICAgLy8gYWx3YXlzIHVzZSB0aGUgdmlydHVhbCBzZXJ2aWNlIGZvciBHZXRDYXBhYmlsaXRpZXNcbiAgICAgICAgdmFyIHVybCA9IHN0b3J5TGF5ZXIuZ2V0KCd1cmwnKTtcbiAgICAgICAgaWYgKHVybCA9PT0gJy9nZW9zZXJ2ZXIvd21zJykge1xuICAgICAgICAgIHZhciBuYW1lID0gc3RvcnlMYXllci5nZXQoJ25hbWUnKTtcbiAgICAgICAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJy9nZW9zZXJ2ZXInLCAnL2dlb3NlcnZlci8nICsgcGFydHNbMF0gKyAnLycgKyBwYXJ0c1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ2h0dHA6JywgJycpO1xuXG4gICAgICAgIHJldHVybiAkaHR0cCh7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICdSRVFVRVNUJzogcmVxdWVzdCxcbiAgICAgICAgICAgICdTRVJWSUNFJzogc2VydmljZSxcbiAgICAgICAgICAgICdWRVJTSU9OJzogJzEuMS4xJyxcbiAgICAgICAgICAgICdUSUxFRCc6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHZhciBjb250ZXh0ID0gbmV3IG93c2pzLkpzb25peC5Db250ZXh0KFtcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLldNU0NfMV8xXzFcbiAgICAgICAgICBdKTtcbiAgICAgICAgICB2YXIgdW5tYXJzaGFsbGVyID0gY29udGV4dC5jcmVhdGVVbm1hcnNoYWxsZXIoKTtcbiAgICAgICAgICB2YXIgY2FwcyA9IHVubWFyc2hhbGxlci51bm1hcnNoYWxTdHJpbmcoZGF0YSk7XG4gICAgICAgICAgdmFyIGxheWVyID0gY2Fwcy52YWx1ZS5jYXBhYmlsaXR5LmxheWVyO1xuICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdsYXRsb25CQk9YJywgW1xuICAgICAgICAgICAgcGFyc2VGbG9hdChsYXllci5sYXRMb25Cb3VuZGluZ0JveC5taW54KSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQobGF5ZXIubGF0TG9uQm91bmRpbmdCb3gubWlueSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGxheWVyLmxhdExvbkJvdW5kaW5nQm94Lm1heHgpLFxuICAgICAgICAgICAgcGFyc2VGbG9hdChsYXllci5sYXRMb25Cb3VuZGluZ0JveC5tYXh5KVxuICAgICAgICAgIF0pO1xuICAgICAgICAgIHZhciB2ZW5kb3JTcGVjaWZpY0NhcGFiaWxpdGllcyA9IGNhcHMudmFsdWUuY2FwYWJpbGl0eS52ZW5kb3JTcGVjaWZpY0NhcGFiaWxpdGllcztcbiAgICAgICAgICB2YXIgdGlsZVNldHMgPSAodmVuZG9yU3BlY2lmaWNDYXBhYmlsaXRpZXMpPyB2ZW5kb3JTcGVjaWZpY0NhcGFiaWxpdGllcy50aWxlU2V0OiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpPTAsIGlpPXRpbGVTZXRzLmxlbmd0aDsgaTxpaTsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGlsZVNldHNbaV0uc3JzID09PSAnRVBTRzo5MDA5MTMnKSB7XG4gICAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdyZXNvbHV0aW9ucycsIHRpbGVTZXRzW2ldLnJlc29sdXRpb25zLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgICB2YXIgYmJveCA9IHRpbGVTZXRzW2ldLmJvdW5kaW5nQm94O1xuICAgICAgICAgICAgICBzdG9yeUxheWVyLnNldCgnYmJveCcsIFtcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGJib3gubWlueCksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChiYm94Lm1pbnkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoYmJveC5tYXh4KSxcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGJib3gubWF4eSlcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZm91bmQgPSBzdG9yeXRvb2xzLmNvcmUudGltZS5tYXBzLnJlYWRDYXBhYmlsaXRpZXNUaW1lRGltZW5zaW9ucyhjYXBzKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHN0b3J5TGF5ZXIuZ2V0KCduYW1lJyk7XG4gICAgICAgICAgaWYgKG5hbWUgaW4gZm91bmQpIHtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCd0aW1lcycsIGZvdW5kW25hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRlc2NyaWJlRmVhdHVyZVR5cGU6IGZ1bmN0aW9uKHN0b3J5TGF5ZXIpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHJlcXVlc3QgPSAnRGVzY3JpYmVGZWF0dXJlVHlwZScsIHNlcnZpY2UgPSAnV0ZTJztcbiAgICAgICAgdmFyIGlkID0gc3RvcnlMYXllci5nZXQoJ2lkJyk7XG4gICAgICAgIHJldHVybiAkaHR0cCh7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICB1cmw6IHN0b3J5TGF5ZXIuZ2V0KCd1cmwnKS5yZXBsYWNlKCdodHRwOicsICcnKSxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICdTRVJWSUNFJzogc2VydmljZSxcbiAgICAgICAgICAgICdWRVJTSU9OJzogJzEuMC4wJyxcbiAgICAgICAgICAgICdSRVFVRVNUJzogcmVxdWVzdCxcbiAgICAgICAgICAgICdUWVBFTkFNRSc6IGlkXG4gICAgICAgICAgfVxuICAgICAgICB9KS5zdWNjZXNzKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IHN0b3J5dG9vbHMuZWRpdC5XRlNEZXNjcmliZUZlYXR1cmVUeXBlLldGU0Rlc2NyaWJlRmVhdHVyZVR5cGUoKTtcbiAgICAgICAgICB2YXIgbGF5ZXJJbmZvID0gcGFyc2VyLnBhcnNlUmVzdWx0KGRhdGEpO1xuICAgICAgICAgIGlmIChsYXllckluZm8udGltZUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ3RpbWVBdHRyaWJ1dGUnLCBsYXllckluZm8udGltZUF0dHJpYnV0ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yeUxheWVyLmdldCgndGltZUVuZHBvaW50JykpIHtcbiAgICAgICAgICAgIG1lLmdldFRpbWVBdHRyaWJ1dGUoc3RvcnlMYXllcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwYXJ0cyA9IGlkLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgc3RvcnlMYXllci5zZXQoJ3R5cGVOYW1lJywgaWQpO1xuICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdmZWF0dXJlUHJlZml4JywgcGFydHNbMF0pO1xuICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdmZWF0dXJlTlMnLCBsYXllckluZm8uZmVhdHVyZU5TKTtcbiAgICAgICAgICBzdG9yeUxheWVyLnNldCgnZ2VvbVR5cGUnLCBsYXllckluZm8uZ2VvbVR5cGUpO1xuICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdhdHRyaWJ1dGVzJywgbGF5ZXJJbmZvLmF0dHJpYnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRUaW1lQXR0cmlidXRlOiBmdW5jdGlvbihzdG9yeUxheWVyKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAkaHR0cCh7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICB1cmw6IHN0b3J5TGF5ZXIuZ2V0KCd0aW1lRW5kcG9pbnQnKVxuICAgICAgICB9KS5zdWNjZXNzKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICBzdG9yeUxheWVyLnNldCgndGltZUF0dHJpYnV0ZScsIGRhdGEuYXR0cmlidXRlKTtcbiAgICAgICAgICBpZiAoZGF0YS5lbmRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdlbmRUaW1lQXR0cmlidXRlJywgZGF0YS5lbmRBdHRyaWJ1dGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0U3R5bGVOYW1lOiBmdW5jdGlvbihzdG9yeUxheWVyKSB7XG4gICAgICAgIGlmIChzdG9yeUxheWVyLmdldCgnY2FuU3R5bGVXTVMnKSkge1xuICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuICRodHRwKHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB1cmw6IHN0b3J5TGF5ZXIuZ2V0KCdwYXRoJykgKyAncmVzdC9sYXllcnMvJyArIHN0b3J5TGF5ZXIuZ2V0KCdpZCcpICsgJy5qc29uJ1xuICAgICAgICAgIH0pLnN1Y2Nlc3MoZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdzdHlsZU5hbWUnLCByZXNwb25zZS5sYXllci5kZWZhdWx0U3R5bGUubmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRxLndoZW4oJycpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0RmVhdHVyZXM6IGZ1bmN0aW9uKHN0b3J5TGF5ZXIsIG1hcCkge1xuICAgICAgICB2YXIgbmFtZSA9IHN0b3J5TGF5ZXIuZ2V0KCdpZCcpO1xuICAgICAgICB2YXIgd2ZzVXJsID0gc3RvcnlMYXllci5nZXQoJ3VybCcpICsgJz9zZXJ2aWNlPVdGUyZ2ZXJzaW9uPTEuMS4wJnJlcXVlc3Q9R2V0RmVhdHVyZSZ0eXBlbmFtZT0nICtcbiAgICAgICAgICAgICAgbmFtZSArICcmb3V0cHV0Rm9ybWF0PWFwcGxpY2F0aW9uL2pzb24nICtcbiAgICAgICAgICAgICAgJyZzcnNOYW1lPScgKyBtYXAuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKS5nZXRDb2RlKCk7XG4gICAgICAgIHJldHVybiAkaHR0cCh7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICB1cmw6IHdmc1VybFxuICAgICAgICB9KS5zdWNjZXNzKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgdmFyIGxheWVyID0gc3RvcnlMYXllci5nZXRMYXllcigpO1xuICAgICAgICAgIHZhciBmZWF0dXJlcyA9IG5ldyBvbC5mb3JtYXQuR2VvSlNPTigpLnJlYWRGZWF0dXJlcyhyZXNwb25zZSk7XG4gICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2ZlYXR1cmVzJywgZmVhdHVyZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBtb2R1bGUuc2VydmljZSgnc3RCYXNlTGF5ZXJCdWlsZGVyJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJ1aWxkTGF5ZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ01hcFF1ZXN0Jykge1xuICAgICAgICAgIHJldHVybiBuZXcgb2wubGF5ZXIuVGlsZSh7XG4gICAgICAgICAgICBzdGF0ZTogZGF0YSxcbiAgICAgICAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgICAgICAgZ3JvdXA6ICdiYWNrZ3JvdW5kJyxcbiAgICAgICAgICAgIHNvdXJjZTogbmV3IG9sLnNvdXJjZS5NYXBRdWVzdCh7bGF5ZXI6IGRhdGEubGF5ZXJ9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ0VTUkknKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBvbC5sYXllci5UaWxlKHtcbiAgICAgICAgICAgIHNvdXJjZTogbmV3IG9sLnNvdXJjZS5YWVooe1xuICAgICAgICAgICAgICBhdHRyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICBuZXcgb2wuQXR0cmlidXRpb24oe1xuICAgICAgICAgICAgICAgICAgaHRtbDogJ1RpbGVzICZjb3B5OyA8YSBocmVmPVwiaHR0cDovL3NlcnZpY2VzLmFyY2dpc29ubGluZS5jb20vQXJjR0lTLycgK1xuICAgICAgICAgICAgICAgICAgJ3Jlc3Qvc2VydmljZXMvV29ybGRfVG9wb19NYXAvTWFwU2VydmVyXCI+QXJjR0lTPC9hPidcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB1cmw6ICdodHRwOi8vc2VydmVyLmFyY2dpc29ubGluZS5jb20vQXJjR0lTL3Jlc3Qvc2VydmljZXMvJyArXG4gICAgICAgICAgICAgICdXb3JsZF9Ub3BvX01hcC9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1lbHNlIGlmIChkYXRhLnR5cGUgPT09ICdIT1QnKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBvbC5sYXllci5UaWxlKHtcbiAgICAgICAgICAgIHN0YXRlOiBkYXRhLFxuICAgICAgICAgICAgdGl0bGU6IGRhdGEudGl0bGUsXG4gICAgICAgICAgICBncm91cDogJ2JhY2tncm91bmQnLFxuICAgICAgICAgICAgc291cmNlOiBuZXcgb2wuc291cmNlLk9TTSh7XG4gICAgICAgICAgICAgIGF0dHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgIG5ldyBvbC5BdHRyaWJ1dGlvbih7XG4gICAgICAgICAgICAgICAgICBodG1sOiAnVGlsZXMgY291cnRlc3kgb2YgPGEgaHJlZj1cIi8vaG90Lm9wZW5zdHJlZXRtYXAub3JnL1wiIHRhcmdldD1cIl9ibGFua1wiPkh1bWFuaXRhcmlhbiBPcGVuU3RyZWV0TWFwIFRlYW08L2E+J1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG9sLnNvdXJjZS5PU00uQVRUUklCVVRJT05cbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgICAgICAgICAgIHVybDogJy8ve2EtY30udGlsZS5vcGVuc3RyZWV0bWFwLmZyL2hvdC97en0ve3h9L3t5fS5wbmcnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ09TTScpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG9sLmxheWVyLlRpbGUoe1xuICAgICAgICAgICAgc3RhdGU6IGRhdGEsXG4gICAgICAgICAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICAgICAgICAgIGdyb3VwOiAnYmFja2dyb3VuZCcsXG4gICAgICAgICAgICBzb3VyY2U6IG5ldyBvbC5zb3VyY2UuT1NNKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdNYXBCb3gnKSB7XG4gICAgICAgICAgdmFyIGxheWVyID0gbmV3IG9sLmxheWVyLlRpbGUoe3N0YXRlOiBkYXRhLCB0aXRsZTogZGF0YS50aXRsZSwgZ3JvdXA6ICdiYWNrZ3JvdW5kJ30pO1xuICAgICAgICAgIHZhciBuYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICAgIHZhciB1cmxzID0gW1xuICAgICAgICAgICAgJy8vYS50aWxlcy5tYXBib3guY29tL3YxL21hcGJveC4nLFxuICAgICAgICAgICAgJy8vYi50aWxlcy5tYXBib3guY29tL3YxL21hcGJveC4nLFxuICAgICAgICAgICAgJy8vYy50aWxlcy5tYXBib3guY29tL3YxL21hcGJveC4nLFxuICAgICAgICAgICAgJy8vZC50aWxlcy5tYXBib3guY29tL3YxL21hcGJveC4nXG4gICAgICAgICAgXTtcbiAgICAgICAgICB2YXIgdGlsZVVybEZ1bmN0aW9uID0gZnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgenh5ID0gdGlsZUNvb3JkO1xuICAgICAgICAgICAgaWYgKHp4eVsxXSA8IDAgfHwgenh5WzJdIDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmxzW01hdGgucm91bmQoTWF0aC5yYW5kb20oKSozKV0gKyBuYW1lICsgJy8nICtcbiAgICAgICAgICAgICAgICAgIHp4eVswXS50b1N0cmluZygpKycvJysgenh5WzFdLnRvU3RyaW5nKCkgKycvJytcbiAgICAgICAgICAgICAgICAgIHp4eVsyXS50b1N0cmluZygpICsnLnBuZyc7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBsYXllci5zZXRTb3VyY2UobmV3IG9sLnNvdXJjZS5UaWxlSW1hZ2Uoe1xuICAgICAgICAgICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgbmV3IG9sLkF0dHJpYnV0aW9uKHtcbiAgICAgICAgICAgICAgICBodG1sOiAvXndvcmxkLy50ZXN0KG5hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgICBcIjxhIGhyZWY9Jy8vbWFwYm94LmNvbSc+TWFwQm94PC9hPiB8IFNvbWUgRGF0YSAmY29weTsgT1NNIENDLUJZLVNBIHwgPGEgaHJlZj0nLy9tYXBib3guY29tL3Rvcyc+VGVybXMgb2YgU2VydmljZTwvYT5cIiA6XG4gICAgICAgICAgICAgICAgICAgICAgXCI8YSBocmVmPScvL21hcGJveC5jb20nPk1hcEJveDwvYT4gfCA8YSBocmVmPScvL21hcGJveC5jb20vdG9zJz5UZXJtcyBvZiBTZXJ2aWNlPC9hPlwiXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdGlsZUdyaWQ6IG5ldyBvbC50aWxlZ3JpZC5UaWxlR3JpZCh7XG4gICAgICAgICAgICAgIG9yaWdpbjogWy0xMjggKiAxNTY1NDMuMDMzOTA2MjUsIC0xMjggKiAxNTY1NDMuMDMzOTA2MjVdLFxuICAgICAgICAgICAgICByZXNvbHV0aW9uczogW1xuICAgICAgICAgICAgICAgIDE1NjU0My4wMzM5MDYyNSwgNzgyNzEuNTE2OTUzMTI1LCAzOTEzNS43NTg0NzY1NjI1LFxuICAgICAgICAgICAgICAgIDE5NTY3Ljg3OTIzODI4MTI1LCA5NzgzLjkzOTYxOTE0MDYyNSwgNDg5MS45Njk4MDk1NzAzMTI1LFxuICAgICAgICAgICAgICAgIDI0NDUuOTg0OTA0Nzg1MTU2MiwgMTIyMi45OTI0NTIzOTI1NzgxLCA2MTEuNDk2MjI2MTk2Mjg5MSxcbiAgICAgICAgICAgICAgICAzMDUuNzQ4MTEzMDk4MTQ0NTMsIDE1Mi44NzQwNTY1NDkwNzIyNiwgNzYuNDM3MDI4Mjc0NTM2MTMsXG4gICAgICAgICAgICAgICAgMzguMjE4NTE0MTM3MjY4MDY2LCAxOS4xMDkyNTcwNjg2MzQwMzMsIDkuNTU0NjI4NTM0MzE3MDE3LFxuICAgICAgICAgICAgICAgIDQuNzc3MzE0MjY3MTU4NTA4LCAyLjM4ODY1NzEzMzU3OTI1NCwgMS4xOTQzMjg1NjY3ODk2MjcsXG4gICAgICAgICAgICAgICAgMC41OTcxNjQyODMzOTQ4MTM1XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGlsZVVybEZ1bmN0aW9uOiB0aWxlVXJsRnVuY3Rpb25cbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ1dNUycpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG9sLmxheWVyLlRpbGUoe1xuICAgICAgICAgICAgZ3JvdXA6IFwiYmFja2dyb3VuZFwiLFxuICAgICAgICAgICAgc291cmNlOiBuZXcgb2wuc291cmNlLlRpbGVXTVMoe1xuICAgICAgICAgICAgICB1cmw6IGRhdGEudXJsLFxuICAgICAgICAgICAgICBwYXJhbXM6IGRhdGEucGFyYW1zXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gdHlwZSBmb3IgOiAnICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgbW9kdWxlLnNlcnZpY2UoJ3N0RWRpdGFibGVMYXllckJ1aWxkZXInLCBmdW5jdGlvbigkcSwgc3RBbm5vdGF0ZUxheWVyLCBzdEJhc2VMYXllckJ1aWxkZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnVpbGRFZGl0YWJsZUxheWVyOiBmdW5jdGlvbihkYXRhLCBtYXApIHtcbiAgICAgICAgdmFyIGxheWVyID0gbmV3IEVkaXRhYmxlU3RvcnlMYXllcihkYXRhKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIC8vIFRPRE8gYWRkIHRoaXMgYmFjayB3aGVuIHdlIGhhdmUgV01TLUMgR2V0Q2Fwc1xuICAgICAgICB2YXIgbmVlZHNDYXBzID0gIShkYXRhLmxhdGxvbkJCT1ggJiYgZGF0YS50aW1lcy8qICYmIGRhdGEuYmJveCAmJiBkYXRhLnJlc29sdXRpb25zKi8pO1xuICAgICAgICBpZiAobmVlZHNDYXBzKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChzdEFubm90YXRlTGF5ZXIubG9hZENhcGFiaWxpdGllcyhsYXllcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWVkc0RGVCA9ICFkYXRhLmF0dHJpYnV0ZXM7XG4gICAgICAgIGlmIChuZWVkc0RGVCkge1xuICAgICAgICAgIHByb21pc2VzLnB1c2goc3RBbm5vdGF0ZUxheWVyLmRlc2NyaWJlRmVhdHVyZVR5cGUobGF5ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGRhdGEudHlwZSA9PT0gJ1ZFQ1RPUicgfHwgZGF0YS50eXBlID09PSAnSEVBVE1BUCcpICYmICFkYXRhLmZlYXR1cmVzKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChzdEFubm90YXRlTGF5ZXIuZ2V0RmVhdHVyZXMobGF5ZXIsIG1hcCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb21pc2VzLnB1c2goc3RBbm5vdGF0ZUxheWVyLmdldFN0eWxlTmFtZShsYXllcikpO1xuICAgICAgICB9XG4gICAgICAgICRxLmFsbChcbiAgICAgICAgICAgICAgcHJvbWlzZXNcbiAgICAgICAgKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgZG9uZSBoZXJlIHdoZW4gZXZlcnl0aGluZyBpcyByZXNvbHZlZFxuICAgICAgICAgICAgICAgIGlmIChsYXllci5nZXQoJ2ZlYXR1cmVzJykpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0aW1lcyA9IGxheWVyLmdldCgndGltZXMnKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aW1lcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aW1lcy5zdGFydCB8fCB0aW1lc1swXTtcbiAgICAgICAgICAgICAgICAgICAgc3Rvcnl0b29scy5jb3JlLnRpbWUubWFwcy5maWx0ZXJWZWN0b3JMYXllcihsYXllciwge3N0YXJ0OiBzdGFydCwgZW5kOiBzdGFydH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZ2V0TGF5ZXIoKS5nZXRTb3VyY2UoKS5hZGRGZWF0dXJlcyhsYXllci5nZXQoJ2ZlYXR1cmVzJykpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBsYXllci5zZXRXTVNTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShsYXllcik7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgbW9kdWxlLnNlcnZpY2UoJ3N0TGF5ZXJCdWlsZGVyJywgZnVuY3Rpb24oJHEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnVpbGRMYXllcjogZnVuY3Rpb24oZGF0YSwgbWFwKSB7XG4gICAgICAgIHZhciBsYXllciA9IG5ldyBTdG9yeUxheWVyKGRhdGEpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICBsYXllci5zZXRXTVNTb3VyY2UoKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShsYXllcik7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIG1vZHVsZS5zZXJ2aWNlKCdzdFN0b3J5TWFwQmFzZUJ1aWxkZXInLCBmdW5jdGlvbihzdEJhc2VMYXllckJ1aWxkZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVmYXVsdE1hcDogZnVuY3Rpb24oc3RvcnltYXApIHtcbiAgICAgICAgc3RvcnltYXAuZ2V0TWFwKCkuc2V0VmlldyhuZXcgb2wuVmlldyh7Y2VudGVyOiBbMCwwXSwgem9vbTogM30pKTtcbiAgICAgICAgdGhpcy5zZXRCYXNlTGF5ZXIoc3RvcnltYXAsIHtcbiAgICAgICAgICB0aXRsZTogJ1dvcmxkIFRvcG8gTWFwJyxcbiAgICAgICAgICB0eXBlOiAnRVNSSScsXG4gICAgICAgICAgbmFtZTogJ3dvcmxkLXRvcG8tbWFwJ1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzZXRCYXNlTGF5ZXI6IGZ1bmN0aW9uKHN0b3J5bWFwLCBkYXRhKSB7XG4gICAgICAgIHZhciBiYXNlTGF5ZXIgPSBzdEJhc2VMYXllckJ1aWxkZXIuYnVpbGRMYXllcihkYXRhKTtcbiAgICAgICAgc3RvcnltYXAuc2V0QmFzZUxheWVyKGJhc2VMYXllcik7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgbW9kdWxlLnNlcnZpY2UoJ3N0U3RvcnlNYXBCdWlsZGVyJywgZnVuY3Rpb24oc3RMYXllckJ1aWxkZXIsIHN0U3RvcnlNYXBCYXNlQnVpbGRlcikge1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZnlTdG9yeU1hcDogZnVuY3Rpb24oc3RvcnltYXAsIGRhdGEpIHtcbiAgICAgICAgc3RvcnltYXAuY2xlYXIoKTtcbiAgICAgICAgdmFyIG1hcENvbmZpZyA9IHN0b3J5dG9vbHMubWFwc3RvcnkuTWFwQ29uZmlnVHJhbnNmb3JtZXIuTWFwQ29uZmlnVHJhbnNmb3JtZXIoZGF0YSk7XG4gICAgICAgIGlmIChtYXBDb25maWcuaWQgPj0gMCkge1xuICAgICAgICAgIHN0b3J5bWFwLnNldCgnaWQnLCBtYXBDb25maWcuaWQpO1xuICAgICAgICAgIHN0b3J5bWFwLnNldE1vZGUobWFwQ29uZmlnLnBsYXliYWNrTW9kZSk7XG4gICAgICAgICAgaWYgKGRhdGEuYWJvdXQgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBzdG9yeW1hcC5zZXRTdG9yeVRpdGxlKGRhdGEuYWJvdXQudGl0bGUpO1xuICAgICAgICAgICAgc3RvcnltYXAuc2V0U3RvcnlBYnN0cmFjdChkYXRhLmFib3V0LmFic3RyYWN0KTtcbiAgICAgICAgICAgIHN0b3J5bWFwLnNldFN0b3J5T3duZXIoZGF0YS5hYm91dC5vd25lcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RvcnltYXAuc2V0Q2VudGVyKG1hcENvbmZpZy5tYXAuY2VudGVyKTtcbiAgICAgICAgICBzdG9yeW1hcC5zZXRab29tKG1hcENvbmZpZy5tYXAuem9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbWFwQ29uZmlnLm1hcC5sYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgIHZhciBsYXllckNvbmZpZyA9IG1hcENvbmZpZy5tYXAubGF5ZXJzW2ldO1xuICAgICAgICAgIGlmIChsYXllckNvbmZpZy5ncm91cCA9PT0gJ2JhY2tncm91bmQnICYmIGxheWVyQ29uZmlnLnZpc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0U3RvcnlNYXBCYXNlQnVpbGRlci5zZXRCYXNlTGF5ZXIoc3RvcnltYXAsIGxheWVyQ29uZmlnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cbiAgICAgICAgICAgIHN0TGF5ZXJCdWlsZGVyLmJ1aWxkTGF5ZXIobGF5ZXJDb25maWcsIHN0b3J5bWFwLmdldE1hcCgpKS50aGVuKGZ1bmN0aW9uKHNsKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gaW5zZXJ0IGF0IHRoZSBjb3JyZWN0IGluZGV4XG4gICAgICAgICAgICAgIHN0b3J5bWFwLmFkZFN0b3J5TGF5ZXIoc2wpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0b3J5bWFwLmdldE1hcCgpLnNldFZpZXcobmV3IG9sLlZpZXcoe1xuICAgICAgICAgIGNlbnRlcjogbWFwQ29uZmlnLm1hcC5jZW50ZXIsXG4gICAgICAgICAgem9vbTogbWFwQ29uZmlnLm1hcC56b29tLFxuICAgICAgICAgIG1pblpvb206IDMsXG4gICAgICAgICAgbWF4Wm9vbTogMTdcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIG1vZHVsZS5zZXJ2aWNlKCdzdEVkaXRhYmxlU3RvcnlNYXBCdWlsZGVyJywgZnVuY3Rpb24oc3RTdG9yeU1hcEJhc2VCdWlsZGVyLCBzdEVkaXRhYmxlTGF5ZXJCdWlsZGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmeVN0b3J5TGF5ZXI6IGZ1bmN0aW9uKHN0b3J5bGF5ZXIsIG5ld1R5cGUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBzdG9yeWxheWVyLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgdmFyIHN0b3J5bWFwID0gc3RvcnlsYXllci5nZXRTdG9yeU1hcCgpO1xuICAgICAgICBkYXRhLnR5cGUgPSBuZXdUeXBlID8gbmV3VHlwZSA6ICgoZGF0YS50eXBlID09PSAnV01TJykgPyAnVkVDVE9SJyA6ICdXTVMnKTtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ1dNUycpIHtcbiAgICAgICAgICBkZWxldGUgZGF0YS5mZWF0dXJlcztcbiAgICAgICAgfVxuICAgICAgICBzdEVkaXRhYmxlTGF5ZXJCdWlsZGVyLmJ1aWxkRWRpdGFibGVMYXllcihkYXRhLCBzdG9yeW1hcC5nZXRNYXAoKSkudGhlbihmdW5jdGlvbihzbCkge1xuICAgICAgICAgIC8vIHNlcXVlbmNlIGlzIGltcG9ydGFudCBoZXJlLCBmaXJzdCBjaGFuZ2UgbGF5ZXIsIHRoZW4gdGhlIHR5cGUuXG4gICAgICAgICAgc3RvcnlsYXllci5zZXRMYXllcihzbC5nZXRMYXllcigpKTtcbiAgICAgICAgICBzdG9yeWxheWVyLnNldCgndHlwZScsIHNsLmdldCgndHlwZScpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgbW9kaWZ5U3RvcnlNYXA6IGZ1bmN0aW9uKHN0b3J5bWFwLCBkYXRhKSB7XG4gICAgICAgIHN0b3J5bWFwLmNsZWFyKCk7XG4gICAgICAgIHZhciBtYXBDb25maWcgPSBzdG9yeXRvb2xzLm1hcHN0b3J5Lk1hcENvbmZpZ1RyYW5zZm9ybWVyLk1hcENvbmZpZ1RyYW5zZm9ybWVyKGRhdGEpO1xuICAgICAgICBpZiAobWFwQ29uZmlnLmlkID49IDApIHtcbiAgICAgICAgICBzdG9yeW1hcC5zZXQoJ2lkJywgbWFwQ29uZmlnLmlkKTtcbiAgICAgICAgICBzdG9yeW1hcC5zZXRNb2RlKG1hcENvbmZpZy5wbGF5YmFja01vZGUpO1xuICAgICAgICAgIGlmIChkYXRhLmFib3V0ICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgc3RvcnltYXAuc2V0U3RvcnlUaXRsZShkYXRhLmFib3V0LnRpdGxlKTtcbiAgICAgICAgICAgIHN0b3J5bWFwLnNldFN0b3J5QWJzdHJhY3QoZGF0YS5hYm91dC5hYnN0cmFjdCk7XG4gICAgICAgICAgICBzdG9yeW1hcC5zZXRTdG9yeU93bmVyKGRhdGEuYWJvdXQub3duZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBtYXBDb25maWcubWFwLmxheWVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgdmFyIGxheWVyQ29uZmlnID0gbWFwQ29uZmlnLm1hcC5sYXllcnNbaV07XG4gICAgICAgICAgaWYgKGxheWVyQ29uZmlnLmdyb3VwID09PSAnYmFja2dyb3VuZCcgJiYgbGF5ZXJDb25maWcudmlzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RTdG9yeU1hcEJhc2VCdWlsZGVyLnNldEJhc2VMYXllcihzdG9yeW1hcCwgbGF5ZXJDb25maWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKmpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICAgICAgc3RFZGl0YWJsZUxheWVyQnVpbGRlci5idWlsZEVkaXRhYmxlTGF5ZXIobGF5ZXJDb25maWcsIHN0b3J5bWFwLmdldE1hcCgpKS50aGVuKGZ1bmN0aW9uKHNsKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gaW5zZXJ0IGF0IHRoZSBjb3JyZWN0IGluZGV4XG4gICAgICAgICAgICAgIHN0b3J5bWFwLmFkZFN0b3J5TGF5ZXIoc2wpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0b3J5bWFwLmdldE1hcCgpLnNldFZpZXcobmV3IG9sLlZpZXcoe1xuICAgICAgICAgIGNlbnRlcjogbWFwQ29uZmlnLm1hcC5jZW50ZXIsXG4gICAgICAgICAgem9vbTogbWFwQ29uZmlnLm1hcC56b29tLFxuICAgICAgICAgIHByb2plY3Rpb246IG1hcENvbmZpZy5tYXAucHJvamVjdGlvbixcbiAgICAgICAgICBtaW5ab29tOiAzLFxuICAgICAgICAgIG1heFpvb206IDE3XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxufSkoKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbW9kdWxlID0gYW5ndWxhci5tb2R1bGUoJ3N0b3J5dG9vbHMuY29yZS5waW5zJywgW1xuICAgIF0pO1xuXG4gICAgdmFyIHBpbnMgPSBzdG9yeXRvb2xzLmNvcmUubWFwcy5waW5zO1xuXG4gICAgZnVuY3Rpb24gU3RvcnlQaW5MYXllck1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMuc3RvcnlQaW5zID0gW107XG4gICAgICAgIHRoaXMubWFwID0gbnVsbDtcbiAgICB9XG4gICAgU3RvcnlQaW5MYXllck1hbmFnZXIucHJvdG90eXBlLnBpbnNDaGFuZ2VkID0gZnVuY3Rpb24ocGlucywgYWN0aW9uKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpZiAoYWN0aW9uID09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwaW4gPSBwaW5zW2ldO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHRoaXMuc3RvcnlQaW5zLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcnlQaW5zW2pdLmlkID09IHBpbi5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yeVBpbnMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09ICdhZGQnKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcnlQaW5zLnB1c2gocGluc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09ICdjaGFuZ2UnKSB7XG4gICAgICAgICAgICAvLyBwcm92aWRlZCBlZGl0cyBjb3VsZCBiZSB1c2VkIHRvIG9wdGltaXplIGJlbG93XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FjdGlvbj8gOicgKyBhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0b2RvIG9wdGltaXplIGJ5IGxvb2tpbmcgYXQgY2hhbmdlc1xuICAgICAgICB2YXIgdGltZXMgPSB0aGlzLnN0b3J5UGlucy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgaWYgKHAuc3RhcnRfdGltZSA+IHAuZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Rvcnl0b29scy5jb3JlLnV0aWxzLmNyZWF0ZVJhbmdlKHAuZW5kX3RpbWUsIHAuc3RhcnRfdGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yeXRvb2xzLmNvcmUudXRpbHMuY3JlYXRlUmFuZ2UocC5zdGFydF90aW1lLCBwLmVuZF90aW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFwLnN0b3J5UGluc0xheWVyLnNldCgndGltZXMnLCB0aW1lcyk7XG4gICAgICAgIHRoaXMubWFwLnN0b3J5UGluc0xheWVyLnNldCgnZmVhdHVyZXMnLCB0aGlzLnN0b3J5UGlucyk7XG4gICAgfTtcbiAgICBTdG9yeVBpbkxheWVyTWFuYWdlci5wcm90b3R5cGUubG9hZEZyb21HZW9KU09OID0gZnVuY3Rpb24oZ2VvanNvbiwgcHJvamVjdGlvbiwgb3ZlcndyaXRlKSB7XG5cbiAgICAgICAgaWYgKG92ZXJ3cml0ZSl7XG4gICAgICAgICAgICB0aGlzLnN0b3J5UGlucyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdlb2pzb24gJiYgZ2VvanNvbi5mZWF0dXJlcykge1xuICAgICAgICAgICAgdmFyIGxvYWRlZCA9IHBpbnMubG9hZEZyb21HZW9KU09OKGdlb2pzb24sIHByb2plY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5waW5zQ2hhbmdlZChsb2FkZWQsICdhZGQnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuc2VydmljZSgnU3RvcnlQaW5MYXllck1hbmFnZXInLCBTdG9yeVBpbkxheWVyTWFuYWdlcik7XG5cbiAgICBtb2R1bGUuY29uc3RhbnQoJ1N0b3J5UGluJywgcGlucy5TdG9yeVBpbik7XG5cbiAgICAvLyBAdG9kbyBuYWl2ZSBpbXBsZW1lbnRhdGlvbiBvbiBsb2NhbCBzdG9yYWdlIGZvciBub3dcbiAgICBtb2R1bGUuc2VydmljZSgnc3RBbm5vdGF0aW9uc1N0b3JlJywgZnVuY3Rpb24oU3RvcnlQaW5MYXllck1hbmFnZXIpIHtcbiAgICAgICAgZnVuY3Rpb24gcGF0aChtYXBpZCkge1xuICAgICAgICAgICAgcmV0dXJuICcvbWFwcy8nICsgbWFwaWQgKyAnL2Fubm90YXRpb25zJztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXQobWFwaWQpIHtcbiAgICAgICAgICAgIHZhciBzYXZlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHBhdGgobWFwaWQpKTtcbiAgICAgICAgICAgIHNhdmVkID0gKHNhdmVkID09PSBudWxsKSA/IFtdIDogSlNPTi5wYXJzZShzYXZlZCk7XG4gICAgICAgICAgICAvLyBUT0RPIGlzIHRoaXMgc3RpbGwgbmVlZGVkP1xuICAgICAgICAgICAgLypzYXZlZC5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICBzLnRoZV9nZW9tID0gZm9ybWF0LnJlYWRHZW9tZXRyeShzLnRoZV9nZW9tKTtcbiAgICAgICAgICAgIH0pOyovXG4gICAgICAgICAgICByZXR1cm4gc2F2ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0KG1hcGlkLCBhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgLy8gVE9ETyBpcyB0aGlzIHN0aWxsIG5lZWRlZD9cbiAgICAgICAgICAgIC8qYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMudGhlX2dlb20gJiYgIWFuZ3VsYXIuaXNTdHJpbmcocy50aGVfZ2VvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcy50aGVfZ2VvbSA9IGZvcm1hdC53cml0ZUdlb21ldHJ5KHMudGhlX2dlb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pOyovXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShwYXRoKG1hcGlkKSxcbiAgICAgICAgICAgICAgICBuZXcgb2wuZm9ybWF0Lkdlb0pTT04oKS53cml0ZUZlYXR1cmVzKGFubm90YXRpb25zLFxuICAgICAgICAgICAgICAgICAgICB7ZGF0YVByb2plY3Rpb246ICdFUFNHOjQzMjYnLCBmZWF0dXJlUHJvamVjdGlvbjogJ0VQU0c6Mzg1Nyd9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9hZEFubm90YXRpb25zOiBmdW5jdGlvbihtYXBpZCwgcHJvamVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdG9yeVBpbkxheWVyTWFuYWdlci5sb2FkRnJvbUdlb0pTT04oZ2V0KG1hcGlkKSwgcHJvamVjdGlvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZXRlQW5ub3RhdGlvbnM6IGZ1bmN0aW9uKGFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhdmVkID0gZ2V0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHRvRGVsZXRlID0gYW5ub3RhdGlvbnMubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2F2ZWQgPSBzYXZlZC5maWx0ZXIoZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9EZWxldGUuaW5kZXhPZihzLmlkKSA8IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2V0KHNhdmVkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYXZlQW5ub3RhdGlvbnM6IGZ1bmN0aW9uKG1hcGlkLCBhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBzYXZlZCA9IGdldCgpO1xuICAgICAgICAgICAgICAgIHZhciBtYXhJZCA9IDA7XG4gICAgICAgICAgICAgICAgc2F2ZWQuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heElkID0gTWF0aC5tYXgobWF4SWQsIHMuaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhLmlkID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmlkID0gKyttYXhJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvbmUgPSBhLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLmdldCgnc3RhcnRfdGltZScpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lLnNldCgnc3RhcnRfdGltZScsIGEuZ2V0KCdzdGFydF90aW1lJykvMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGEuZ2V0KCdlbmRfdGltZScpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lLnNldCgnZW5kX3RpbWUnLCBhLmdldCgnZW5kX3RpbWUnKS8xMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbG9uZXMucHVzaChjbG9uZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2V0KG1hcGlkLCBjbG9uZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG59KSgpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5jb3JlLnN0eWxlLm9sM1N0eWxlQ29udmVydGVyJywgW10pO1xuXG4gICAgbW9kdWxlLmZhY3RvcnkoJ29sM01hcmtSZW5kZXJlcicsIGZ1bmN0aW9uKG9sM1N0eWxlQ29udmVydGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzaGFwZU5hbWUsIHNpemUpIHtcbiAgICAgICAgICAgIHZhciBibGFjayA9IG9sM1N0eWxlQ29udmVydGVyLmdldENvbG9yKCcjMDAwMDAwJyk7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSAzOyAvLyBoYWNrIHRvIGZpeCBkb3duLXNjYWxpbmcgZm9yIHggYW5kIGNyb3NzXG4gICAgICAgICAgICB2YXIgb3B0cyA9IHtjb2xvcjogYmxhY2ssIHdpZHRoOiBzdHJva2VXaWR0aH07XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gYW5ndWxhci5lbGVtZW50KG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU2hhcGUoe1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IHtzaGFwZTogc2hhcGVOYW1lLCBzaXplOiBzaXplIC0gc3Ryb2tlV2lkdGh9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuZXcgb2wuc3R5bGUuRmlsbChvcHRzKSxcbiAgICAgICAgICAgICAgICBuZXcgb2wuc3R5bGUuU3Ryb2tlKG9wdHMpKS5nZXRJbWFnZSgpKTtcbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZmFjdG9yeSgnb2wzU3R5bGVDb252ZXJ0ZXInLCBmdW5jdGlvbihzdFN2Z0ljb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdlbmVyYXRlU2hhcGVDb25maWc6IGZ1bmN0aW9uKHN0eWxlLCBmaWxsLCBzdHJva2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBzdHlsZS5zeW1ib2wuc2hhcGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmFsIHNpemUgaXMgYWN0dWFsbHkgKDIgKiAocmFkaXVzICsgc3Ryb2tlLndpZHRoKSkgKyAxXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IHN0eWxlLnN5bWJvbC5zaXplIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1c1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdzcXVhcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IDQsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlOiBNYXRoLlBJIC8gNFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICd0cmlhbmdsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGU6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAnc3RhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzMjogMC41KnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlOiAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2Nyb3NzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGU6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzMjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlOiBNYXRoLlBJIC8gNFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxjdWxhdGVSb3RhdGlvbjogZnVuY3Rpb24oc3R5bGUsIGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc3ltYm9sICYmIHN0eWxlLnN5bWJvbC5yb3RhdGlvbkF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc3ltYm9sLnJvdGF0aW9uVW5pdHMgPT09ICdyYWRpYW5zJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmUuZ2V0KHN0eWxlLnN5bWJvbC5yb3RhdGlvbkF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGZlYXR1cmUuZ2V0KHN0eWxlLnN5bWJvbC5yb3RhdGlvbkF0dHJpYnV0ZSkvMzYwKSpNYXRoLlBJO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVTaGFwZTogZnVuY3Rpb24oc3R5bGUsIGZpbGwsIHN0cm9rZSwgZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLmdlbmVyYXRlU2hhcGVDb25maWcoc3R5bGUsIGZpbGwsIHN0cm9rZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5yb3RhdGlvbiA9IHRoaXMuY2FsY3VsYXRlUm90YXRpb24oc3R5bGUsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc3ltYm9sLmdyYXBoaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBzdFN2Z0ljb24uZ2V0SW1hZ2Uoc3R5bGUuc3ltYm9sLmdyYXBoaWMsIGZpbGwuZ2V0Q29sb3IoKSwgc3Ryb2tlLmdldENvbG9yKCksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG9sLnN0eWxlLkljb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBpbmZvLmRhdGFVUkksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogdGhpcy5jYWxjdWxhdGVSb3RhdGlvbihzdHlsZSwgZmVhdHVyZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogc3R5bGUuc3ltYm9sLnNpemUgLyBNYXRoLm1heChpbmZvLndpZHRoLCBpbmZvLmhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBzdHlsZS5zeW1ib2wub3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLnN5bWJvbC5zaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBvbC5zdHlsZS5DaXJjbGUoY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG9sLnN0eWxlLlJlZ3VsYXJTaGFwZShjb25maWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRUZXh0OiBmdW5jdGlvbihzdHlsZSwgZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5sYWJlbCAmJiBzdHlsZS5sYWJlbC5hdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnICsgZmVhdHVyZS5nZXQoc3R5bGUubGFiZWwuYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZVRleHQ6IGZ1bmN0aW9uKHN0eWxlLCBzdHJva2UsIGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUubGFiZWwgJiYgc3R5bGUubGFiZWwuYXR0cmlidXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgb2wuc3R5bGUuVGV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBuZXcgb2wuc3R5bGUuRmlsbCh7Y29sb3I6IHN0eWxlLmxhYmVsLmZpbGxDb2xvcn0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250OiBzdHlsZS5sYWJlbC5mb250U3R5bGUgKyAnICcgKyBzdHlsZS5sYWJlbC5mb250V2VpZ2h0ICsgJyAnICsgc3R5bGUubGFiZWwuZm9udFNpemUgKyAncHggJyArIHN0eWxlLmxhYmVsLmZvbnRGYW1pbHksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmdldFRleHQoc3R5bGUsIGZlYXR1cmUpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRDb2xvcjogZnVuY3Rpb24oY29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmdiYSA9IG9sLmNvbG9yLmFzQXJyYXkoY29sb3IpO1xuICAgICAgICAgICAgICAgIGlmIChvcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmdiYSA9IHJnYmEuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmdiYVszXSA9IG9wYWNpdHkvMTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHJnYmEuam9pbignLCcpICsgJyknO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlQ2FjaGVLZXk6IGZ1bmN0aW9uKHN0eWxlLCBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFRleHQoc3R5bGUsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc2lmeSA9IChzdHlsZS5jbGFzc2lmeSAmJiBzdHlsZS5jbGFzc2lmeS5hdHRyaWJ1dGUpID8gZmVhdHVyZS5nZXQoc3R5bGUuY2xhc3NpZnkuYXR0cmlidXRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSAoc3R5bGUuc3ltYm9sICYmIHN0eWxlLnN5bWJvbC5yb3RhdGlvbkF0dHJpYnV0ZSkgPyBmZWF0dXJlLmdldChzdHlsZS5zeW1ib2wucm90YXRpb25BdHRyaWJ1dGUpOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQgKyAnfCcgKyBjbGFzc2lmeSArICd8JyArIHJvdGF0aW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlU3R5bGU6IGZ1bmN0aW9uKHN0eWxlLCBmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCwga2V5MjtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVDYWNoZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZUNhY2hlXyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkoc3R5bGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlQ2FjaGVfW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0eWxlQ2FjaGVfW2tleV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkyID0gdGhpcy5nZW5lcmF0ZUNhY2hlS2V5KHN0eWxlLCBmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlQ2FjaGVfW2tleV1ba2V5Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZUNhY2hlX1trZXldW2tleTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVDYWNoZV9ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3Ryb2tlO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVEYXNoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc3Ryb2tlLnN0cm9rZVN0eWxlID09PSAnZGFzaGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZURhc2ggPSBbNV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuc3Ryb2tlLnN0cm9rZVN0eWxlID09PSAnZG90dGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZURhc2ggPSBbMSwyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHJva2UgPSBuZXcgb2wuc3R5bGUuU3Ryb2tlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBsaW5lRGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmdldENvbG9yKHN0eWxlLnN0cm9rZS5zdHJva2VDb2xvciwgc3R5bGUuc3Ryb2tlLnN0cm9rZU9wYWNpdHkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHN0eWxlLnN0cm9rZS5zdHJva2VXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmNsYXNzaWZ5ICYmIHN0eWxlLmNsYXNzaWZ5LmF0dHJpYnV0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaWk9c3R5bGUucnVsZXMubGVuZ3RoOyBpPGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydWxlID0gc3R5bGUucnVsZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0clZhbCA9IGZlYXR1cmUuZ2V0KHN0eWxlLmNsYXNzaWZ5LmF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGF0dHJWYWwgPT09IHJ1bGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJ1bGUucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IChhdHRyVmFsID49IHJ1bGUucmFuZ2UubWluICYmIGF0dHJWYWwgPD0gcnVsZS5yYW5nZS5tYXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSB0aGlzLmdlbmVyYXRlVGV4dChzdHlsZSwgc3Ryb2tlLCBmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuZ2VvbVR5cGUgPT09ICdwb2ludCcgJiYgcnVsZS5zdHlsZS5zeW1ib2wuZmlsbENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtuZXcgb2wuc3R5bGUuU3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogdGhpcy5nZW5lcmF0ZVNoYXBlKHN0eWxlLCBuZXcgb2wuc3R5bGUuRmlsbCh7Y29sb3I6IHJ1bGUuc3R5bGUuc3ltYm9sLmZpbGxDb2xvcn0pLCBzdHJva2UsIGZlYXR1cmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmdlb21UeXBlID09PSAnbGluZScgJiYgcnVsZS5zdHlsZS5zdHJva2Uuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW25ldyBvbC5zdHlsZS5TdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogbmV3IG9sLnN0eWxlLlN0cm9rZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJ1bGUuc3R5bGUuc3Ryb2tlLnN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5nZW9tVHlwZSA9PT0gJ3BvbHlnb24nICYmIHJ1bGUuc3R5bGUuc3ltYm9sLmZpbGxDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbbmV3IG9sLnN0eWxlLlN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBuZXcgb2wuc3R5bGUuRmlsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJ1bGUuc3R5bGUuc3ltYm9sLmZpbGxDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVDYWNoZV9ba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVDYWNoZV9ba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5MiA9IHRoaXMuZ2VuZXJhdGVDYWNoZUtleShzdHlsZSwgZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlQ2FjaGVfW2tleV1ba2V5Ml0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsbCA9IG5ldyBvbC5zdHlsZS5GaWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmdldENvbG9yKHN0eWxlLnN5bWJvbC5maWxsQ29sb3IsIHN0eWxlLnN5bWJvbC5maWxsT3BhY2l0eSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBvbC5zdHlsZS5TdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHRoaXMuZ2VuZXJhdGVTaGFwZShzdHlsZSwgZmlsbCwgc3Ryb2tlLCBmZWF0dXJlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuZ2VuZXJhdGVUZXh0KHN0eWxlLCBzdHJva2UsIGZlYXR1cmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNUZXh0ID0gcmVzdWx0WzBdLmdldFRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1RleHQgfHwgKHN0eWxlLmNsYXNzaWZ5ICYmIHN0eWxlLmNsYXNzaWZ5LmF0dHJpYnV0ZSkgfHwgKHN0eWxlLnN5bWJvbCAmJiBzdHlsZS5zeW1ib2wucm90YXRpb25BdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVDYWNoZV9ba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVDYWNoZV9ba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5Mj0gdGhpcy5nZW5lcmF0ZUNhY2hlS2V5KHN0eWxlLCBmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVDYWNoZV9ba2V5XVtrZXkyXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVDYWNoZV9ba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufSkoKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbW9kdWxlID0gYW5ndWxhci5tb2R1bGUoJ3N0b3J5dG9vbHMuY29yZS5zdHlsZS5zdmdJY29uJywgW10pO1xuXG4gICAgbW9kdWxlLmZhY3RvcnkoJ3N0U3ZnSWNvbicsIGZ1bmN0aW9uKCRjYWNoZUZhY3RvcnksICRodHRwLCAkcSwgJGxvZykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgIHZhciBpbWFnZUNhY2hlID0gJGNhY2hlRmFjdG9yeSgnc3RTdmdJbWFnZScpO1xuICAgICAgICB2YXIgZGF0YUNhY2hlID0gJGNhY2hlRmFjdG9yeSgnc3RTdmdEYXRhJyk7XG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Moc3ZnLCBmaWxsLCBzdHJva2UpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuaHRtbChzdmcpO1xuICAgICAgICAgICAgLy8gQHRvZG8gbWFrZSBzbWFydGVyXG4gICAgICAgICAgICBbJ3BhdGgnLCAncG9seWdvbicsICdjaXJjbGUnLCAnZWxsaXBzZScsICdyZWN0JywgJ2xpbmUnLCAncG9seWxpbmUnXS5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGVsZW1lbnQuZmluZChlbCksIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRvZG8gZG9lcyBpdCBtYWtlIHNlbnNlIHRvIG92ZXJyaWRlIHN0cm9rZSB3aWR0aD9cbiAgICAgICAgICAgICAgICAgICAgZSA9IGFuZ3VsYXIuZWxlbWVudChlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRmlsbCA9IGUuY3NzKCdmaWxsJykgfHwgZS5hdHRyKCdmaWxsJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0ZpbGwgIT0gJ25vbmUnICYmIGV4aXN0aW5nRmlsbCAhPSAncmdiKDI1NSwgMjU1LCAyNTUpJyAmJiBleGlzdGluZ0ZpbGwudG9Mb3dlckNhc2UoKSAhPSAnI2ZmZmZmZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5maWxsID0gZmlsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdTdHJva2UgPSBlLmNzcygnc3Ryb2tlJykgfHwgZS5hdHRyKCdzdHJva2UnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3Ryb2tlICE9ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnN0cm9rZSA9IHN0cm9rZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlLmNzcyhjc3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVsZW1lbnQuZmluZCgnc3ZnJyk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBwYXJzZUludChyb290LmF0dHIoJ3dpZHRoJykpO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KHJvb3QuYXR0cignaGVpZ2h0JykpO1xuICAgICAgICAgICAgLy8gdWdoIC0gd2UncmUgdG90YWxseSBndWVzc2luZyBoZXJlIGJ1dCB0aGluZ3MgZ28gYmFkbHkgd2l0aG91dDpcbiAgICAgICAgICAgIC8vIG9uIGZpcmVmb3g6IG5zX2Vycm9yX25vdF9hdmFpbGFibGUgb24gY2FsbGluZyBjYW52YXMuZHJhd2ltYWdlXG4gICAgICAgICAgICAvLyBvbiBjaHJvbWU6IHZlcnkgbGFyZ2UgaWNvbiAoZGVmYXVsdCBzaXplIGFzIGl0IHJlbmRlcnMpXG4gICAgICAgICAgICAvLyB3ZSBtaWdodCBiZSBhYmxlIHRvIHNldCB0aGUgc3JjIG9uIGFuIGltZyBlbGVtZW50IGFuZCBmaWd1cmUgdGhpcyBvdXQuLi5cbiAgICAgICAgICAgIGlmIChpc05hTih3aWR0aCkgfHwgaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJvb3QuYXR0cignd2lkdGgnLCA2NCk7XG4gICAgICAgICAgICAgICAgcm9vdC5hdHRyKCdoZWlnaHQnLCA2NCk7XG4gICAgICAgICAgICAgICAgd2lkdGggPSA2NDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSA2NDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXRhVVJJID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJyArIGJ0b2EoZWxlbWVudC5odG1sKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhVVJJOiBkYXRhVVJJLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0SW1hZ2U6IGZ1bmN0aW9uKHN2Z1VSSSwgZmlsbCwgc3Ryb2tlLCBzeW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHN2Z1VSSSArIGZpbGwgKyBzdHJva2U7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZCA9IGltYWdlQ2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoY2FjaGVkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN2ZyA9IGRhdGFDYWNoZS5nZXQoc3ZnVVJJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VJbmZvID0gcHJvY2VzcyhzdmcsIGZpbGwsIHN0cm9rZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VJbmZvLnVyaSA9IHN2Z1VSSTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUNhY2hlLnB1dChrZXksIGltYWdlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlSW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICRsb2cud2FybmluZygnbm8gc3ZnIGZvcicsIHN2Z1VSSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEltYWdlRGF0YShzdmdVUkkpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZUluZm8gPSBwcm9jZXNzKHJlc3BvbnNlLmRhdGEsIGZpbGwsIHN0cm9rZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUluZm8udXJpID0gc3ZnVVJJO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VDYWNoZS5wdXQoa2V5LCBpbWFnZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShpbWFnZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEltYWdlRGF0YTogZnVuY3Rpb24oc3ZnVVJJKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRodHRwLmdldChzdmdVUkksIHtjYWNoZTogdHJ1ZX0pLnN1Y2Nlc3MoZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUNhY2hlLnB1dChzdmdVUkksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLndhcm4oJ2Vycm9yIGZldGNoaW5nICcgKyBzdmdVUkkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG59KSgpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5jb3JlLnRpbWUuc2VydmljZXMnLCBbXSk7XG5cbiAgICB2YXIgc3R1dGlscyA9IHN0b3J5dG9vbHMuY29yZS50aW1lLnV0aWxzO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSBhIHNvcnRlZCwgdW5pcXVlIGFycmF5IG9mIHRpY2tzIGZvciB0aGUgcHJvdmlkZWQgbGF5ZXJzLiBUaGVcbiAgICAgKiBhbGdvcml0aG0gdXNlcyBhbnkgcHJvdmlkZWQgaW5zdGFudCBvciBleHRlbnQoc3RhcnQgdmFsdWUgdXNlZCkgbGlzdCB2YWx1ZXNcbiAgICAgKiBhbmQgbG9va3MgYXQgdGhlIHRvdGFsIHJhbmdlIG9mIGFsbCBpbnRlcnZhbCB2YWx1ZXMgY3JlYXRpbmcgYSB0aWNrIGF0IHRoZVxuICAgICAqIG1pbmltdW0gaW50ZXJ2YWwgZm9yIHRoZSB0b3RhbCByYW5nZS4gU2VlIHRoZSB0ZXN0cyBmb3IgZXhhbXBsZXMuXG4gICAgICogQHBhcmFtIHthcnJheXxvbC5NYXB9IGxheWVyc1dpdGhUaW1lXG4gICAgICogQHJldHVybnMgYXJyYXkgb2YgdGlja3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wdXRlVGlja3MobGF5ZXJzV2l0aFRpbWUpIHtcbiAgICAgICAgLy8gYWxsb3cgYSBtYXAgdG8gYmUgcGFzc2VkIGluXG4gICAgICAgIGlmICghYW5ndWxhci5pc0FycmF5KGxheWVyc1dpdGhUaW1lKSkge1xuICAgICAgICAgICAgdmFyIHN0b3J5TWFwID0gbGF5ZXJzV2l0aFRpbWU7XG4gICAgICAgICAgICBsYXllcnNXaXRoVGltZSA9IHN0b3J5TWFwLmdldFN0b3J5TGF5ZXJzKCkuZ2V0QXJyYXkoKS5maWx0ZXIoZnVuY3Rpb24obCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lcyA9IGwuZ2V0KCd0aW1lcycpO1xuICAgICAgICAgICAgICAgIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVzICE9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxheWVyc1dpdGhUaW1lLnB1c2goc3RvcnlNYXAuc3RvcnlQaW5zTGF5ZXIpO1xuICAgICAgICAgICAgbGF5ZXJzV2l0aFRpbWUucHVzaChzdG9yeU1hcC5zdG9yeUJveGVzTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aWNrcyA9IHt9O1xuICAgICAgICB2YXIgdG90YWxSYW5nZSA9IG51bGw7XG4gICAgICAgIHZhciBpbnRlcnZhbHMgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkVGljayhhZGQpIHtcbiAgICAgICAgICAgIGFkZCA9IHN0dXRpbHMuZ2V0VGltZShhZGQpO1xuICAgICAgICAgICAgaWYgKGFkZCAhPT0gbnVsbCAmJiAhIChhZGQgaW4gdGlja3MpKSB7XG4gICAgICAgICAgICAgICAgdGlja3NbYWRkXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXJzV2l0aFRpbWUuZm9yRWFjaChmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICB2YXIgdGltZXMgPSBsLmdldCgndGltZXMnKTtcbiAgICAgICAgICAgIHZhciByYW5nZTtcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzQXJyYXkodGltZXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gYW4gYXJyYXkgb2YgaW5zdGFudHMgb3IgZXh0ZW50c1xuICAgICAgICAgICAgICAgIHJhbmdlID0gc3R1dGlscy5jb21wdXRlUmFuZ2UodGltZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0dXRpbHMuaXNSYW5nZUxpa2UodGltZXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRUaWNrKHIuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbFJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUmFuZ2UgPSBzdHV0aWxzLmNyZWF0ZVJhbmdlKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUmFuZ2UuZXh0ZW5kKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXMuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVGljayhyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFkZCBhIHRpY2sgYXQgdGhlIGVuZCB0byBlbnN1cmUgd2UgZ2V0IHRoZXJlXG4gICAgICAgICAgICAgICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVGljayhyYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBhIGludGVydmFsIChyYW5nZStkdXJhdGlvbilcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRpbWVzO1xuICAgICAgICAgICAgICAgIGludGVydmFscy5wdXNoKHRpbWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3RhbFJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gY29weSwgd2lsbCBiZSBtb2RpZnlpbmdcbiAgICAgICAgICAgICAgICB0b3RhbFJhbmdlID0gc3R1dGlscy5jcmVhdGVSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvdGFsUmFuZ2UuZXh0ZW5kKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpbnRlcnZhbHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW50ZXJ2YWwgLSBiLmludGVydmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgc21hbGxlc3QgPSBpbnRlcnZhbHNbMF07XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0b3RhbFJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0IDw9IHRvdGFsUmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICAgICAgYWRkVGljayhzdGFydCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzbWFsbGVzdC5vZmZzZXQoc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRpY2tzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGlja3MpLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGlja3Muc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFRpbWVDb250cm9sc01hbmFnZXIoJGxvZywgJHJvb3RTY29wZSwgU3RvcnlQaW5MYXllck1hbmFnZXIsIE1hcE1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy50aW1lQ29udHJvbHMgPSBudWxsO1xuICAgICAgICB2YXIgdGltZUNvbnRyb2xzTWFuYWdlciA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVDcmVhdGVUaW1lQ29udHJvbHModXBkYXRlKSB7XG4gICAgICAgICAgICAkbG9nLmRlYnVnKFwiQ3JlYXRpbmcgVGltZUNvbnRyb2xzIHdpdGggYm94ZXM6IFwiKTtcbiAgICAgICAgICAgLy8gJGxvZy5kZWJ1ZyhTdG9yeUJveExheWVyTWFuYWdlci5zdG9yeUJveGVzKTtcbiAgICAgICAgICAgIGlmICh0aW1lQ29udHJvbHNNYW5hZ2VyLnRpbWVDb250cm9scyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lQ29udHJvbHNNYW5hZ2VyLnRpbWVDb250cm9scy51cGRhdGUodmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBjb21wdXRlVGlja3MoTWFwTWFuYWdlci5zdG9yeU1hcCk7XG4gICAgICAgICAgICBpZiAocmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25zID0gU3RvcnlQaW5MYXllck1hbmFnZXIuc3RvcnlQaW5zO1xuICAgICAgICAgICAgICAgIHRpbWVDb250cm9sc01hbmFnZXIudGltZUNvbnRyb2xzID0gc3Rvcnl0b29scy5jb3JlLnRpbWUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGFubm90YXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBzdG9yeU1hcDogTWFwTWFuYWdlci5zdG9yeU1hcCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcnlMYXllcnM6IE1hcE1hbmFnZXIuc3RvcnlNYXAuZ2V0U3RvcnlMYXllcnMoKS5nZXRBcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiByYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogTWFwTWFuYWdlci5zdG9yeU1hcC5tb2RlLFxuICAgICAgICAgICAgICAgICAgICB0aWxlU3RhdHVzQ2FsbGJhY2s6IGZ1bmN0aW9uKHJlbWFpbmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCd0aWxlc0xvYWRlZCcsIHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNoYXB0ZXJDb3VudDogTWFwTWFuYWdlci5jaGFwdGVyQ291bnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aW1lQ29udHJvbHNNYW5hZ2VyLnRpbWVDb250cm9scy5vbigncmFuZ2VDaGFuZ2UnLCBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lQ29udHJvbHNNYW5hZ2VyLmN1cnJlbnRSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGluc1RvQ2hlY2sgPSBTdG9yeVBpbkxheWVyTWFuYWdlci5zdG9yeVBpbnMuZmlsdGVyKGZ1bmN0aW9uIChwaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwaW4uZ2V0KCdhdXRvX3Nob3cnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaVBpbiA9IDA7IGlQaW4gPCBwaW5zVG9DaGVjay5sZW5ndGg7IGlQaW4gKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpbiA9IHBpbnNUb0NoZWNrW2lQaW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpblJhbmdlID0gc3R1dGlscy5jcmVhdGVSYW5nZShwaW4uc3RhcnRfdGltZSwgcGluLmVuZF90aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaW5SYW5nZS5pbnRlcnNlY3RzKHJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdy1waW4nLCBwaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBNYXBNYW5hZ2VyLnN0b3J5TWFwLmdldFN0b3J5TGF5ZXJzKCkub24oJ2NoYW5nZTpsZW5ndGgnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1heWJlQ3JlYXRlVGltZUNvbnRyb2xzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGNvbXB1dGVUaWNrcyhNYXBNYW5hZ2VyLnN0b3J5TWFwKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yeUxheWVyczogTWFwTWFuYWdlci5zdG9yeU1hcC5nZXRTdG9yeUxheWVycygpLmdldEFycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByYW5nZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBpbnNMYXllciA9IE1hcE1hbmFnZXIuc3RvcnlNYXAuc3RvcnlQaW5zTGF5ZXI7XG4gICAgICAgIHZhciBib3hlc0xheWVyID0gTWFwTWFuYWdlci5zdG9yeU1hcC5zdG9yeUJveGVzTGF5ZXI7XG4gICAgICAgIHBpbnNMYXllci5vbignY2hhbmdlOmZlYXR1cmVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtYXliZUNyZWF0ZVRpbWVDb250cm9scyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBjb21wdXRlVGlja3MoTWFwTWFuYWdlci5zdG9yeU1hcCk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcnlMYXllcnM6IE1hcE1hbmFnZXIuc3RvcnlNYXAuZ2V0U3RvcnlMYXllcnMoKS5nZXRBcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHBpbnNMYXllci5nZXQoXCJmZWF0dXJlc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveGVzOiBib3hlc0xheWVyLmdldChcImZlYXR1cmVzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYm94ZXNMYXllci5vbignY2hhbmdlOmZlYXR1cmVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtYXliZUNyZWF0ZVRpbWVDb250cm9scyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBjb21wdXRlVGlja3MoTWFwTWFuYWdlci5zdG9yeU1hcCk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHBpbnNMYXllci5nZXQoXCJmZWF0dXJlc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94ZXM6IGJveGVzTGF5ZXIuZ2V0KFwiZmVhdHVyZXNcIilcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWF5YmVDcmVhdGVUaW1lQ29udHJvbHMoKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuY29uc3RhbnQoJ1RpbWVDb250cm9sc01hbmFnZXInLCBUaW1lQ29udHJvbHNNYW5hZ2VyKTtcblxuICAgIG1vZHVsZS5zZXJ2aWNlKCdUaW1lTWFjaGluZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcHV0ZVRpY2tzOiBjb21wdXRlVGlja3NcbiAgICAgICAgfTtcbiAgICB9KTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnN0eWxlLmRpcmVjdGl2ZXMnLCBbXSk7XG5cbiAgICBmdW5jdGlvbiBlZGl0b3JEaXJlY3RpdmUobmFtZSwgdGVtcGxhdGVVcmwsIHByb3BlcnR5LCBsaW5rZXIpIHtcbiAgICAgICAgbW9kdWxlLmRpcmVjdGl2ZShuYW1lLCBbJ3N0U3R5bGVDaG9pY2VzJywgZnVuY3Rpb24oc3R5bGVDaG9pY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RNb2RlbDogXCI9XCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcIkBcIixcbiAgICAgICAgICAgICAgICAgICAgcG9wb3ZlcjogXCJAcG9wb3ZlclRleHRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3R5bGUvd2lkZ2V0cy8nICsgdGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvIGJsZWNrIC0gZ3JhYmJpbmcgdGhlIGxheWVyIGZyb20gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmcgbW9yZSBleHBsaWNpdFxuICAgICAgICAgICAgICAgICAgICBzY29wZS5sYXllciA9IHNjb3BlLiRwYXJlbnQubGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS4kcGFyZW50LmxheWVyO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihuZXUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmxheWVyID0gbmV1O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kYmxlY2tcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUubW9kZWwgPSBzY29wZS5zdE1vZGVsW3Byb3BlcnR5IHx8IHNjb3BlLnByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3R5bGVDaG9pY2VzID0gc3R5bGVDaG9pY2VzO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlua2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rZXIoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1dKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdzdHlsZUVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3R5bGUvc3R5bGUtZWRpdG9yLmh0bWwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogJ3N0eWxlRWRpdG9yQ29udHJvbGxlcicsXG4gICAgICAgICAgICByZXF1aXJlOiAnP3N0eWxlRWRpdG9yQ29udHJvbGxlcicsXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIGxheWVyIDogJz0nLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlIDogJz0nLFxuICAgICAgICAgICAgICAgIGZvcm1DaGFuZ2VkIDogJz0nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdhdHRyaWJ1dGVDb21ibycsIGZ1bmN0aW9uKCRsb2cpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0eWxlL3dpZGdldHMvYXR0cmlidXRlLWNvbWJvLmh0bWwnLFxuICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICBsYXllcjogJz0nLFxuICAgICAgICAgICAgICAgIG1vZGVsOiBcIj1zdE1vZGVsXCIsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IFwiPT9cIixcbiAgICAgICAgICAgICAgICBjc3M6IFwiQGNzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGVzKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUubGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmxheWVyLmdldCgnYXR0cmlidXRlcycpLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmNsdWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMuZmlsdGVyID09PSAnbm9nZW9tJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlID0gYS50eXBlTlMgIT09ICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRycy5maWx0ZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBhLnR5cGUgPT09ICdpbnRlZ2VyJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS50eXBlID09PSAnZG91YmxlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS50eXBlID09PSAnbG9uZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRycy5maWx0ZXIgPT09ICd1bmlxdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBhLnR5cGUgPT09ICdpbnRlZ2VyJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS50eXBlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS50eXBlID09PSAnbG9uZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRycy5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy53YXJuKCd1bmtub3duIGZpbHRlcicsIGF0dHJzLmZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5pbmNsdWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBhdHRycy5pbmNsdWRlLmluZGV4T2YoYS50eXBlKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRzLnB1c2goYS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHMuc29ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuYXR0cmlidXRlcyA9IGF0dHM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5hdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQHRvZG8gaXMgd2F0Y2ggYWN0dWFsbHkgbmVlZGVkIGhlcmUgKHBvc3NpYmx5IHRoZSBjYXNlIGlmIHJldXNpbmcgdGhlIGVkaXRvcilcbiAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goJ2xheWVyJywgZnVuY3Rpb24obmV1LCBvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ldSAhPSBvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWFkQXR0cmlidXRlcygpO1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgcHJvcGVydHkgdG8gbW9kaWZ5XG4gICAgICAgICAgICAgICAgc2NvcGUucHJvcGVydHkgPSBhdHRycy5wcm9wZXJ0eSB8fCAnYXR0cmlidXRlJztcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGNoYW5nZSB0aGUgbW9kZWxcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm9uQ2hhbmdlID0gZnVuY3Rpb24ocHJvcGVydHksIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUubW9kZWxbcHJvcGVydHldID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGVkaXRvckRpcmVjdGl2ZSgnc3ltYm9sRWRpdG9yJywgJ3N5bWJvbC1lZGl0b3IuaHRtbCcsICdzeW1ib2wnLCBmdW5jdGlvbihzY29wZSwgZWwsIGF0dHJzKSB7XG4gICAgICAgIFsnc2hvd0dyYXBoaWMnLCAnc2hvd1JvdGF0aW9uJywgJ2hpZGVDb2xvciddLmZvckVhY2goZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgICAgICBzY29wZVtvcHRdID0gYXR0cnNbb3B0XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNjb3BlLmdldFN5bWJvbGl6ZXJUZXh0ID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC5zaGFwZSB8fCBtb2RlbC5ncmFwaGljO1xuICAgICAgICB9O1xuICAgICAgICBzY29wZS5nZXRTeW1ib2xpemVySW1hZ2UgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgZWRpdG9yRGlyZWN0aXZlKCdzdHJva2VFZGl0b3InLCAnc3Ryb2tlLWVkaXRvci5odG1sJywgJ3N0cm9rZScpO1xuICAgIGVkaXRvckRpcmVjdGl2ZSgnbnVtYmVyRWRpdG9yJywgJ251bWJlci1lZGl0b3IuaHRtbCcsIG51bGwsIGZ1bmN0aW9uKHNjb3BlLCBlbCwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgbWF4OiAzMCxcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIHN0ZXA6IDFcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgc2NvcGVbZV0gPSBhdHRyc1tlXSB8fCBkZWZhdWx0c1tlXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHdoZWVsKGV2KSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBlbC5maW5kKCdpbnB1dCcpO1xuICAgICAgICAgICAgdmFyIG1pbiA9IE51bWJlcihpbnB1dC5hdHRyKCdtaW4nKSkgfHwgMDtcbiAgICAgICAgICAgIHZhciBtYXggPSBOdW1iZXIoaW5wdXQuYXR0cignbWF4JykpO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBOdW1iZXIoaW5wdXQuYXR0cignc3RlcCcpKSB8fCAxO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHNjb3BlLnN0TW9kZWxbc2NvcGUucHJvcGVydHldO1xuICAgICAgICAgICAgdmFyIHNjcm9sbCA9IGV2LmRldGFpbCB8fCBldi53aGVlbERlbHRhO1xuICAgICAgICAgICAgdmFsID0gTWF0aC5taW4obWF4LCB2YWwgKyAoc2Nyb2xsID4gMCA/IC1zdGVwOiBzdGVwKSk7XG4gICAgICAgICAgICB2YWwgPSBNYXRoLm1heChtaW4sIHZhbCk7XG4gICAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuc3RNb2RlbFtzY29wZS5wcm9wZXJ0eV0gPSB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbFswXS5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHdoZWVsLCBmYWxzZSApOyAvLyBGb3IgRkYgYW5kIE9wZXJhXG4gICAgICAgIGVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB3aGVlbCwgZmFsc2UgKTsgLy8gRm9yIG90aGVyc1xuICAgIH0pO1xuICAgIGVkaXRvckRpcmVjdGl2ZSgnY29sb3JFZGl0b3InLCAnY29sb3ItZWRpdG9yLmh0bWwnKTtcbiAgICBlZGl0b3JEaXJlY3RpdmUoJ2xhYmVsRWRpdG9yJywgJ2xhYmVsLWVkaXRvci5odG1sJywgJ2xhYmVsJywgZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgLy8gQHRvZG8gb3RoZXIgb3B0aW9uc1xuICAgICAgICBzY29wZS5zdHlsZU1vZGVsID0ge1xuICAgICAgICAgICAgYm9sZCA6IHNjb3BlLm1vZGVsLmZvbnRXZWlnaHQgPT0gJ2JvbGQnLFxuICAgICAgICAgICAgaXRhbGljIDogc2NvcGUubW9kZWwuZm9udFN0eWxlID09ICdpdGFsaWMnXG4gICAgICAgIH07XG4gICAgICAgIHNjb3BlLnN0eWxlTW9kZWxDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNjb3BlLm1vZGVsLmZvbnRXZWlnaHQgPSBzY29wZS5zdHlsZU1vZGVsLmJvbGQgPyAnYm9sZCcgOiAnbm9ybWFsJztcbiAgICAgICAgICAgIHNjb3BlLm1vZGVsLmZvbnRTdHlsZSA9IHNjb3BlLnN0eWxlTW9kZWwuaXRhbGljID8gJ2l0YWxpYycgOiAnbm9ybWFsJztcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEB0b2RvIGJyZWFrIGludG8gcGllY2VzIG9yIG1ha2Ugc2ltcGxlclxuICAgIC8vIEB0b2RvIGRvZXNuJ3Qgd2F0Y2ggaWNvbkNvbW1vbnMuZGVmYXVsdHMoKSAtIGNhbiBiZWNvbWUgb3V0IG9mIGRhdGVcbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdncmFwaGljRWRpdG9yJywgZnVuY3Rpb24oc3RTdHlsZUNob2ljZXMsIG9sM01hcmtSZW5kZXJlciwgaWNvbkNvbW1vbnMsIGljb25Db21tb25zU2VhcmNoLCBzdFN2Z0ljb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0eWxlL3dpZGdldHMvZ3JhcGhpYy1lZGl0b3IuaHRtbCcsXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIHN5bWJvbDogJz0nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYW52YXMoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGFuZ3VsYXIuZWxlbWVudChvbDNNYXJrUmVuZGVyZXIoc3ltYm9sLCAyNCkpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRDbGFzcygnc3ltYm9sLWljb24nKTtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0cignbWFyaycsIHN5bWJvbCk7IC8vIGZvciB0ZXN0aW5nIHVudGlsIHdlIHVzZSBkYXRhIFVSSVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGltYWdlKGljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gYW5ndWxhci5lbGVtZW50KCc8aW1nPicpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hdHRyKCdzcmMnLCBpY29uLmRhdGFVUkkpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRDbGFzcygnc3ltYm9sLWljb24nKTtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0cignZ3JhcGhpYycsIGljb24udXJpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGVsZW1lbnQgd2l0aCB0aGUgZGF0YS1jdXJyZW50LXN5bWJvbCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAvLyB0byBtYXRjaCB0aGUgY3VycmVudCBzeW1ib2xcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjdXJyZW50KCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBhbmd1bGFyLmVsZW1lbnQoZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jdXJyZW50LXN5bWJvbF0nKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsLmZpbmQoJyonKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLnN5bWJvbC5zaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kKGNhbnZhcyhzY29wZS5zeW1ib2wuc2hhcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY29wZS5zeW1ib2wuZ3JhcGhpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RTdmdJY29uLmdldEltYWdlKHNjb3BlLnN5bWJvbC5ncmFwaGljLCAnIzAwMCcsICcjZmZmJykudGhlbihmdW5jdGlvbihpY29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kKGltYWdlKGljb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjbGlja2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGFuZ3VsYXIuZWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmF0dHIoJ3NoYXBlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnN5bWJvbC5zaGFwZSA9IGVsLmF0dHIoJ3NoYXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5zeW1ib2wuZ3JhcGhpYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwuYXR0cignZ3JhcGhpYycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5zeW1ib2wuc2hhcGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3ltYm9sLmdyYXBoaWMgPSBlbC5hdHRyKCdncmFwaGljJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBtaWdodCBiZSBkb25lIGFub3RoZXIgd2F5IGJ1dCBiZWNhdXNlIHdlIGdldCBjYW52YXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAvLyBiYWNrIGZyb20gb2wzIHN0eWxlcywgd2UgYnVpbGQgdGhlIGRvbSBtYW51YWxseVxuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gYW5ndWxhci5lbGVtZW50KGVsZW1lbnRbMF0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnb2wtbWFya3MnKSk7XG4gICAgICAgICAgICAgICAgc3RTdHlsZUNob2ljZXMuc3ltYm9saXplcnMuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBjYW52YXMocyk7XG4gICAgICAgICAgICAgICAgICAgIGltZy5hdHRyKCdzaGFwZScsIHMpO1xuICAgICAgICAgICAgICAgICAgICBpbWcub24oJ2NsaWNrJywgY2xpY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuYXBwZW5kKGltZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlUmVjZW50KCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ID0gYW5ndWxhci5lbGVtZW50KGVsZW1lbnRbMF0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmVjZW50LWljb25zJykpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lmh0bWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBpY29uQ29tbW9ucy5kZWZhdWx0cygpLnRoZW4oZnVuY3Rpb24oaWNvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25zLmZvckVhY2goZnVuY3Rpb24oaWNvbiwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBpbWFnZShpY29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcub24oJ2NsaWNrJywgY2xpY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5hcHBlbmQoaW1nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVseWluZyBvbiB0aGlzIGluIHRoZSB0ZXN0cyBhcyBhIG1lYW5zIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrbm93aW5nIHdoZW4gdGhlIHJlY2VudCBpY29ucyBsb2FkaW5nIGhhcyBjb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnJlY2VudCA9IGljb25zO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25seSBpbiBzY29wZSBmb3IgdHJpZ2dlcmluZyBpbiB0ZXN0c1xuICAgICAgICAgICAgICAgIHNjb3BlLl91cGRhdGVSZWNlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVjZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjb3BlLl91cGRhdGVSZWNlbnQoKTtcbiAgICAgICAgICAgICAgICBzY29wZS5zaG93SWNvbkNvbW1vbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNvbW1vbnNTZWFyY2guc2VhcmNoKCkudGhlbihmdW5jdGlvbihzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugb2wzIHN0eWxlIGNyZWF0aW9uIGlzIHN5bmMsIHByZWxvYWQgaWNvbiBiZWZvcmUgc2V0dGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RTdmdJY29uLmdldEltYWdlRGF0YShzZWxlY3RlZC5ocmVmKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnN5bWJvbC5zaGFwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3ltYm9sLmdyYXBoaWMgPSBzZWxlY3RlZC5ocmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLl91cGRhdGVSZWNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgbW9kdWxlLmRpcmVjdGl2ZSgnY2xhc3NpZnlFZGl0b3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0eWxlL3dpZGdldHMvY2xhc3NpZnktZWRpdG9yLmh0bWwnLFxuICAgICAgICAgICAgc2NvcGU6IHRydWUsXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBbJ3Nob3dNZXRob2QnLCdzaG93TWF4Q2xhc3NlcycsICdzaG93UmFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAnc2hvd0NvbG9yUmFtcCcsJ3Nob3dDb2xvclBhbGV0dGUnLCAnYXR0cmlidXRlRmlsdGVyJ10uZm9yRWFjaChmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVbb3B0XSA9IGF0dHJzW29wdF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdjb2xvclJhbXAnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIHJhbXA6IFwiPXJhbXBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGVsZW1lbnRbMF0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIGF0dHJzLndpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc2NvcGUucmFtcCkuZm9yRWFjaChmdW5jdGlvbihzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gcGFyc2VGbG9hdChzdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oc3RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgc2NvcGUucmFtcFtzdG9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBhdHRycy53aWR0aCwgYXR0cnMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCdyYW1wJywgcmVuZGVyKTtcbiAgICAgICAgICAgICAgICByZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIG1vZHVsZS5kaXJlY3RpdmUoJ2NvbG9yRmllbGQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlZ2V4ID0gLyheI1swLTlhLWZdezZ9JCl8KF4jWzAtOWEtZl17M30kKS9pO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZENvbG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBAdG9kbyBzdXBwb3J0IG5hbWVkIGNvbG9ycz9cbiAgICAgICAgICAgIHJldHVybiByZWdleC5leGVjKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybCkge1xuICAgICAgICAgICAgICAgIGN0cmwuJHBhcnNlcnMucHVzaChmdW5jdGlvbih2aWV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ2NvbG9yJywgdmFsaWRDb2xvcih2aWV3VmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24obW9kZWxWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGxvYWRlZCBidXQgYWxzbyBwb3NzaWJsZSB0aGUgcGlja2VyIHdpZGdldCBtb2RpZmllc1xuICAgICAgICAgICAgICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnY29sb3InLCB2YWxpZENvbG9yKG1vZGVsVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsVmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdub0Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgJGVsZW1lbnQub24oJ2NsaWNrJywgZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIG1vZHVsZS5kaXJlY3RpdmUoJ3N0eWxlVHlwZUVkaXRvcicsIGZ1bmN0aW9uKCRjb21waWxlLCAkdGVtcGxhdGVDYWNoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6IFwiRVwiLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCdjdXJyZW50RWRpdG9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RWRpdG9yID0gc2NvcGUuY3VycmVudEVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmN1cnJlbnRFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVVybCA9ICdzdHlsZS90eXBlcy8nICsgY3VycmVudEVkaXRvci5uYW1lLnJlcGxhY2UoJyAnLCAnLScpICsgXCIuaHRtbFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5odG1sKCR0ZW1wbGF0ZUNhY2hlLmdldCh0ZW1wbGF0ZVVybCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGNvbXBpbGUoZWxlbWVudC5jb250ZW50cygpKShzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmh0bWwoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdydWxlc0VkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3R5bGUvcnVsZXMtZWRpdG9yLmh0bWwnLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuZGVsZXRlUnVsZSA9IGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuYWN0aXZlU3R5bGUucnVsZXMgPSBzY29wZS5hY3RpdmVTdHlsZS5ydWxlcy5maWx0ZXIoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgIT09IHJ1bGU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnN0eWxlLmljb25Db21tb25zJywgW10pO1xuXG4gICAgbW9kdWxlLmZhY3RvcnkoJ2ljb25Db21tb25zJywgZnVuY3Rpb24oJHEsIHN0U3ZnSWNvbiwgc3RSZWNlbnRDaG9pY2VzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZhdWx0czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChzdFJlY2VudENob2ljZXMuaWNvbnMucmVjZW50Lm1hcChmdW5jdGlvbih1cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0U3ZnSWNvbi5nZXRJbWFnZSh1cmkpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIG1vZHVsZS5mYWN0b3J5KCdpY29uQ29tbW9uc1NlYXJjaCcsIGZ1bmN0aW9uKCRodHRwLCAkbW9kYWwsICRpbmplY3Rvcikge1xuICAgICAgICB2YXIgaWNvbkNvbW1vbnNIb3N0ID0gJGluamVjdG9yLmhhcygnaWNvbkNvbW1vbnNIb3N0JykgP1xuICAgICAgICAgICAgJGluamVjdG9yLmdldCgnaWNvbkNvbW1vbnNIb3N0JykgOiAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJztcbiAgICAgICAgZnVuY3Rpb24gZml4SHJlZnMoc3R1ZmYpIHtcbiAgICAgICAgICAgIHZhciB0b0ZpeCA9IHN0dWZmLmljb25zIHx8IHN0dWZmO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdG9GaXgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRvRml4W2ldLmhyZWYgPSBpY29uQ29tbW9uc0hvc3QgKyB0b0ZpeFtpXS5ocmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0dWZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWdFbmRwb2ludDogaWNvbkNvbW1vbnNIb3N0ICsgJy9pY29ucy9pY29uJyxcbiAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RhbCA9ICRtb2RhbC5vcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogJ2xnJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ2ljb25Db21tb25zQ29udHJvbGxlcicsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3R5bGUvd2lkZ2V0cy9pY29uLWNvbW1vbnMtc2VhcmNoLmh0bWwnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kYWwgPyB0aGlzLm1vZGFsLnJlc3VsdCA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q29sbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQoaWNvbkNvbW1vbnNIb3N0ICsgJy9pY29ucy9jb2xsZWN0aW9ucycpLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZml4SHJlZnMoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0TW9yZTogZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBocmVmID0gY29sbGVjdGlvbi5ocmVmO1xuICAgICAgICAgICAgICAgIGlmIChocmVmLmluZGV4T2YoaWNvbkNvbW1vbnNIb3N0KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gaWNvbkNvbW1vbnNIb3N0ICsgaHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRodHRwLmdldChocmVmLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogY29sbGVjdGlvbi5fbmV4dFBhZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZml4SHJlZnMoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q29sbGVjdGlvbkljb25zOiBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uLl9uZXh0UGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMucGFnZSA9IGNvbGxlY3Rpb24uX25leHRQYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KGljb25Db21tb25zSG9zdCArIGNvbGxlY3Rpb24uaHJlZiwge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICAgICAgICAgIH0pLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZml4SHJlZnMoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnlUYWc6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQodGhpcy50YWdFbmRwb2ludCwge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogdGFnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5zdWNjZXNzKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpeEhyZWZzKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFRhZ3M6IGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KGljb25Db21tb25zSG9zdCArICcvaWNvbnMvc2VhcmNoL3RhZ3MnLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEudGFncztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIG1vZHVsZS5jb250cm9sbGVyKCdpY29uQ29tbW9uc0NvbnRyb2xsZXInLCBmdW5jdGlvbigkc2NvcGUsIGljb25Db21tb25zU2VhcmNoLCBzdFJlY2VudENob2ljZXMpIHtcbiAgICAgICAgdmFyIHRhZ0NvbGxlY3Rpb24gPSB7XG4gICAgICAgICAgICBocmVmOiBpY29uQ29tbW9uc1NlYXJjaC50YWdFbmRwb2ludFxuICAgICAgICB9LCBjb2xsZWN0aW9uID0ge1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVDb2xsZWN0aW9ucyhjb2xsZWN0aW9uLCByZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGljb25zID0gcmVzcG9uc2UuZGF0YS5pY29ucztcbiAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uLl9pY29ucykge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uX2ljb25zID0gY29sbGVjdGlvbi5faWNvbnMuY29uY2F0KGljb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5faWNvbnMgPSBpY29ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbGxlY3Rpb24uX21vcmUgPSByZXNwb25zZS5kYXRhLnBhZ2UgPCByZXNwb25zZS5kYXRhLnBhZ2VzO1xuICAgICAgICAgICAgY29sbGVjdGlvbi5fbmV4dFBhZ2UgPSByZXNwb25zZS5kYXRhLnBhZ2UgKyAxO1xuICAgICAgICAgICAgJHNjb3BlLmljb25zID0gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAkc2NvcGUubG9hZE1vcmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGljb25Db21tb25zU2VhcmNoLmdldE1vcmUoJHNjb3BlLmljb25zKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDb2xsZWN0aW9ucygkc2NvcGUuaWNvbnMsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RSZWNlbnRDaG9pY2VzLmljb25zLmFkZCgkc2NvcGUuc2VsZWN0ZWRJY29uLmhyZWYpO1xuICAgICAgICAgICAgaWNvbkNvbW1vbnNTZWFyY2gubW9kYWwuY2xvc2UoJHNjb3BlLnNlbGVjdGVkSWNvbik7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5kaXNtaXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpY29uQ29tbW9uc1NlYXJjaC5tb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS50YWdTZWxlY3QgPSBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgICAgIHRhZ0NvbGxlY3Rpb24uX2ljb25zID0gW107XG4gICAgICAgICAgICBpY29uQ29tbW9uc1NlYXJjaC5nZXRCeVRhZyh0YWcpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUNvbGxlY3Rpb25zKHRhZ0NvbGxlY3Rpb24sIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS52aWV3Q29sbGVjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS5pY29ucyA9IGNvbGxlY3Rpb247XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS52aWV3VGFncyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLmljb25zID0gdGFnQ29sbGVjdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmNvbGxlY3Rpb25TZWxlY3QgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLl9pY29ucyA9IFtdO1xuICAgICAgICAgICAgaWNvbkNvbW1vbnNTZWFyY2guZ2V0Q29sbGVjdGlvbkljb25zKGNvbGxlY3Rpb24pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUNvbGxlY3Rpb25zKGNvbGxlY3Rpb24sIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5pY29uU2VsZWN0ZWQgPSBmdW5jdGlvbihpY29uLCBkb25lKSB7XG4gICAgICAgICAgICAkc2NvcGUuc2VsZWN0ZWRJY29uID0gaWNvbjtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5zZWxlY3RlZENsYXNzID0gZnVuY3Rpb24oaWNvbikge1xuICAgICAgICAgICAgcmV0dXJuIGljb24gPT09ICRzY29wZS5zZWxlY3RlZEljb24gPyAnYWN0aXZlJyA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5nZXRUYWdzID0gaWNvbkNvbW1vbnNTZWFyY2guZ2V0VGFncztcbiAgICAgICAgaWNvbkNvbW1vbnNTZWFyY2guZ2V0Q29sbGVjdGlvbnMoKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAkc2NvcGUuY29sbGVjdGlvbnMgPSByZXNwb25zZS5kYXRhLmNvbGxlY3Rpb25zO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pKCk7IiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnN0eWxlLnN0eWxlQ2hvaWNlcycsIFtdKTtcblxuICAgIG1vZHVsZS5mYWN0b3J5KCdzdFN0eWxlQ2hvaWNlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3ltYm9saXplcnM6IFtcbiAgICAgICAgICAgICAgICAnY2lyY2xlJywgJ3NxdWFyZScsICd0cmlhbmdsZScsICdzdGFyJywgJ2Nyb3NzJywgJ3gnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcm90YXRpb25Vbml0czogW1xuICAgICAgICAgICAgICAgICdkZWdyZWVzJywgJ3JhZGlhbnMnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IFtcbiAgICAgICAgICAgICAgICAnc29saWQnLCAnZGFzaGVkJywgJ2RvdHRlZCdcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBmb250RmFtaWx5OiBbXG4gICAgICAgICAgICAgICAgJ3NlcmlmJywgJ3NhbnMtc2VyaWYnLCAnY3Vyc2l2ZScsICdtb25vc3BhY2UnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgY29sb3JSYW1wczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgMDogJyNmZjAwMDAnLFxuICAgICAgICAgICAgICAgICAgICAxOiAnIzAwMDBmZidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgMDogJyMwMGZmMDAnLFxuICAgICAgICAgICAgICAgICAgICAxOiAnI2ZmZmYwMCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLy8gQHRvZG8gYnVpbGQgdGhlc2Ugc3RhdGljYWxseSBhaGVhZCBvZiB0aW1lIHVzaW5nIGNvbG9yLXNjaGVtZS1qc1xuICAgICAgICAgICAgY29sb3JQYWxldHRlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvbG9ycyAxJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsczogW1wiI2ZmOTkwMFwiLCBcIiNiMzZiMDBcIiwgXCIjZmZlNmJmXCIsIFwiI2ZmY2M4MFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIjMDBiMzY2XCIsIFwiIzAwN2Q0OFwiLCBcIiNiZmZmZTRcIiwgXCIjODBmZmM5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiM0MDAwOTlcIiwgXCIjMmQwMDZiXCIsIFwiI2RhYmZmZlwiLCBcIiNiNTgwZmZcIl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvbG9ycyAyJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsczogW1wiI2ZmOTlhYVwiLCBcIiNiMzZiYWFcIiwgXCIjYWFlNmJmXCIsIFwiI2FhY2M4MFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIjMDBiMzY2XCIsIFwiIzAwN2Q0OFwiLCBcIiNiZmFhZTRcIiwgXCIjODBhYWM5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiM0MGFhOTlcIiwgXCIjMmRhYTZiXCIsIFwiI2RhYmZhYVwiLCBcIiNiNTgwYWFcIl1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgY2xhc3NNZXRob2RzOiBbXG4gICAgICAgICAgICAgICAgJ05hdHVyYWwgQnJlYWtzJyxcbiAgICAgICAgICAgICAgICAnRXF1YWwgSW50ZXJ2YWwnLFxuICAgICAgICAgICAgICAgICdRdWFudGlsZScvKixcbiAgICAgICAgICAgICAgICAnR2VvbWV0cmljIEludGVydmFsJyxcbiAgICAgICAgICAgICAgICAnU3RhbmRhcmQgRGV2aWF0aW9uJyovXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZ2V0UGFsZXR0ZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IHRoaXMuY29sb3JQYWxldHRlcy5maWx0ZXIoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5uYW1lID09PSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5sZW5ndGggPyBmb3VuZFswXSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZmFjdG9yeSgnc3RSZWNlbnRDaG9pY2VzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpY29uczogbmV3IFJlY2VudENob2ljZXMoJ2ljb25zJywgMjQpXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBSZWNlbnRDaG9pY2VzKG5hbWUsIG1heCkge1xuICAgICAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgICAgIHRoaXMuX2tleSA9ICdzdFJlY2VudENob2ljZXMtJyArIG5hbWU7XG4gICAgICAgIHZhciBzYXZlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuX2tleSk7XG4gICAgICAgIHRoaXMucmVjZW50ID0gc2F2ZWQgPyBKU09OLnBhcnNlKHNhdmVkKSA6IFtdO1xuICAgIH1cblxuICAgIFJlY2VudENob2ljZXMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVjZW50ID0gW107XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkodGhpcy5yZWNlbnQpKTtcbiAgICB9O1xuXG4gICAgUmVjZW50Q2hvaWNlcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY2hvaWNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY2VudC5pbmRleE9mKGNob2ljZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2VudC5wdXNoKGNob2ljZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWNlbnQubGVuZ3RoID4gdGhpcy5fbWF4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlbnQuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkodGhpcy5yZWNlbnQpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdzdG9yeXRvb2xzLmVkaXQuc3R5bGUuc3R5bGVSdWxlQnVpbGRlcicsIFtcbiAgICAgICAgJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5zdHlsZVR5cGVzJyxcbiAgICAgICAgJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5zdHlsZUNob2ljZXMnXG4gICAgXSk7XG5cbiAgICBtb2R1bGUuZmFjdG9yeSgnc3RTdHlsZVJ1bGVCdWlsZGVyJywgZnVuY3Rpb24oc3RTdHlsZVR5cGVzLCBzdFN0eWxlQ2hvaWNlcykge1xuICAgICAgICBmdW5jdGlvbiBoZXgodikge1xuICAgICAgICAgICAgcmV0dXJuICgnMDAnICsgdi50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb2xvclJhbXBWYWx1ZXMocmFtcCwgbnVtKSB7XG4gICAgICAgICAgICBpZiAobnVtID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyYW1wWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciByYW1wU3RvcHMgPSBPYmplY3Qua2V5cyhyYW1wKS5maWx0ZXIoZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnRvU3RyaW5nKCkuY2hhckF0KDApICE9ICckJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmFtcFN0b3BzLnNvcnQoKTtcbiAgICAgICAgICAgIHZhciBtcyA9IHJhbXBTdG9wcy5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSByYW1wW2tdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbcGFyc2VJbnQoJzB4JyArIHZhbC5zdWJzdHIoMSwgMikpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludCgnMHgnICsgdmFsLnN1YnN0cigzLCAyKSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KCcweCcgKyB2YWwuc3Vic3RyKDUsIDIpKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzdGVwID0gMS4wIC8gKG51bSAtIDEpO1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U3RvcHModmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRvZG8gZmluZCBzdG9wc1xuICAgICAgICAgICAgICAgIHJldHVybiBbcmFtcFN0b3BzWzBdLCByYW1wU3RvcHNbMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBAdG9kbyBoc3YgaW50ZXJwb2xhdGlvbiAoeWllbGRzIGJyaWdodGVyIGNvbG9ycyk/XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGkgKiBzdGVwO1xuICAgICAgICAgICAgICAgIHZhciBzdG9wcyA9IGdldFN0b3BzKHZhbCk7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSAodmFsIC0gc3RvcHNbMF0pIC8gKHN0b3BzWzFdIC0gc3RvcHNbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG1zW3N0b3BzWzBdXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcCA9IG1zW3N0b3BzWzFdXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkID0gTWF0aC5mbG9vcihzdGFydFswXSArIChzdG9wWzBdIC0gc3RhcnRbMF0pICogcik7XG4gICAgICAgICAgICAgICAgdmFyIGdyZWVuID0gTWF0aC5mbG9vcihzdGFydFsxXSArIChzdG9wWzFdIC0gc3RhcnRbMV0pICogcik7XG4gICAgICAgICAgICAgICAgdmFyIGJsdWUgPSBNYXRoLmZsb29yKHN0YXJ0WzJdICsgKHN0b3BbMl0gLSBzdGFydFsyXSkgKiByKTtcbiAgICAgICAgICAgICAgICBjb2xvcnMucHVzaCgnIycgKyBoZXgocmVkKSArIGhleChncmVlbikgKyBoZXgoYmx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZFJ1bGUocnVsZSwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBjb250ZXh0LnN0eWxlVHlwZS5ydWxlO1xuICAgICAgICAgICAgdmFyIHJ1bGVTdHlsZSA9IHt9O1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHR5cGUsIGZ1bmN0aW9uKGNvcHlSdWxlLCBzdHlsZVByb3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvcHlSdWxlLCBmdW5jdGlvbihjb3B5U291cmNlLCBjb3B5RGVzdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb3B5U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY29sb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGNvbnRleHQuY29sb3JzW2NvbnRleHQuaW5kZXggJSBjb250ZXh0LmNvbG9ycy5sZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhbmdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5yYW5nZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gTWF0aC5yb3VuZChjb250ZXh0LnJhbmdlU3RlcCAqIGNvbnRleHQuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgY29weVNvdXJjZSAnICsgY29weVNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbY29weURlc3RdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcnVsZVN0eWxlW3N0eWxlUHJvcF0gPSB0YXJnZXQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJ1bGUuc3R5bGUgPSBydWxlU3R5bGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2NvbG9yUmFtcFZhbHVlczogY29sb3JSYW1wVmFsdWVzLFxuICAgICAgICAgICAgYnVpbGRSdWxlU3R5bGVzOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvcnM7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlU3RlcDtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuY2xhc3NpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmNsYXNzaWZ5LmNvbG9yUmFtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzID0gY29sb3JSYW1wVmFsdWVzKHN0eWxlLmNsYXNzaWZ5LmNvbG9yUmFtcCwgc3R5bGUucnVsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5jbGFzc2lmeS5jb2xvclBhbGV0dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWxldHRlID0gc3RTdHlsZUNob2ljZXMuZ2V0UGFsZXR0ZShzdHlsZS5jbGFzc2lmeS5jb2xvclBhbGV0dGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRvZG8gaW50ZXJwb2xhdGUgaWYgbmVlZGVkP1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzID0gcGFsZXR0ZS52YWxzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5jbGFzc2lmeS5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VTdGVwID0gKHN0eWxlLmNsYXNzaWZ5LnJhbmdlLm1heCAtIHN0eWxlLmNsYXNzaWZ5LnJhbmdlLm1pbikgLyBzdHlsZS5ydWxlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yczogY29sb3JzLFxuICAgICAgICAgICAgICAgICAgICByYW5nZVN0ZXA6IHJhbmdlU3RlcCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVR5cGU6IHN0U3R5bGVUeXBlcy5nZXRTdHlsZVR5cGUoc3R5bGUudHlwZU5hbWUpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdHlsZS5ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkUnVsZShyLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdzdG9yeXRvb2xzLmVkaXQuc3R5bGUuc3R5bGVUeXBlcycsIFtdKTtcblxuICAgIHZhciBkZWZhdWx0U3ltYm9sID0ge1xuICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgc2hhcGU6ICdjaXJjbGUnLFxuICAgICAgICBncmFwaGljOiBudWxsLFxuICAgICAgICBncmFwaGljVHlwZTogbnVsbCxcbiAgICAgICAgZmlsbENvbG9yOiAnI2Y1OTYyMCcsXG4gICAgICAgIGZpbGxPcGFjaXR5OiA3MCxcbiAgICAgICAgcm90YXRpb25BdHRyaWJ1dGU6IG51bGwsXG4gICAgICAgIHJvdGF0aW9uVW5pdHM6ICdkZWdyZWVzJ1xuICAgIH07XG5cbiAgICB2YXIgZGVmYXVsdFN0cm9rZSA9IHtcbiAgICAgICAgc3Ryb2tlQ29sb3I6ICcjZjU5NjIwJyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZVN0eWxlOiAnc29saWQnLFxuICAgICAgICBzdHJva2VPcGFjaXR5OiAxMDBcbiAgICB9O1xuXG4gICAgdmFyIGRlZmF1bHRMYWJlbCA9IHtcbiAgICAgICAgYXR0cmlidXRlOiBudWxsLFxuICAgICAgICBmaWxsQ29sb3I6ICcjZjU5NjIwJyxcbiAgICAgICAgZm9udEZhbWlseTogJ1NlcmlmJyxcbiAgICAgICAgZm9udFNpemU6IDEwLFxuICAgICAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgcGxhY2VtZW50OiAncG9pbnQnXG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0VW5pcXVlQ2xhc3MgPSB7XG4gICAgICAgIG1ldGhvZDogJ3VuaXF1ZScsXG4gICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgbWF4Q2xhc3NlczogNSxcbiAgICAgICAgY29sb3JSYW1wOiBudWxsXG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0QnJlYWtzQ2xhc3MgPSB7XG4gICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgYXR0cmlidXRlOiBudWxsLFxuICAgICAgICBtYXhDbGFzc2VzOiA1LFxuICAgICAgICBjb2xvclJhbXA6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIGRlZmF1bHRSYW5nZUNsYXNzID0ge1xuICAgICAgICBtZXRob2Q6IG51bGwsXG4gICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgbWF4Q2xhc3NlczogNSxcbiAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMTZcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdHlwZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdzaW1wbGUgcG9pbnQnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdTaW1wbGUnLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgZ2VvbVR5cGU6ICdwb2ludCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ3VuaXF1ZSBwb2ludCcsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogJ1VuaXF1ZScsXG4gICAgICAgICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvaW50JyxcbiAgICAgICAgICAgICAgICBjbGFzc2lmeTogZGVmYXVsdFVuaXF1ZUNsYXNzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVsZToge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnY29sb3InXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnY2xhc3MgcG9pbnQnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdDaG9yb3BsZXRoJyxcbiAgICAgICAgICAgIHByb3RvdHlwZToge1xuICAgICAgICAgICAgICAgIGdlb21UeXBlOiAncG9pbnQnLFxuICAgICAgICAgICAgICAgIGNsYXNzaWZ5OiBkZWZhdWx0QnJlYWtzQ2xhc3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydWxlOiB7XG4gICAgICAgICAgICAgICAgc3ltYm9sIDoge1xuICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICdjb2xvcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdncmFkdWF0ZWQgcG9pbnQnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdHcmFkdWF0ZWQnLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgZ2VvbVR5cGU6ICdwb2ludCcsXG4gICAgICAgICAgICAgICAgY2xhc3NpZnk6IGRlZmF1bHRSYW5nZUNsYXNzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVsZToge1xuICAgICAgICAgICAgICAgIHN5bWJvbDoge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiAncmFuZ2UnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnaGVhdG1hcCcsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogJ0hlYXRNYXAnLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgZ2VvbVR5cGU6ICdwb2ludCcsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiA4LFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuOFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnc2ltcGxlIGxpbmUnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdTaW1wbGUnLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgZ2VvbVR5cGU6ICdsaW5lJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAndW5pcXVlIGxpbmUnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdVbmlxdWUnLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgZ2VvbVR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBjbGFzc2lmeTogZGVmYXVsdFVuaXF1ZUNsYXNzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVsZToge1xuICAgICAgICAgICAgICAgIHN0cm9rZSA6IHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6ICdjb2xvcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdzaW1wbGUgcG9seWdvbicsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogJ1NpbXBsZScsXG4gICAgICAgICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvbHlnb24nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICd1bmlxdWUgcG9seWdvbicsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogJ1VuaXF1ZScsXG4gICAgICAgICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvbHlnb24nLFxuICAgICAgICAgICAgICAgIGNsYXNzaWZ5OiBkZWZhdWx0VW5pcXVlQ2xhc3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydWxlOiB7XG4gICAgICAgICAgICAgICAgc3ltYm9sIDoge1xuICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICdjb2xvcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdjbGFzcyBwb2x5Z29uJyxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnQ2hvcm9wbGV0aCcsXG4gICAgICAgICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvbHlnb24nLFxuICAgICAgICAgICAgICAgIGNsYXNzaWZ5OiBkZWZhdWx0QnJlYWtzQ2xhc3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydWxlOiB7XG4gICAgICAgICAgICAgICAgc3ltYm9sIDoge1xuICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICdjb2xvcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdO1xuXG4gICAgbW9kdWxlLnJ1bihmdW5jdGlvbigkaW5qZWN0b3IpIHtcbiAgICAgICAgaWYgKCRpbmplY3Rvci5oYXMoJ3N0U3R5bGVEZWZhdWx0cycpKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSAkaW5qZWN0b3IuZ2V0KCdzdFN0eWxlRGVmYXVsdHMnKTtcbiAgICAgICAgICAgIFtkZWZhdWx0U3ltYm9sLCBkZWZhdWx0U3Ryb2tlXS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNba10gPSBkZWZhdWx0c1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5mYWN0b3J5KCdzdFN0eWxlVHlwZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldFR5cGVzOiBmdW5jdGlvbihzdG9yeUxheWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuZ3VsYXIuY29weSh0eXBlcykuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYucHJvdG90eXBlLmdlb21UeXBlID09PSBzdG9yeUxheWVyLmdldCgnZ2VvbVR5cGUnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTdHlsZVR5cGU6IGZ1bmN0aW9uKHR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdHlwZXMuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQubmFtZSA9PSB0eXBlTmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2R1cGxpY2F0ZSB0eXBlIG5hbWVzISc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC5sZW5ndGggPT09IDAgPyBudWxsIDogbWF0Y2hbMF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlU3R5bGU6IGZ1bmN0aW9uKHN0eWxlVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlID0ge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IGRlZmF1bHRTeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogZGVmYXVsdFN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGRlZmF1bHRMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZU5hbWU6IHN0eWxlVHlwZS5uYW1lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhbmd1bGFyLmV4dGVuZCh7fSwgYW5ndWxhci5jb3B5KGJhc2UpLCBzdHlsZVR5cGUucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoJ2NsYXNzaWZ5JyBpbiBzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5ydWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnRpbWUuZGlyZWN0aXZlcycsIFtdKTtcblxuICAgIG1vZHVsZS5kaXJlY3RpdmUoJ3N0RGF0ZVRpbWVGaWVsZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAndGltZS9kYXRlLXRpbWUtZmllbGQuaHRtbCcsXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIGRhdGVUaW1lOiAnPScsXG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWU6ICc9J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUub3BlbiA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIG1vZHVsZS5kaXJlY3RpdmUoJ2lzb0RhdGVUaW1lJywgZnVuY3Rpb24oJGxvZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtLCBhdHRycywgbmdNb2RlbEN0cmwpIHtcbiAgICAgICAgICAgICAgICBuZ01vZGVsQ3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKG1vZGVsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IG1vZGVsVmFsdWUgIT0gbnVsbCA/IG5ldyBEYXRlKG1vZGVsVmFsdWUpLnRvSVNPU3RyaW5nKCkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZ01vZGVsQ3RybC4kcGFyc2Vycy5wdXNoKGZ1bmN0aW9uKHZpZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gIERhdGUucGFyc2Uodmlld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkID0gIWlzTmFOKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZGF0ZVRpbWUnLCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZCA/IHBhcnNlZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2NvcGUuc2V0RnJvbUN1cnJlbnRUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5jdXJyZW50VGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmdNb2RlbEN0cmwuJG1vZGVsVmFsdWUgPSBzY29wZS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ25vIGN1cnJlbnQgdGltZSBwcm92aWRlZCEnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59KSgpOyIsIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4xNC4xXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICBmdW5jdGlvbiB1dGlsc19ob29rc19faG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXRzIG5vdCBvd24gcHJvcGVydHkgSSdkIHN0aWxsIGNhbGwgaXQgbm9uLWVtcHR5XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfdXRjX19jcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9faXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gbS5faXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkX19jcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IHV0aWxzX2hvb2tzX19ob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBtb21lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJywgJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfc2V0X19zZXQgKGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX29yZGluYWxQYXJzZUxlbmllbnQuXG4gICAgICAgIHRoaXMuX29yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UgKyAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLCBwcm9wO1xuICAgICAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXM7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgaSwgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgIGggIDogJ2FuIGhvdXInLFxuICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgIGQgIDogJ2EgZGF5JyxcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgIE0gIDogJ2EgbW9udGgnLFxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICB5ICA6ICdhIHllYXInLFxuICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVfX3JlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnZXRfc2V0X19zZXQodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX2dldCAobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uaXNWYWxpZCgpID9cbiAgICAgICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX3NldCAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxuICAgIHZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG4gICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJycsIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG4gICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcbiAgICB2YXIgV0VFSyA9IDc7XG4gICAgdmFyIFdFRUtEQVkgPSA4O1xuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccyspK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXRzX21vbnRoX19oYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5pdHNfbW9udGhfX2hhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODEzNDgvaW5zdGFudGlhdGluZy1hLWphdmFzY3JpcHQtb2JqZWN0LWJ5LWNhbGxpbmctcHJvdG90eXBlLWNvbnN0cnVjdG9yLWFwcGx5XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgIC8vdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUgKHkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcblxuICAgICAgICAvL3RoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlfb2Zfd2Vla19faGFuZGxlU3RyaWN0UGFyc2Uod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5X29mX3dlZWtfX2hhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgLy8gdGhpcyBydWxlLlxuICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgIHZhciBiYXNlQ29uZmlnID0ge1xuICAgICAgICBjYWxlbmRhcjogZGVmYXVsdENhbGVuZGFyLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxuICAgICAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxuICAgICAgICBvcmRpbmFsOiBkZWZhdWx0T3JkaW5hbCxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiBkZWZhdWx0T3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBkZWZpbmVMb2NhbGUgY3VycmVudGx5IGFsc28gc2V0cyB0aGUgZ2xvYmFsIGxvY2FsZSwgd2VcbiAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdCBhcyBpZiB0aGVyZSBpcyBubyBiYXNlIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoJ3BhcmVudExvY2FsZVVuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NwZWNpZmllZCBwYXJlbnRMb2NhbGUgaXMgbm90IGRlZmluZWQgeWV0LiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9wYXJlbnQtbG9jYWxlLycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICAvLyBNRVJHRVxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XG4gICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19saXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyAobSkge1xuICAgICAgICB2YXIgb3ZlcmZsb3c7XG4gICAgICAgIHZhciBhID0gbS5fYTtcblxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgICAgIGFbREFURV0gICAgICAgIDwgMSB8fCBhW0RBVEVdICAgICAgICA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKSA/IERBVEUgOlxuICAgICAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgICAgICBhW1NFQ09ORF0gICAgICA8IDAgfHwgYVtTRUNPTkRdICAgICAgPiA1OSAgPyBTRUNPTkQgOlxuICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dEYXlPZlllYXIgJiYgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/LztcbiAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/LztcblxuICAgIHZhciB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vO1xuXG4gICAgdmFyIGlzb0RhdGVzID0gW1xuICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcbiAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZREREJywgL1xcZHs3fS9dXG4gICAgXTtcblxuICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICB2YXIgaXNvVGltZXMgPSBbXG4gICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISCcsIC9cXGRcXGQvXVxuICAgIF07XG5cbiAgICB2YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLCBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlLiBUaGlzIGlzICcgK1xuICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB1cGNvbWluZyBtYWpvciAnICtcbiAgICAgICAgJ3JlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKHV0aWxzX2hvb2tzX19ob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgMSk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF2YWxpZF9faXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHV0aWxzX2hvb2tzX19ob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZihsb2NhbGUpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxfX2NyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuICAgIGZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4ICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcikgfHwgW10pO1xuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAvL1xuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNikge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQob2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhjLl9hKSA6IGxvY2FsX19jcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gL14oXFwtKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKylcXC4/KFxcZHszfSk/XFxkKik/JC87XG5cbiAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgdmFyIGlzb1JlZ2V4ID0gL14oLSk/UCg/OigtP1swLTksLl0qKVkpPyg/OigtP1swLTksLl0qKU0pPyg/OigtP1swLTksLl0qKVcpPyg/OigtP1swLTksLl0qKUQpPyg/OlQoPzooLT9bMC05LC5dKilIKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlX19jcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBoICA6IHRvSW50KG1hdGNoW0hPVVJdKSAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtcyA6IHRvSW50KG1hdGNoW01JTExJU0VDT05EXSkgKiBzaWduXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlX19jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIGdldF9zZXRfX3NldChtb20sICdEYXRlJywgZ2V0X3NldF9fZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXRfc2V0X19nZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSB1dGlsc19ob29rc19faG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgbG9jYWxfX2NyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUoZnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsXG4gICAgICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZyAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5jbG9uZSgpLnV0YygpO1xuICAgICAgICBpZiAoMCA8IG0ueWVhcigpICYmIG0ueWVhcigpIDw9IDk5OTkpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGxvY2FsX19jcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGxvY2FsX19jcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhsb2NhbF9fY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX3R5cGVfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF92YWxpZF9faXNWYWxpZCAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZF9faXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JPSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyBsb2NhbGUuX29yZGluYWxQYXJzZSA6IGxvY2FsZS5fb3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvdG90eXBlX19wcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgICAgICA9IG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBtb21lbnRfdmFsaWRfX2lzVmFsaWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBhZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgICAgID0gdG9fdHlwZV9fdmFsdWVPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuXG4gICAgLy8gWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuICAgIC8vIFdlZWsgWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5cbiAgICAvLyBRdWFydGVyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG5cbiAgICAvLyBNb250aFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbiAgICAvLyBXZWVrXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWsgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG5cbiAgICAvLyBEYXlcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5ICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcblxuICAgIC8vIEhvdXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcblxuICAgIC8vIE1pbnV0ZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuXG4gICAgLy8gU2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbiAgICAvLyBNaWxsaXNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuXG4gICAgLy8gT2Zmc2V0XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbiAgICAvLyBUaW1lem9uZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG87XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVfX3Byb3RvID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgID0gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG90eXBlX19wcm90by5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVfX3JlbGF0aXZlVGltZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgPSBsb2NhbGVfc2V0X19zZXQ7XG5cbiAgICAvLyBNb250aFxuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG5cbiAgICAvLyBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgLy8gRGF5IG9mIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICAvLyBIb3Vyc1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG90eXBlX19wcm90by5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2dldCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuICAgICAgICB2YXIgdXRjID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwgKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0c19fZ2V0KGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdHNfX2dldChmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSk7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWJzX19hYnMgKCkge1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0IChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICB2YXIgZGF5cztcbiAgICAgICAgdmFyIG1vbnRocztcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYXNfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fZ2V0X19nZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpc1t1bml0cyArICdzJ10oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHM6IDQ1LCAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbTogNDUsICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaDogMjIsICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZDogMjYsICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE06IDExICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgaXNvX3N0cmluZ19fYWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBpc29fc3RyaW5nX190b0lTT1N0cmluZygpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIHZhciBzZWNvbmRzID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21vbnRocyk7XG4gICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICB2YXIgWSA9IHllYXJzO1xuICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICB2YXIgaCA9IGhvdXJzO1xuICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgIHZhciBzID0gc2Vjb25kcztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRvdGFsIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKFkgPyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8gTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGggPyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAocyA/IHMgKyAnUycgOiAnJyk7XG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFicyAgICAgICAgICAgID0gZHVyYXRpb25fYWJzX19hYnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgICA9IGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXMgICAgICAgICAgICAgPSBhcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udmFsdWVPZiAgICAgICAgPSBkdXJhdGlvbl9hc19fdmFsdWVPZjtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgPSBkdXJhdGlvbl9nZXRfX2dldDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnZlcnNpb24gPSAnMi4xNC4xJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhsb2NhbF9fY3JlYXRlTG9jYWwpO1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbiAgICB1dGlsc19ob29rc19faG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZVVuaXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IHZhbGlkX19jcmVhdGVJbnZhbGlkO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5cztcbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVJblpvbmU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNNaW47XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fbGlzdExvY2FsZXM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nID0gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICB1dGlsc19ob29rc19faG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuXG4gICAgdmFyIF9tb21lbnQgPSB1dGlsc19ob29rc19faG9va3M7XG5cbiAgICByZXR1cm4gX21vbWVudDtcblxufSkpOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGF0YVNldFxuICpcbiAqIFVzYWdlOlxuICogICAgIHZhciBkYXRhU2V0ID0gbmV3IERhdGFTZXQoe1xuICogICAgICAgICBmaWVsZElkOiAnX2lkJyxcbiAqICAgICAgICAgdHlwZToge1xuICogICAgICAgICAgICAgLy8gLi4uXG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgZGF0YVNldC5hZGQoaXRlbSk7XG4gKiAgICAgZGF0YVNldC5hZGQoZGF0YSk7XG4gKiAgICAgZGF0YVNldC51cGRhdGUoaXRlbSk7XG4gKiAgICAgZGF0YVNldC51cGRhdGUoZGF0YSk7XG4gKiAgICAgZGF0YVNldC5yZW1vdmUoaWQpO1xuICogICAgIGRhdGFTZXQucmVtb3ZlKGlkcyk7XG4gKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldCgpO1xuICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoaWQpO1xuICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoaWRzKTtcbiAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkcywgb3B0aW9ucywgZGF0YSk7XG4gKiAgICAgZGF0YVNldC5jbGVhcigpO1xuICpcbiAqIEEgZGF0YSBzZXQgY2FuOlxuICogLSBhZGQvcmVtb3ZlL3VwZGF0ZSBkYXRhXG4gKiAtIGdpdmVzIHRyaWdnZXJzIHVwb24gY2hhbmdlcyBpbiB0aGUgZGF0YVxuICogLSBjYW4gIGltcG9ydC9leHBvcnQgZGF0YSBpbiB2YXJpb3VzIGRhdGEgZm9ybWF0c1xuICpcbiAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhVGFibGV9IFtkYXRhXSAgICBPcHRpb25hbCBhcnJheSB3aXRoIGluaXRpYWwgZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGZpZWxkSWQgRmllbGQgbmFtZSBvZiB0aGUgaWQgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtcywgJ2lkJyBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nfSB0eXBlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIG1hcCB3aXRoIGZpZWxkIG5hbWVzIGFzIGtleSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgZmllbGQgdHlwZSBhcyB2YWx1ZS5cbiAqIEBjb25zdHJ1Y3RvciBEYXRhU2V0XG4gKi9cbi8vIFRPRE86IGFkZCBhIERhdGFTZXQgY29uc3RydWN0b3IgRGF0YVNldChkYXRhLCBvcHRpb25zKVxuZnVuY3Rpb24gRGF0YVNldCAoZGF0YSwgb3B0aW9ucykge1xuICAvLyBjb3JyZWN0bHkgcmVhZCBvcHRpb25hbCBhcmd1bWVudHNcbiAgaWYgKGRhdGEgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkgJiYgIXV0aWwuaXNEYXRhVGFibGUoZGF0YSkpIHtcbiAgICBvcHRpb25zID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9kYXRhID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFwIHdpdGggZGF0YSBpbmRleGVkIGJ5IGlkXG4gIHRoaXMuX2ZpZWxkSWQgPSB0aGlzLl9vcHRpb25zLmZpZWxkSWQgfHwgJ2lkJzsgICAvLyBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIGlkXG4gIHRoaXMuX3R5cGUgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcm5hbCBmaWVsZCB0eXBlcyAoTk9URTogdGhpcyBjYW4gZGlmZmVyIGZyb20gdGhpcy5fb3B0aW9ucy50eXBlKVxuXG4gIC8vIGFsbCB2YXJpYW50cyBvZiBhIERhdGUgYXJlIGludGVybmFsbHkgc3RvcmVkIGFzIERhdGUsIHNvIHdlIGNhbiBjb252ZXJ0XG4gIC8vIGZyb20gZXZlcnl0aGluZyB0byBldmVyeXRoaW5nIChhbHNvIGZyb20gSVNPRGF0ZSB0byBOdW1iZXIgZm9yIGV4YW1wbGUpXG4gIGlmICh0aGlzLl9vcHRpb25zLnR5cGUpIHtcbiAgICBmb3IgKHZhciBmaWVsZCBpbiB0aGlzLl9vcHRpb25zLnR5cGUpIHtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnR5cGUuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX29wdGlvbnMudHlwZVtmaWVsZF07XG4gICAgICAgIGlmICh2YWx1ZSA9PSAnRGF0ZScgfHwgdmFsdWUgPT0gJ0lTT0RhdGUnIHx8IHZhbHVlID09ICdBU1BEYXRlJykge1xuICAgICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gJ0RhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xLjEgKG9yIDIuMC4wPylcbiAgaWYgKHRoaXMuX29wdGlvbnMuY29udmVydCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIFwiY29udmVydFwiIGlzIGRlcHJlY2F0ZWQuIFVzZSBcInR5cGVcIiBpbnN0ZWFkLicpO1xuICB9XG5cbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTsgIC8vIGV2ZW50IHN1YnNjcmliZXJzXG5cbiAgLy8gYWRkIGluaXRpYWwgZGF0YSB3aGVuIHByb3ZpZGVkXG4gIGlmIChkYXRhKSB7XG4gICAgdGhpcy5hZGQoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gYW4gZXZlbnQsIGFkZCBhbiBldmVudCBsaXN0ZW5lclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50ICAgICAgICBFdmVudCBuYW1lLiBBdmFpbGFibGUgZXZlbnRzOiAncHV0JywgJ3VwZGF0ZScsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZW1vdmUnXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrIG1ldGhvZC4gQ2FsbGVkIHdpdGggdGhyZWUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGV2ZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0IHwgbnVsbH0gcGFyYW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgTnVtYmVyfSBzZW5kZXJJZFxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuICB2YXIgc3Vic2NyaWJlcnMgPSB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF07XG4gIGlmICghc3Vic2NyaWJlcnMpIHtcbiAgICBzdWJzY3JpYmVycyA9IFtdO1xuICAgIHRoaXMuX3N1YnNjcmliZXJzW2V2ZW50XSA9IHN1YnNjcmliZXJzO1xuICB9XG5cbiAgc3Vic2NyaWJlcnMucHVzaCh7XG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxuLy8gVE9ETzogbWFrZSB0aGlzIGZ1bmN0aW9uIGRlcHJlY2F0ZWQgKHJlcGxhY2VkIHdpdGggYG9uYCBzaW5jZSB2ZXJzaW9uIDAuNSlcbkRhdGFTZXQucHJvdG90eXBlLnN1YnNjcmliZSA9IERhdGFTZXQucHJvdG90eXBlLm9uO1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gYW4gZXZlbnQsIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdO1xuICBpZiAoc3Vic2NyaWJlcnMpIHtcbiAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBzdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gKGxpc3RlbmVyLmNhbGxiYWNrICE9IGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gVE9ETzogbWFrZSB0aGlzIGZ1bmN0aW9uIGRlcHJlY2F0ZWQgKHJlcGxhY2VkIHdpdGggYG9uYCBzaW5jZSB2ZXJzaW9uIDAuNSlcbkRhdGFTZXQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gRGF0YVNldC5wcm90b3R5cGUub2ZmO1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3QgfCBudWxsfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdICAgICAgIE9wdGlvbmFsIGlkIG9mIHRoZSBzZW5kZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICBpZiAoZXZlbnQgPT0gJyonKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdHJpZ2dlciBldmVudCAqJyk7XG4gIH1cblxuICB2YXIgc3Vic2NyaWJlcnMgPSBbXTtcbiAgaWYgKGV2ZW50IGluIHRoaXMuX3N1YnNjcmliZXJzKSB7XG4gICAgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5jb25jYXQodGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdKTtcbiAgfVxuICBpZiAoJyonIGluIHRoaXMuX3N1YnNjcmliZXJzKSB7XG4gICAgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5jb25jYXQodGhpcy5fc3Vic2NyaWJlcnNbJyonXSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBpZiAoc3Vic2NyaWJlci5jYWxsYmFjaykge1xuICAgICAgc3Vic2NyaWJlci5jYWxsYmFjayhldmVudCwgcGFyYW1zLCBzZW5kZXJJZCB8fCBudWxsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGRhdGEuXG4gKiBBZGRpbmcgYW4gaXRlbSB3aWxsIGZhaWwgd2hlbiB0aGVyZSBhbHJlYWR5IGlzIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZC5cbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXkgfCBEYXRhVGFibGV9IGRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdIE9wdGlvbmFsIHNlbmRlciBpZFxuICogQHJldHVybiB7QXJyYXl9IGFkZGVkSWRzICAgICAgQXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSwgc2VuZGVySWQpIHtcbiAgdmFyIGFkZGVkSWRzID0gW10sXG4gICAgICBpZCxcbiAgICAgIG1lID0gdGhpcztcblxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIC8vIEFycmF5XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlkID0gbWUuX2FkZEl0ZW0oZGF0YVtpXSk7XG4gICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodXRpbC5pc0RhdGFUYWJsZShkYXRhKSkge1xuICAgIC8vIEdvb2dsZSBEYXRhVGFibGVcbiAgICB2YXIgY29sdW1ucyA9IHRoaXMuX2dldENvbHVtbk5hbWVzKGRhdGEpO1xuICAgIGZvciAodmFyIHJvdyA9IDAsIHJvd3MgPSBkYXRhLmdldE51bWJlck9mUm93cygpOyByb3cgPCByb3dzOyByb3crKykge1xuICAgICAgdmFyIGl0ZW0gPSB7fTtcbiAgICAgIGZvciAodmFyIGNvbCA9IDAsIGNvbHMgPSBjb2x1bW5zLmxlbmd0aDsgY29sIDwgY29sczsgY29sKyspIHtcbiAgICAgICAgdmFyIGZpZWxkID0gY29sdW1uc1tjb2xdO1xuICAgICAgICBpdGVtW2ZpZWxkXSA9IGRhdGEuZ2V0VmFsdWUocm93LCBjb2wpO1xuICAgICAgfVxuXG4gICAgICBpZCA9IG1lLl9hZGRJdGVtKGl0ZW0pO1xuICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAvLyBTaW5nbGUgaXRlbVxuICAgIGlkID0gbWUuX2FkZEl0ZW0oZGF0YSk7XG4gICAgYWRkZWRJZHMucHVzaChpZCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdGFUeXBlJyk7XG4gIH1cblxuICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcignYWRkJywge2l0ZW1zOiBhZGRlZElkc30sIHNlbmRlcklkKTtcbiAgfVxuXG4gIHJldHVybiBhZGRlZElkcztcbn07XG5cbi8qKlxuICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZFxuICogQHBhcmFtIHtPYmplY3QgfCBBcnJheSB8IERhdGFUYWJsZX0gZGF0YVxuICogQHBhcmFtIHtTdHJpbmd9IFtzZW5kZXJJZF0gT3B0aW9uYWwgc2VuZGVyIGlkXG4gKiBAcmV0dXJuIHtBcnJheX0gdXBkYXRlZElkcyAgICAgVGhlIGlkcyBvZiB0aGUgYWRkZWQgb3IgdXBkYXRlZCBpdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgc2VuZGVySWQpIHtcbiAgdmFyIGFkZGVkSWRzID0gW10sXG4gICAgICB1cGRhdGVkSWRzID0gW10sXG4gICAgICBtZSA9IHRoaXMsXG4gICAgICBmaWVsZElkID0gbWUuX2ZpZWxkSWQ7XG5cbiAgdmFyIGFkZE9yVXBkYXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgaWQgPSBpdGVtW2ZpZWxkSWRdO1xuICAgIGlmIChtZS5fZGF0YVtpZF0pIHtcbiAgICAgIC8vIHVwZGF0ZSBpdGVtXG4gICAgICBpZCA9IG1lLl91cGRhdGVJdGVtKGl0ZW0pO1xuICAgICAgdXBkYXRlZElkcy5wdXNoKGlkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhZGQgbmV3IGl0ZW1cbiAgICAgIGlkID0gbWUuX2FkZEl0ZW0oaXRlbSk7XG4gICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAvLyBBcnJheVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhZGRPclVwZGF0ZShkYXRhW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodXRpbC5pc0RhdGFUYWJsZShkYXRhKSkge1xuICAgIC8vIEdvb2dsZSBEYXRhVGFibGVcbiAgICB2YXIgY29sdW1ucyA9IHRoaXMuX2dldENvbHVtbk5hbWVzKGRhdGEpO1xuICAgIGZvciAodmFyIHJvdyA9IDAsIHJvd3MgPSBkYXRhLmdldE51bWJlck9mUm93cygpOyByb3cgPCByb3dzOyByb3crKykge1xuICAgICAgdmFyIGl0ZW0gPSB7fTtcbiAgICAgIGZvciAodmFyIGNvbCA9IDAsIGNvbHMgPSBjb2x1bW5zLmxlbmd0aDsgY29sIDwgY29sczsgY29sKyspIHtcbiAgICAgICAgdmFyIGZpZWxkID0gY29sdW1uc1tjb2xdO1xuICAgICAgICBpdGVtW2ZpZWxkXSA9IGRhdGEuZ2V0VmFsdWUocm93LCBjb2wpO1xuICAgICAgfVxuXG4gICAgICBhZGRPclVwZGF0ZShpdGVtKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgYWRkT3JVcGRhdGUoZGF0YSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdGFUeXBlJyk7XG4gIH1cblxuICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcignYWRkJywge2l0ZW1zOiBhZGRlZElkc30sIHNlbmRlcklkKTtcbiAgfVxuICBpZiAodXBkYXRlZElkcy5sZW5ndGgpIHtcbiAgICB0aGlzLl90cmlnZ2VyKCd1cGRhdGUnLCB7aXRlbXM6IHVwZGF0ZWRJZHN9LCBzZW5kZXJJZCk7XG4gIH1cblxuICByZXR1cm4gYWRkZWRJZHMuY29uY2F0KHVwZGF0ZWRJZHMpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBkYXRhIGl0ZW0gb3IgbXVsdGlwbGUgaXRlbXMuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAgIGdldCgpXG4gKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdClcbiAqICAgICBnZXQob3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAqXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIgfCBTdHJpbmcpXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIgfCBTdHJpbmcsIG9wdGlvbnM6IE9iamVjdClcbiAqICAgICBnZXQoaWQ6IE51bWJlciB8IFN0cmluZywgb3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAqXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10gfCBTdHJpbmdbXSlcbiAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSB8IFN0cmluZ1tdLCBvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10gfCBTdHJpbmdbXSwgb3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAqXG4gKiBXaGVyZTpcbiAqXG4gKiB7TnVtYmVyIHwgU3RyaW5nfSBpZCAgICAgICAgIFRoZSBpZCBvZiBhbiBpdGVtXG4gKiB7TnVtYmVyW10gfCBTdHJpbmd7fX0gaWRzICAgIEFuIGFycmF5IHdpdGggaWRzIG9mIGl0ZW1zXG4gKiB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBbcmV0dXJuVHlwZV0gVHlwZSBvZiBkYXRhIHRvIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZC4gQ2FuIGJlICdEYXRhVGFibGUnIG9yICdBcnJheScgKGRlZmF1bHQpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmdbXX0gW2ZpZWxkc10gZmllbGQgbmFtZXMgdG8gYmUgcmV0dXJuZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICoge0FycmF5IHwgRGF0YVRhYmxlfSBbZGF0YV0gICBJZiBwcm92aWRlZCwgaXRlbXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5IG9yIHRhYmxlLiBSZXF1aXJlZCBpbiBjYXNlIG9mIEdvb2dsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXRhVGFibGUuXG4gKlxuICogQHRocm93cyBFcnJvclxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXJncykge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIHBhcnNlIHRoZSBhcmd1bWVudHNcbiAgdmFyIGlkLCBpZHMsIG9wdGlvbnMsIGRhdGE7XG4gIHZhciBmaXJzdFR5cGUgPSB1dGlsLmdldFR5cGUoYXJndW1lbnRzWzBdKTtcbiAgaWYgKGZpcnN0VHlwZSA9PSAnU3RyaW5nJyB8fCBmaXJzdFR5cGUgPT0gJ051bWJlcicpIHtcbiAgICAvLyBnZXQoaWQgWywgb3B0aW9uc10gWywgZGF0YV0pXG4gICAgaWQgPSBhcmd1bWVudHNbMF07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICBkYXRhID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIGVsc2UgaWYgKGZpcnN0VHlwZSA9PSAnQXJyYXknKSB7XG4gICAgLy8gZ2V0KGlkcyBbLCBvcHRpb25zXSBbLCBkYXRhXSlcbiAgICBpZHMgPSBhcmd1bWVudHNbMF07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICBkYXRhID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGdldChbLCBvcHRpb25zXSBbLCBkYXRhXSlcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzBdO1xuICAgIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlXG4gIHZhciByZXR1cm5UeXBlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJldHVyblR5cGUpIHtcbiAgICB2YXIgYWxsb3dlZFZhbHVlcyA9IFtcIkRhdGFUYWJsZVwiLCBcIkFycmF5XCIsIFwiT2JqZWN0XCJdO1xuICAgIHJldHVyblR5cGUgPSBhbGxvd2VkVmFsdWVzLmluZGV4T2Yob3B0aW9ucy5yZXR1cm5UeXBlKSA9PSAtMSA/IFwiQXJyYXlcIiA6IG9wdGlvbnMucmV0dXJuVHlwZTtcblxuICAgIGlmIChkYXRhICYmIChyZXR1cm5UeXBlICE9IHV0aWwuZ2V0VHlwZShkYXRhKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHlwZSBvZiBwYXJhbWV0ZXIgXCJkYXRhXCIgKCcgKyB1dGlsLmdldFR5cGUoZGF0YSkgKyAnKSAnICtcbiAgICAgICAgICAnZG9lcyBub3QgY29ycmVzcG9uZCB3aXRoIHNwZWNpZmllZCBvcHRpb25zLnR5cGUgKCcgKyBvcHRpb25zLnR5cGUgKyAnKScpO1xuICAgIH1cbiAgICBpZiAocmV0dXJuVHlwZSA9PSAnRGF0YVRhYmxlJyAmJiAhdXRpbC5pc0RhdGFUYWJsZShkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgXCJkYXRhXCIgbXVzdCBiZSBhIERhdGFUYWJsZSAnICtcbiAgICAgICAgICAnd2hlbiBvcHRpb25zLnR5cGUgaXMgXCJEYXRhVGFibGVcIicpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChkYXRhKSB7XG4gICAgcmV0dXJuVHlwZSA9ICh1dGlsLmdldFR5cGUoZGF0YSkgPT0gJ0RhdGFUYWJsZScpID8gJ0RhdGFUYWJsZScgOiAnQXJyYXknO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVyblR5cGUgPSAnQXJyYXknO1xuICB9XG5cbiAgLy8gYnVpbGQgb3B0aW9uc1xuICB2YXIgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IHRoaXMuX29wdGlvbnMudHlwZTtcbiAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXI7XG4gIHZhciBpdGVtcyA9IFtdLCBpdGVtLCBpdGVtSWQsIGksIGxlbjtcblxuICAvLyBjb252ZXJ0IGl0ZW1zXG4gIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAvLyByZXR1cm4gYSBzaW5nbGUgaXRlbVxuICAgIGl0ZW0gPSBtZS5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyKGl0ZW0pKSB7XG4gICAgICBpdGVtID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaWRzICE9IHVuZGVmaW5lZCkge1xuICAgIC8vIHJldHVybiBhIHN1YnNldCBvZiBpdGVtc1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaXRlbSA9IG1lLl9nZXRJdGVtKGlkc1tpXSwgdHlwZSk7XG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gcmV0dXJuIGFsbCBpdGVtc1xuICAgIGZvciAoaXRlbUlkIGluIHRoaXMuX2RhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9kYXRhLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgaXRlbSA9IG1lLl9nZXRJdGVtKGl0ZW1JZCwgdHlwZSk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBvcmRlciB0aGUgcmVzdWx0c1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyICYmIGlkID09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9wdGlvbnMub3JkZXIpO1xuICB9XG5cbiAgLy8gZmlsdGVyIGZpZWxkcyBvZiB0aGUgaXRlbXNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWVsZHMpIHtcbiAgICB2YXIgZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgaXRlbSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtLCBmaWVsZHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGl0ZW1zW2ldID0gdGhpcy5fZmlsdGVyRmllbGRzKGl0ZW1zW2ldLCBmaWVsZHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJldHVybiB0aGUgcmVzdWx0c1xuICBpZiAocmV0dXJuVHlwZSA9PSAnRGF0YVRhYmxlJykge1xuICAgIHZhciBjb2x1bW5zID0gdGhpcy5fZ2V0Q29sdW1uTmFtZXMoZGF0YSk7XG4gICAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYXBwZW5kIGEgc2luZ2xlIGl0ZW0gdG8gdGhlIGRhdGEgdGFibGVcbiAgICAgIG1lLl9hcHBlbmRSb3coZGF0YSwgY29sdW1ucywgaXRlbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gY29weSB0aGUgaXRlbXMgdG8gdGhlIHByb3ZpZGVkIGRhdGEgdGFibGVcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZS5fYXBwZW5kUm93KGRhdGEsIGNvbHVtbnMsIGl0ZW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZWxzZSBpZiAocmV0dXJuVHlwZSA9PSBcIk9iamVjdFwiKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W2l0ZW1zW2ldLmlkXSA9IGl0ZW1zW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIHJldHVybiBhbiBhcnJheVxuICAgIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGEgc2luZ2xlIGl0ZW1cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIG11bHRpcGxlIGl0ZW1zXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICAvLyBjb3B5IHRoZSBpdGVtcyB0byB0aGUgcHJvdmlkZWQgYXJyYXlcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBkYXRhLnB1c2goaXRlbXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGp1c3QgcmV0dXJuIG91ciBhcnJheVxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCBpZHMgb2YgYWxsIGl0ZW1zIG9yIGZyb20gYSBmaWx0ZXJlZCBzZXQgb2YgaXRlbXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gaWRzXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmdldElkcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIsXG4gICAgICBvcmRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcixcbiAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICBpLFxuICAgICAgbGVuLFxuICAgICAgaWQsXG4gICAgICBpdGVtLFxuICAgICAgaXRlbXMsXG4gICAgICBpZHMgPSBbXTtcblxuICBpZiAoZmlsdGVyKSB7XG4gICAgLy8gZ2V0IGZpbHRlcmVkIGl0ZW1zXG4gICAgaWYgKG9yZGVyKSB7XG4gICAgICAvLyBjcmVhdGUgb3JkZXJlZCBsaXN0XG4gICAgICBpdGVtcyA9IFtdO1xuICAgICAgZm9yIChpZCBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgICBpZiAoZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcmRlcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlkc1tpXSA9IGl0ZW1zW2ldW3RoaXMuX2ZpZWxkSWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgZm9yIChpZCBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgICBpZiAoZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZHMucHVzaChpdGVtW3RoaXMuX2ZpZWxkSWRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2V0IGFsbCBpdGVtc1xuICAgIGlmIChvcmRlcikge1xuICAgICAgLy8gY3JlYXRlIGFuIG9yZGVyZWQgbGlzdFxuICAgICAgaXRlbXMgPSBbXTtcbiAgICAgIGZvciAoaWQgaW4gZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGRhdGFbaWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcmRlcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlkc1tpXSA9IGl0ZW1zW2ldW3RoaXMuX2ZpZWxkSWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgZm9yIChpZCBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICAgICAgICBpZHMucHVzaChpdGVtW3RoaXMuX2ZpZWxkSWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERhdGFTZXQgaXRzZWxmLiBJcyBvdmVyd3JpdHRlbiBmb3IgZXhhbXBsZSBieSB0aGUgRGF0YVZpZXcsXG4gKiB3aGljaCByZXR1cm5zIHRoZSBEYXRhU2V0IGl0IGlzIGNvbm5lY3RlZCB0byBpbnN0ZWFkLlxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5nZXREYXRhU2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBldmVyeSBpdGVtIGluIHRoZSBkYXRhc2V0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmdbXX0gW2ZpZWxkc10gZmlsdGVyIGZpZWxkc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIsXG4gICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBpdGVtLFxuICAgICAgaWQ7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcikge1xuICAgIC8vIGV4ZWN1dGUgZm9yRWFjaCBvbiBvcmRlcmVkIGxpc3RcbiAgICB2YXIgaXRlbXMgPSB0aGlzLmdldChvcHRpb25zKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgaWQgPSBpdGVtW3RoaXMuX2ZpZWxkSWRdO1xuICAgICAgY2FsbGJhY2soaXRlbSwgaWQpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyB1bm9yZGVyZWRcbiAgICBmb3IgKGlkIGluIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBpdGVtID0gdGhpcy5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNYXAgZXZlcnkgaXRlbSBpbiB0aGUgZGF0YXNldC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFt0eXBlXVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nW119IFtmaWVsZHNdIGZpbHRlciBmaWVsZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JqZWN0W119IG1hcHBlZEl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICBtYXBwZWRJdGVtcyA9IFtdLFxuICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBpdGVtO1xuXG4gIC8vIGNvbnZlcnQgYW5kIGZpbHRlciBpdGVtc1xuICBmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBpdGVtID0gdGhpcy5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgbWFwcGVkSXRlbXMucHVzaChjYWxsYmFjayhpdGVtLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG9yZGVyIGl0ZW1zXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICB0aGlzLl9zb3J0KG1hcHBlZEl0ZW1zLCBvcHRpb25zLm9yZGVyKTtcbiAgfVxuXG4gIHJldHVybiBtYXBwZWRJdGVtcztcbn07XG5cbi8qKlxuICogRmlsdGVyIHRoZSBmaWVsZHMgb2YgYW4gaXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAqIEBwYXJhbSB7U3RyaW5nW119IGZpZWxkcyAgICAgRmllbGQgbmFtZXNcbiAqIEByZXR1cm4ge09iamVjdH0gZmlsdGVyZWRJdGVtXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fZmlsdGVyRmllbGRzID0gZnVuY3Rpb24gKGl0ZW0sIGZpZWxkcykge1xuICB2YXIgZmlsdGVyZWRJdGVtID0ge307XG5cbiAgZm9yICh2YXIgZmllbGQgaW4gaXRlbSkge1xuICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KGZpZWxkKSAmJiAoZmllbGRzLmluZGV4T2YoZmllbGQpICE9IC0xKSkge1xuICAgICAgZmlsdGVyZWRJdGVtW2ZpZWxkXSA9IGl0ZW1bZmllbGRdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZEl0ZW07XG59O1xuXG4vKipcbiAqIFNvcnQgdGhlIHByb3ZpZGVkIGFycmF5IHdpdGggaXRlbXNcbiAqIEBwYXJhbSB7T2JqZWN0W119IGl0ZW1zXG4gKiBAcGFyYW0ge1N0cmluZyB8IGZ1bmN0aW9ufSBvcmRlciAgICAgIEEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9zb3J0ID0gZnVuY3Rpb24gKGl0ZW1zLCBvcmRlcikge1xuICBpZiAodXRpbC5pc1N0cmluZyhvcmRlcikpIHtcbiAgICAvLyBvcmRlciBieSBwcm92aWRlZCBmaWVsZCBuYW1lXG4gICAgdmFyIG5hbWUgPSBvcmRlcjsgLy8gZmllbGQgbmFtZVxuICAgIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBhdiA9IGFbbmFtZV07XG4gICAgICB2YXIgYnYgPSBiW25hbWVdO1xuICAgICAgcmV0dXJuIChhdiA+IGJ2KSA/IDEgOiAoKGF2IDwgYnYpID8gLTEgOiAwKTtcbiAgICB9KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBvcmRlciBieSBzb3J0IGZ1bmN0aW9uXG4gICAgaXRlbXMuc29ydChvcmRlcik7XG4gIH1cbiAgLy8gVE9ETzogZXh0ZW5kIG9yZGVyIGJ5IGFuIE9iamVjdCB7ZmllbGQ6U3RyaW5nLCBkaXJlY3Rpb246U3RyaW5nfVxuICAvLyAgICAgICB3aGVyZSBkaXJlY3Rpb24gY2FuIGJlICdhc2MnIG9yICdkZXNjJ1xuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPcmRlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gb2JqZWN0IGJ5IHBvaW50ZXIgb3IgYnkgaWRcbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyIHwgT2JqZWN0IHwgQXJyYXl9IGlkIE9iamVjdCBvciBpZCwgb3IgYW4gYXJyYXkgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0cyBvciBpZHMgdG8gYmUgcmVtb3ZlZFxuICogQHBhcmFtIHtTdHJpbmd9IFtzZW5kZXJJZF0gT3B0aW9uYWwgc2VuZGVyIGlkXG4gKiBAcmV0dXJuIHtBcnJheX0gcmVtb3ZlZElkc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaWQsIHNlbmRlcklkKSB7XG4gIHZhciByZW1vdmVkSWRzID0gW10sXG4gICAgICBpLCBsZW4sIHJlbW92ZWRJZDtcblxuICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVtb3ZlZElkID0gdGhpcy5fcmVtb3ZlKGlkW2ldKTtcbiAgICAgIGlmIChyZW1vdmVkSWQgIT0gbnVsbCkge1xuICAgICAgICByZW1vdmVkSWRzLnB1c2gocmVtb3ZlZElkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmVtb3ZlZElkID0gdGhpcy5fcmVtb3ZlKGlkKTtcbiAgICBpZiAocmVtb3ZlZElkICE9IG51bGwpIHtcbiAgICAgIHJlbW92ZWRJZHMucHVzaChyZW1vdmVkSWQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHtpdGVtczogcmVtb3ZlZElkc30sIHNlbmRlcklkKTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVkSWRzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBieSBpdHMgaWRcbiAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nIHwgT2JqZWN0fSBpZCAgIGlkIG9yIGl0ZW1cbiAqIEByZXR1cm5zIHtOdW1iZXIgfCBTdHJpbmcgfCBudWxsfSBpZFxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAodXRpbC5pc051bWJlcihpZCkgfHwgdXRpbC5pc1N0cmluZyhpZCkpIHtcbiAgICBpZiAodGhpcy5fZGF0YVtpZF0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9kYXRhW2lkXTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaWQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgaXRlbUlkID0gaWRbdGhpcy5fZmllbGRJZF07XG4gICAgaWYgKGl0ZW1JZCAmJiB0aGlzLl9kYXRhW2l0ZW1JZF0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9kYXRhW2l0ZW1JZF07XG4gICAgICByZXR1cm4gaXRlbUlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIGRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdIE9wdGlvbmFsIHNlbmRlciBpZFxuICogQHJldHVybiB7QXJyYXl9IHJlbW92ZWRJZHMgICAgVGhlIGlkcyBvZiBhbGwgcmVtb3ZlZCBpdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChzZW5kZXJJZCkge1xuICB2YXIgaWRzID0gT2JqZWN0LmtleXModGhpcy5fZGF0YSk7XG5cbiAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHtpdGVtczogaWRzfSwgc2VuZGVySWQpO1xuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIGl0ZW0gd2l0aCBtYXhpbXVtIHZhbHVlIG9mIGEgc3BlY2lmaWVkIGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGl0ZW0gIEl0ZW0gY29udGFpbmluZyBtYXggdmFsdWUsIG9yIG51bGwgaWYgbm8gaXRlbXNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgIG1heCA9IG51bGwsXG4gICAgICBtYXhGaWVsZCA9IG51bGw7XG5cbiAgZm9yICh2YXIgaWQgaW4gZGF0YSkge1xuICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICAgIHZhciBpdGVtRmllbGQgPSBpdGVtW2ZpZWxkXTtcbiAgICAgIGlmIChpdGVtRmllbGQgIT0gbnVsbCAmJiAoIW1heCB8fCBpdGVtRmllbGQgPiBtYXhGaWVsZCkpIHtcbiAgICAgICAgbWF4ID0gaXRlbTtcbiAgICAgICAgbWF4RmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1heDtcbn07XG5cbi8qKlxuICogRmluZCB0aGUgaXRlbSB3aXRoIG1pbmltdW0gdmFsdWUgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gaXRlbSAgSXRlbSBjb250YWluaW5nIG1heCB2YWx1ZSwgb3IgbnVsbCBpZiBubyBpdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgbWluID0gbnVsbCxcbiAgICAgIG1pbkZpZWxkID0gbnVsbDtcblxuICBmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGFbaWRdO1xuICAgICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuICAgICAgaWYgKGl0ZW1GaWVsZCAhPSBudWxsICYmICghbWluIHx8IGl0ZW1GaWVsZCA8IG1pbkZpZWxkKSkge1xuICAgICAgICBtaW4gPSBpdGVtO1xuICAgICAgICBtaW5GaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufTtcblxuLyoqXG4gKiBGaW5kIGFsbCBkaXN0aW5jdCB2YWx1ZXMgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7QXJyYXl9IHZhbHVlcyAgQXJyYXkgY29udGFpbmluZyBhbGwgZGlzdGluY3QgdmFsdWVzLiBJZiBkYXRhIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBkbyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIGFyZSBpZ25vcmVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJldHVybmVkIGFycmF5IGlzIHVub3JkZXJlZC5cbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBmaWVsZFR5cGUgPSB0aGlzLl9vcHRpb25zLnR5cGUgJiYgdGhpcy5fb3B0aW9ucy50eXBlW2ZpZWxkXSB8fCBudWxsO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgaTtcblxuICBmb3IgKHZhciBwcm9wIGluIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW3Byb3BdO1xuICAgICAgdmFyIHZhbHVlID0gaXRlbVtmaWVsZF07XG4gICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBpZiAodmFsdWVzW2ldID09IHZhbHVlKSB7XG4gICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFleGlzdHMgJiYgKHZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhbHVlc1tjb3VudF0gPSB2YWx1ZTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZmllbGRUeXBlKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gdXRpbC5jb252ZXJ0KHZhbHVlc1tpXSwgZmllbGRUeXBlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgaXRlbS4gV2lsbCBmYWlsIHdoZW4gYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkIGFscmVhZHkgZXhpc3RzLlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAqIEByZXR1cm4ge1N0cmluZ30gaWRcbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9hZGRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcblxuICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGlzIGlkIGlzIGFscmVhZHkgdGFrZW5cbiAgICBpZiAodGhpcy5fZGF0YVtpZF0pIHtcbiAgICAgIC8vIGl0ZW0gYWxyZWFkeSBleGlzdHNcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBpdGVtOiBpdGVtIHdpdGggaWQgJyArIGlkICsgJyBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnZW5lcmF0ZSBhbiBpZFxuICAgIGlkID0gdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgaXRlbVt0aGlzLl9maWVsZElkXSA9IGlkO1xuICB9XG5cbiAgdmFyIGQgPSB7fTtcbiAgZm9yICh2YXIgZmllbGQgaW4gaXRlbSkge1xuICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX3R5cGVbZmllbGRdOyAgLy8gdHlwZSBtYXkgYmUgdW5kZWZpbmVkXG4gICAgICBkW2ZpZWxkXSA9IHV0aWwuY29udmVydChpdGVtW2ZpZWxkXSwgZmllbGRUeXBlKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fZGF0YVtpZF0gPSBkO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbi8qKlxuICogR2V0IGFuIGl0ZW0uIEZpZWxkcyBjYW4gYmUgY29udmVydGVkIHRvIGEgc3BlY2lmaWMgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZXNdICBmaWVsZCB0eXBlcyB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCwgdHlwZXMpIHtcbiAgdmFyIGZpZWxkLCB2YWx1ZTtcblxuICAvLyBnZXQgdGhlIGl0ZW0gZnJvbSB0aGUgZGF0YXNldFxuICB2YXIgcmF3ID0gdGhpcy5fZGF0YVtpZF07XG4gIGlmICghcmF3KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBjb252ZXJ0IHRoZSBpdGVtcyBmaWVsZCB0eXBlc1xuICB2YXIgY29udmVydGVkID0ge307XG4gIGlmICh0eXBlcykge1xuICAgIGZvciAoZmllbGQgaW4gcmF3KSB7XG4gICAgICBpZiAocmF3Lmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICB2YWx1ZSA9IHJhd1tmaWVsZF07XG4gICAgICAgIGNvbnZlcnRlZFtmaWVsZF0gPSB1dGlsLmNvbnZlcnQodmFsdWUsIHR5cGVzW2ZpZWxkXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vIGZpZWxkIHR5cGVzIHNwZWNpZmllZCwgbm8gY29udmVydGluZyBuZWVkZWRcbiAgICBmb3IgKGZpZWxkIGluIHJhdykge1xuICAgICAgaWYgKHJhdy5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgdmFsdWUgPSByYXdbZmllbGRdO1xuICAgICAgICBjb252ZXJ0ZWRbZmllbGRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhIHNpbmdsZSBpdGVtOiBtZXJnZSB3aXRoIGV4aXN0aW5nIGl0ZW0uXG4gKiBXaWxsIGZhaWwgd2hlbiB0aGUgaXRlbSBoYXMgbm8gaWQsIG9yIHdoZW4gdGhlcmUgZG9lcyBub3QgZXhpc3QgYW4gaXRlbVxuICogd2l0aCB0aGUgc2FtZSBpZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fdXBkYXRlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBpZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG4gIGlmIChpZCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgaXRlbTogaXRlbSBoYXMgbm8gaWQgKGl0ZW06ICcgKyBKU09OLnN0cmluZ2lmeShpdGVtKSArICcpJyk7XG4gIH1cbiAgdmFyIGQgPSB0aGlzLl9kYXRhW2lkXTtcbiAgaWYgKCFkKSB7XG4gICAgLy8gaXRlbSBkb2Vzbid0IGV4aXN0XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIGl0ZW06IG5vIGl0ZW0gd2l0aCBpZCAnICsgaWQgKyAnIGZvdW5kJyk7XG4gIH1cblxuICAvLyBtZXJnZSB3aXRoIGN1cnJlbnQgaXRlbVxuICBmb3IgKHZhciBmaWVsZCBpbiBpdGVtKSB7XG4gICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICB2YXIgZmllbGRUeXBlID0gdGhpcy5fdHlwZVtmaWVsZF07ICAvLyB0eXBlIG1heSBiZSB1bmRlZmluZWRcbiAgICAgIGRbZmllbGRdID0gdXRpbC5jb252ZXJ0KGl0ZW1bZmllbGRdLCBmaWVsZFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZDtcbn07XG5cbi8qKlxuICogR2V0IGFuIGFycmF5IHdpdGggdGhlIGNvbHVtbiBuYW1lcyBvZiBhIEdvb2dsZSBEYXRhVGFibGVcbiAqIEBwYXJhbSB7RGF0YVRhYmxlfSBkYXRhVGFibGVcbiAqIEByZXR1cm4ge1N0cmluZ1tdfSBjb2x1bW5OYW1lc1xuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX2dldENvbHVtbk5hbWVzID0gZnVuY3Rpb24gKGRhdGFUYWJsZSkge1xuICB2YXIgY29sdW1ucyA9IFtdO1xuICBmb3IgKHZhciBjb2wgPSAwLCBjb2xzID0gZGF0YVRhYmxlLmdldE51bWJlck9mQ29sdW1ucygpOyBjb2wgPCBjb2xzOyBjb2wrKykge1xuICAgIGNvbHVtbnNbY29sXSA9IGRhdGFUYWJsZS5nZXRDb2x1bW5JZChjb2wpIHx8IGRhdGFUYWJsZS5nZXRDb2x1bW5MYWJlbChjb2wpO1xuICB9XG4gIHJldHVybiBjb2x1bW5zO1xufTtcblxuLyoqXG4gKiBBcHBlbmQgYW4gaXRlbSBhcyBhIHJvdyB0byB0aGUgZGF0YVRhYmxlXG4gKiBAcGFyYW0gZGF0YVRhYmxlXG4gKiBAcGFyYW0gY29sdW1uc1xuICogQHBhcmFtIGl0ZW1cbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9hcHBlbmRSb3cgPSBmdW5jdGlvbiAoZGF0YVRhYmxlLCBjb2x1bW5zLCBpdGVtKSB7XG4gIHZhciByb3cgPSBkYXRhVGFibGUuYWRkUm93KCk7XG5cbiAgZm9yICh2YXIgY29sID0gMCwgY29scyA9IGNvbHVtbnMubGVuZ3RoOyBjb2wgPCBjb2xzOyBjb2wrKykge1xuICAgIHZhciBmaWVsZCA9IGNvbHVtbnNbY29sXTtcbiAgICBkYXRhVGFibGUuc2V0VmFsdWUocm93LCBjb2wsIGl0ZW1bZmllbGRdKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU2V0O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBEYXRhU2V0ID0gcmVxdWlyZSgnLi9EYXRhU2V0Jyk7XG5cbi8qKlxuICogRGF0YVZpZXdcbiAqXG4gKiBhIGRhdGF2aWV3IG9mZmVycyBhIGZpbHRlcmVkIHZpZXcgb24gYSBkYXRhc2V0IG9yIGFuIG90aGVyIGRhdGF2aWV3LlxuICpcbiAqIEBwYXJhbSB7RGF0YVNldCB8IERhdGFWaWV3fSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgQXZhaWxhYmxlIG9wdGlvbnM6IHNlZSBtZXRob2QgZ2V0XG4gKlxuICogQGNvbnN0cnVjdG9yIERhdGFWaWV3XG4gKi9cbmZ1bmN0aW9uIERhdGFWaWV3IChkYXRhLCBvcHRpb25zKSB7XG4gIHRoaXMuX2RhdGEgPSBudWxsO1xuICB0aGlzLl9pZHMgPSB7fTsgLy8gaWRzIG9mIHRoZSBpdGVtcyBjdXJyZW50bHkgaW4gbWVtb3J5IChqdXN0IGNvbnRhaW5zIGEgYm9vbGVhbiB0cnVlKVxuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fZmllbGRJZCA9ICdpZCc7IC8vIG5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgaWRcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTsgLy8gZXZlbnQgc3Vic2NyaWJlcnNcblxuICB2YXIgbWUgPSB0aGlzO1xuICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgIG1lLl9vbkV2ZW50LmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHRoaXMuc2V0RGF0YShkYXRhKTtcbn1cblxuLy8gVE9ETzogaW1wbGVtZW50IGEgZnVuY3Rpb24gLmNvbmZpZygpIHRvIGR5bmFtaWNhbGx5IHVwZGF0ZSB0aGluZ3MgbGlrZSBjb25maWd1cmVkIGZpbHRlclxuLy8gYW5kIHRyaWdnZXIgY2hhbmdlcyBhY2NvcmRpbmdseVxuXG4vKipcbiAqIFNldCBhIGRhdGEgc291cmNlIGZvciB0aGUgdmlld1xuICogQHBhcmFtIHtEYXRhU2V0IHwgRGF0YVZpZXd9IGRhdGFcbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgaWRzLCBpLCBsZW47XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICAgIGlmICh0aGlzLl9kYXRhLnVuc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLl9kYXRhLnVuc3Vic2NyaWJlKCcqJywgdGhpcy5saXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBhIHJlbW92ZSBvZiBhbGwgaXRlbXMgaW4gbWVtb3J5XG4gICAgaWRzID0gW107XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5faWRzKSB7XG4gICAgICBpZiAodGhpcy5faWRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBpZHMucHVzaChpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2lkcyA9IHt9O1xuICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHtpdGVtczogaWRzfSk7XG4gIH1cblxuICB0aGlzLl9kYXRhID0gZGF0YTtcblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIC8vIHVwZGF0ZSBmaWVsZElkXG4gICAgdGhpcy5fZmllbGRJZCA9IHRoaXMuX29wdGlvbnMuZmllbGRJZCB8fFxuICAgICAgICAodGhpcy5fZGF0YSAmJiB0aGlzLl9kYXRhLm9wdGlvbnMgJiYgdGhpcy5fZGF0YS5vcHRpb25zLmZpZWxkSWQpIHx8XG4gICAgICAgICdpZCc7XG5cbiAgICAvLyB0cmlnZ2VyIGFuIGFkZCBvZiBhbGwgYWRkZWQgaXRlbXNcbiAgICBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7ZmlsdGVyOiB0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMuZmlsdGVyfSk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZCA9IGlkc1tpXTtcbiAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7aXRlbXM6IGlkc30pO1xuXG4gICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgaWYgKHRoaXMuX2RhdGEub24pIHtcbiAgICAgIHRoaXMuX2RhdGEub24oJyonLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGRhdGEgZnJvbSB0aGUgZGF0YSB2aWV3XG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAgIGdldCgpXG4gKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdClcbiAqICAgICBnZXQob3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAqXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIpXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIsIG9wdGlvbnM6IE9iamVjdClcbiAqICAgICBnZXQoaWQ6IE51bWJlciwgb3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAqXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10pXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10sIG9wdGlvbnM6IE9iamVjdClcbiAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSwgb3B0aW9uczogT2JqZWN0LCBkYXRhOiBBcnJheSB8IERhdGFUYWJsZSlcbiAqXG4gKiBXaGVyZTpcbiAqXG4gKiB7TnVtYmVyIHwgU3RyaW5nfSBpZCAgICAgICAgIFRoZSBpZCBvZiBhbiBpdGVtXG4gKiB7TnVtYmVyW10gfCBTdHJpbmd7fX0gaWRzICAgIEFuIGFycmF5IHdpdGggaWRzIG9mIGl0ZW1zXG4gKiB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBbdHlwZV0gVHlwZSBvZiBkYXRhIHRvIGJlIHJldHVybmVkLiBDYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlICdEYXRhVGFibGUnIG9yICdBcnJheScgKGRlZmF1bHQpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW2NvbnZlcnRdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmdbXX0gW2ZpZWxkc10gZmllbGQgbmFtZXMgdG8gYmUgcmV0dXJuZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICoge0FycmF5IHwgRGF0YVRhYmxlfSBbZGF0YV0gICBJZiBwcm92aWRlZCwgaXRlbXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5IG9yIHRhYmxlLiBSZXF1aXJlZCBpbiBjYXNlIG9mIEdvb2dsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXRhVGFibGUuXG4gKiBAcGFyYW0gYXJnc1xuICovXG5EYXRhVmlldy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG4gIHZhciBpZHMsIG9wdGlvbnMsIGRhdGE7XG4gIHZhciBmaXJzdFR5cGUgPSB1dGlsLmdldFR5cGUoYXJndW1lbnRzWzBdKTtcbiAgaWYgKGZpcnN0VHlwZSA9PSAnU3RyaW5nJyB8fCBmaXJzdFR5cGUgPT0gJ051bWJlcicgfHwgZmlyc3RUeXBlID09ICdBcnJheScpIHtcbiAgICAvLyBnZXQoaWQocykgWywgb3B0aW9uc10gWywgZGF0YV0pXG4gICAgaWRzID0gYXJndW1lbnRzWzBdOyAgLy8gY2FuIGJlIGEgc2luZ2xlIGlkIG9yIGFuIGFycmF5IHdpdGggaWRzXG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICBkYXRhID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGdldChbLCBvcHRpb25zXSBbLCBkYXRhXSlcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzBdO1xuICAgIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gIH1cblxuICAvLyBleHRlbmQgdGhlIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zIGFuZCBwcm92aWRlZCBvcHRpb25zXG4gIHZhciB2aWV3T3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcblxuICAvLyBjcmVhdGUgYSBjb21iaW5lZCBmaWx0ZXIgbWV0aG9kIHdoZW4gbmVlZGVkXG4gIGlmICh0aGlzLl9vcHRpb25zLmZpbHRlciAmJiBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgdmlld09wdGlvbnMuZmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBtZS5fb3B0aW9ucy5maWx0ZXIoaXRlbSkgJiYgb3B0aW9ucy5maWx0ZXIoaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYnVpbGQgdXAgdGhlIGNhbGwgdG8gdGhlIGxpbmtlZCBkYXRhIHNldFxuICB2YXIgZ2V0QXJndW1lbnRzID0gW107XG4gIGlmIChpZHMgIT0gdW5kZWZpbmVkKSB7XG4gICAgZ2V0QXJndW1lbnRzLnB1c2goaWRzKTtcbiAgfVxuICBnZXRBcmd1bWVudHMucHVzaCh2aWV3T3B0aW9ucyk7XG4gIGdldEFyZ3VtZW50cy5wdXNoKGRhdGEpO1xuXG4gIHJldHVybiB0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEuZ2V0LmFwcGx5KHRoaXMuX2RhdGEsIGdldEFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIEdldCBpZHMgb2YgYWxsIGl0ZW1zIG9yIGZyb20gYSBmaWx0ZXJlZCBzZXQgb2YgaXRlbXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gaWRzXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5nZXRJZHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgaWRzO1xuXG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgdmFyIGRlZmF1bHRGaWx0ZXIgPSB0aGlzLl9vcHRpb25zLmZpbHRlcjtcbiAgICB2YXIgZmlsdGVyO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9ucy5maWx0ZXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyO1xuICAgIH1cblxuICAgIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgb3JkZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlclxuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGlkcyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGlkcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBEYXRhU2V0IHRvIHdoaWNoIHRoaXMgRGF0YVZpZXcgaXMgY29ubmVjdGVkLiBJbiBjYXNlIHRoZXJlIGlzIGEgY2hhaW5cbiAqIG9mIG11bHRpcGxlIERhdGFWaWV3cywgdGhlIHJvb3QgRGF0YVNldCBvZiB0aGlzIGNoYWluIGlzIHJldHVybmVkLlxuICogQHJldHVybiB7RGF0YVNldH0gZGF0YVNldFxuICovXG5EYXRhVmlldy5wcm90b3R5cGUuZ2V0RGF0YVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGFTZXQgPSB0aGlzO1xuICB3aGlsZSAoZGF0YVNldCBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgZGF0YVNldCA9IGRhdGFTZXQuX2RhdGE7XG4gIH1cbiAgcmV0dXJuIGRhdGFTZXQgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogRXZlbnQgbGlzdGVuZXIuIFdpbGwgcHJvcGFnYXRlIGFsbCBldmVudHMgZnJvbSB0aGUgY29ubmVjdGVkIGRhdGEgc2V0IHRvXG4gKiB0aGUgc3Vic2NyaWJlcnMgb2YgdGhlIERhdGFWaWV3LCBidXQgd2lsbCBmaWx0ZXIgdGhlIGl0ZW1zIGFuZCBvbmx5IHRyaWdnZXJcbiAqIHdoZW4gdGhlcmUgYXJlIGNoYW5nZXMgaW4gdGhlIGZpbHRlcmVkIGRhdGEgc2V0LlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IHNlbmRlcklkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhVmlldy5wcm90b3R5cGUuX29uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgdmFyIGksIGxlbiwgaWQsIGl0ZW0sXG4gICAgICBpZHMgPSBwYXJhbXMgJiYgcGFyYW1zLml0ZW1zLFxuICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBhZGRlZCA9IFtdLFxuICAgICAgdXBkYXRlZCA9IFtdLFxuICAgICAgcmVtb3ZlZCA9IFtdO1xuXG4gIGlmIChpZHMgJiYgZGF0YSkge1xuICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgIC8vIGZpbHRlciB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtc1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgICBpdGVtID0gdGhpcy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGFkZGVkLnB1c2goaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGV2ZW50IGZyb20gdGhlIHZpZXdzIHZpZXdwb2ludDogYW4gdXBkYXRlZFxuICAgICAgICAvLyBpdGVtIGNhbiBiZSBhZGRlZCwgdXBkYXRlZCwgb3IgcmVtb3ZlZCBmcm9tIHRoaXMgdmlldy5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgaXRlbSA9IHRoaXMuZ2V0KGlkKTtcblxuICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faWRzW2lkXSkge1xuICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICBhZGRlZC5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faWRzW2lkXSkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faWRzW2lkXTtcbiAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBub3RoaW5nIGludGVyZXN0aW5nIGZvciBtZSA6LShcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIHJlbW92ZWQgaXRlbXNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7aXRlbXM6IGFkZGVkfSwgc2VuZGVySWQpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ3VwZGF0ZScsIHtpdGVtczogdXBkYXRlZH0sIHNlbmRlcklkKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7aXRlbXM6IHJlbW92ZWR9LCBzZW5kZXJJZCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBjb3B5IHN1YnNjcmlwdGlvbiBmdW5jdGlvbmFsaXR5IGZyb20gRGF0YVNldFxuRGF0YVZpZXcucHJvdG90eXBlLm9uID0gRGF0YVNldC5wcm90b3R5cGUub247XG5EYXRhVmlldy5wcm90b3R5cGUub2ZmID0gRGF0YVNldC5wcm90b3R5cGUub2ZmO1xuRGF0YVZpZXcucHJvdG90eXBlLl90cmlnZ2VyID0gRGF0YVNldC5wcm90b3R5cGUuX3RyaWdnZXI7XG5cbi8vIFRPRE86IG1ha2UgdGhlc2UgZnVuY3Rpb25zIGRlcHJlY2F0ZWQgKHJlcGxhY2VkIHdpdGggYG9uYCBhbmQgYG9mZmAgc2luY2UgdmVyc2lvbiAwLjUpXG5EYXRhVmlldy5wcm90b3R5cGUuc3Vic2NyaWJlID0gRGF0YVZpZXcucHJvdG90eXBlLm9uO1xuRGF0YVZpZXcucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gRGF0YVZpZXcucHJvdG90eXBlLm9mZjtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldzsiLCJ2YXIgSGFtbWVyID0gcmVxdWlyZSgnLi9tb2R1bGUvaGFtbWVyJyk7XG5cbi8qKlxuICogRmFrZSBhIGhhbW1lci5qcyBnZXN0dXJlLiBFdmVudCBjYW4gYmUgYSBTY3JvbGxFdmVudCBvciBNb3VzZU1vdmVFdmVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICovXG5leHBvcnRzLmZha2VHZXN0dXJlID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQpIHtcbiAgdmFyIGV2ZW50VHlwZSA9IG51bGw7XG5cbiAgLy8gZm9yIGhhbW1lci5qcyAxLjAuNVxuICAvLyB2YXIgZ2VzdHVyZSA9IEhhbW1lci5ldmVudC5jb2xsZWN0RXZlbnREYXRhKHRoaXMsIGV2ZW50VHlwZSwgZXZlbnQpO1xuXG4gIC8vIGZvciBoYW1tZXIuanMgMS4wLjYrXG4gIHZhciB0b3VjaGVzID0gSGFtbWVyLmV2ZW50LmdldFRvdWNoTGlzdChldmVudCwgZXZlbnRUeXBlKTtcbiAgdmFyIGdlc3R1cmUgPSBIYW1tZXIuZXZlbnQuY29sbGVjdEV2ZW50RGF0YSh0aGlzLCBldmVudFR5cGUsIHRvdWNoZXMsIGV2ZW50KTtcblxuICAvLyBvbiBJRSBpbiBzdGFuZGFyZHMgbW9kZSwgbm8gdG91Y2hlcyBhcmUgcmVjb2duaXplZCBieSBoYW1tZXIuanMsXG4gIC8vIHJlc3VsdGluZyBpbiBOYU4gdmFsdWVzIGZvciBjZW50ZXIucGFnZVggYW5kIGNlbnRlci5wYWdlWVxuICBpZiAoaXNOYU4oZ2VzdHVyZS5jZW50ZXIucGFnZVgpKSB7XG4gICAgZ2VzdHVyZS5jZW50ZXIucGFnZVggPSBldmVudC5wYWdlWDtcbiAgfVxuICBpZiAoaXNOYU4oZ2VzdHVyZS5jZW50ZXIucGFnZVkpKSB7XG4gICAgZ2VzdHVyZS5jZW50ZXIucGFnZVkgPSBldmVudC5wYWdlWTtcbiAgfVxuXG4gIHJldHVybiBnZXN0dXJlO1xufTtcbiIsIi8vIE9ubHkgbG9hZCBoYW1tZXIuanMgd2hlbiBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbi8vIChsb2FkaW5nIGhhbW1lci5qcyBpbiBhIG5vZGUuanMgZW52aXJvbm1lbnQgZ2l2ZXMgZXJyb3JzKVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gd2luZG93WydIYW1tZXInXSB8fCByZXF1aXJlKCdoYW1tZXJqcycpO1xufVxuZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IEVycm9yKCdoYW1tZXIuanMgaXMgb25seSBhdmFpbGFibGUgaW4gYSBicm93c2VyLCBub3QgaW4gbm9kZS5qcy4nKTtcbiAgfVxufVxuIiwiLy8gZmlyc3QgY2hlY2sgaWYgbW9tZW50LmpzIGlzIGFscmVhZHkgbG9hZGVkIGluIHRoZSBicm93c2VyIHdpbmRvdywgaWYgc28sXG4vLyB1c2UgdGhpcyBpbnN0YW5jZS4gRWxzZSwgbG9hZCB2aWEgY29tbW9uanMuXG5tb2R1bGUuZXhwb3J0cyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgJiYgd2luZG93Wydtb21lbnQnXSB8fCByZXF1aXJlKCdtb21lbnQnKTtcbiIsInZhciBtb3VzZXRyYXAgPSByZXF1aXJlKCdtb3VzZXRyYXAnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlci1jb21wb25lbnQnKTtcbnZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuLyoqXG4gKiBUdXJuIGFuIGVsZW1lbnQgaW50byBhbiBjbGlja1RvVXNlIGVsZW1lbnQuXG4gKiBXaGVuIG5vdCBhY3RpdmUsIHRoZSBlbGVtZW50IGhhcyBhIHRyYW5zcGFyZW50IG92ZXJsYXkuIFdoZW4gdGhlIG92ZXJsYXkgaXNcbiAqIGNsaWNrZWQsIHRoZSBtb2RlIGlzIGNoYW5nZWQgdG8gYWN0aXZlLlxuICogV2hlbiBhY3RpdmUsIHRoZSBlbGVtZW50IGlzIGRpc3BsYXllZCB3aXRoIGEgYmx1ZSBib3JkZXIgYXJvdW5kIGl0LCBhbmRcbiAqIHRoZSBpbnRlcmFjdGl2ZSBjb250ZW50cyBvZiB0aGUgZWxlbWVudCBjYW4gYmUgdXNlZC4gV2hlbiBjbGlja2VkIG91dHNpZGVcbiAqIHRoZSBlbGVtZW50LCB0aGUgZWxlbWVudHMgbW9kZSBpcyBjaGFuZ2VkIHRvIGluYWN0aXZlLlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBY3RpdmF0b3IoY29udGFpbmVyKSB7XG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5kb20gPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgfTtcblxuICB0aGlzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLm92ZXJsYXkuY2xhc3NOYW1lID0gJ292ZXJsYXknO1xuXG4gIHRoaXMuZG9tLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5vdmVybGF5KTtcblxuICB0aGlzLmhhbW1lciA9IEhhbW1lcih0aGlzLmRvbS5vdmVybGF5LCB7cHJldmVudF9kZWZhdWx0OiBmYWxzZX0pO1xuICB0aGlzLmhhbW1lci5vbigndGFwJywgdGhpcy5fb25UYXBPdmVybGF5LmJpbmQodGhpcykpO1xuXG4gIC8vIGJsb2NrIGFsbCB0b3VjaCBldmVudHMgKGV4Y2VwdCB0YXApXG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBldmVudHMgPSBbXG4gICAgJ3RvdWNoJywgJ3BpbmNoJyxcbiAgICAnZG91YmxldGFwJywgJ2hvbGQnLFxuICAgICdkcmFnc3RhcnQnLCAnZHJhZycsICdkcmFnZW5kJyxcbiAgICAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcgLy8gRE9NTW91c2VTY3JvbGwgaXMgbmVlZGVkIGZvciBGaXJlZm94XG4gIF07XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIG1lLmhhbW1lci5vbihldmVudCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gYXR0YWNoIGEgdGFwIGV2ZW50IHRvIHRoZSB3aW5kb3csIGluIG9yZGVyIHRvIGRlYWN0aXZhdGUgd2hlbiBjbGlja2luZyBvdXRzaWRlIHRoZSB0aW1lbGluZVxuICB0aGlzLndpbmRvd0hhbW1lciA9IEhhbW1lcih3aW5kb3csIHtwcmV2ZW50X2RlZmF1bHQ6IGZhbHNlfSk7XG4gIHRoaXMud2luZG93SGFtbWVyLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBkZWFjdGl2YXRlIHdoZW4gY2xpY2tlZCBvdXRzaWRlIHRoZSBjb250YWluZXJcbiAgICBpZiAoIV9oYXNQYXJlbnQoZXZlbnQudGFyZ2V0LCBjb250YWluZXIpKSB7XG4gICAgICBtZS5kZWFjdGl2YXRlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBtb3VzZXRyYXAgbGlzdGVuZXIgb25seSBib3VuZGVkIHdoZW4gYWN0aXZlKVxuICB0aGlzLmVzY0xpc3RlbmVyID0gdGhpcy5kZWFjdGl2YXRlLmJpbmQodGhpcyk7XG59XG5cbi8vIHR1cm4gaW50byBhbiBldmVudCBlbWl0dGVyXG5FbWl0dGVyKEFjdGl2YXRvci5wcm90b3R5cGUpO1xuXG4vLyBUaGUgY3VycmVudGx5IGFjdGl2ZSBhY3RpdmF0b3JcbkFjdGl2YXRvci5jdXJyZW50ID0gbnVsbDtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBhY3RpdmF0b3IuIENsZWFucyB1cCBhbGwgY3JlYXRlZCBET00gYW5kIGV2ZW50IGxpc3RlbmVyc1xuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGVhY3RpdmF0ZSgpO1xuXG4gIC8vIHJlbW92ZSBkb21cbiAgdGhpcy5kb20ub3ZlcmxheS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLm92ZXJsYXkpO1xuXG4gIC8vIGNsZWFudXAgaGFtbWVyIGluc3RhbmNlc1xuICB0aGlzLmhhbW1lciA9IG51bGw7XG4gIHRoaXMud2luZG93SGFtbWVyID0gbnVsbDtcbiAgLy8gRklYTUU6IGNsZWFuaW5nIHVwIGhhbW1lciBpbnN0YW5jZXMgZG9lc24ndCB3b3JrIChUaW1lbGluZSBub3QgcmVtb3ZlZCBmcm9tIG1lbW9yeSlcbn07XG5cbi8qKlxuICogQWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAqIE92ZXJsYXkgaXMgaGlkZGVuLCBlbGVtZW50IGlzIGRlY29yYXRlZCB3aXRoIGEgYmx1ZSBzaGFkb3cgYm9yZGVyXG4gKi9cbkFjdGl2YXRvci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHdlIGFsbG93IG9ubHkgb25lIGFjdGl2ZSBhY3RpdmF0b3IgYXQgYSB0aW1lXG4gIGlmIChBY3RpdmF0b3IuY3VycmVudCkge1xuICAgIEFjdGl2YXRvci5jdXJyZW50LmRlYWN0aXZhdGUoKTtcbiAgfVxuICBBY3RpdmF0b3IuY3VycmVudCA9IHRoaXM7XG5cbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmNvbnRhaW5lciwgJ3Zpcy1hY3RpdmUnKTtcblxuICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICB0aGlzLmVtaXQoJ2FjdGl2YXRlJyk7XG5cbiAgLy8gdWdseSBoYWNrOiBiaW5kIEVTQyBhZnRlciBlbWl0dGluZyB0aGUgZXZlbnRzLCBhcyB0aGUgTmV0d29yayByZWJpbmRzIGFsbFxuICAvLyBrZXlib2FyZCBldmVudHMgb24gYSAnY2hhbmdlJyBldmVudFxuICBtb3VzZXRyYXAuYmluZCgnZXNjJywgdGhpcy5lc2NMaXN0ZW5lcik7XG59O1xuXG4vKipcbiAqIERlYWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAqIE92ZXJsYXkgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgZWxlbWVudFxuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIHRoaXMuZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICcnO1xuICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5jb250YWluZXIsICd2aXMtYWN0aXZlJyk7XG4gIG1vdXNldHJhcC51bmJpbmQoJ2VzYycsIHRoaXMuZXNjTGlzdGVuZXIpO1xuXG4gIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gIHRoaXMuZW1pdCgnZGVhY3RpdmF0ZScpO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYSB0YXAgZXZlbnQ6IGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAqIEBwYXJhbSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQWN0aXZhdG9yLnByb3RvdHlwZS5fb25UYXBPdmVybGF5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAgdGhpcy5hY3RpdmF0ZSgpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgcmVxdWVzdGVkIHBhcmVudCBlbGVtZW50IHNvbWV3aGVyZSBpblxuICogaXRzIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBwYXJlbnQgaXMgZm91bmQgc29tZXdoZXJlIGluIHRoZVxuICogICAgICAgICAgICAgICAgICAgIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9oYXNQYXJlbnQoZWxlbWVudCwgcGFyZW50KSB7XG4gIHdoaWxlIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWN0aXZhdG9yO1xuIiwidmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdlbWl0dGVyLWNvbXBvbmVudCcpO1xudmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIERhdGFTZXQgPSByZXF1aXJlKCcuLi9EYXRhU2V0Jyk7XG52YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuLi9EYXRhVmlldycpO1xudmFyIFJhbmdlID0gcmVxdWlyZSgnLi9SYW5nZScpO1xudmFyIFRpbWVBeGlzID0gcmVxdWlyZSgnLi9jb21wb25lbnQvVGltZUF4aXMnKTtcbnZhciBDdXJyZW50VGltZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50L0N1cnJlbnRUaW1lJyk7XG52YXIgQ3VzdG9tVGltZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50L0N1c3RvbVRpbWUnKTtcbnZhciBJdGVtU2V0ID0gcmVxdWlyZSgnLi9jb21wb25lbnQvSXRlbVNldCcpO1xudmFyIEFjdGl2YXRvciA9IHJlcXVpcmUoJy4uL3NoYXJlZC9BY3RpdmF0b3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYSB0aW1lbGluZSB2aXN1YWxpemF0aW9uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCBBcnJheSB8IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhdGFUYWJsZX0gW2l0ZW1zXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgU2VlIENvcmUuc2V0T3B0aW9ucyBmb3IgdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvcmUgKCkge31cblxuLy8gdHVybiBDb3JlIGludG8gYW4gZXZlbnQgZW1pdHRlclxuRW1pdHRlcihDb3JlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtYWluIERPTSBmb3IgdGhlIENvcmU6IGEgcm9vdCBwYW5lbCBjb250YWluaW5nIGxlZnQsIHJpZ2h0LFxuICogdG9wLCBib3R0b20sIGNvbnRlbnQsIGFuZCBiYWNrZ3JvdW5kIHBhbmVsLlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgIFRoZSBjb250YWluZXIgZWxlbWVudCB3aGVyZSB0aGUgQ29yZSB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgYXR0YWNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICB0aGlzLmRvbSA9IHt9O1xuXG4gIHRoaXMuZG9tLnJvb3QgICAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmRWZXJ0aWNhbCAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lciAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmxlZnRDb250YWluZXIgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmNlbnRlciAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmxlZnQgICAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnJpZ2h0ICAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnRvcCAgICAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJvdHRvbSAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd1RvcCAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd0JvdHRvbSAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd1RvcExlZnQgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd0JvdHRvbUxlZnQgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd1RvcFJpZ2h0ICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLnNoYWRvd0JvdHRvbVJpZ2h0ICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgdGhpcy5kb20ucm9vdC5jbGFzc05hbWUgICAgICAgICAgICAgICAgID0gJ3ZpcyB0aW1lbGluZSByb290JztcbiAgdGhpcy5kb20uYmFja2dyb3VuZC5jbGFzc05hbWUgICAgICAgICAgID0gJ3Zpc3BhbmVsIGJhY2tncm91bmQnO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuY2xhc3NOYW1lICAgPSAndmlzcGFuZWwgYmFja2dyb3VuZCB2ZXJ0aWNhbCc7XG4gIHRoaXMuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLmNsYXNzTmFtZSA9ICd2aXNwYW5lbCBiYWNrZ3JvdW5kIGhvcml6b250YWwnO1xuICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuY2xhc3NOYW1lICAgICAgPSAndmlzcGFuZWwgY2VudGVyJztcbiAgdGhpcy5kb20ubGVmdENvbnRhaW5lci5jbGFzc05hbWUgICAgICAgID0gJ3Zpc3BhbmVsIGxlZnQnO1xuICB0aGlzLmRvbS5yaWdodENvbnRhaW5lci5jbGFzc05hbWUgICAgICAgPSAndmlzcGFuZWwgcmlnaHQnO1xuICB0aGlzLmRvbS50b3AuY2xhc3NOYW1lICAgICAgICAgICAgICAgICAgPSAndmlzcGFuZWwgdG9wJztcbiAgdGhpcy5kb20uYm90dG9tLmNsYXNzTmFtZSAgICAgICAgICAgICAgID0gJ3Zpc3BhbmVsIGJvdHRvbSc7XG4gIHRoaXMuZG9tLmxlZnQuY2xhc3NOYW1lICAgICAgICAgICAgICAgICA9ICdjb250ZW50JztcbiAgdGhpcy5kb20uY2VudGVyLmNsYXNzTmFtZSAgICAgICAgICAgICAgID0gJ2NvbnRlbnQnO1xuICB0aGlzLmRvbS5yaWdodC5jbGFzc05hbWUgICAgICAgICAgICAgICAgPSAnY29udGVudCc7XG4gIHRoaXMuZG9tLnNoYWRvd1RvcC5jbGFzc05hbWUgICAgICAgICAgICA9ICdzaGFkb3cgdG9wJztcbiAgdGhpcy5kb20uc2hhZG93Qm90dG9tLmNsYXNzTmFtZSAgICAgICAgID0gJ3NoYWRvdyBib3R0b20nO1xuICB0aGlzLmRvbS5zaGFkb3dUb3BMZWZ0LmNsYXNzTmFtZSAgICAgICAgPSAnc2hhZG93IHRvcCc7XG4gIHRoaXMuZG9tLnNoYWRvd0JvdHRvbUxlZnQuY2xhc3NOYW1lICAgICA9ICdzaGFkb3cgYm90dG9tJztcbiAgdGhpcy5kb20uc2hhZG93VG9wUmlnaHQuY2xhc3NOYW1lICAgICAgID0gJ3NoYWRvdyB0b3AnO1xuICB0aGlzLmRvbS5zaGFkb3dCb3R0b21SaWdodC5jbGFzc05hbWUgICAgPSAnc2hhZG93IGJvdHRvbSc7XG5cbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kKTtcbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kVmVydGljYWwpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsKTtcbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5jZW50ZXJDb250YWluZXIpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmxlZnRDb250YWluZXIpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyKTtcbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS50b3ApO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmJvdHRvbSk7XG5cbiAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLmNlbnRlcik7XG4gIHRoaXMuZG9tLmxlZnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ubGVmdCk7XG4gIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnJpZ2h0KTtcblxuICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93VG9wKTtcbiAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd0JvdHRvbSk7XG4gIHRoaXMuZG9tLmxlZnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93VG9wTGVmdCk7XG4gIHRoaXMuZG9tLmxlZnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93Qm90dG9tTGVmdCk7XG4gIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd1RvcFJpZ2h0KTtcbiAgdGhpcy5kb20ucmlnaHRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93Qm90dG9tUmlnaHQpO1xuXG4gIHRoaXMub24oJ3JhbmdlY2hhbmdlJywgdGhpcy5yZWRyYXcuYmluZCh0aGlzKSk7XG4gIHRoaXMub24oJ2NoYW5nZScsIHRoaXMucmVkcmF3LmJpbmQodGhpcykpO1xuICB0aGlzLm9uKCd0b3VjaCcsIHRoaXMuX29uVG91Y2guYmluZCh0aGlzKSk7XG4gIHRoaXMub24oJ3BpbmNoJywgdGhpcy5fb25QaW5jaC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5vbignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gIHRoaXMub24oJ2RyYWcnLCB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG5cbiAgLy8gY3JlYXRlIGV2ZW50IGxpc3RlbmVycyBmb3IgYWxsIGludGVyZXN0aW5nIGV2ZW50cywgdGhlc2UgZXZlbnRzIHdpbGwgYmVcbiAgLy8gZW1pdHRlZCB2aWEgZW1pdHRlclxuICB0aGlzLmhhbW1lciA9IEhhbW1lcih0aGlzLmRvbS5yb290LCB7XG4gICAgcHJldmVudERlZmF1bHQ6IHRydWVcbiAgfSk7XG4gIHRoaXMubGlzdGVuZXJzID0ge307XG5cbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIGV2ZW50cyA9IFtcbiAgICAndG91Y2gnLCAncGluY2gnLFxuICAgICd0YXAnLCAnZG91YmxldGFwJywgJ2hvbGQnLFxuICAgICdkcmFnc3RhcnQnLCAnZHJhZycsICdkcmFnZW5kJyxcbiAgICAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcgLy8gRE9NTW91c2VTY3JvbGwgaXMgbmVlZGVkIGZvciBGaXJlZm94XG4gIF07XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW2V2ZW50XS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgICBpZiAobWUuaXNBY3RpdmUoKSkge1xuICAgICAgICBtZS5lbWl0LmFwcGx5KG1lLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1lLmhhbW1lci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIG1lLmxpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcjtcbiAgfSk7XG5cbiAgLy8gc2l6ZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2YgdGhlIHBhbmVsc1xuICB0aGlzLnByb3BzID0ge1xuICAgIHJvb3Q6IHt9LFxuICAgIGJhY2tncm91bmQ6IHt9LFxuICAgIGNlbnRlckNvbnRhaW5lcjoge30sXG4gICAgbGVmdENvbnRhaW5lcjoge30sXG4gICAgcmlnaHRDb250YWluZXI6IHt9LFxuICAgIGNlbnRlcjoge30sXG4gICAgbGVmdDoge30sXG4gICAgcmlnaHQ6IHt9LFxuICAgIHRvcDoge30sXG4gICAgYm90dG9tOiB7fSxcbiAgICBib3JkZXI6IHt9LFxuICAgIHNjcm9sbFRvcDogMCxcbiAgICBzY3JvbGxUb3BNaW46IDBcbiAgfTtcbiAgdGhpcy50b3VjaCA9IHt9OyAvLyBzdG9yZSBzdGF0ZSBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIHRvdWNoIGV2ZW50c1xuXG4gIC8vIGF0dGFjaCB0aGUgcm9vdCBwYW5lbCB0byB0aGUgcHJvdmlkZWQgY29udGFpbmVyXG4gIGlmICghY29udGFpbmVyKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRhaW5lciBwcm92aWRlZCcpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ucm9vdCk7XG59O1xuXG4vKipcbiAqIFNldCBvcHRpb25zLiBPcHRpb25zIHdpbGwgYmUgcGFzc2VkIHRvIGFsbCBjb21wb25lbnRzIGxvYWRlZCBpbiB0aGUgVGltZWxpbmUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG9yaWVudGF0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2FsIG9yaWVudGF0aW9uIGZvciB0aGUgVGltZWxpbmUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbiBiZSAnYm90dG9tJyAoZGVmYXVsdCkgb3IgJ3RvcCcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IHdpZHRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdpZHRoIGZvciB0aGUgdGltZWxpbmUsIGEgbnVtYmVyIGluIHBpeGVscyBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGNzcyBzdHJpbmcgbGlrZSAnMTAwMHB4JyBvciAnNzUlJy4gJzEwMCUnIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IGhlaWdodFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXhlZCBoZWlnaHQgZm9yIHRoZSBUaW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgY3NzIHN0cmluZyBsaWtlICc0MDBweCcgb3IgJzc1JScuIElmIHVuZGVmaW5lZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIFRpbWVsaW5lIHdpbGwgYXV0b21hdGljYWxseSBzaXplIHN1Y2ggdGhhdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdHMgY29udGVudHMgZml0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgTnVtYmVyfSBtaW5IZWlnaHRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWluaW11bSBoZWlnaHQgZm9yIHRoZSBUaW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgY3NzIHN0cmluZyBsaWtlICc0MDBweCcgb3IgJzc1JScuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IG1heEhlaWdodFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXhpbXVtIGhlaWdodCBmb3IgdGhlIFRpbWVsaW5lLCBhIG51bWJlciBpbiBwaXhlbHMgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzQwMHB4JyBvciAnNzUlJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlciB8IERhdGUgfCBTdHJpbmd9IHN0YXJ0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0YXJ0IGRhdGUgZm9yIHRoZSB2aXNpYmxlIHdpbmRvd1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyIHwgRGF0ZSB8IFN0cmluZ30gZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZCBkYXRlIGZvciB0aGUgdmlzaWJsZSB3aW5kb3dcbiAqL1xuQ29yZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSB0aGUga25vd24gb3B0aW9uc1xuICAgIHZhciBmaWVsZHMgPSBbJ3dpZHRoJywgJ2hlaWdodCcsICdtaW5IZWlnaHQnLCAnbWF4SGVpZ2h0JywgJ2F1dG9SZXNpemUnLCAnc3RhcnQnLCAnZW5kJywgJ29yaWVudGF0aW9uJywgJ2NsaWNrVG9Vc2UnLCAnZGF0YUF0dHJpYnV0ZXMnXTtcbiAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ2NsaWNrVG9Vc2UnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UpIHtcbiAgICAgICAgdGhpcy5hY3RpdmF0b3IgPSBuZXcgQWN0aXZhdG9yKHRoaXMuZG9tLnJvb3QpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRvcikge1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlbmFibGUvZGlzYWJsZSBhdXRvUmVzaXplXG4gICAgdGhpcy5faW5pdEF1dG9SZXNpemUoKTtcbiAgfVxuXG4gIC8vIHByb3BhZ2F0ZSBvcHRpb25zIHRvIGFsbCBjb21wb25lbnRzXG4gIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICBjb21wb25lbnQuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfSk7XG5cbiAgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0aW9uIGVycm9yIG9uZSBkYXkgKGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAwLjguMClcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIG9yZGVyIGlzIGRlcHJlY2F0ZWQuIFRoZXJlIGlzIG5vIHJlcGxhY2VtZW50IGZvciB0aGlzIGZlYXR1cmUuJyk7XG4gIH1cblxuICAvLyByZWRyYXcgZXZlcnl0aGluZ1xuICB0aGlzLnJlZHJhdygpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgVGltZWxpbmUgaXMgYWN0aXZlLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkNvcmUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIXRoaXMuYWN0aXZhdG9yIHx8IHRoaXMuYWN0aXZhdG9yLmFjdGl2ZTtcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgQ29yZSwgY2xlYW4gdXAgYWxsIERPTSBlbGVtZW50cyBhbmQgZXZlbnQgbGlzdGVuZXJzLlxuICovXG5Db3JlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAvLyB1bmJpbmQgZGF0YXNldHNcbiAgdGhpcy5jbGVhcigpO1xuXG4gIC8vIHJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gIHRoaXMub2ZmKCk7XG5cbiAgLy8gc3RvcCBjaGVja2luZyBmb3IgY2hhbmdlZCBzaXplXG4gIHRoaXMuX3N0b3BBdXRvUmVzaXplKCk7XG5cbiAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gIGlmICh0aGlzLmRvbS5yb290LnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmRvbS5yb290LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ucm9vdCk7XG4gIH1cbiAgdGhpcy5kb20gPSBudWxsO1xuXG4gIC8vIHJlbW92ZSBBY3RpdmF0b3JcbiAgaWYgKHRoaXMuYWN0aXZhdG9yKSB7XG4gICAgdGhpcy5hY3RpdmF0b3IuZGVzdHJveSgpO1xuICAgIGRlbGV0ZSB0aGlzLmFjdGl2YXRvcjtcbiAgfVxuXG4gIC8vIGNsZWFudXAgaGFtbWVyIHRvdWNoIGV2ZW50c1xuICBmb3IgKHZhciBldmVudCBpbiB0aGlzLmxpc3RlbmVycykge1xuICAgIGlmICh0aGlzLmxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG4gICAgfVxuICB9XG4gIHRoaXMubGlzdGVuZXJzID0gbnVsbDtcbiAgdGhpcy5oYW1tZXIgPSBudWxsO1xuXG4gIC8vIGdpdmUgYWxsIGNvbXBvbmVudHMgdGhlIG9wcG9ydHVuaXR5IHRvIGNsZWFudXBcbiAgdGhpcy5jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudC5kZXN0cm95KCk7XG4gIH0pO1xuXG4gIHRoaXMuYm9keSA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogU2V0IGEgY3VzdG9tIHRpbWUgYmFyXG4gKiBAcGFyYW0ge0RhdGV9IHRpbWVcbiAqL1xuQ29yZS5wcm90b3R5cGUuc2V0Q3VzdG9tVGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gIGlmICghdGhpcy5jdXN0b21UaW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IGN1c3RvbSB0aW1lOiBDdXN0b20gdGltZSBiYXIgaXMgbm90IGVuYWJsZWQnKTtcbiAgfVxuXG4gIHRoaXMuY3VzdG9tVGltZS5zZXRDdXN0b21UaW1lKHRpbWUpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBjdXN0b20gdGltZS5cbiAqIEByZXR1cm4ge0RhdGV9IGN1c3RvbVRpbWVcbiAqL1xuQ29yZS5wcm90b3R5cGUuZ2V0Q3VzdG9tVGltZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY3VzdG9tVGltZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBjdXN0b20gdGltZTogQ3VzdG9tIHRpbWUgYmFyIGlzIG5vdCBlbmFibGVkJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXN0b21UaW1lLmdldEN1c3RvbVRpbWUoKTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGlkJ3Mgb2YgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGl0ZW1zLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgaWRzIG9mIHRoZSB2aXNpYmxlIGl0ZW1zXG4gKi9cbkNvcmUucHJvdG90eXBlLmdldFZpc2libGVJdGVtcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5nZXRWaXNpYmxlSXRlbXMoKSB8fCBbXTtcbn07XG5cblxuXG4vKipcbiAqIENsZWFyIHRoZSBDb3JlLiBCeSBEZWZhdWx0LCBpdGVtcywgZ3JvdXBzIGFuZCBvcHRpb25zIGFyZSBjbGVhcmVkLlxuICogRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgICAgdGltZWxpbmUuY2xlYXIoKTsgICAgICAgICAgICAgICAgLy8gY2xlYXIgaXRlbXMsIGdyb3VwcywgYW5kIG9wdGlvbnNcbiAqICAgICB0aW1lbGluZS5jbGVhcih7b3B0aW9uczogdHJ1ZX0pOyAvLyBjbGVhciBvcHRpb25zIG9ubHlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3doYXRdICAgICAgT3B0aW9uYWxseSBzcGVjaWZ5IHdoYXQgdG8gY2xlYXIuIEJ5IGRlZmF1bHQ6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2l0ZW1zOiB0cnVlLCBncm91cHM6IHRydWUsIG9wdGlvbnM6IHRydWV9XG4gKi9cbkNvcmUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24od2hhdCkge1xuICAvLyBjbGVhciBpdGVtc1xuICBpZiAoIXdoYXQgfHwgd2hhdC5pdGVtcykge1xuICAgIHRoaXMuc2V0SXRlbXMobnVsbCk7XG4gIH1cblxuICAvLyBjbGVhciBncm91cHNcbiAgaWYgKCF3aGF0IHx8IHdoYXQuZ3JvdXBzKSB7XG4gICAgdGhpcy5zZXRHcm91cHMobnVsbCk7XG4gIH1cblxuICAvLyBjbGVhciBvcHRpb25zIG9mIHRpbWVsaW5lIGFuZCBvZiBlYWNoIG9mIHRoZSBjb21wb25lbnRzXG4gIGlmICghd2hhdCB8fCB3aGF0Lm9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICBjb21wb25lbnQuc2V0T3B0aW9ucyhjb21wb25lbnQuZGVmYXVsdE9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKHRoaXMuZGVmYXVsdE9wdGlvbnMpOyAvLyB0aGlzIHdpbGwgYWxzbyBkbyBhIHJlZHJhd1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBDb3JlIHdpbmRvdyBzdWNoIHRoYXQgaXQgZml0cyBhbGwgaXRlbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGU6IGJvb2xlYW4gfCBudW1iZXJgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGEgbnVtYmVyLCB0aGUgbnVtYmVyIGlzIHRha2VuIGFzIGR1cmF0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgYW5pbWF0aW9uLiBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcy5cbiAqL1xuQ29yZS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAvLyBhcHBseSB0aGUgZGF0YSByYW5nZSBhcyByYW5nZVxuICB2YXIgZGF0YVJhbmdlID0gdGhpcy5nZXRJdGVtUmFuZ2UoKTtcblxuICAvLyBhZGQgNSUgc3BhY2Ugb24gYm90aCBzaWRlc1xuICB2YXIgc3RhcnQgPSBkYXRhUmFuZ2UubWluO1xuICB2YXIgZW5kID0gZGF0YVJhbmdlLm1heDtcbiAgaWYgKHN0YXJ0ICE9IG51bGwgJiYgZW5kICE9IG51bGwpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSAoZW5kLnZhbHVlT2YoKSAtIHN0YXJ0LnZhbHVlT2YoKSk7XG4gICAgaWYgKGludGVydmFsIDw9IDApIHtcbiAgICAgIC8vIHByZXZlbnQgYW4gZW1wdHkgaW50ZXJ2YWxcbiAgICAgIGludGVydmFsID0gMjQgKiA2MCAqIDYwICogMTAwMDsgLy8gMSBkYXlcbiAgICB9XG4gICAgc3RhcnQgPSBuZXcgRGF0ZShzdGFydC52YWx1ZU9mKCkgLSBpbnRlcnZhbCAqIDAuMDUpO1xuICAgIGVuZCA9IG5ldyBEYXRlKGVuZC52YWx1ZU9mKCkgKyBpbnRlcnZhbCAqIDAuMDUpO1xuICB9XG5cbiAgLy8gc2tpcCByYW5nZSBzZXQgaWYgdGhlcmUgaXMgbm8gc3RhcnQgYW5kIGVuZCBkYXRlXG4gIGlmIChzdGFydCA9PT0gbnVsbCAmJiBlbmQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYW5pbWF0ZSA9IChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuYW5pbWF0ZSA6IHRydWU7XG4gIHRoaXMucmFuZ2Uuc2V0UmFuZ2Uoc3RhcnQsIGVuZCwgYW5pbWF0ZSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmlzaWJsZSB3aW5kb3cuIEJvdGggcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwsIHlvdSBjYW4gY2hhbmdlIG9ubHlcbiAqIHN0YXJ0IG9yIG9ubHkgZW5kLiBTeW50YXg6XG4gKlxuICogICAgIFRpbWVMaW5lLnNldFdpbmRvdyhzdGFydCwgZW5kKVxuICogICAgIFRpbWVMaW5lLnNldFdpbmRvdyhyYW5nZSlcbiAqXG4gKiBXaGVyZSBzdGFydCBhbmQgZW5kIGNhbiBiZSBhIERhdGUsIG51bWJlciwgb3Igc3RyaW5nLCBhbmQgcmFuZ2UgaXMgYW5cbiAqIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgc3RhcnQgYW5kIGVuZC5cbiAqXG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmcgfCBPYmplY3R9IFtzdGFydF0gU3RhcnQgZGF0ZSBvZiB2aXNpYmxlIHdpbmRvd1xuICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSBbZW5kXSAgICAgICAgICAgIEVuZCBkYXRlIG9mIHZpc2libGUgd2luZG93XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRlOiBib29sZWFuIHwgbnVtYmVyYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIG51bWJlciwgdGhlIG51bWJlciBpcyB0YWtlbiBhcyBkdXJhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdGhlIGFuaW1hdGlvbi4gRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMuXG4gKi9cbkNvcmUucHJvdG90eXBlLnNldFdpbmRvdyA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcbiAgdmFyIGFuaW1hdGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmFuaW1hdGUgOiB0cnVlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgdmFyIHJhbmdlID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMucmFuZ2Uuc2V0UmFuZ2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgYW5pbWF0ZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5yYW5nZS5zZXRSYW5nZShzdGFydCwgZW5kLCBhbmltYXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNb3ZlIHRoZSB3aW5kb3cgc3VjaCB0aGF0IGdpdmVuIHRpbWUgaXMgY2VudGVyZWQgb24gc2NyZWVuLlxuICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSB0aW1lXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRlOiBib29sZWFuIHwgbnVtYmVyYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIG51bWJlciwgdGhlIG51bWJlciBpcyB0YWtlbiBhcyBkdXJhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdGhlIGFuaW1hdGlvbi4gRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMuXG4gKi9cbkNvcmUucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKHRpbWUsIG9wdGlvbnMpIHtcbiAgdmFyIGludGVydmFsID0gdGhpcy5yYW5nZS5lbmQgLSB0aGlzLnJhbmdlLnN0YXJ0O1xuICB2YXIgdCA9IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpLnZhbHVlT2YoKTtcblxuICB2YXIgc3RhcnQgPSB0IC0gaW50ZXJ2YWwgLyAyO1xuICB2YXIgZW5kID0gdCArIGludGVydmFsIC8gMjtcbiAgdmFyIGFuaW1hdGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmFuaW1hdGUgOiB0cnVlO1xuXG4gIHRoaXMucmFuZ2Uuc2V0UmFuZ2Uoc3RhcnQsIGVuZCwgYW5pbWF0ZSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmlzaWJsZSB3aW5kb3dcbiAqIEByZXR1cm4ge3tzdGFydDogRGF0ZSwgZW5kOiBEYXRlfX0gICBWaXNpYmxlIHJhbmdlXG4gKi9cbkNvcmUucHJvdG90eXBlLmdldFdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlLmdldFJhbmdlKCk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IG5ldyBEYXRlKHJhbmdlLnN0YXJ0KSxcbiAgICBlbmQ6IG5ldyBEYXRlKHJhbmdlLmVuZClcbiAgfTtcbn07XG5cbi8qKlxuICogRm9yY2UgYSByZWRyYXcgb2YgdGhlIENvcmUuIENhbiBiZSB1c2VmdWwgdG8gbWFudWFsbHkgcmVkcmF3IHdoZW5cbiAqIG9wdGlvbiBhdXRvUmVzaXplPWZhbHNlXG4gKi9cbkNvcmUucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzaXplZCA9IGZhbHNlLFxuICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgIGRvbSA9IHRoaXMuZG9tO1xuXG4gIGlmICghZG9tKSByZXR1cm47IC8vIHdoZW4gZGVzdHJveWVkXG5cbiAgLy8gdXBkYXRlIGNsYXNzIG5hbWVzXG4gIGlmIChvcHRpb25zLm9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUoZG9tLnJvb3QsICd0b3AnKTtcbiAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZShkb20ucm9vdCwgJ2JvdHRvbScpO1xuICB9XG4gIGVsc2Uge1xuICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKGRvbS5yb290LCAndG9wJyk7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUoZG9tLnJvb3QsICdib3R0b20nKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSByb290IHdpZHRoIGFuZCBoZWlnaHQgb3B0aW9uc1xuICBkb20ucm9vdC5zdHlsZS5tYXhIZWlnaHQgPSB1dGlsLm9wdGlvbi5hc1NpemUob3B0aW9ucy5tYXhIZWlnaHQsICcnKTtcbiAgZG9tLnJvb3Quc3R5bGUubWluSGVpZ2h0ID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMubWluSGVpZ2h0LCAnJyk7XG4gIGRvbS5yb290LnN0eWxlLndpZHRoID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMud2lkdGgsICcnKTtcblxuICAvLyBjYWxjdWxhdGUgYm9yZGVyIHdpZHRoc1xuICBwcm9wcy5ib3JkZXIubGVmdCAgID0gKGRvbS5jZW50ZXJDb250YWluZXIub2Zmc2V0V2lkdGggLSBkb20uY2VudGVyQ29udGFpbmVyLmNsaWVudFdpZHRoKSAvIDI7XG4gIHByb3BzLmJvcmRlci5yaWdodCAgPSBwcm9wcy5ib3JkZXIubGVmdDtcbiAgcHJvcHMuYm9yZGVyLnRvcCAgICA9IChkb20uY2VudGVyQ29udGFpbmVyLm9mZnNldEhlaWdodCAtIGRvbS5jZW50ZXJDb250YWluZXIuY2xpZW50SGVpZ2h0KSAvIDI7XG4gIHByb3BzLmJvcmRlci5ib3R0b20gPSBwcm9wcy5ib3JkZXIudG9wO1xuICB2YXIgYm9yZGVyUm9vdEhlaWdodD0gZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0IC0gZG9tLnJvb3QuY2xpZW50SGVpZ2h0O1xuICB2YXIgYm9yZGVyUm9vdFdpZHRoID0gZG9tLnJvb3Qub2Zmc2V0V2lkdGggLSBkb20ucm9vdC5jbGllbnRXaWR0aDtcblxuICAvLyB3b3JrYXJvdW5kIGZvciBhIGJ1ZyBpbiBJRTogdGhlIGNsaWVudFdpZHRoIG9mIGFuIGVsZW1lbnQgd2l0aFxuICAvLyBhIGhlaWdodDowcHggYW5kIG92ZXJmbG93OmhpZGRlbiBpcyBub3QgY2FsY3VsYXRlZCBhbmQgYWx3YXlzIGhhcyB2YWx1ZSAwXG4gIGlmIChkb20uY2VudGVyQ29udGFpbmVyLmNsaWVudEhlaWdodCA9PT0gMCkge1xuICAgIHByb3BzLmJvcmRlci5sZWZ0ID0gcHJvcHMuYm9yZGVyLnRvcDtcbiAgICBwcm9wcy5ib3JkZXIucmlnaHQgID0gcHJvcHMuYm9yZGVyLmxlZnQ7XG4gIH1cbiAgaWYgKGRvbS5yb290LmNsaWVudEhlaWdodCA9PT0gMCkge1xuICAgIGJvcmRlclJvb3RXaWR0aCA9IGJvcmRlclJvb3RIZWlnaHQ7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIGhlaWdodHMuIElmIGFueSBvZiB0aGUgc2lkZSBwYW5lbHMgaXMgZW1wdHksIHdlIHNldCB0aGUgaGVpZ2h0IHRvXG4gIC8vIG1pbnVzIHRoZSBib3JkZXIgd2lkdGgsIHN1Y2ggdGhhdCB0aGUgYm9yZGVyIHdpbGwgYmUgaW52aXNpYmxlXG4gIHByb3BzLmNlbnRlci5oZWlnaHQgPSBkb20uY2VudGVyLm9mZnNldEhlaWdodDtcbiAgcHJvcHMubGVmdC5oZWlnaHQgICA9IGRvbS5sZWZ0Lm9mZnNldEhlaWdodDtcbiAgcHJvcHMucmlnaHQuaGVpZ2h0ICA9IGRvbS5yaWdodC5vZmZzZXRIZWlnaHQ7XG4gIHByb3BzLnRvcC5oZWlnaHQgICAgPSBkb20udG9wLmNsaWVudEhlaWdodCAgICB8fCAtcHJvcHMuYm9yZGVyLnRvcDtcbiAgcHJvcHMuYm90dG9tLmhlaWdodCA9IGRvbS5ib3R0b20uY2xpZW50SGVpZ2h0IHx8IC1wcm9wcy5ib3JkZXIuYm90dG9tO1xuXG4gIC8vIFRPRE86IGNvbXBlbnNhdGUgYm9yZGVycyB3aGVuIGFueSBvZiB0aGUgcGFuZWxzIGlzIGVtcHR5LlxuXG4gIC8vIGFwcGx5IGF1dG8gaGVpZ2h0XG4gIC8vIFRPRE86IG9ubHkgY2FsY3VsYXRlIGF1dG9IZWlnaHQgd2hlbiBuZWVkZWQgKGVsc2Ugd2UgY2F1c2UgYW4gZXh0cmEgcmVmbG93L3JlcGFpbnQgb2YgdGhlIERPTSlcbiAgdmFyIGNvbnRlbnRIZWlnaHQgPSBNYXRoLm1heChwcm9wcy5sZWZ0LmhlaWdodCwgcHJvcHMuY2VudGVyLmhlaWdodCwgcHJvcHMucmlnaHQuaGVpZ2h0KTtcbiAgdmFyIGF1dG9IZWlnaHQgPSBwcm9wcy50b3AuaGVpZ2h0ICsgY29udGVudEhlaWdodCArIHByb3BzLmJvdHRvbS5oZWlnaHQgK1xuICAgIGJvcmRlclJvb3RIZWlnaHQgKyBwcm9wcy5ib3JkZXIudG9wICsgcHJvcHMuYm9yZGVyLmJvdHRvbTtcbiAgZG9tLnJvb3Quc3R5bGUuaGVpZ2h0ID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMuaGVpZ2h0LCBhdXRvSGVpZ2h0ICsgJ3B4Jyk7XG5cbiAgLy8gY2FsY3VsYXRlIGhlaWdodHMgb2YgdGhlIGNvbnRlbnQgcGFuZWxzXG4gIHByb3BzLnJvb3QuaGVpZ2h0ID0gZG9tLnJvb3Qub2Zmc2V0SGVpZ2h0O1xuICBwcm9wcy5iYWNrZ3JvdW5kLmhlaWdodCA9IHByb3BzLnJvb3QuaGVpZ2h0IC0gYm9yZGVyUm9vdEhlaWdodDtcbiAgdmFyIGNvbnRhaW5lckhlaWdodCA9IHByb3BzLnJvb3QuaGVpZ2h0IC0gcHJvcHMudG9wLmhlaWdodCAtIHByb3BzLmJvdHRvbS5oZWlnaHQgLVxuICAgIGJvcmRlclJvb3RIZWlnaHQ7XG4gIHByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgID0gY29udGFpbmVySGVpZ2h0O1xuICBwcm9wcy5sZWZ0Q29udGFpbmVyLmhlaWdodCAgICA9IGNvbnRhaW5lckhlaWdodDtcbiAgcHJvcHMucmlnaHRDb250YWluZXIuaGVpZ2h0ICAgPSBwcm9wcy5sZWZ0Q29udGFpbmVyLmhlaWdodDtcblxuICAvLyBjYWxjdWxhdGUgdGhlIHdpZHRocyBvZiB0aGUgcGFuZWxzXG4gIHByb3BzLnJvb3Qud2lkdGggPSBkb20ucm9vdC5vZmZzZXRXaWR0aDtcbiAgcHJvcHMuYmFja2dyb3VuZC53aWR0aCA9IHByb3BzLnJvb3Qud2lkdGggLSBib3JkZXJSb290V2lkdGg7XG4gIHByb3BzLmxlZnQud2lkdGggPSBkb20ubGVmdENvbnRhaW5lci5jbGllbnRXaWR0aCAgIHx8IC1wcm9wcy5ib3JkZXIubGVmdDtcbiAgcHJvcHMubGVmdENvbnRhaW5lci53aWR0aCA9IHByb3BzLmxlZnQud2lkdGg7XG4gIHByb3BzLnJpZ2h0LndpZHRoID0gZG9tLnJpZ2h0Q29udGFpbmVyLmNsaWVudFdpZHRoIHx8IC1wcm9wcy5ib3JkZXIucmlnaHQ7XG4gIHByb3BzLnJpZ2h0Q29udGFpbmVyLndpZHRoID0gcHJvcHMucmlnaHQud2lkdGg7XG4gIHZhciBjZW50ZXJXaWR0aCA9IHByb3BzLnJvb3Qud2lkdGggLSBwcm9wcy5sZWZ0LndpZHRoIC0gcHJvcHMucmlnaHQud2lkdGggLSBib3JkZXJSb290V2lkdGg7XG4gIHByb3BzLmNlbnRlci53aWR0aCAgICAgICAgICA9IGNlbnRlcldpZHRoO1xuICBwcm9wcy5jZW50ZXJDb250YWluZXIud2lkdGggPSBjZW50ZXJXaWR0aDtcbiAgcHJvcHMudG9wLndpZHRoICAgICAgICAgICAgID0gY2VudGVyV2lkdGg7XG4gIHByb3BzLmJvdHRvbS53aWR0aCAgICAgICAgICA9IGNlbnRlcldpZHRoO1xuXG4gIC8vIHJlc2l6ZSB0aGUgcGFuZWxzXG4gIGRvbS5iYWNrZ3JvdW5kLnN0eWxlLmhlaWdodCAgICAgICAgICAgPSBwcm9wcy5iYWNrZ3JvdW5kLmhlaWdodCArICdweCc7XG4gIGRvbS5iYWNrZ3JvdW5kVmVydGljYWwuc3R5bGUuaGVpZ2h0ICAgPSBwcm9wcy5iYWNrZ3JvdW5kLmhlaWdodCArICdweCc7XG4gIGRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5zdHlsZS5oZWlnaHQgPSBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLmNlbnRlckNvbnRhaW5lci5zdHlsZS5oZWlnaHQgICAgICA9IHByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuICBkb20ubGVmdENvbnRhaW5lci5zdHlsZS5oZWlnaHQgICAgICAgID0gcHJvcHMubGVmdENvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuICBkb20ucmlnaHRDb250YWluZXIuc3R5bGUuaGVpZ2h0ICAgICAgID0gcHJvcHMucmlnaHRDb250YWluZXIuaGVpZ2h0ICsgJ3B4JztcblxuICBkb20uYmFja2dyb3VuZC5zdHlsZS53aWR0aCAgICAgICAgICAgID0gcHJvcHMuYmFja2dyb3VuZC53aWR0aCArICdweCc7XG4gIGRvbS5iYWNrZ3JvdW5kVmVydGljYWwuc3R5bGUud2lkdGggICAgPSBwcm9wcy5jZW50ZXJDb250YWluZXIud2lkdGggKyAncHgnO1xuICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUud2lkdGggID0gcHJvcHMuYmFja2dyb3VuZC53aWR0aCArICdweCc7XG4gIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUud2lkdGggICAgICAgPSBwcm9wcy5jZW50ZXIud2lkdGggKyAncHgnO1xuICBkb20udG9wLnN0eWxlLndpZHRoICAgICAgICAgICAgICAgICAgID0gcHJvcHMudG9wLndpZHRoICsgJ3B4JztcbiAgZG9tLmJvdHRvbS5zdHlsZS53aWR0aCAgICAgICAgICAgICAgICA9IHByb3BzLmJvdHRvbS53aWR0aCArICdweCc7XG5cbiAgLy8gcmVwb3NpdGlvbiB0aGUgcGFuZWxzXG4gIGRvbS5iYWNrZ3JvdW5kLnN0eWxlLmxlZnQgICAgICAgICAgID0gJzAnO1xuICBkb20uYmFja2dyb3VuZC5zdHlsZS50b3AgICAgICAgICAgICA9ICcwJztcbiAgZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5zdHlsZS5sZWZ0ICAgPSAocHJvcHMubGVmdC53aWR0aCArIHByb3BzLmJvcmRlci5sZWZ0KSArICdweCc7XG4gIGRvbS5iYWNrZ3JvdW5kVmVydGljYWwuc3R5bGUudG9wICAgID0gJzAnO1xuICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUubGVmdCA9ICcwJztcbiAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLnRvcCAgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLmNlbnRlckNvbnRhaW5lci5zdHlsZS5sZWZ0ICAgICAgPSBwcm9wcy5sZWZ0LndpZHRoICsgJ3B4JztcbiAgZG9tLmNlbnRlckNvbnRhaW5lci5zdHlsZS50b3AgICAgICAgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLmxlZnRDb250YWluZXIuc3R5bGUubGVmdCAgICAgICAgPSAnMCc7XG4gIGRvbS5sZWZ0Q29udGFpbmVyLnN0eWxlLnRvcCAgICAgICAgID0gcHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIGRvbS5yaWdodENvbnRhaW5lci5zdHlsZS5sZWZ0ICAgICAgID0gKHByb3BzLmxlZnQud2lkdGggKyBwcm9wcy5jZW50ZXIud2lkdGgpICsgJ3B4JztcbiAgZG9tLnJpZ2h0Q29udGFpbmVyLnN0eWxlLnRvcCAgICAgICAgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLnRvcC5zdHlsZS5sZWZ0ICAgICAgICAgICAgICAgICAgPSBwcm9wcy5sZWZ0LndpZHRoICsgJ3B4JztcbiAgZG9tLnRvcC5zdHlsZS50b3AgICAgICAgICAgICAgICAgICAgPSAnMCc7XG4gIGRvbS5ib3R0b20uc3R5bGUubGVmdCAgICAgICAgICAgICAgID0gcHJvcHMubGVmdC53aWR0aCArICdweCc7XG4gIGRvbS5ib3R0b20uc3R5bGUudG9wICAgICAgICAgICAgICAgID0gKHByb3BzLnRvcC5oZWlnaHQgKyBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0KSArICdweCc7XG5cbiAgLy8gdXBkYXRlIHRoZSBzY3JvbGxUb3AsIGZlYXNpYmxlIHJhbmdlIGZvciB0aGUgb2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gIC8vIHdoZW4gdGhlIGhlaWdodCBvZiB0aGUgQ29yZSBvciBvZiB0aGUgY29udGVudHMgb2YgdGhlIGNlbnRlciBjaGFuZ2VkXG4gIHRoaXMuX3VwZGF0ZVNjcm9sbFRvcCgpO1xuXG4gIC8vIHJlcG9zaXRpb24gdGhlIHNjcm9sbGFibGUgY29udGVudHNcbiAgdmFyIG9mZnNldCA9IHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xuICBpZiAob3B0aW9ucy5vcmllbnRhdGlvbiA9PSAnYm90dG9tJykge1xuICAgIG9mZnNldCArPSBNYXRoLm1heCh0aGlzLnByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgLSB0aGlzLnByb3BzLmNlbnRlci5oZWlnaHQgLVxuICAgICAgdGhpcy5wcm9wcy5ib3JkZXIudG9wIC0gdGhpcy5wcm9wcy5ib3JkZXIuYm90dG9tLCAwKTtcbiAgfVxuICBkb20uY2VudGVyLnN0eWxlLmxlZnQgPSAnMCc7XG4gIGRvbS5jZW50ZXIuc3R5bGUudG9wICA9IG9mZnNldCArICdweCc7XG4gIGRvbS5sZWZ0LnN0eWxlLmxlZnQgICA9ICcwJztcbiAgZG9tLmxlZnQuc3R5bGUudG9wICAgID0gb2Zmc2V0ICsgJ3B4JztcbiAgZG9tLnJpZ2h0LnN0eWxlLmxlZnQgID0gJzAnO1xuICBkb20ucmlnaHQuc3R5bGUudG9wICAgPSBvZmZzZXQgKyAncHgnO1xuXG4gIC8vIHNob3cgc2hhZG93cyB3aGVuIHZlcnRpY2FsIHNjcm9sbGluZyBpcyBhdmFpbGFibGVcbiAgdmFyIHZpc2liaWxpdHlUb3AgPSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9PSAwID8gJ2hpZGRlbicgOiAnJztcbiAgdmFyIHZpc2liaWxpdHlCb3R0b20gPSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9PSB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbiA/ICdoaWRkZW4nIDogJyc7XG4gIGRvbS5zaGFkb3dUb3Auc3R5bGUudmlzaWJpbGl0eSAgICAgICAgICA9IHZpc2liaWxpdHlUb3A7XG4gIGRvbS5zaGFkb3dCb3R0b20uc3R5bGUudmlzaWJpbGl0eSAgICAgICA9IHZpc2liaWxpdHlCb3R0b207XG4gIGRvbS5zaGFkb3dUb3BMZWZ0LnN0eWxlLnZpc2liaWxpdHkgICAgICA9IHZpc2liaWxpdHlUb3A7XG4gIGRvbS5zaGFkb3dCb3R0b21MZWZ0LnN0eWxlLnZpc2liaWxpdHkgICA9IHZpc2liaWxpdHlCb3R0b207XG4gIGRvbS5zaGFkb3dUb3BSaWdodC5zdHlsZS52aXNpYmlsaXR5ICAgICA9IHZpc2liaWxpdHlUb3A7XG4gIGRvbS5zaGFkb3dCb3R0b21SaWdodC5zdHlsZS52aXNpYmlsaXR5ICA9IHZpc2liaWxpdHlCb3R0b207XG5cbiAgLy8gcmVkcmF3IGFsbCBjb21wb25lbnRzXG4gIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICByZXNpemVkID0gY29tcG9uZW50LnJlZHJhdygpIHx8IHJlc2l6ZWQ7XG4gIH0pO1xuICBpZiAocmVzaXplZCkge1xuICAgIC8vIGtlZXAgcmVwYWludGluZyB1bnRpbCBhbGwgc2l6ZXMgYXJlIHNldHRsZWRcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9XG59O1xuXG4vLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xLjAsIHJlbW92ZSBzb21lIGRheVxuQ29yZS5wcm90b3R5cGUucmVwYWludCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiByZXBhaW50IGlzIGRlcHJlY2F0ZWQuIFVzZSByZWRyYXcgaW5zdGVhZC4nKTtcbn07XG5cbi8qKlxuICogU2V0IGEgY3VycmVudCB0aW1lLiBUaGlzIGNhbiBiZSB1c2VkIGZvciBleGFtcGxlIHRvIGVuc3VyZSB0aGF0IGEgY2xpZW50J3NcbiAqIHRpbWUgaXMgc3luY2hyb25pemVkIHdpdGggYSBzaGFyZWQgc2VydmVyIHRpbWUuXG4gKiBPbmx5IGFwcGxpY2FibGUgd2hlbiBvcHRpb24gYHNob3dDdXJyZW50VGltZWAgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7RGF0ZSB8IFN0cmluZyB8IE51bWJlcn0gdGltZSAgICAgQSBEYXRlLCB1bml4IHRpbWVzdGFtcCwgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSVNPIGRhdGUgc3RyaW5nLlxuICovXG5Db3JlLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgaWYgKCF0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gc2hvd0N1cnJlbnRUaW1lIG11c3QgYmUgdHJ1ZScpO1xuICB9XG5cbiAgdGhpcy5jdXJyZW50VGltZS5zZXRDdXJyZW50VGltZSh0aW1lKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHRpbWUuXG4gKiBPbmx5IGFwcGxpY2FibGUgd2hlbiBvcHRpb24gYHNob3dDdXJyZW50VGltZWAgaXMgdHJ1ZS5cbiAqIEByZXR1cm4ge0RhdGV9IFJldHVybnMgdGhlIGN1cnJlbnQgdGltZS5cbiAqL1xuQ29yZS5wcm90b3R5cGUuZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gc2hvd0N1cnJlbnRUaW1lIG11c3QgYmUgdHJ1ZScpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUuZ2V0Q3VycmVudFRpbWUoKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHBvc2l0aW9uIG9uIHNjcmVlbiAocGl4ZWxzKSB0byBhIGRhdGV0aW1lXG4gKiBAcGFyYW0ge2ludH0gICAgIHggICAgUG9zaXRpb24gb24gdGhlIHNjcmVlbiBpbiBwaXhlbHNcbiAqIEByZXR1cm4ge0RhdGV9ICAgdGltZSBUaGUgZGF0ZXRpbWUgdGhlIGNvcnJlc3BvbmRzIHdpdGggZ2l2ZW4gcG9zaXRpb24geFxuICogQHByaXZhdGVcbiAqL1xuLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIFJhbmdlXG5Db3JlLnByb3RvdHlwZS5fdG9UaW1lID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY29udmVyc2lvbiA9IHRoaXMucmFuZ2UuY29udmVyc2lvbih0aGlzLnByb3BzLmNlbnRlci53aWR0aCk7XG4gIHJldHVybiBuZXcgRGF0ZSh4IC8gY29udmVyc2lvbi5zY2FsZSArIGNvbnZlcnNpb24ub2Zmc2V0KTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgcG9zaXRpb24gb24gdGhlIGdsb2JhbCBzY3JlZW4gKHBpeGVscykgdG8gYSBkYXRldGltZVxuICogQHBhcmFtIHtpbnR9ICAgICB4ICAgIFBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gaW4gcGl4ZWxzXG4gKiBAcmV0dXJuIHtEYXRlfSAgIHRpbWUgVGhlIGRhdGV0aW1lIHRoZSBjb3JyZXNwb25kcyB3aXRoIGdpdmVuIHBvc2l0aW9uIHhcbiAqIEBwcml2YXRlXG4gKi9cbi8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuQ29yZS5wcm90b3R5cGUuX3RvR2xvYmFsVGltZSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNvbnZlcnNpb24gPSB0aGlzLnJhbmdlLmNvbnZlcnNpb24odGhpcy5wcm9wcy5yb290LndpZHRoKTtcbiAgcmV0dXJuIG5ldyBEYXRlKHggLyBjb252ZXJzaW9uLnNjYWxlICsgY29udmVyc2lvbi5vZmZzZXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgZGF0ZXRpbWUgKERhdGUgb2JqZWN0KSBpbnRvIGEgcG9zaXRpb24gb24gdGhlIHNjcmVlblxuICogQHBhcmFtIHtEYXRlfSAgIHRpbWUgQSBkYXRlXG4gKiBAcmV0dXJuIHtpbnR9ICAgeCAgICBUaGUgcG9zaXRpb24gb24gdGhlIHNjcmVlbiBpbiBwaXhlbHMgd2hpY2ggY29ycmVzcG9uZHNcbiAqICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGdpdmVuIGRhdGUuXG4gKiBAcHJpdmF0ZVxuICovXG4vLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gdG8gUmFuZ2VcbkNvcmUucHJvdG90eXBlLl90b1NjcmVlbiA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgdmFyIGNvbnZlcnNpb24gPSB0aGlzLnJhbmdlLmNvbnZlcnNpb24odGhpcy5wcm9wcy5jZW50ZXIud2lkdGgpO1xuICByZXR1cm4gKHRpbWUudmFsdWVPZigpIC0gY29udmVyc2lvbi5vZmZzZXQpICogY29udmVyc2lvbi5zY2FsZTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgZGF0ZXRpbWUgKERhdGUgb2JqZWN0KSBpbnRvIGEgcG9zaXRpb24gb24gdGhlIHJvb3RcbiAqIFRoaXMgaXMgdXNlZCB0byBnZXQgdGhlIHBpeGVsIGRlbnNpdHkgZXN0aW1hdGUgZm9yIHRoZSBzY3JlZW4sIG5vdCB0aGUgY2VudGVyIHBhbmVsXG4gKiBAcGFyYW0ge0RhdGV9ICAgdGltZSBBIGRhdGVcbiAqIEByZXR1cm4ge2ludH0gICB4ICAgIFRoZSBwb3NpdGlvbiBvbiByb290IGluIHBpeGVscyB3aGljaCBjb3JyZXNwb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIEBwcml2YXRlXG4gKi9cbi8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuQ29yZS5wcm90b3R5cGUuX3RvR2xvYmFsU2NyZWVuID0gZnVuY3Rpb24odGltZSkge1xuICB2YXIgY29udmVyc2lvbiA9IHRoaXMucmFuZ2UuY29udmVyc2lvbih0aGlzLnByb3BzLnJvb3Qud2lkdGgpO1xuICByZXR1cm4gKHRpbWUudmFsdWVPZigpIC0gY29udmVyc2lvbi5vZmZzZXQpICogY29udmVyc2lvbi5zY2FsZTtcbn07XG5cblxuLyoqXG4gKiBJbml0aWFsaXplIHdhdGNoaW5nIHdoZW4gb3B0aW9uIGF1dG9SZXNpemUgaXMgdHJ1ZVxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX2luaXRBdXRvUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmF1dG9SZXNpemUgPT0gdHJ1ZSkge1xuICAgIHRoaXMuX3N0YXJ0QXV0b1Jlc2l6ZSgpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX3N0b3BBdXRvUmVzaXplKCk7XG4gIH1cbn07XG5cbi8qKlxuICogV2F0Y2ggZm9yIGNoYW5nZXMgaW4gdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lci4gT24gcmVzaXplLCB0aGUgUGFuZWwgd2lsbFxuICogYXV0b21hdGljYWxseSByZWRyYXcgaXRzZWxmLlxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX3N0YXJ0QXV0b1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICB0aGlzLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuXG4gIHRoaXMuX29uUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKG1lLm9wdGlvbnMuYXV0b1Jlc2l6ZSAhPSB0cnVlKSB7XG4gICAgICAvLyBzdG9wIHdhdGNoaW5nIHdoZW4gdGhlIG9wdGlvbiBhdXRvUmVzaXplIGlzIGNoYW5nZWQgdG8gZmFsc2VcbiAgICAgIG1lLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtZS5kb20ucm9vdCkge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgZnJhbWUgaXMgcmVzaXplZFxuICAgICAgLy8gTm90ZTogd2UgY29tcGFyZSBvZmZzZXRXaWR0aCBoZXJlLCBub3QgY2xpZW50V2lkdGguIEZvciBzb21lIHJlYXNvbixcbiAgICAgIC8vIElFIGRvZXMgbm90IHJlc3RvcmUgdGhlIGNsaWVudFdpZHRoIGZyb20gMCB0byB0aGUgYWN0dWFsIHdpZHRoIGFmdGVyXG4gICAgICAvLyBjaGFuZ2luZyB0aGUgdGltZWxpbmUncyBjb250YWluZXIgZGlzcGxheSBzdHlsZSBmcm9tIG5vbmUgdG8gdmlzaWJsZVxuICAgICAgaWYgKChtZS5kb20ucm9vdC5vZmZzZXRXaWR0aCAhPSBtZS5wcm9wcy5sYXN0V2lkdGgpIHx8XG4gICAgICAgIChtZS5kb20ucm9vdC5vZmZzZXRIZWlnaHQgIT0gbWUucHJvcHMubGFzdEhlaWdodCkpIHtcbiAgICAgICAgbWUucHJvcHMubGFzdFdpZHRoID0gbWUuZG9tLnJvb3Qub2Zmc2V0V2lkdGg7XG4gICAgICAgIG1lLnByb3BzLmxhc3RIZWlnaHQgPSBtZS5kb20ucm9vdC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgbWUuZW1pdCgnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGFkZCBldmVudCBsaXN0ZW5lciB0byB3aW5kb3cgcmVzaXplXG4gIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSk7XG5cbiAgdGhpcy53YXRjaFRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5fb25SZXNpemUsIDEwMDApO1xufTtcblxuLyoqXG4gKiBTdG9wIHdhdGNoaW5nIGZvciBhIHJlc2l6ZSBvZiB0aGUgZnJhbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fc3RvcEF1dG9SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLndhdGNoVGltZXIpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMud2F0Y2hUaW1lcik7XG4gICAgdGhpcy53YXRjaFRpbWVyID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvdy5yZXNpemVcbiAgdXRpbC5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcbiAgdGhpcy5fb25SZXNpemUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBTdGFydCBtb3ZpbmcgdGhlIHRpbWVsaW5lIHZlcnRpY2FsbHlcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fb25Ub3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB0aGlzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBTdGFydCBtb3ZpbmcgdGhlIHRpbWVsaW5lIHZlcnRpY2FsbHlcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fb25QaW5jaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB0aGlzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogU3RhcnQgbW92aW5nIHRoZSB0aW1lbGluZSB2ZXJ0aWNhbGx5XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHRoaXMudG91Y2guaW5pdGlhbFNjcm9sbFRvcCA9IHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xufTtcblxuLyoqXG4gKiBNb3ZlIHRoZSB0aW1lbGluZSB2ZXJ0aWNhbGx5XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyByZWZ1c2UgdG8gZHJhZyB3aGVuIHdlIHdoZXJlIHBpbmNoaW5nIHRvIHByZXZlbnQgdGhlIHRpbWVsaW5lIG1ha2UgYSBqdW1wXG4gIC8vIHdoZW4gcmVsZWFzaW5nIHRoZSBmaW5nZXJzIGluIG9wcG9zaXRlIG9yZGVyIGZyb20gdGhlIHRvdWNoIHNjcmVlblxuICBpZiAoIXRoaXMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gIHZhciBkZWx0YSA9IGV2ZW50Lmdlc3R1cmUuZGVsdGFZO1xuXG4gIHZhciBvbGRTY3JvbGxUb3AgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKTtcbiAgdmFyIG5ld1Njcm9sbFRvcCA9IHRoaXMuX3NldFNjcm9sbFRvcCh0aGlzLnRvdWNoLmluaXRpYWxTY3JvbGxUb3AgKyBkZWx0YSk7XG5cbiAgaWYgKG5ld1Njcm9sbFRvcCAhPSBvbGRTY3JvbGxUb3ApIHtcbiAgICB0aGlzLnJlZHJhdygpOyAvLyBUT0RPOiB0aGlzIGNhdXNlcyB0d28gcmVkcmF3cyB3aGVuIGRyYWdnaW5nLCB0aGUgb3RoZXIgaXMgdHJpZ2dlcmVkIGJ5IHJhbmdlY2hhbmdlIGFscmVhZHlcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBseSBhIHNjcm9sbFRvcFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbFRvcFxuICogQHJldHVybnMge051bWJlcn0gc2Nyb2xsVG9wICBSZXR1cm5zIHRoZSBhcHBsaWVkIHNjcm9sbFRvcFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX3NldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHtcbiAgdGhpcy5wcm9wcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gIHRoaXMuX3VwZGF0ZVNjcm9sbFRvcCgpO1xuICByZXR1cm4gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY3VycmVudCBzY3JvbGxUb3Agd2hlbiB0aGUgaGVpZ2h0IG9mICB0aGUgY29udGFpbmVycyBoYXMgYmVlbiBjaGFuZ2VkXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzY3JvbGxUb3AgIFJldHVybnMgdGhlIGFwcGxpZWQgc2Nyb2xsVG9wXG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fdXBkYXRlU2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAvLyByZWNhbGN1bGF0ZSB0aGUgc2Nyb2xsVG9wTWluXG4gIHZhciBzY3JvbGxUb3BNaW4gPSBNYXRoLm1pbih0aGlzLnByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgLSB0aGlzLnByb3BzLmNlbnRlci5oZWlnaHQsIDApOyAvLyBpcyBuZWdhdGl2ZSBvciB6ZXJvXG4gIGlmIChzY3JvbGxUb3BNaW4gIT0gdGhpcy5wcm9wcy5zY3JvbGxUb3BNaW4pIHtcbiAgICAvLyBpbiBjYXNlIG9mIGJvdHRvbSBvcmllbnRhdGlvbiwgY2hhbmdlIHRoZSBzY3JvbGxUb3Agc3VjaCB0aGF0IHRoZSBjb250ZW50c1xuICAgIC8vIGRvIG5vdCBtb3ZlIHJlbGF0aXZlIHRvIHRoZSB0aW1lIGF4aXMgYXQgdGhlIGJvdHRvbVxuICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMucHJvcHMuc2Nyb2xsVG9wICs9IChzY3JvbGxUb3BNaW4gLSB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbik7XG4gICAgfVxuICAgIHRoaXMucHJvcHMuc2Nyb2xsVG9wTWluID0gc2Nyb2xsVG9wTWluO1xuICB9XG5cbiAgLy8gbGltaXQgdGhlIHNjcm9sbFRvcCB0byB0aGUgZmVhc2libGUgc2Nyb2xsIHJhbmdlXG4gIGlmICh0aGlzLnByb3BzLnNjcm9sbFRvcCA+IDApIHRoaXMucHJvcHMuc2Nyb2xsVG9wID0gMDtcbiAgaWYgKHRoaXMucHJvcHMuc2Nyb2xsVG9wIDwgc2Nyb2xsVG9wTWluKSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcE1pbjtcblxuICByZXR1cm4gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzY3JvbGxUb3BcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNjcm9sbFRvcFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX2dldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb3JlO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgaGFtbWVyVXRpbCA9IHJlcXVpcmUoJy4uL2hhbW1lclV0aWwnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCcuLi9tb2R1bGUvbW9tZW50Jyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9jb21wb25lbnQvQ29tcG9uZW50Jyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIFJhbmdlXG4gKiBBIFJhbmdlIGNvbnRyb2xzIGEgbnVtZXJpYyByYW5nZSB3aXRoIGEgc3RhcnQgYW5kIGVuZCB2YWx1ZS5cbiAqIFRoZSBSYW5nZSBhZGp1c3RzIHRoZSByYW5nZSBiYXNlZCBvbiBtb3VzZSBldmVudHMgb3IgcHJvZ3JhbW1hdGljIGNoYW5nZXMsXG4gKiBhbmQgdHJpZ2dlcnMgZXZlbnRzIHdoZW4gdGhlIHJhbmdlIGlzIGNoYW5naW5nIG9yIGhhcyBiZWVuIGNoYW5nZWQuXG4gKiBAcGFyYW0ge3tkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdCwgZW1pdHRlcjogRW1pdHRlcn19IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgU2VlIGRlc2NyaXB0aW9uIGF0IFJhbmdlLnNldE9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmFuZ2UoYm9keSwgb3B0aW9ucykge1xuICB2YXIgbm93ID0gbW9tZW50KCkuaG91cnMoMCkubWludXRlcygwKS5zZWNvbmRzKDApLm1pbGxpc2Vjb25kcygwKTtcbiAgdGhpcy5zdGFydCA9IG5vdy5jbG9uZSgpLmFkZCgtMywgJ2RheXMnKS52YWx1ZU9mKCk7IC8vIE51bWJlclxuICB0aGlzLmVuZCA9IG5vdy5jbG9uZSgpLmFkZCg0LCAnZGF5cycpLnZhbHVlT2YoKTsgICAvLyBOdW1iZXJcblxuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIHN0YXJ0OiBudWxsLFxuICAgIGVuZDogbnVsbCxcbiAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJywgLy8gJ2hvcml6b250YWwnIG9yICd2ZXJ0aWNhbCdcbiAgICBtb3ZlYWJsZTogdHJ1ZSxcbiAgICB6b29tYWJsZTogdHJ1ZSxcbiAgICBtaW46IG51bGwsXG4gICAgbWF4OiBudWxsLFxuICAgIHpvb21NaW46IDEwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlsbGlzZWNvbmRzXG4gICAgem9vbU1heDogMTAwMCAqIDYwICogNjAgKiAyNCAqIDM2NSAqIDEwMDAwICAvLyBtaWxsaXNlY29uZHNcbiAgfTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gIHRoaXMucHJvcHMgPSB7XG4gICAgdG91Y2g6IHt9XG4gIH07XG4gIHRoaXMuYW5pbWF0ZVRpbWVyID0gbnVsbDtcblxuICAvLyBkcmFnIGxpc3RlbmVycyBmb3IgZHJhZ2dpbmdcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuICB0aGlzLmJvZHkuZW1pdHRlci5vbignZHJhZycsICAgICAgdGhpcy5fb25EcmFnLmJpbmQodGhpcykpO1xuICB0aGlzLmJvZHkuZW1pdHRlci5vbignZHJhZ2VuZCcsICAgdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcykpO1xuXG4gIC8vIGlnbm9yZSBkcmFnZ2luZyB3aGVuIGhvbGRpbmdcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ2hvbGQnLCB0aGlzLl9vbkhvbGQuYmluZCh0aGlzKSk7XG5cbiAgLy8gbW91c2Ugd2hlZWwgZm9yIHpvb21pbmdcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ21vdXNld2hlZWwnLCAgICAgIHRoaXMuX29uTW91c2VXaGVlbC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ0RPTU1vdXNlU2Nyb2xsJywgIHRoaXMuX29uTW91c2VXaGVlbC5iaW5kKHRoaXMpKTsgLy8gRm9yIEZGXG5cbiAgLy8gcGluY2ggdG8gem9vbVxuICB0aGlzLmJvZHkuZW1pdHRlci5vbigndG91Y2gnLCB0aGlzLl9vblRvdWNoLmJpbmQodGhpcykpO1xuICB0aGlzLmJvZHkuZW1pdHRlci5vbigncGluY2gnLCB0aGlzLl9vblBpbmNoLmJpbmQodGhpcykpO1xuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbn1cblxuUmFuZ2UucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIFNldCBvcHRpb25zIGZvciB0aGUgcmFuZ2UgY29udHJvbGxlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlciB8IERhdGUgfCBTdHJpbmd9IHN0YXJ0ICBTdGFydCBkYXRlIGZvciB0aGUgcmFuZ2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlciB8IERhdGUgfCBTdHJpbmd9IGVuZCAgICBFbmQgZGF0ZSBmb3IgdGhlIHJhbmdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1pbiAgICBNaW5pbXVtIHZhbHVlIGZvciBzdGFydFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXggICAgTWF4aW11bSB2YWx1ZSBmb3IgZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IHpvb21NaW4gICAgU2V0IGEgbWluaW11bSB2YWx1ZSBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW5kIC0gc3RhcnQpLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSB6b29tTWF4ICAgIFNldCBhIG1heGltdW0gdmFsdWUgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVuZCAtIHN0YXJ0KS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IG1vdmVhYmxlIEVuYWJsZSBtb3Zpbmcgb2YgdGhlIHJhbmdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSBkcmFnZ2luZy4gVHJ1ZSBieSBkZWZhdWx0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSB6b29tYWJsZSBFbmFibGUgem9vbWluZyBvZiB0aGUgcmFuZ2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHBpbmNoaW5nL3Njcm9sbGluZy4gVHJ1ZSBieSBkZWZhdWx0XG4gKi9cblJhbmdlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBjb3B5IHRoZSBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgIHZhciBmaWVsZHMgPSBbJ2RpcmVjdGlvbicsICdtaW4nLCAnbWF4JywgJ3pvb21NaW4nLCAnem9vbU1heCcsICdtb3ZlYWJsZScsICd6b29tYWJsZScsICdhY3RpdmF0ZSddO1xuICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICgnc3RhcnQnIGluIG9wdGlvbnMgfHwgJ2VuZCcgaW4gb3B0aW9ucykge1xuICAgICAgLy8gYXBwbHkgYSBuZXcgcmFuZ2UuIGJvdGggc3RhcnQgYW5kIGVuZCBhcmUgb3B0aW9uYWxcbiAgICAgIHRoaXMuc2V0UmFuZ2Uob3B0aW9ucy5zdGFydCwgb3B0aW9ucy5lbmQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgZGlyZWN0aW9uIGhhcyBhIHZhbGlkIHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uICAgICdob3Jpem9udGFsJyBvciAndmVydGljYWwnXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aW9uIChkaXJlY3Rpb24pIHtcbiAgaWYgKGRpcmVjdGlvbiAhPSAnaG9yaXpvbnRhbCcgJiYgZGlyZWN0aW9uICE9ICd2ZXJ0aWNhbCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGRpcmVjdGlvbiBcIicgKyBkaXJlY3Rpb24gKyAnXCIuICcgK1xuICAgICAgICAnQ2hvb3NlIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi4nKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIG5ldyBzdGFydCBhbmQgZW5kIHJhbmdlXG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmd9IFtzdGFydF1cbiAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZ30gW2VuZF1cbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IG51bWJlcn0gW2FuaW1hdGU9ZmFsc2VdICAgICBJZiB0cnVlLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhbmltYXRlIGlzIGEgbnVtYmVyLCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgaXMgdGFrZW4gYXMgZHVyYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcy5cbiAqXG4gKi9cblJhbmdlLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGFuaW1hdGUpIHtcbiAgdmFyIF9zdGFydCA9IHN0YXJ0ICE9IHVuZGVmaW5lZCA/IHV0aWwuY29udmVydChzdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiBudWxsO1xuICB2YXIgX2VuZCAgID0gZW5kICE9IHVuZGVmaW5lZCAgID8gdXRpbC5jb252ZXJ0KGVuZCwgJ0RhdGUnKS52YWx1ZU9mKCkgICA6IG51bGw7XG5cbiAgdGhpcy5fY2FuY2VsQW5pbWF0aW9uKCk7XG5cbiAgaWYgKGFuaW1hdGUpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBpbml0U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIHZhciBpbml0RW5kID0gdGhpcy5lbmQ7XG4gICAgdmFyIGR1cmF0aW9uID0gdHlwZW9mIGFuaW1hdGUgPT09ICdudW1iZXInID8gYW5pbWF0ZSA6IDUwMDtcbiAgICB2YXIgaW5pdFRpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICB2YXIgYW55Q2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGlmICghbWUucHJvcHMudG91Y2guZHJhZ2dpbmcpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB2YXIgdGltZSA9IG5vdyAtIGluaXRUaW1lO1xuICAgICAgICB2YXIgZG9uZSA9IHRpbWUgPiBkdXJhdGlvbjtcbiAgICAgICAgdmFyIHMgPSAoZG9uZSB8fCBfc3RhcnQgPT09IG51bGwpID8gX3N0YXJ0IDogdXRpbC5lYXNlSW5PdXRRdWFkKHRpbWUsIGluaXRTdGFydCwgX3N0YXJ0LCBkdXJhdGlvbik7XG4gICAgICAgIHZhciBlID0gKGRvbmUgfHwgX2VuZCA9PT0gbnVsbCkgICA/IF9lbmQgICA6IHV0aWwuZWFzZUluT3V0UXVhZCh0aW1lLCBpbml0RW5kLCBfZW5kLCBkdXJhdGlvbik7XG5cbiAgICAgICAgY2hhbmdlZCA9IG1lLl9hcHBseVJhbmdlKHMsIGUpO1xuICAgICAgICBhbnlDaGFuZ2VkID0gYW55Q2hhbmdlZCB8fCBjaGFuZ2VkO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZScsIHtzdGFydDogbmV3IERhdGUobWUuc3RhcnQpLCBlbmQ6IG5ldyBEYXRlKG1lLmVuZCl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgaWYgKGFueUNoYW5nZWQpIHtcbiAgICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZWQnLCB7c3RhcnQ6IG5ldyBEYXRlKG1lLnN0YXJ0KSwgZW5kOiBuZXcgRGF0ZShtZS5lbmQpfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGFuaW1hdGUgd2l0aCBhcyBoaWdoIGFzIHBvc3NpYmxlIGZyYW1lIHJhdGUsIGxlYXZlIDIwIG1zIGluIGJldHdlZW5cbiAgICAgICAgICAvLyBlYWNoIHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBibG9ja2luZ1xuICAgICAgICAgIG1lLmFuaW1hdGVUaW1lciA9IHNldFRpbWVvdXQobmV4dCwgMjApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX2FwcGx5UmFuZ2UoX3N0YXJ0LCBfZW5kKTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHtzdGFydDogbmV3IERhdGUodGhpcy5zdGFydCksIGVuZDogbmV3IERhdGUodGhpcy5lbmQpfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlJywgcGFyYW1zKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlZCcsIHBhcmFtcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFN0b3AgYW4gYW5pbWF0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX2NhbmNlbEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYW5pbWF0ZVRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbWF0ZVRpbWVyKTtcbiAgICB0aGlzLmFuaW1hdGVUaW1lciA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGEgbmV3IHN0YXJ0IGFuZCBlbmQgcmFuZ2UuIFRoaXMgbWV0aG9kIGlzIHRoZSBzYW1lIGFzIHNldFJhbmdlLCBidXRcbiAqIGRvZXMgbm90IHRyaWdnZXIgYSByYW5nZSBjaGFuZ2UgYW5kIHJhbmdlIGNoYW5nZWQgZXZlbnQsIGFuZCBpdCByZXR1cm5zXG4gKiB0cnVlIHdoZW4gdGhlIHJhbmdlIGlzIGNoYW5nZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdXG4gKiBAcGFyYW0ge051bWJlcn0gW2VuZF1cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fYXBwbHlSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIG5ld1N0YXJ0ID0gKHN0YXJ0ICE9IG51bGwpID8gdXRpbC5jb252ZXJ0KHN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKSA6IHRoaXMuc3RhcnQsXG4gICAgICBuZXdFbmQgICA9IChlbmQgIT0gbnVsbCkgICA/IHV0aWwuY29udmVydChlbmQsICdEYXRlJykudmFsdWVPZigpICAgOiB0aGlzLmVuZCxcbiAgICAgIG1heCA9ICh0aGlzLm9wdGlvbnMubWF4ICE9IG51bGwpID8gdXRpbC5jb252ZXJ0KHRoaXMub3B0aW9ucy5tYXgsICdEYXRlJykudmFsdWVPZigpIDogbnVsbCxcbiAgICAgIG1pbiA9ICh0aGlzLm9wdGlvbnMubWluICE9IG51bGwpID8gdXRpbC5jb252ZXJ0KHRoaXMub3B0aW9ucy5taW4sICdEYXRlJykudmFsdWVPZigpIDogbnVsbCxcbiAgICAgIGRpZmY7XG5cbiAgLy8gY2hlY2sgZm9yIHZhbGlkIG51bWJlclxuICBpZiAoaXNOYU4obmV3U3RhcnQpIHx8IG5ld1N0YXJ0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXJ0IFwiJyArIHN0YXJ0ICsgJ1wiJyk7XG4gIH1cbiAgaWYgKGlzTmFOKG5ld0VuZCkgfHwgbmV3RW5kID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuZCBcIicgKyBlbmQgKyAnXCInKTtcbiAgfVxuXG4gIC8vIHByZXZlbnQgc3RhcnQgPCBlbmRcbiAgaWYgKG5ld0VuZCA8IG5ld1N0YXJ0KSB7XG4gICAgbmV3RW5kID0gbmV3U3RhcnQ7XG4gIH1cblxuICAvLyBwcmV2ZW50IHN0YXJ0IDwgbWluXG4gIGlmIChtaW4gIT09IG51bGwpIHtcbiAgICBpZiAobmV3U3RhcnQgPCBtaW4pIHtcbiAgICAgIGRpZmYgPSAobWluIC0gbmV3U3RhcnQpO1xuICAgICAgbmV3U3RhcnQgKz0gZGlmZjtcbiAgICAgIG5ld0VuZCArPSBkaWZmO1xuXG4gICAgICAvLyBwcmV2ZW50IGVuZCA+IG1heFxuICAgICAgaWYgKG1heCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXdFbmQgPiBtYXgpIHtcbiAgICAgICAgICBuZXdFbmQgPSBtYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwcmV2ZW50IGVuZCA+IG1heFxuICBpZiAobWF4ICE9PSBudWxsKSB7XG4gICAgaWYgKG5ld0VuZCA+IG1heCkge1xuICAgICAgZGlmZiA9IChuZXdFbmQgLSBtYXgpO1xuICAgICAgbmV3U3RhcnQgLT0gZGlmZjtcbiAgICAgIG5ld0VuZCAtPSBkaWZmO1xuXG4gICAgICAvLyBwcmV2ZW50IHN0YXJ0IDwgbWluXG4gICAgICBpZiAobWluICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5ld1N0YXJ0IDwgbWluKSB7XG4gICAgICAgICAgbmV3U3RhcnQgPSBtaW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwcmV2ZW50IChlbmQtc3RhcnQpIDwgem9vbU1pblxuICBpZiAodGhpcy5vcHRpb25zLnpvb21NaW4gIT09IG51bGwpIHtcbiAgICB2YXIgem9vbU1pbiA9IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21NaW4pO1xuICAgIGlmICh6b29tTWluIDwgMCkge1xuICAgICAgem9vbU1pbiA9IDA7XG4gICAgfVxuICAgIGlmICgobmV3RW5kIC0gbmV3U3RhcnQpIDwgem9vbU1pbikge1xuICAgICAgaWYgKCh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpID09PSB6b29tTWluKSB7XG4gICAgICAgIC8vIGlnbm9yZSB0aGlzIGFjdGlvbiwgd2UgYXJlIGFscmVhZHkgem9vbWVkIHRvIHRoZSBtaW5pbXVtXG4gICAgICAgIG5ld1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgbmV3RW5kID0gdGhpcy5lbmQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gem9vbSB0byB0aGUgbWluaW11bVxuICAgICAgICBkaWZmID0gKHpvb21NaW4gLSAobmV3RW5kIC0gbmV3U3RhcnQpKTtcbiAgICAgICAgbmV3U3RhcnQgLT0gZGlmZiAvIDI7XG4gICAgICAgIG5ld0VuZCArPSBkaWZmIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwcmV2ZW50IChlbmQtc3RhcnQpID4gem9vbU1heFxuICBpZiAodGhpcy5vcHRpb25zLnpvb21NYXggIT09IG51bGwpIHtcbiAgICB2YXIgem9vbU1heCA9IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21NYXgpO1xuICAgIGlmICh6b29tTWF4IDwgMCkge1xuICAgICAgem9vbU1heCA9IDA7XG4gICAgfVxuICAgIGlmICgobmV3RW5kIC0gbmV3U3RhcnQpID4gem9vbU1heCkge1xuICAgICAgaWYgKCh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpID09PSB6b29tTWF4KSB7XG4gICAgICAgIC8vIGlnbm9yZSB0aGlzIGFjdGlvbiwgd2UgYXJlIGFscmVhZHkgem9vbWVkIHRvIHRoZSBtYXhpbXVtXG4gICAgICAgIG5ld1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgbmV3RW5kID0gdGhpcy5lbmQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gem9vbSB0byB0aGUgbWF4aW11bVxuICAgICAgICBkaWZmID0gKChuZXdFbmQgLSBuZXdTdGFydCkgLSB6b29tTWF4KTtcbiAgICAgICAgbmV3U3RhcnQgKz0gZGlmZiAvIDI7XG4gICAgICAgIG5ld0VuZCAtPSBkaWZmIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY2hhbmdlZCA9ICh0aGlzLnN0YXJ0ICE9IG5ld1N0YXJ0IHx8IHRoaXMuZW5kICE9IG5ld0VuZCk7XG5cbiAgdGhpcy5zdGFydCA9IG5ld1N0YXJ0O1xuICB0aGlzLmVuZCA9IG5ld0VuZDtcblxuICByZXR1cm4gY2hhbmdlZDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgcmFuZ2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHN0YXJ0IGFuZCBlbmQgcHJvcGVydGllc1xuICovXG5SYW5nZS5wcm90b3R5cGUuZ2V0UmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICBlbmQ6IHRoaXMuZW5kXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgY29udmVyc2lvbiBvZmZzZXQgYW5kIHNjYWxlIGZvciBjdXJyZW50IHJhbmdlLCBiYXNlZCBvblxuICogdGhlIHByb3ZpZGVkIHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqIEByZXR1cm5zIHt7b2Zmc2V0OiBudW1iZXIsIHNjYWxlOiBudW1iZXJ9fSBjb252ZXJzaW9uXG4gKi9cblJhbmdlLnByb3RvdHlwZS5jb252ZXJzaW9uID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHJldHVybiBSYW5nZS5jb252ZXJzaW9uKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB3aWR0aCk7XG59O1xuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgdG8gY2FsY3VsYXRlIHRoZSBjb252ZXJzaW9uIG9mZnNldCBhbmQgc2NhbGUgZm9yIGEgcmFuZ2UsXG4gKiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgc3RhcnQsIGVuZCwgYW5kIHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogQHJldHVybnMge3tvZmZzZXQ6IG51bWJlciwgc2NhbGU6IG51bWJlcn19IGNvbnZlcnNpb25cbiAqL1xuUmFuZ2UuY29udmVyc2lvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB3aWR0aCkge1xuICBpZiAod2lkdGggIT0gMCAmJiAoZW5kIC0gc3RhcnQgIT0gMCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgIHNjYWxlOiB3aWR0aCAvIChlbmQgLSBzdGFydClcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIHNjYWxlOiAxXG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydCBkcmFnZ2luZyBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuICAvLyBvbmx5IGFsbG93IGRyYWdnaW5nIHdoZW4gY29uZmlndXJlZCBhcyBtb3ZhYmxlXG4gIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG5cbiAgLy8gcmVmdXNlIHRvIGRyYWcgd2hlbiB3ZSB3aGVyZSBwaW5jaGluZyB0byBwcmV2ZW50IHRoZSB0aW1lbGluZSBtYWtlIGEganVtcFxuICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcpIHJldHVybjtcblxuICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5wcm9wcy50b3VjaC5kcmFnZ2luZyA9IHRydWU7XG5cbiAgaWYgKHRoaXMuYm9keS5kb20ucm9vdCkge1xuICAgIHRoaXMuYm9keS5kb20ucm9vdC5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybSBkcmFnZ2luZyBvcGVyYXRpb25cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBvbmx5IGFsbG93IGRyYWdnaW5nIHdoZW4gY29uZmlndXJlZCBhcyBtb3ZhYmxlXG4gIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG4gIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICB2YWxpZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pO1xuXG4gIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgLy8gd2hlbiByZWxlYXNpbmcgdGhlIGZpbmdlcnMgaW4gb3Bwb3NpdGUgb3JkZXIgZnJvbSB0aGUgdG91Y2ggc2NyZWVuXG4gIGlmICghdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nKSByZXR1cm47XG5cbiAgdmFyIGRlbHRhID0gKGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpID8gZXZlbnQuZ2VzdHVyZS5kZWx0YVggOiBldmVudC5nZXN0dXJlLmRlbHRhWTtcbiAgdmFyIGludGVydmFsID0gKHRoaXMucHJvcHMudG91Y2guZW5kIC0gdGhpcy5wcm9wcy50b3VjaC5zdGFydCk7XG4gIHZhciB3aWR0aCA9IChkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKSA/IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXIud2lkdGggOiB0aGlzLmJvZHkuZG9tUHJvcHMuY2VudGVyLmhlaWdodDtcbiAgdmFyIGRpZmZSYW5nZSA9IC1kZWx0YSAvIHdpZHRoICogaW50ZXJ2YWw7XG4gIHRoaXMuX2FwcGx5UmFuZ2UodGhpcy5wcm9wcy50b3VjaC5zdGFydCArIGRpZmZSYW5nZSwgdGhpcy5wcm9wcy50b3VjaC5lbmQgKyBkaWZmUmFuZ2UpO1xuXG4gIC8vIGZpcmUgYSByYW5nZWNoYW5nZSBldmVudFxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZScsIHtcbiAgICBzdGFydDogbmV3IERhdGUodGhpcy5zdGFydCksXG4gICAgZW5kOiAgIG5ldyBEYXRlKHRoaXMuZW5kKVxuICB9KTtcbn07XG5cbi8qKlxuICogU3RvcCBkcmFnZ2luZyBvcGVyYXRpb25cbiAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBvbmx5IGFsbG93IGRyYWdnaW5nIHdoZW4gY29uZmlndXJlZCBhcyBtb3ZhYmxlXG4gIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG5cbiAgLy8gcmVmdXNlIHRvIGRyYWcgd2hlbiB3ZSB3aGVyZSBwaW5jaGluZyB0byBwcmV2ZW50IHRoZSB0aW1lbGluZSBtYWtlIGEganVtcFxuICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcpIHJldHVybjtcblxuICB0aGlzLnByb3BzLnRvdWNoLmRyYWdnaW5nID0gZmFsc2U7XG4gIGlmICh0aGlzLmJvZHkuZG9tLnJvb3QpIHtcbiAgICB0aGlzLmJvZHkuZG9tLnJvb3Quc3R5bGUuY3Vyc29yID0gJ2F1dG8nO1xuICB9XG5cbiAgLy8gZmlyZSBhIHJhbmdlY2hhbmdlZCBldmVudFxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZWQnLCB7XG4gICAgc3RhcnQ6IG5ldyBEYXRlKHRoaXMuc3RhcnQpLFxuICAgIGVuZDogICBuZXcgRGF0ZSh0aGlzLmVuZClcbiAgfSk7XG59O1xuXG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlIHdoZWVsIGV2ZW50LCB1c2VkIHRvIHpvb21cbiAqIENvZGUgZnJvbSBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsL1xuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fb25Nb3VzZVdoZWVsID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgLy8gb25seSBhbGxvdyB6b29taW5nIHdoZW4gY29uZmlndXJlZCBhcyB6b29tYWJsZSBhbmQgbW92ZWFibGVcbiAgaWYgKCEodGhpcy5vcHRpb25zLnpvb21hYmxlICYmIHRoaXMub3B0aW9ucy5tb3ZlYWJsZSkpIHJldHVybjtcblxuICAvLyByZXRyaWV2ZSBkZWx0YVxuICB2YXIgZGVsdGEgPSAwO1xuICBpZiAoZXZlbnQud2hlZWxEZWx0YSkgeyAvKiBJRS9PcGVyYS4gKi9cbiAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGEgLyAxMjA7XG4gIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7IC8qIE1vemlsbGEgY2FzZS4gKi9cbiAgICAvLyBJbiBNb3ppbGxhLCBzaWduIG9mIGRlbHRhIGlzIGRpZmZlcmVudCB0aGFuIGluIElFLlxuICAgIC8vIEFsc28sIGRlbHRhIGlzIG11bHRpcGxlIG9mIDMuXG4gICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gMztcbiAgfVxuXG4gIC8vIElmIGRlbHRhIGlzIG5vbnplcm8sIGhhbmRsZSBpdC5cbiAgLy8gQmFzaWNhbGx5LCBkZWx0YSBpcyBub3cgcG9zaXRpdmUgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIHVwLFxuICAvLyBhbmQgbmVnYXRpdmUsIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCBkb3duLlxuICBpZiAoZGVsdGEpIHtcbiAgICAvLyBwZXJmb3JtIHRoZSB6b29tIGFjdGlvbi4gRGVsdGEgaXMgbm9ybWFsbHkgMSBvciAtMVxuXG4gICAgLy8gYWRqdXN0IGEgbmVnYXRpdmUgZGVsdGEgc3VjaCB0aGF0IHpvb21pbmcgaW4gd2l0aCBkZWx0YSAwLjFcbiAgICAvLyBlcXVhbHMgem9vbWluZyBvdXQgd2l0aCBhIGRlbHRhIC0wLjFcbiAgICB2YXIgc2NhbGU7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgc2NhbGUgPSAxIC0gKGRlbHRhIC8gNSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2NhbGUgPSAxIC8gKDEgKyAoZGVsdGEgLyA1KSkgO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBjZW50ZXIsIHRoZSBkYXRlIHRvIHpvb20gYXJvdW5kXG4gICAgdmFyIGdlc3R1cmUgPSBoYW1tZXJVdGlsLmZha2VHZXN0dXJlKHRoaXMsIGV2ZW50KSxcbiAgICAgICAgcG9pbnRlciA9IGdldFBvaW50ZXIoZ2VzdHVyZS5jZW50ZXIsIHRoaXMuYm9keS5kb20uY2VudGVyKSxcbiAgICAgICAgcG9pbnRlckRhdGUgPSB0aGlzLl9wb2ludGVyVG9EYXRlKHBvaW50ZXIpO1xuXG4gICAgdGhpcy56b29tKHNjYWxlLCBwb2ludGVyRGF0ZSk7XG4gIH1cblxuICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9ucyBjYXVzZWQgYnkgbW91c2Ugd2hlZWxcbiAgLy8gKGVsc2UgdGhlIHBhZ2UgYW5kIHRpbWVsaW5lIGJvdGggem9vbSBhbmQgc2Nyb2xsKVxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuLyoqXG4gKiBTdGFydCBvZiBhIHRvdWNoIGdlc3R1cmVcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fb25Ub3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nID0gdHJ1ZTtcbiAgdGhpcy5wcm9wcy50b3VjaC5jZW50ZXIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBPbiBzdGFydCBvZiBhIGhvbGQgZ2VzdHVyZVxuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9vbkhvbGQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgcGluY2ggZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uUGluY2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gb25seSBhbGxvdyB6b29taW5nIHdoZW4gY29uZmlndXJlZCBhcyB6b29tYWJsZSBhbmQgbW92ZWFibGVcbiAgaWYgKCEodGhpcy5vcHRpb25zLnpvb21hYmxlICYmIHRoaXMub3B0aW9ucy5tb3ZlYWJsZSkpIHJldHVybjtcblxuICB0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSBmYWxzZTtcblxuICBpZiAoZXZlbnQuZ2VzdHVyZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMudG91Y2guY2VudGVyKSB7XG4gICAgICB0aGlzLnByb3BzLnRvdWNoLmNlbnRlciA9IGdldFBvaW50ZXIoZXZlbnQuZ2VzdHVyZS5jZW50ZXIsIHRoaXMuYm9keS5kb20uY2VudGVyKTtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGUgPSAxIC8gZXZlbnQuZ2VzdHVyZS5zY2FsZSxcbiAgICAgICAgaW5pdERhdGUgPSB0aGlzLl9wb2ludGVyVG9EYXRlKHRoaXMucHJvcHMudG91Y2guY2VudGVyKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgYW5kIGVuZFxuICAgIHZhciBuZXdTdGFydCA9IHBhcnNlSW50KGluaXREYXRlICsgKHRoaXMucHJvcHMudG91Y2guc3RhcnQgLSBpbml0RGF0ZSkgKiBzY2FsZSk7XG4gICAgdmFyIG5ld0VuZCA9IHBhcnNlSW50KGluaXREYXRlICsgKHRoaXMucHJvcHMudG91Y2guZW5kIC0gaW5pdERhdGUpICogc2NhbGUpO1xuXG4gICAgLy8gYXBwbHkgbmV3IHJhbmdlXG4gICAgdGhpcy5zZXRSYW5nZShuZXdTdGFydCwgbmV3RW5kKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBjZW50ZXIgZGF0ZSBmb3Igem9vbWluZ1xuICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb2ludGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGRhdGVcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fcG9pbnRlclRvRGF0ZSA9IGZ1bmN0aW9uIChwb2ludGVyKSB7XG4gIHZhciBjb252ZXJzaW9uO1xuICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcblxuICB2YWxpZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pO1xuXG4gIGlmIChkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlci53aWR0aDtcbiAgICBjb252ZXJzaW9uID0gdGhpcy5jb252ZXJzaW9uKHdpZHRoKTtcbiAgICByZXR1cm4gcG9pbnRlci54IC8gY29udmVyc2lvbi5zY2FsZSArIGNvbnZlcnNpb24ub2Zmc2V0O1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmJvZHkuZG9tUHJvcHMuY2VudGVyLmhlaWdodDtcbiAgICBjb252ZXJzaW9uID0gdGhpcy5jb252ZXJzaW9uKGhlaWdodCk7XG4gICAgcmV0dXJuIHBvaW50ZXIueSAvIGNvbnZlcnNpb24uc2NhbGUgKyBjb252ZXJzaW9uLm9mZnNldDtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHBvaW50ZXIgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIGxvY2F0aW9uIG9mIHRoZSBkb20gZWxlbWVudFxuICogQHBhcmFtIHt7cGFnZVg6IE51bWJlciwgcGFnZVk6IE51bWJlcn19IHRvdWNoXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIERPTSBlbGVtZW50XG4gKiBAcmV0dXJuIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb2ludGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRQb2ludGVyICh0b3VjaCwgZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHg6IHRvdWNoLnBhZ2VYIC0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQoZWxlbWVudCksXG4gICAgeTogdG91Y2gucGFnZVkgLSB1dGlsLmdldEFic29sdXRlVG9wKGVsZW1lbnQpXG4gIH07XG59XG5cbi8qKlxuICogWm9vbSB0aGUgcmFuZ2UgdGhlIGdpdmVuIHNjYWxlIGluIG9yIG91dC4gU3RhcnQgYW5kIGVuZCBkYXRlIHdpbGxcbiAqIGJlIGFkanVzdGVkLCBhbmQgdGhlIHRpbWVsaW5lIHdpbGwgYmUgcmVkcmF3bi4gWW91IGNhbiBvcHRpb25hbGx5IGdpdmUgYVxuICogZGF0ZSBhcm91bmQgd2hpY2ggdG8gem9vbS5cbiAqIEZvciBleGFtcGxlLCB0cnkgc2NhbGUgPSAwLjkgb3IgMS4xXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgICAgICBTY2FsaW5nIGZhY3Rvci4gVmFsdWVzIGFib3ZlIDEgd2lsbCB6b29tIG91dCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBiZWxvdyAxIHdpbGwgem9vbSBpbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY2VudGVyXSAgIFZhbHVlIHJlcHJlc2VudGluZyBhIGRhdGUgYXJvdW5kIHdoaWNoIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHpvb21lZC5cbiAqL1xuUmFuZ2UucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbihzY2FsZSwgY2VudGVyKSB7XG4gIC8vIGlmIGNlbnRlckRhdGUgaXMgbm90IHByb3ZpZGVkLCB0YWtlIGl0IGhhbGYgYmV0d2VlbiBzdGFydCBEYXRlIGFuZCBlbmQgRGF0ZVxuICBpZiAoY2VudGVyID09IG51bGwpIHtcbiAgICBjZW50ZXIgPSAodGhpcy5zdGFydCArIHRoaXMuZW5kKSAvIDI7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IGFuZCBlbmRcbiAgdmFyIG5ld1N0YXJ0ID0gY2VudGVyICsgKHRoaXMuc3RhcnQgLSBjZW50ZXIpICogc2NhbGU7XG4gIHZhciBuZXdFbmQgPSBjZW50ZXIgKyAodGhpcy5lbmQgLSBjZW50ZXIpICogc2NhbGU7XG5cbiAgdGhpcy5zZXRSYW5nZShuZXdTdGFydCwgbmV3RW5kKTtcbn07XG5cbi8qKlxuICogTW92ZSB0aGUgcmFuZ2Ugd2l0aCBhIGdpdmVuIGRlbHRhIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0LiBTdGFydCBhbmQgZW5kXG4gKiB2YWx1ZSB3aWxsIGJlIGFkanVzdGVkLiBGb3IgZXhhbXBsZSwgdHJ5IGRlbHRhID0gMC4xIG9yIC0wLjFcbiAqIEBwYXJhbSB7TnVtYmVyfSAgZGVsdGEgICAgIE1vdmluZyBhbW91bnQuIFBvc2l0aXZlIHZhbHVlIHdpbGwgbW92ZSByaWdodCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlIHZhbHVlIHdpbGwgbW92ZSBsZWZ0XG4gKi9cblJhbmdlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oZGVsdGEpIHtcbiAgLy8gem9vbSBzdGFydCBEYXRlIGFuZCBlbmQgRGF0ZSByZWxhdGl2ZSB0byB0aGUgY2VudGVyRGF0ZVxuICB2YXIgZGlmZiA9ICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpO1xuXG4gIC8vIGFwcGx5IG5ldyB2YWx1ZXNcbiAgdmFyIG5ld1N0YXJ0ID0gdGhpcy5zdGFydCArIGRpZmYgKiBkZWx0YTtcbiAgdmFyIG5ld0VuZCA9IHRoaXMuZW5kICsgZGlmZiAqIGRlbHRhO1xuXG4gIC8vIFRPRE86IHJlY2tvbiB3aXRoIG1pbiBhbmQgbWF4IHJhbmdlXG5cbiAgdGhpcy5zdGFydCA9IG5ld1N0YXJ0O1xuICB0aGlzLmVuZCA9IG5ld0VuZDtcbn07XG5cbi8qKlxuICogTW92ZSB0aGUgcmFuZ2UgdG8gYSBuZXcgY2VudGVyIHBvaW50XG4gKiBAcGFyYW0ge051bWJlcn0gbW92ZVRvICAgICAgTmV3IGNlbnRlciBwb2ludCBvZiB0aGUgcmFuZ2VcbiAqL1xuUmFuZ2UucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKG1vdmVUbykge1xuICB2YXIgY2VudGVyID0gKHRoaXMuc3RhcnQgKyB0aGlzLmVuZCkgLyAyO1xuXG4gIHZhciBkaWZmID0gY2VudGVyIC0gbW92ZVRvO1xuXG4gIC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgYW5kIGVuZFxuICB2YXIgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0IC0gZGlmZjtcbiAgdmFyIG5ld0VuZCA9IHRoaXMuZW5kIC0gZGlmZjtcblxuICB0aGlzLnNldFJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZTtcbiIsIi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBvcmRlcmluZyBhbmQgc3RhY2tpbmcgb2YgaXRlbXNcbnZhciBFUFNJTE9OID0gMC4wMDE7IC8vIHVzZWQgd2hlbiBjaGVja2luZyBjb2xsaXNpb25zLCB0byBwcmV2ZW50IHJvdW5kLW9mZiBlcnJvcnNcblxuLyoqXG4gKiBPcmRlciBpdGVtcyBieSB0aGVpciBzdGFydCBkYXRhXG4gKiBAcGFyYW0ge0l0ZW1bXX0gaXRlbXNcbiAqL1xuZXhwb3J0cy5vcmRlckJ5U3RhcnQgPSBmdW5jdGlvbihpdGVtcykge1xuICBpdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZGF0YS5zdGFydCAtIGIuZGF0YS5zdGFydDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIE9yZGVyIGl0ZW1zIGJ5IHRoZWlyIGVuZCBkYXRlLiBJZiB0aGV5IGhhdmUgbm8gZW5kIGRhdGUsIHRoZWlyIHN0YXJ0IGRhdGVcbiAqIGlzIHVzZWQuXG4gKiBAcGFyYW0ge0l0ZW1bXX0gaXRlbXNcbiAqL1xuZXhwb3J0cy5vcmRlckJ5RW5kID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgaXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhVGltZSA9ICgnZW5kJyBpbiBhLmRhdGEpID8gYS5kYXRhLmVuZCA6IGEuZGF0YS5zdGFydCxcbiAgICAgICAgYlRpbWUgPSAoJ2VuZCcgaW4gYi5kYXRhKSA/IGIuZGF0YS5lbmQgOiBiLmRhdGEuc3RhcnQ7XG5cbiAgICByZXR1cm4gYVRpbWUgLSBiVGltZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkanVzdCB2ZXJ0aWNhbCBwb3NpdGlvbnMgb2YgdGhlIGl0ZW1zIHN1Y2ggdGhhdCB0aGV5IGRvbid0IG92ZXJsYXAgZWFjaFxuICogb3RoZXIuXG4gKiBAcGFyYW0ge0l0ZW1bXX0gaXRlbXNcbiAqICAgICAgICAgICAgQWxsIHZpc2libGUgaXRlbXNcbiAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAqICAgICAgICAgICAgTWFyZ2lucyBiZXR3ZWVuIGl0ZW1zIGFuZCBiZXR3ZWVuIGl0ZW1zIGFuZCB0aGUgYXhpcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXVxuICogICAgICAgICAgICBJZiB0cnVlLCBhbGwgaXRlbXMgd2lsbCBiZSByZXBvc2l0aW9uZWQuIElmIGZhbHNlIChkZWZhdWx0KSwgb25seVxuICogICAgICAgICAgICBpdGVtcyBoYXZpbmcgYSB0b3A9PT1udWxsIHdpbGwgYmUgcmUtc3RhY2tlZFxuICovXG5leHBvcnRzLnN0YWNrID0gZnVuY3Rpb24oaXRlbXMsIG1hcmdpbiwgZm9yY2UpIHtcbiAgdmFyIGksIGlNYXg7XG5cbiAgaWYgKGZvcmNlKSB7XG4gICAgLy8gcmVzZXQgdG9wIHBvc2l0aW9uIG9mIGFsbCBpdGVtc1xuICAgIGZvciAoaSA9IDAsIGlNYXggPSBpdGVtcy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGl0ZW1zW2ldLnRvcCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIG5ldywgbm9uLW92ZXJsYXBwaW5nIHBvc2l0aW9uc1xuICBmb3IgKGkgPSAwLCBpTWF4ID0gaXRlbXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBpZiAoaXRlbS50b3AgPT09IG51bGwpIHtcbiAgICAgIC8vIGluaXRpYWxpemUgdG9wIHBvc2l0aW9uXG4gICAgICBpdGVtLnRvcCA9IG1hcmdpbi5heGlzO1xuXG4gICAgICBkbyB7XG4gICAgICAgIC8vIFRPRE86IG9wdGltaXplIGNoZWNraW5nIGZvciBvdmVybGFwLiB3aGVuIHRoZXJlIGlzIGEgZ2FwIHdpdGhvdXQgaXRlbXMsXG4gICAgICAgIC8vICAgICAgIHlvdSBvbmx5IG5lZWQgdG8gY2hlY2sgZm9yIGl0ZW1zIGZyb20gdGhlIG5leHQgaXRlbSBvbiwgbm90IGZyb20gemVyb1xuICAgICAgICB2YXIgY29sbGlkaW5nSXRlbSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGl0ZW1zLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICB2YXIgb3RoZXIgPSBpdGVtc1tqXTtcbiAgICAgICAgICBpZiAob3RoZXIudG9wICE9PSBudWxsICYmIG90aGVyICE9PSBpdGVtICYmIGV4cG9ydHMuY29sbGlzaW9uKGl0ZW0sIG90aGVyLCBtYXJnaW4uaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbGxpZGluZ0l0ZW0gPSBvdGhlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2xsaWRpbmdJdGVtICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBhIGNvbGxpc2lvbi4gUmVwb3NpdGlvbiB0aGUgaXRlbXMgYWJvdmUgdGhlIGNvbGxpZGluZyBlbGVtZW50XG4gICAgICAgICAgaXRlbS50b3AgPSBjb2xsaWRpbmdJdGVtLnRvcCArIGNvbGxpZGluZ0l0ZW0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKGNvbGxpZGluZ0l0ZW0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGp1c3QgdmVydGljYWwgcG9zaXRpb25zIG9mIHRoZSBpdGVtcyB3aXRob3V0IHN0YWNraW5nIHRoZW1cbiAqIEBwYXJhbSB7SXRlbVtdfSBpdGVtc1xuICogICAgICAgICAgICBBbGwgdmlzaWJsZSBpdGVtc1xuICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICogICAgICAgICAgICBNYXJnaW5zIGJldHdlZW4gaXRlbXMgYW5kIGJldHdlZW4gaXRlbXMgYW5kIHRoZSBheGlzLlxuICovXG5leHBvcnRzLm5vc3RhY2sgPSBmdW5jdGlvbihpdGVtcywgbWFyZ2luKSB7XG4gIHZhciBpLCBpTWF4O1xuXG4gIC8vIHJlc2V0IHRvcCBwb3NpdGlvbiBvZiBhbGwgaXRlbXNcbiAgZm9yIChpID0gMCwgaU1heCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgIGl0ZW1zW2ldLnRvcCA9IG1hcmdpbi5heGlzO1xuICB9XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhlIHR3byBwcm92aWRlZCBpdGVtcyBjb2xsaWRlXG4gKiBUaGUgaXRlbXMgbXVzdCBoYXZlIHBhcmFtZXRlcnMgbGVmdCwgd2lkdGgsIHRvcCwgYW5kIGhlaWdodC5cbiAqIEBwYXJhbSB7SXRlbX0gYSAgICAgICAgICBUaGUgZmlyc3QgaXRlbVxuICogQHBhcmFtIHtJdGVtfSBiICAgICAgICAgIFRoZSBzZWNvbmQgaXRlbVxuICogQHBhcmFtIHt7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfX0gbWFyZ2luXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW0gcmVxdWlyZWQgbWFyZ2luLlxuICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgIHRydWUgaWYgYSBhbmQgYiBjb2xsaWRlLCBlbHNlIGZhbHNlXG4gKi9cbmV4cG9ydHMuY29sbGlzaW9uID0gZnVuY3Rpb24oYSwgYiwgbWFyZ2luKSB7XG4gIHJldHVybiAoKGEubGVmdCAtIG1hcmdpbi5ob3Jpem9udGFsICsgRVBTSUxPTikgICAgICAgPCAoYi5sZWZ0ICsgYi53aWR0aCkgJiZcbiAgICAgIChhLmxlZnQgKyBhLndpZHRoICsgbWFyZ2luLmhvcml6b250YWwgLSBFUFNJTE9OKSA+IGIubGVmdCAmJlxuICAgICAgKGEudG9wIC0gbWFyZ2luLnZlcnRpY2FsICsgRVBTSUxPTikgICAgICAgICAgICAgIDwgKGIudG9wICsgYi5oZWlnaHQpICYmXG4gICAgICAoYS50b3AgKyBhLmhlaWdodCArIG1hcmdpbi52ZXJ0aWNhbCAtIEVQU0lMT04pICAgPiBiLnRvcCk7XG59O1xuIiwidmFyIG1vbWVudCA9IHJlcXVpcmUoJy4uL21vZHVsZS9tb21lbnQnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgIFRpbWVTdGVwXG4gKiBUaGUgY2xhc3MgVGltZVN0ZXAgaXMgYW4gaXRlcmF0b3IgZm9yIGRhdGVzLiBZb3UgcHJvdmlkZSBhIHN0YXJ0IGRhdGUgYW5kIGFuXG4gKiBlbmQgZGF0ZS4gVGhlIGNsYXNzIGl0c2VsZiBkZXRlcm1pbmVzIHRoZSBiZXN0IHNjYWxlIChzdGVwIHNpemUpIGJhc2VkIG9uIHRoZVxuICogcHJvdmlkZWQgc3RhcnQgRGF0ZSwgZW5kIERhdGUsIGFuZCBtaW5pbXVtU3RlcC5cbiAqXG4gKiBJZiBtaW5pbXVtU3RlcCBpcyBwcm92aWRlZCwgdGhlIHN0ZXAgc2l6ZSBpcyBjaG9zZW4gYXMgY2xvc2UgYXMgcG9zc2libGVcbiAqIHRvIHRoZSBtaW5pbXVtU3RlcCBidXQgbGFyZ2VyIHRoYW4gbWluaW11bVN0ZXAuIElmIG1pbmltdW1TdGVwIGlzIG5vdFxuICogcHJvdmlkZWQsIHRoZSBzY2FsZSBpcyBzZXQgdG8gMSBEQVkuXG4gKiBUaGUgbWluaW11bVN0ZXAgc2hvdWxkIGNvcnJlc3BvbmQgd2l0aCB0aGUgb25zY3JlZW4gc2l6ZSBvZiBhYm91dCA2IGNoYXJhY3RlcnNcbiAqXG4gKiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIHNldCBhIHNjYWxlIGJ5IGhhbmQuXG4gKiBBZnRlciBjcmVhdGlvbiwgeW91IGNhbiBpbml0aWFsaXplIHRoZSBjbGFzcyBieSBleGVjdXRpbmcgZmlyc3QoKS4gVGhlbiB5b3VcbiAqIGNhbiBpdGVyYXRlIGZyb20gdGhlIHN0YXJ0IGRhdGUgdG8gdGhlIGVuZCBkYXRlIHZpYSBuZXh0KCkuIFlvdSBjYW4gY2hlY2sgaWZcbiAqIHRoZSBlbmQgZGF0ZSBpcyByZWFjaGVkIHdpdGggdGhlIGZ1bmN0aW9uIGhhc05leHQoKS4gQWZ0ZXIgZWFjaCBzdGVwLCB5b3UgY2FuXG4gKiByZXRyaWV2ZSB0aGUgY3VycmVudCBkYXRlIHZpYSBnZXRDdXJyZW50KCkuXG4gKiBUaGUgVGltZVN0ZXAgaGFzIHNjYWxlcyByYW5naW5nIGZyb20gbWlsbGlzZWNvbmRzLCBzZWNvbmRzLCBtaW51dGVzLCBob3VycyxcbiAqIGRheXMsIHRvIHllYXJzLlxuICpcbiAqIFZlcnNpb246IDEuMlxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gW3N0YXJ0XSAgICAgICAgIFRoZSBzdGFydCBkYXRlLCBmb3IgZXhhbXBsZSBuZXcgRGF0ZSgyMDEwLCA5LCAyMSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIG5ldyBEYXRlKDIwMTAsIDksIDIxLCAyMywgNDUsIDAwKVxuICogQHBhcmFtIHtEYXRlfSBbZW5kXSAgICAgICAgICAgVGhlIGVuZCBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW21pbmltdW1TdGVwXSBPcHRpb25hbC4gTWluaW11bSBzdGVwIHNpemUgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmZ1bmN0aW9uIFRpbWVTdGVwKHN0YXJ0LCBlbmQsIG1pbmltdW1TdGVwKSB7XG4gIC8vIHZhcmlhYmxlc1xuICB0aGlzLmN1cnJlbnQgPSBuZXcgRGF0ZSgpO1xuICB0aGlzLl9zdGFydCA9IG5ldyBEYXRlKCk7XG4gIHRoaXMuX2VuZCA9IG5ldyBEYXRlKCk7XG5cbiAgdGhpcy5hdXRvU2NhbGUgID0gdHJ1ZTtcbiAgdGhpcy5zY2FsZSA9IFRpbWVTdGVwLlNDQUxFLkRBWTtcbiAgdGhpcy5zdGVwID0gMTtcblxuICAvLyBpbml0aWFsaXplIHRoZSByYW5nZVxuICB0aGlzLnNldFJhbmdlKHN0YXJ0LCBlbmQsIG1pbmltdW1TdGVwKTtcbn1cblxuLy8vIGVudW0gc2NhbGVcblRpbWVTdGVwLlNDQUxFID0ge1xuICBNSUxMSVNFQ09ORDogMSxcbiAgU0VDT05EOiAyLFxuICBNSU5VVEU6IDMsXG4gIEhPVVI6IDQsXG4gIERBWTogNSxcbiAgV0VFS0RBWTogNixcbiAgTU9OVEg6IDcsXG4gIFlFQVI6IDhcbn07XG5cblxuLyoqXG4gKiBTZXQgYSBuZXcgcmFuZ2VcbiAqIElmIG1pbmltdW1TdGVwIGlzIHByb3ZpZGVkLCB0aGUgc3RlcCBzaXplIGlzIGNob3NlbiBhcyBjbG9zZSBhcyBwb3NzaWJsZVxuICogdG8gdGhlIG1pbmltdW1TdGVwIGJ1dCBsYXJnZXIgdGhhbiBtaW5pbXVtU3RlcC4gSWYgbWluaW11bVN0ZXAgaXMgbm90XG4gKiBwcm92aWRlZCwgdGhlIHNjYWxlIGlzIHNldCB0byAxIERBWS5cbiAqIFRoZSBtaW5pbXVtU3RlcCBzaG91bGQgY29ycmVzcG9uZCB3aXRoIHRoZSBvbnNjcmVlbiBzaXplIG9mIGFib3V0IDYgY2hhcmFjdGVyc1xuICogQHBhcmFtIHtEYXRlfSBbc3RhcnRdICAgICAgVGhlIHN0YXJ0IGRhdGUgYW5kIHRpbWUuXG4gKiBAcGFyYW0ge0RhdGV9IFtlbmRdICAgICAgICBUaGUgZW5kIGRhdGUgYW5kIHRpbWUuXG4gKiBAcGFyYW0ge2ludH0gW21pbmltdW1TdGVwXSBPcHRpb25hbC4gTWluaW11bSBzdGVwIHNpemUgaW4gbWlsbGlzZWNvbmRzXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG1pbmltdW1TdGVwKSB7XG4gIGlmICghKHN0YXJ0IGluc3RhbmNlb2YgRGF0ZSkgfHwgIShlbmQgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHRocm93ICBcIk5vIGxlZ2FsIHN0YXJ0IG9yIGVuZCBkYXRlIGluIG1ldGhvZCBzZXRSYW5nZVwiO1xuICB9XG5cbiAgdGhpcy5fc3RhcnQgPSAoc3RhcnQgIT0gdW5kZWZpbmVkKSA/IG5ldyBEYXRlKHN0YXJ0LnZhbHVlT2YoKSkgOiBuZXcgRGF0ZSgpO1xuICB0aGlzLl9lbmQgPSAoZW5kICE9IHVuZGVmaW5lZCkgPyBuZXcgRGF0ZShlbmQudmFsdWVPZigpKSA6IG5ldyBEYXRlKCk7XG5cbiAgaWYgKHRoaXMuYXV0b1NjYWxlKSB7XG4gICAgdGhpcy5zZXRNaW5pbXVtU3RlcChtaW5pbXVtU3RlcCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSByYW5nZSBpdGVyYXRvciB0byB0aGUgc3RhcnQgZGF0ZS5cbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3VycmVudCA9IG5ldyBEYXRlKHRoaXMuX3N0YXJ0LnZhbHVlT2YoKSk7XG4gIHRoaXMucm91bmRUb01pbm9yKCk7XG59O1xuXG4vKipcbiAqIFJvdW5kIHRoZSBjdXJyZW50IGRhdGUgdG8gdGhlIGZpcnN0IG1pbm9yIGRhdGUgdmFsdWVcbiAqIFRoaXMgbXVzdCBiZSBleGVjdXRlZCBvbmNlIHdoZW4gdGhlIGN1cnJlbnQgZGF0ZSBpcyBzZXQgdG8gc3RhcnQgRGF0ZVxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUucm91bmRUb01pbm9yID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJvdW5kIHRvIGZsb29yXG4gIC8vIElNUE9SVEFOVDogd2UgaGF2ZSBubyBicmVha3MgaW4gdGhpcyBzd2l0Y2ghICh0aGlzIGlzIG5vIGJ1ZylcbiAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuWUVBUjpcbiAgICAgIHRoaXMuY3VycmVudC5zZXRGdWxsWWVhcih0aGlzLnN0ZXAgKiBNYXRoLmZsb29yKHRoaXMuY3VycmVudC5nZXRGdWxsWWVhcigpIC8gdGhpcy5zdGVwKSk7XG4gICAgICB0aGlzLmN1cnJlbnQuc2V0TW9udGgoMCk7XG4gICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5NT05USDogICAgICAgIHRoaXMuY3VycmVudC5zZXREYXRlKDEpO1xuICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuREFZOiAgICAgICAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLldFRUtEQVk6ICAgICAgdGhpcy5jdXJyZW50LnNldEhvdXJzKDApO1xuICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuSE9VUjogICAgICAgICB0aGlzLmN1cnJlbnQuc2V0TWludXRlcygwKTtcbiAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLk1JTlVURTogICAgICAgdGhpcy5jdXJyZW50LnNldFNlY29uZHMoMCk7XG4gICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5TRUNPTkQ6ICAgICAgIHRoaXMuY3VycmVudC5zZXRNaWxsaXNlY29uZHMoMCk7XG4gICAgLy9jYXNlIFRpbWVTdGVwLlNDQUxFLk1JTExJU0VDT05EOiAvLyBub3RoaW5nIHRvIGRvIGZvciBtaWxsaXNlY29uZHNcbiAgfVxuXG4gIGlmICh0aGlzLnN0ZXAgIT0gMSkge1xuICAgIC8vIHJvdW5kIGRvd24gdG8gdGhlIGZpcnN0IG1pbm9yIHZhbHVlIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiB0aGUgY3VycmVudCBzdGVwIHNpemVcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuTUlMTElTRUNPTkQ6ICB0aGlzLmN1cnJlbnQuc2V0TWlsbGlzZWNvbmRzKHRoaXMuY3VycmVudC5nZXRNaWxsaXNlY29uZHMoKSAtIHRoaXMuY3VycmVudC5nZXRNaWxsaXNlY29uZHMoKSAlIHRoaXMuc3RlcCk7ICBicmVhaztcbiAgICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuU0VDT05EOiAgICAgICB0aGlzLmN1cnJlbnQuc2V0U2Vjb25kcyh0aGlzLmN1cnJlbnQuZ2V0U2Vjb25kcygpIC0gdGhpcy5jdXJyZW50LmdldFNlY29uZHMoKSAlIHRoaXMuc3RlcCk7IGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5NSU5VVEU6ICAgICAgIHRoaXMuY3VycmVudC5zZXRNaW51dGVzKHRoaXMuY3VycmVudC5nZXRNaW51dGVzKCkgLSB0aGlzLmN1cnJlbnQuZ2V0TWludXRlcygpICUgdGhpcy5zdGVwKTsgYnJlYWs7XG4gICAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLkhPVVI6ICAgICAgICAgdGhpcy5jdXJyZW50LnNldEhvdXJzKHRoaXMuY3VycmVudC5nZXRIb3VycygpIC0gdGhpcy5jdXJyZW50LmdldEhvdXJzKCkgJSB0aGlzLnN0ZXApOyBicmVhaztcbiAgICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuV0VFS0RBWTogICAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuREFZOiAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0RGF0ZSgodGhpcy5jdXJyZW50LmdldERhdGUoKS0xKSAtICh0aGlzLmN1cnJlbnQuZ2V0RGF0ZSgpLTEpICUgdGhpcy5zdGVwICsgMSk7IGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5NT05USDogICAgICAgIHRoaXMuY3VycmVudC5zZXRNb250aCh0aGlzLmN1cnJlbnQuZ2V0TW9udGgoKSAtIHRoaXMuY3VycmVudC5nZXRNb250aCgpICUgdGhpcy5zdGVwKTsgIGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5ZRUFSOiAgICAgICAgIHRoaXMuY3VycmVudC5zZXRGdWxsWWVhcih0aGlzLmN1cnJlbnQuZ2V0RnVsbFllYXIoKSAtIHRoaXMuY3VycmVudC5nZXRGdWxsWWVhcigpICUgdGhpcy5zdGVwKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRoZXJlIGlzIGEgbmV4dCBzdGVwXG4gKiBAcmV0dXJuIHtib29sZWFufSAgdHJ1ZSBpZiB0aGUgY3VycmVudCBkYXRlIGhhcyBub3QgcGFzc2VkIHRoZSBlbmQgZGF0ZVxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmN1cnJlbnQudmFsdWVPZigpIDw9IHRoaXMuX2VuZC52YWx1ZU9mKCkpO1xufTtcblxuLyoqXG4gKiBEbyB0aGUgbmV4dCBzdGVwXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50LnZhbHVlT2YoKTtcblxuICAvLyBUd28gY2FzZXMsIG5lZWRlZCB0byBwcmV2ZW50IGlzc3VlcyB3aXRoIHN3aXRjaGluZyBkYXlsaWdodCBzYXZpbmdzXG4gIC8vIChlbmQgb2YgTWFyY2ggYW5kIGVuZCBvZiBPY3RvYmVyKVxuICBpZiAodGhpcy5jdXJyZW50LmdldE1vbnRoKCkgPCA2KSAgIHtcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuTUlMTElTRUNPTkQ6XG5cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IERhdGUodGhpcy5jdXJyZW50LnZhbHVlT2YoKSArIHRoaXMuc3RlcCk7IGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5TRUNPTkQ6ICAgICAgIHRoaXMuY3VycmVudCA9IG5ldyBEYXRlKHRoaXMuY3VycmVudC52YWx1ZU9mKCkgKyB0aGlzLnN0ZXAgKiAxMDAwKTsgYnJlYWs7XG4gICAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLk1JTlVURTogICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IERhdGUodGhpcy5jdXJyZW50LnZhbHVlT2YoKSArIHRoaXMuc3RlcCAqIDEwMDAgKiA2MCk7IGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5IT1VSOlxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgRGF0ZSh0aGlzLmN1cnJlbnQudmFsdWVPZigpICsgdGhpcy5zdGVwICogMTAwMCAqIDYwICogNjApO1xuICAgICAgICAvLyBpbiBjYXNlIG9mIHNraXBwaW5nIGFuIGhvdXIgZm9yIGRheWxpZ2h0IHNhdmluZ3MsIGFkanVzdCB0aGUgaG91ciBhZ2FpbiAoZWxzZSB5b3UgZ2V0OiAwaCA1aCA5aCAuLi4gaW5zdGVhZCBvZiAwaCA0aCA4aCAuLi4pXG4gICAgICAgIHZhciBoID0gdGhpcy5jdXJyZW50LmdldEhvdXJzKCk7XG4gICAgICAgIHRoaXMuY3VycmVudC5zZXRIb3VycyhoIC0gKGggJSB0aGlzLnN0ZXApKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLldFRUtEQVk6ICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLkRBWTogICAgICAgICAgdGhpcy5jdXJyZW50LnNldERhdGUodGhpcy5jdXJyZW50LmdldERhdGUoKSArIHRoaXMuc3RlcCk7IGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5NT05USDogICAgICAgIHRoaXMuY3VycmVudC5zZXRNb250aCh0aGlzLmN1cnJlbnQuZ2V0TW9udGgoKSArIHRoaXMuc3RlcCk7IGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5ZRUFSOiAgICAgICAgIHRoaXMuY3VycmVudC5zZXRGdWxsWWVhcih0aGlzLmN1cnJlbnQuZ2V0RnVsbFllYXIoKSArIHRoaXMuc3RlcCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5NSUxMSVNFQ09ORDogIHRoaXMuY3VycmVudCA9IG5ldyBEYXRlKHRoaXMuY3VycmVudC52YWx1ZU9mKCkgKyB0aGlzLnN0ZXApOyBicmVhaztcbiAgICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuU0VDT05EOiAgICAgICB0aGlzLmN1cnJlbnQuc2V0U2Vjb25kcyh0aGlzLmN1cnJlbnQuZ2V0U2Vjb25kcygpICsgdGhpcy5zdGVwKTsgYnJlYWs7XG4gICAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLk1JTlVURTogICAgICAgdGhpcy5jdXJyZW50LnNldE1pbnV0ZXModGhpcy5jdXJyZW50LmdldE1pbnV0ZXMoKSArIHRoaXMuc3RlcCk7IGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5IT1VSOiAgICAgICAgIHRoaXMuY3VycmVudC5zZXRIb3Vycyh0aGlzLmN1cnJlbnQuZ2V0SG91cnMoKSArIHRoaXMuc3RlcCk7IGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5XRUVLREFZOiAgICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5EQVk6ICAgICAgICAgIHRoaXMuY3VycmVudC5zZXREYXRlKHRoaXMuY3VycmVudC5nZXREYXRlKCkgKyB0aGlzLnN0ZXApOyBicmVhaztcbiAgICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuTU9OVEg6ICAgICAgICB0aGlzLmN1cnJlbnQuc2V0TW9udGgodGhpcy5jdXJyZW50LmdldE1vbnRoKCkgKyB0aGlzLnN0ZXApOyBicmVhaztcbiAgICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuWUVBUjogICAgICAgICB0aGlzLmN1cnJlbnQuc2V0RnVsbFllYXIodGhpcy5jdXJyZW50LmdldEZ1bGxZZWFyKCkgKyB0aGlzLnN0ZXApOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnN0ZXAgIT0gMSkge1xuICAgIC8vIHJvdW5kIGRvd24gdG8gdGhlIGNvcnJlY3QgbWFqb3IgdmFsdWVcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuTUlMTElTRUNPTkQ6ICBpZih0aGlzLmN1cnJlbnQuZ2V0TWlsbGlzZWNvbmRzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5zZXRNaWxsaXNlY29uZHMoMCk7ICBicmVhaztcbiAgICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuU0VDT05EOiAgICAgICBpZih0aGlzLmN1cnJlbnQuZ2V0U2Vjb25kcygpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQuc2V0U2Vjb25kcygwKTsgIGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5NSU5VVEU6ICAgICAgIGlmKHRoaXMuY3VycmVudC5nZXRNaW51dGVzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5zZXRNaW51dGVzKDApOyAgYnJlYWs7XG4gICAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLkhPVVI6ICAgICAgICAgaWYodGhpcy5jdXJyZW50LmdldEhvdXJzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5zZXRIb3VycygwKTsgIGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5XRUVLREFZOiAgICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5EQVk6ICAgICAgICAgIGlmKHRoaXMuY3VycmVudC5nZXREYXRlKCkgPCB0aGlzLnN0ZXArMSkgdGhpcy5jdXJyZW50LnNldERhdGUoMSk7IGJyZWFrO1xuICAgICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5NT05USDogICAgICAgIGlmKHRoaXMuY3VycmVudC5nZXRNb250aCgpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQuc2V0TW9udGgoMCk7ICBicmVhaztcbiAgICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuWUVBUjogICAgICAgICBicmVhazsgLy8gbm90aGluZyB0byBkbyBmb3IgeWVhclxuICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gc2FmZXR5IG1lY2hhbmlzbTogaWYgY3VycmVudCB0aW1lIGlzIHN0aWxsIHVuY2hhbmdlZCwgbW92ZSB0byB0aGUgZW5kXG4gIGlmICh0aGlzLmN1cnJlbnQudmFsdWVPZigpID09IHByZXYpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgRGF0ZSh0aGlzLl9lbmQudmFsdWVPZigpKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBkYXRldGltZVxuICogQHJldHVybiB7RGF0ZX0gIGN1cnJlbnQgVGhlIGN1cnJlbnQgZGF0ZVxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuZ2V0Q3VycmVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jdXJyZW50O1xufTtcblxuLyoqXG4gKiBTZXQgYSBjdXN0b20gc2NhbGUuIEF1dG9zY2FsaW5nIHdpbGwgYmUgZGlzYWJsZWQuXG4gKiBGb3IgZXhhbXBsZSBzZXRTY2FsZShTQ0FMRS5NSU5VVEVTLCA1KSB3aWxsIHJlc3VsdFxuICogaW4gbWlub3Igc3RlcHMgb2YgNSBtaW51dGVzLCBhbmQgbWFqb3Igc3RlcHMgb2YgYW4gaG91ci5cbiAqXG4gKiBAcGFyYW0ge1RpbWVTdGVwLlNDQUxFfSBuZXdTY2FsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBzY2FsZS4gQ2hvb3NlIGZyb20gU0NBTEUuTUlMTElTRUNPTkQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0FMRS5TRUNPTkQsIFNDQUxFLk1JTlVURSwgU0NBTEUuSE9VUixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNDQUxFLldFRUtEQVksIFNDQUxFLkRBWSwgU0NBTEUuTU9OVEgsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTQ0FMRS5ZRUFSLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICBuZXdTdGVwICAgQSBzdGVwIHNpemUsIGJ5IGRlZmF1bHQgMS4gQ2hvb3NlIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhbXBsZSAxLCAyLCA1LCBvciAxMC5cbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24obmV3U2NhbGUsIG5ld1N0ZXApIHtcbiAgdGhpcy5zY2FsZSA9IG5ld1NjYWxlO1xuXG4gIGlmIChuZXdTdGVwID4gMCkge1xuICAgIHRoaXMuc3RlcCA9IG5ld1N0ZXA7XG4gIH1cblxuICB0aGlzLmF1dG9TY2FsZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvc2NhbGluZ1xuICogQHBhcmFtIHtib29sZWFufSBlbmFibGUgIElmIHRydWUsIGF1dG9hc2NhbGluZyBpcyBzZXQgdHJ1ZVxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc2V0QXV0b1NjYWxlID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICB0aGlzLmF1dG9TY2FsZSA9IGVuYWJsZTtcbn07XG5cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IGRldGVybWluZSB0aGUgc2NhbGUgdGhhdCBiZXN0cyBmaXRzIHRoZSBwcm92aWRlZCBtaW5pbXVtIHN0ZXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluaW11bVN0ZXBdICBUaGUgbWluaW11bSBzdGVwIHNpemUgaW4gbWlsbGlzZWNvbmRzXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zZXRNaW5pbXVtU3RlcCA9IGZ1bmN0aW9uKG1pbmltdW1TdGVwKSB7XG4gIGlmIChtaW5pbXVtU3RlcCA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3RlcFllYXIgICAgICAgPSAoMTAwMCAqIDYwICogNjAgKiAyNCAqIDMwICogMTIpO1xuICB2YXIgc3RlcE1vbnRoICAgICAgPSAoMTAwMCAqIDYwICogNjAgKiAyNCAqIDMwKTtcbiAgdmFyIHN0ZXBEYXkgICAgICAgID0gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xuICB2YXIgc3RlcEhvdXIgICAgICAgPSAoMTAwMCAqIDYwICogNjApO1xuICB2YXIgc3RlcE1pbnV0ZSAgICAgPSAoMTAwMCAqIDYwKTtcbiAgdmFyIHN0ZXBTZWNvbmQgICAgID0gKDEwMDApO1xuICB2YXIgc3RlcE1pbGxpc2Vjb25kPSAoMSk7XG5cbiAgLy8gZmluZCB0aGUgc21hbGxlc3Qgc3RlcCB0aGF0IGlzIGxhcmdlciB0aGFuIHRoZSBwcm92aWRlZCBtaW5pbXVtU3RlcFxuICBpZiAoc3RlcFllYXIqMTAwMCA+IG1pbmltdW1TdGVwKSAgICAgICAge3RoaXMuc2NhbGUgPSBUaW1lU3RlcC5TQ0FMRS5ZRUFSOyAgICAgICAgdGhpcy5zdGVwID0gMTAwMDt9XG4gIGlmIChzdGVwWWVhcio1MDAgPiBtaW5pbXVtU3RlcCkgICAgICAgICB7dGhpcy5zY2FsZSA9IFRpbWVTdGVwLlNDQUxFLllFQVI7ICAgICAgICB0aGlzLnN0ZXAgPSA1MDA7fVxuICBpZiAoc3RlcFllYXIqMTAwID4gbWluaW11bVN0ZXApICAgICAgICAge3RoaXMuc2NhbGUgPSBUaW1lU3RlcC5TQ0FMRS5ZRUFSOyAgICAgICAgdGhpcy5zdGVwID0gMTAwO31cbiAgaWYgKHN0ZXBZZWFyKjUwID4gbWluaW11bVN0ZXApICAgICAgICAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuWUVBUjsgICAgICAgIHRoaXMuc3RlcCA9IDUwO31cbiAgaWYgKHN0ZXBZZWFyKjEwID4gbWluaW11bVN0ZXApICAgICAgICAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuWUVBUjsgICAgICAgIHRoaXMuc3RlcCA9IDEwO31cbiAgaWYgKHN0ZXBZZWFyKjUgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuWUVBUjsgICAgICAgIHRoaXMuc3RlcCA9IDU7fVxuICBpZiAoc3RlcFllYXIgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICAge3RoaXMuc2NhbGUgPSBUaW1lU3RlcC5TQ0FMRS5ZRUFSOyAgICAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwTW9udGgqMyA+IG1pbmltdW1TdGVwKSAgICAgICAgICB7dGhpcy5zY2FsZSA9IFRpbWVTdGVwLlNDQUxFLk1PTlRIOyAgICAgICB0aGlzLnN0ZXAgPSAzO31cbiAgaWYgKHN0ZXBNb250aCA+IG1pbmltdW1TdGVwKSAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuTU9OVEg7ICAgICAgIHRoaXMuc3RlcCA9IDE7fVxuICBpZiAoc3RlcERheSo1ID4gbWluaW11bVN0ZXApICAgICAgICAgICAge3RoaXMuc2NhbGUgPSBUaW1lU3RlcC5TQ0FMRS5EQVk7ICAgICAgICAgdGhpcy5zdGVwID0gNTt9XG4gIGlmIChzdGVwRGF5KjIgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICB7dGhpcy5zY2FsZSA9IFRpbWVTdGVwLlNDQUxFLkRBWTsgICAgICAgICB0aGlzLnN0ZXAgPSAyO31cbiAgaWYgKHN0ZXBEYXkgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuREFZOyAgICAgICAgIHRoaXMuc3RlcCA9IDE7fVxuICBpZiAoc3RlcERheS8yID4gbWluaW11bVN0ZXApICAgICAgICAgICAge3RoaXMuc2NhbGUgPSBUaW1lU3RlcC5TQ0FMRS5XRUVLREFZOyAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwSG91cio0ID4gbWluaW11bVN0ZXApICAgICAgICAgICB7dGhpcy5zY2FsZSA9IFRpbWVTdGVwLlNDQUxFLkhPVVI7ICAgICAgICB0aGlzLnN0ZXAgPSA0O31cbiAgaWYgKHN0ZXBIb3VyID4gbWluaW11bVN0ZXApICAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuSE9VUjsgICAgICAgIHRoaXMuc3RlcCA9IDE7fVxuICBpZiAoc3RlcE1pbnV0ZSoxNSA+IG1pbmltdW1TdGVwKSAgICAgICAge3RoaXMuc2NhbGUgPSBUaW1lU3RlcC5TQ0FMRS5NSU5VVEU7ICAgICAgdGhpcy5zdGVwID0gMTU7fVxuICBpZiAoc3RlcE1pbnV0ZSoxMCA+IG1pbmltdW1TdGVwKSAgICAgICAge3RoaXMuc2NhbGUgPSBUaW1lU3RlcC5TQ0FMRS5NSU5VVEU7ICAgICAgdGhpcy5zdGVwID0gMTA7fVxuICBpZiAoc3RlcE1pbnV0ZSo1ID4gbWluaW11bVN0ZXApICAgICAgICAge3RoaXMuc2NhbGUgPSBUaW1lU3RlcC5TQ0FMRS5NSU5VVEU7ICAgICAgdGhpcy5zdGVwID0gNTt9XG4gIGlmIChzdGVwTWludXRlID4gbWluaW11bVN0ZXApICAgICAgICAgICB7dGhpcy5zY2FsZSA9IFRpbWVTdGVwLlNDQUxFLk1JTlVURTsgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBTZWNvbmQqMTUgPiBtaW5pbXVtU3RlcCkgICAgICAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuU0VDT05EOyAgICAgIHRoaXMuc3RlcCA9IDE1O31cbiAgaWYgKHN0ZXBTZWNvbmQqMTAgPiBtaW5pbXVtU3RlcCkgICAgICAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuU0VDT05EOyAgICAgIHRoaXMuc3RlcCA9IDEwO31cbiAgaWYgKHN0ZXBTZWNvbmQqNSA+IG1pbmltdW1TdGVwKSAgICAgICAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuU0VDT05EOyAgICAgIHRoaXMuc3RlcCA9IDU7fVxuICBpZiAoc3RlcFNlY29uZCA+IG1pbmltdW1TdGVwKSAgICAgICAgICAge3RoaXMuc2NhbGUgPSBUaW1lU3RlcC5TQ0FMRS5TRUNPTkQ7ICAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwTWlsbGlzZWNvbmQqMjAwID4gbWluaW11bVN0ZXApICB7dGhpcy5zY2FsZSA9IFRpbWVTdGVwLlNDQUxFLk1JTExJU0VDT05EOyB0aGlzLnN0ZXAgPSAyMDA7fVxuICBpZiAoc3RlcE1pbGxpc2Vjb25kKjEwMCA+IG1pbmltdW1TdGVwKSAge3RoaXMuc2NhbGUgPSBUaW1lU3RlcC5TQ0FMRS5NSUxMSVNFQ09ORDsgdGhpcy5zdGVwID0gMTAwO31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCo1MCA+IG1pbmltdW1TdGVwKSAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuTUlMTElTRUNPTkQ7IHRoaXMuc3RlcCA9IDUwO31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCoxMCA+IG1pbmltdW1TdGVwKSAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuTUlMTElTRUNPTkQ7IHRoaXMuc3RlcCA9IDEwO31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCo1ID4gbWluaW11bVN0ZXApICAgIHt0aGlzLnNjYWxlID0gVGltZVN0ZXAuU0NBTEUuTUlMTElTRUNPTkQ7IHRoaXMuc3RlcCA9IDU7fVxuICBpZiAoc3RlcE1pbGxpc2Vjb25kID4gbWluaW11bVN0ZXApICAgICAge3RoaXMuc2NhbGUgPSBUaW1lU3RlcC5TQ0FMRS5NSUxMSVNFQ09ORDsgdGhpcy5zdGVwID0gMTt9XG59O1xuXG4vKipcbiAqIFNuYXAgYSBkYXRlIHRvIGEgcm91bmRlZCB2YWx1ZS5cbiAqIFRoZSBzbmFwIGludGVydmFscyBhcmUgZGVwZW5kZW50IG9uIHRoZSBjdXJyZW50IHNjYWxlIGFuZCBzdGVwLlxuICogQHBhcmFtIHtEYXRlfSBkYXRlICAgdGhlIGRhdGUgdG8gYmUgc25hcHBlZC5cbiAqIEByZXR1cm4ge0RhdGV9IHNuYXBwZWREYXRlXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zbmFwID0gZnVuY3Rpb24oZGF0ZSkge1xuICB2YXIgY2xvbmUgPSBuZXcgRGF0ZShkYXRlLnZhbHVlT2YoKSk7XG5cbiAgaWYgKHRoaXMuc2NhbGUgPT0gVGltZVN0ZXAuU0NBTEUuWUVBUikge1xuICAgIHZhciB5ZWFyID0gY2xvbmUuZ2V0RnVsbFllYXIoKSArIE1hdGgucm91bmQoY2xvbmUuZ2V0TW9udGgoKSAvIDEyKTtcbiAgICBjbG9uZS5zZXRGdWxsWWVhcihNYXRoLnJvdW5kKHllYXIgLyB0aGlzLnN0ZXApICogdGhpcy5zdGVwKTtcbiAgICBjbG9uZS5zZXRNb250aCgwKTtcbiAgICBjbG9uZS5zZXREYXRlKDApO1xuICAgIGNsb25lLnNldEhvdXJzKDApO1xuICAgIGNsb25lLnNldE1pbnV0ZXMoMCk7XG4gICAgY2xvbmUuc2V0U2Vjb25kcygwKTtcbiAgICBjbG9uZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gIH1cbiAgZWxzZSBpZiAodGhpcy5zY2FsZSA9PSBUaW1lU3RlcC5TQ0FMRS5NT05USCkge1xuICAgIGlmIChjbG9uZS5nZXREYXRlKCkgPiAxNSkge1xuICAgICAgY2xvbmUuc2V0RGF0ZSgxKTtcbiAgICAgIGNsb25lLnNldE1vbnRoKGNsb25lLmdldE1vbnRoKCkgKyAxKTtcbiAgICAgIC8vIGltcG9ydGFudDogZmlyc3Qgc2V0IERhdGUgdG8gMSwgYWZ0ZXIgdGhhdCBjaGFuZ2UgdGhlIG1vbnRoLlxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNsb25lLnNldERhdGUoMSk7XG4gICAgfVxuXG4gICAgY2xvbmUuc2V0SG91cnMoMCk7XG4gICAgY2xvbmUuc2V0TWludXRlcygwKTtcbiAgICBjbG9uZS5zZXRTZWNvbmRzKDApO1xuICAgIGNsb25lLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgfVxuICBlbHNlIGlmICh0aGlzLnNjYWxlID09IFRpbWVTdGVwLlNDQUxFLkRBWSkge1xuICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaCAodGhpcy5zdGVwKSB7XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGNsb25lLnNldEhvdXJzKE1hdGgucm91bmQoY2xvbmUuZ2V0SG91cnMoKSAvIDI0KSAqIDI0KTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjbG9uZS5zZXRIb3VycyhNYXRoLnJvdW5kKGNsb25lLmdldEhvdXJzKCkgLyAxMikgKiAxMik7IGJyZWFrO1xuICAgIH1cbiAgICBjbG9uZS5zZXRNaW51dGVzKDApO1xuICAgIGNsb25lLnNldFNlY29uZHMoMCk7XG4gICAgY2xvbmUuc2V0TWlsbGlzZWNvbmRzKDApO1xuICB9XG4gIGVsc2UgaWYgKHRoaXMuc2NhbGUgPT0gVGltZVN0ZXAuU0NBTEUuV0VFS0RBWSkge1xuICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaCAodGhpcy5zdGVwKSB7XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGNsb25lLnNldEhvdXJzKE1hdGgucm91bmQoY2xvbmUuZ2V0SG91cnMoKSAvIDEyKSAqIDEyKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjbG9uZS5zZXRIb3VycyhNYXRoLnJvdW5kKGNsb25lLmdldEhvdXJzKCkgLyA2KSAqIDYpOyBicmVhaztcbiAgICB9XG4gICAgY2xvbmUuc2V0TWludXRlcygwKTtcbiAgICBjbG9uZS5zZXRTZWNvbmRzKDApO1xuICAgIGNsb25lLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgfVxuICBlbHNlIGlmICh0aGlzLnNjYWxlID09IFRpbWVTdGVwLlNDQUxFLkhPVVIpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RlcCkge1xuICAgICAgY2FzZSA0OlxuICAgICAgICBjbG9uZS5zZXRNaW51dGVzKE1hdGgucm91bmQoY2xvbmUuZ2V0TWludXRlcygpIC8gNjApICogNjApOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNsb25lLnNldE1pbnV0ZXMoTWF0aC5yb3VuZChjbG9uZS5nZXRNaW51dGVzKCkgLyAzMCkgKiAzMCk7IGJyZWFrO1xuICAgIH1cbiAgICBjbG9uZS5zZXRTZWNvbmRzKDApO1xuICAgIGNsb25lLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgfSBlbHNlIGlmICh0aGlzLnNjYWxlID09IFRpbWVTdGVwLlNDQUxFLk1JTlVURSkge1xuICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaCAodGhpcy5zdGVwKSB7XG4gICAgICBjYXNlIDE1OlxuICAgICAgY2FzZSAxMDpcbiAgICAgICAgY2xvbmUuc2V0TWludXRlcyhNYXRoLnJvdW5kKGNsb25lLmdldE1pbnV0ZXMoKSAvIDUpICogNSk7XG4gICAgICAgIGNsb25lLnNldFNlY29uZHMoMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBjbG9uZS5zZXRTZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuZ2V0U2Vjb25kcygpIC8gNjApICogNjApOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNsb25lLnNldFNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5nZXRTZWNvbmRzKCkgLyAzMCkgKiAzMCk7IGJyZWFrO1xuICAgIH1cbiAgICBjbG9uZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gIH1cbiAgZWxzZSBpZiAodGhpcy5zY2FsZSA9PSBUaW1lU3RlcC5TQ0FMRS5TRUNPTkQpIHtcbiAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICBzd2l0Y2ggKHRoaXMuc3RlcCkge1xuICAgICAgY2FzZSAxNTpcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIGNsb25lLnNldFNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5nZXRTZWNvbmRzKCkgLyA1KSAqIDUpO1xuICAgICAgICBjbG9uZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBjbG9uZS5zZXRNaWxsaXNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5nZXRNaWxsaXNlY29uZHMoKSAvIDEwMDApICogMTAwMCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2xvbmUuc2V0TWlsbGlzZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuZ2V0TWlsbGlzZWNvbmRzKCkgLyA1MDApICogNTAwKTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHRoaXMuc2NhbGUgPT0gVGltZVN0ZXAuU0NBTEUuTUlMTElTRUNPTkQpIHtcbiAgICB2YXIgc3RlcCA9IHRoaXMuc3RlcCA+IDUgPyB0aGlzLnN0ZXAgLyAyIDogMTtcbiAgICBjbG9uZS5zZXRNaWxsaXNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5nZXRNaWxsaXNlY29uZHMoKSAvIHN0ZXApICogc3RlcCk7XG4gIH1cbiAgXG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYSBtYWpvciB2YWx1ZSAoZm9yIGV4YW1wbGUgd2hlbiB0aGUgc3RlcFxuICogaXMgREFZLCBhIG1ham9yIHZhbHVlIGlzIGVhY2ggZmlyc3QgZGF5IG9mIHRoZSBNT05USClcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgY3VycmVudCBkYXRlIGlzIG1ham9yLCBlbHNlIGZhbHNlLlxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuaXNNYWpvciA9IGZ1bmN0aW9uKCkge1xuICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLk1JTExJU0VDT05EOlxuICAgICAgcmV0dXJuICh0aGlzLmN1cnJlbnQuZ2V0TWlsbGlzZWNvbmRzKCkgPT0gMCk7XG4gICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5TRUNPTkQ6XG4gICAgICByZXR1cm4gKHRoaXMuY3VycmVudC5nZXRTZWNvbmRzKCkgPT0gMCk7XG4gICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5NSU5VVEU6XG4gICAgICByZXR1cm4gKHRoaXMuY3VycmVudC5nZXRIb3VycygpID09IDApICYmICh0aGlzLmN1cnJlbnQuZ2V0TWludXRlcygpID09IDApO1xuICAgIC8vIE5vdGU6IHRoaXMgaXMgbm8gYnVnLiBNYWpvciBsYWJlbCBpcyBlcXVhbCBmb3IgYm90aCBtaW51dGUgYW5kIGhvdXIgc2NhbGVcbiAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLkhPVVI6XG4gICAgICByZXR1cm4gKHRoaXMuY3VycmVudC5nZXRIb3VycygpID09IDApO1xuICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuV0VFS0RBWTogLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5EQVk6XG4gICAgICByZXR1cm4gKHRoaXMuY3VycmVudC5nZXREYXRlKCkgPT0gMSk7XG4gICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5NT05USDpcbiAgICAgIHJldHVybiAodGhpcy5jdXJyZW50LmdldE1vbnRoKCkgPT0gMCk7XG4gICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5ZRUFSOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGZvcm1hdHRlZCB0ZXh0IGZvciB0aGUgbWlub3IgYXhpc2xhYmVsLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnRcbiAqIGRhdGUgYW5kIHRoZSBzY2FsZS4gRm9yIGV4YW1wbGUgd2hlbiBzY2FsZSBpcyBNSU5VVEUsIHRoZSBjdXJyZW50IHRpbWUgaXNcbiAqIGZvcm1hdHRlZCBhcyBcImhoOm1tXCIuXG4gKiBAcGFyYW0ge0RhdGV9IFtkYXRlXSBjdXN0b20gZGF0ZS4gaWYgbm90IHByb3ZpZGVkLCBjdXJyZW50IGRhdGUgaXMgdGFrZW5cbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLmdldExhYmVsTWlub3IgPSBmdW5jdGlvbihkYXRlKSB7XG4gIGlmIChkYXRlID09IHVuZGVmaW5lZCkge1xuICAgIGRhdGUgPSB0aGlzLmN1cnJlbnQ7XG4gIH1cblxuICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLk1JTExJU0VDT05EOiAgcmV0dXJuIG1vbWVudChkYXRlKS5mb3JtYXQoJ1NTUycpO1xuICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuU0VDT05EOiAgICAgICByZXR1cm4gbW9tZW50KGRhdGUpLmZvcm1hdCgncycpO1xuICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuTUlOVVRFOiAgICAgICByZXR1cm4gbW9tZW50KGRhdGUpLmZvcm1hdCgnSEg6bW0nKTtcbiAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLkhPVVI6ICAgICAgICAgcmV0dXJuIG1vbWVudChkYXRlKS5mb3JtYXQoJ0hIOm1tJyk7XG4gICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5XRUVLREFZOiAgICAgIHJldHVybiBtb21lbnQoZGF0ZSkuZm9ybWF0KCdkZGQgRCcpO1xuICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuREFZOiAgICAgICAgICByZXR1cm4gbW9tZW50KGRhdGUpLmZvcm1hdCgnRCcpO1xuICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuTU9OVEg6ICAgICAgICByZXR1cm4gbW9tZW50KGRhdGUpLmZvcm1hdCgnTU1NJyk7XG4gICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5ZRUFSOiAgICAgICAgIHJldHVybiBtb21lbnQoZGF0ZSkuZm9ybWF0KCdZWVlZJyk7XG4gICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgZm9ybWF0dGVkIHRleHQgZm9yIHRoZSBtYWpvciBheGlzIGxhYmVsLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnRcbiAqIGRhdGUgYW5kIHRoZSBzY2FsZS4gRm9yIGV4YW1wbGUgd2hlbiBzY2FsZSBpcyBNSU5VVEUsIHRoZSBtYWpvciBzY2FsZSBpc1xuICogaG91cnMsIGFuZCB0aGUgaG91ciB3aWxsIGJlIGZvcm1hdHRlZCBhcyBcImhoXCIuXG4gKiBAcGFyYW0ge0RhdGV9IFtkYXRlXSBjdXN0b20gZGF0ZS4gaWYgbm90IHByb3ZpZGVkLCBjdXJyZW50IGRhdGUgaXMgdGFrZW5cbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLmdldExhYmVsTWFqb3IgPSBmdW5jdGlvbihkYXRlKSB7XG4gIGlmIChkYXRlID09IHVuZGVmaW5lZCkge1xuICAgIGRhdGUgPSB0aGlzLmN1cnJlbnQ7XG4gIH1cblxuICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5NSUxMSVNFQ09ORDpyZXR1cm4gbW9tZW50KGRhdGUpLmZvcm1hdCgnSEg6bW06c3MnKTtcbiAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLlNFQ09ORDogICAgIHJldHVybiBtb21lbnQoZGF0ZSkuZm9ybWF0KCdEIE1NTU0gSEg6bW0nKTtcbiAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLk1JTlVURTpcbiAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLkhPVVI6ICAgICAgIHJldHVybiBtb21lbnQoZGF0ZSkuZm9ybWF0KCdkZGQgRCBNTU1NJyk7XG4gICAgY2FzZSBUaW1lU3RlcC5TQ0FMRS5XRUVLREFZOlxuICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuREFZOiAgICAgICAgcmV0dXJuIG1vbWVudChkYXRlKS5mb3JtYXQoJ01NTU0gWVlZWScpO1xuICAgIGNhc2UgVGltZVN0ZXAuU0NBTEUuTU9OVEg6ICAgICAgcmV0dXJuIG1vbWVudChkYXRlKS5mb3JtYXQoJ1lZWVknKTtcbiAgICBjYXNlIFRpbWVTdGVwLlNDQUxFLllFQVI6ICAgICAgIHJldHVybiAnJztcbiAgICBkZWZhdWx0OiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lU3RlcDtcbiIsInZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlci1jb21wb25lbnQnKTtcbnZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBEYXRhU2V0ID0gcmVxdWlyZSgnLi4vRGF0YVNldCcpO1xudmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi4vRGF0YVZpZXcnKTtcbnZhciBSYW5nZSA9IHJlcXVpcmUoJy4vUmFuZ2UnKTtcbnZhciBDb3JlID0gcmVxdWlyZSgnLi9Db3JlJyk7XG52YXIgVGltZUF4aXMgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9UaW1lQXhpcycpO1xudmFyIEN1cnJlbnRUaW1lID0gcmVxdWlyZSgnLi9jb21wb25lbnQvQ3VycmVudFRpbWUnKTtcbnZhciBDdXN0b21UaW1lID0gcmVxdWlyZSgnLi9jb21wb25lbnQvQ3VzdG9tVGltZScpO1xudmFyIEl0ZW1TZXQgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9JdGVtU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgdGltZWxpbmUgdmlzdWFsaXphdGlvblxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXkgfCBnb29nbGUudmlzdWFsaXphdGlvbi5EYXRhVGFibGV9IFtpdGVtc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIFNlZSBUaW1lbGluZS5zZXRPcHRpb25zIGZvciB0aGUgYXZhaWxhYmxlIG9wdGlvbnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENvcmVcbiAqL1xuZnVuY3Rpb24gVGltZWxpbmUgKGNvbnRhaW5lciwgaXRlbXMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRpbWVsaW5lKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICB2YXIgbWUgPSB0aGlzO1xuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIHN0YXJ0OiBudWxsLFxuICAgIGVuZDogICBudWxsLFxuXG4gICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcblxuICAgIG9yaWVudGF0aW9uOiAnYm90dG9tJyxcbiAgICB3aWR0aDogbnVsbCxcbiAgICBoZWlnaHQ6IG51bGwsXG4gICAgbWF4SGVpZ2h0OiBudWxsLFxuICAgIG1pbkhlaWdodDogbnVsbFxuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmRlZXBFeHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gIC8vIENyZWF0ZSB0aGUgRE9NLCBwcm9wcywgYW5kIGVtaXR0ZXJcbiAgdGhpcy5fY3JlYXRlKGNvbnRhaW5lcik7XG5cbiAgLy8gYWxsIGNvbXBvbmVudHMgbGlzdGVkIGhlcmUgd2lsbCBiZSByZXBhaW50ZWQgYXV0b21hdGljYWxseVxuICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcblxuICB0aGlzLmJvZHkgPSB7XG4gICAgZG9tOiB0aGlzLmRvbSxcbiAgICBkb21Qcm9wczogdGhpcy5wcm9wcyxcbiAgICBlbWl0dGVyOiB7XG4gICAgICBvbjogdGhpcy5vbi5iaW5kKHRoaXMpLFxuICAgICAgb2ZmOiB0aGlzLm9mZi5iaW5kKHRoaXMpLFxuICAgICAgZW1pdDogdGhpcy5lbWl0LmJpbmQodGhpcylcbiAgICB9LFxuICAgIHV0aWw6IHtcbiAgICAgIHNuYXA6IG51bGwsIC8vIHdpbGwgYmUgc3BlY2lmaWVkIGFmdGVyIFRpbWVBeGlzIGlzIGNyZWF0ZWRcbiAgICAgIHRvU2NyZWVuOiBtZS5fdG9TY3JlZW4uYmluZChtZSksXG4gICAgICB0b0dsb2JhbFNjcmVlbjogbWUuX3RvR2xvYmFsU2NyZWVuLmJpbmQobWUpLCAvLyB0aGlzIHJlZmVycyB0byB0aGUgcm9vdC53aWR0aFxuICAgICAgdG9UaW1lOiBtZS5fdG9UaW1lLmJpbmQobWUpLFxuICAgICAgdG9HbG9iYWxUaW1lIDogbWUuX3RvR2xvYmFsVGltZS5iaW5kKG1lKVxuICAgIH1cbiAgfTtcblxuICAvLyByYW5nZVxuICB0aGlzLnJhbmdlID0gbmV3IFJhbmdlKHRoaXMuYm9keSk7XG4gIHRoaXMuY29tcG9uZW50cy5wdXNoKHRoaXMucmFuZ2UpO1xuICB0aGlzLmJvZHkucmFuZ2UgPSB0aGlzLnJhbmdlO1xuXG4gIC8vIHRpbWUgYXhpc1xuICB0aGlzLnRpbWVBeGlzID0gbmV3IFRpbWVBeGlzKHRoaXMuYm9keSk7XG4gIHRoaXMuY29tcG9uZW50cy5wdXNoKHRoaXMudGltZUF4aXMpO1xuICB0aGlzLmJvZHkudXRpbC5zbmFwID0gdGhpcy50aW1lQXhpcy5zbmFwLmJpbmQodGhpcy50aW1lQXhpcyk7XG5cbiAgLy8gY3VycmVudCB0aW1lIGJhclxuICB0aGlzLmN1cnJlbnRUaW1lID0gbmV3IEN1cnJlbnRUaW1lKHRoaXMuYm9keSk7XG4gIHRoaXMuY29tcG9uZW50cy5wdXNoKHRoaXMuY3VycmVudFRpbWUpO1xuXG4gIC8vIGN1c3RvbSB0aW1lIGJhclxuICAvLyBOb3RlOiB0aW1lIGJhciB3aWxsIGJlIGF0dGFjaGVkIGluIHRoaXMuc2V0T3B0aW9ucyB3aGVuIHNlbGVjdGVkXG4gIHRoaXMuY3VzdG9tVGltZSA9IG5ldyBDdXN0b21UaW1lKHRoaXMuYm9keSk7XG4gIHRoaXMuY29tcG9uZW50cy5wdXNoKHRoaXMuY3VzdG9tVGltZSk7XG5cbiAgLy8gaXRlbSBzZXRcbiAgdGhpcy5pdGVtU2V0ID0gbmV3IEl0ZW1TZXQodGhpcy5ib2R5KTtcbiAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5pdGVtU2V0KTtcblxuICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7ICAgICAgLy8gRGF0YVNldFxuICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsOyAgICAgLy8gRGF0YVNldFxuXG4gIC8vIGFwcGx5IG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICAvLyBjcmVhdGUgaXRlbXNldFxuICBpZiAoaXRlbXMpIHtcbiAgICB0aGlzLnNldEl0ZW1zKGl0ZW1zKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9XG59XG5cbi8vIEV4dGVuZCB0aGUgZnVuY3Rpb25hbGl0eSBmcm9tIENvcmVcblRpbWVsaW5lLnByb3RvdHlwZSA9IG5ldyBDb3JlKCk7XG5cbi8qKlxuICogU2V0IGl0ZW1zXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXkgfCBnb29nbGUudmlzdWFsaXphdGlvbi5EYXRhVGFibGUgfCBudWxsfSBpdGVtc1xuICovXG5UaW1lbGluZS5wcm90b3R5cGUuc2V0SXRlbXMgPSBmdW5jdGlvbihpdGVtcykge1xuICB2YXIgaW5pdGlhbExvYWQgPSAodGhpcy5pdGVtc0RhdGEgPT0gbnVsbCk7XG5cbiAgLy8gY29udmVydCB0byB0eXBlIERhdGFTZXQgd2hlbiBuZWVkZWRcbiAgdmFyIG5ld0RhdGFTZXQ7XG4gIGlmICghaXRlbXMpIHtcbiAgICBuZXdEYXRhU2V0ID0gbnVsbDtcbiAgfVxuICBlbHNlIGlmIChpdGVtcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgaXRlbXMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIG5ld0RhdGFTZXQgPSBpdGVtcztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyB0dXJuIGFuIGFycmF5IGludG8gYSBkYXRhc2V0XG4gICAgbmV3RGF0YVNldCA9IG5ldyBEYXRhU2V0KGl0ZW1zLCB7XG4gICAgICB0eXBlOiB7XG4gICAgICAgIHN0YXJ0OiAnRGF0ZScsXG4gICAgICAgIGVuZDogJ0RhdGUnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBzZXQgaXRlbXNcbiAgdGhpcy5pdGVtc0RhdGEgPSBuZXdEYXRhU2V0O1xuICB0aGlzLml0ZW1TZXQgJiYgdGhpcy5pdGVtU2V0LnNldEl0ZW1zKG5ld0RhdGFTZXQpO1xuICBpZiAoaW5pdGlhbExvYWQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnN0YXJ0ICE9IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5vcHRpb25zLnN0YXJ0ICE9IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zdGFydCA6IG51bGw7XG4gICAgICB2YXIgZW5kICAgPSB0aGlzLm9wdGlvbnMuZW5kICE9IHVuZGVmaW5lZCAgID8gdGhpcy5vcHRpb25zLmVuZCA6IG51bGw7XG5cbiAgICAgIHRoaXMuc2V0V2luZG93KHN0YXJ0LCBlbmQsIHthbmltYXRlOiBmYWxzZX0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZml0KHthbmltYXRlOiBmYWxzZX0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgZ3JvdXBzXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXkgfCBnb29nbGUudmlzdWFsaXphdGlvbi5EYXRhVGFibGV9IGdyb3Vwc1xuICovXG5UaW1lbGluZS5wcm90b3R5cGUuc2V0R3JvdXBzID0gZnVuY3Rpb24oZ3JvdXBzKSB7XG4gIC8vIGNvbnZlcnQgdG8gdHlwZSBEYXRhU2V0IHdoZW4gbmVlZGVkXG4gIHZhciBuZXdEYXRhU2V0O1xuICBpZiAoIWdyb3Vwcykge1xuICAgIG5ld0RhdGFTZXQgPSBudWxsO1xuICB9XG4gIGVsc2UgaWYgKGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICBuZXdEYXRhU2V0ID0gZ3JvdXBzO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIHR1cm4gYW4gYXJyYXkgaW50byBhIGRhdGFzZXRcbiAgICBuZXdEYXRhU2V0ID0gbmV3IERhdGFTZXQoZ3JvdXBzKTtcbiAgfVxuXG4gIHRoaXMuZ3JvdXBzRGF0YSA9IG5ld0RhdGFTZXQ7XG4gIHRoaXMuaXRlbVNldC5zZXRHcm91cHMobmV3RGF0YVNldCk7XG59O1xuXG4vKipcbiAqIFNldCBzZWxlY3RlZCBpdGVtcyBieSB0aGVpciBpZC4gUmVwbGFjZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gKiBVbmtub3duIGlkJ3MgYXJlIHNpbGVudGx5IGlnbm9yZWQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdIHwgc3RyaW5nfSBbaWRzXSAgQW4gYXJyYXkgd2l0aCB6ZXJvIG9yIG1vcmUgaWQncyBvZiB0aGUgaXRlbXMgdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC4gSWYgaWRzIGlzIGFuIGVtcHR5IGFycmF5LCBhbGwgaXRlbXMgd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGZvY3VzOiBib29sZWFuYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlLCBmb2N1cyB3aWxsIGJlIHNldCB0byB0aGUgc2VsZWN0ZWQgaXRlbShzKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRlOiBib29sZWFuIHwgbnVtYmVyYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIG51bWJlciwgdGhlIG51bWJlciBpcyB0YWtlbiBhcyBkdXJhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdGhlIGFuaW1hdGlvbi4gRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgYXBwbGljYWJsZSB3aGVuIG9wdGlvbiBmb2N1cyBpcyB0cnVlLlxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oaWRzLCBvcHRpb25zKSB7XG4gIHRoaXMuaXRlbVNldCAmJiB0aGlzLml0ZW1TZXQuc2V0U2VsZWN0aW9uKGlkcyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mb2N1cykge1xuICAgIHRoaXMuZm9jdXMoaWRzLCBvcHRpb25zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNlbGVjdGVkIGl0ZW1zIGJ5IHRoZWlyIGlkXG4gKiBAcmV0dXJuIHtBcnJheX0gaWRzICBUaGUgaWRzIG9mIHRoZSBzZWxlY3RlZCBpdGVtc1xuICovXG5UaW1lbGluZS5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLml0ZW1TZXQgJiYgdGhpcy5pdGVtU2V0LmdldFNlbGVjdGlvbigpIHx8IFtdO1xufTtcblxuLyoqXG4gKiBBZGp1c3QgdGhlIHZpc2libGUgd2luZG93IHN1Y2ggdGhhdCB0aGUgc2VsZWN0ZWQgaXRlbSAob3IgbXVsdGlwbGUgaXRlbXMpXG4gKiBhcmUgY2VudGVyZWQgb24gc2NyZWVuLlxuICogQHBhcmFtIHtTdHJpbmcgfCBTdHJpbmdbXX0gaWQgICAgIEFuIGl0ZW0gaWQgb3IgYXJyYXkgd2l0aCBpdGVtIGlkc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRlOiBib29sZWFuIHwgbnVtYmVyYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIG51bWJlciwgdGhlIG51bWJlciBpcyB0YWtlbiBhcyBkdXJhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdGhlIGFuaW1hdGlvbi4gRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgYXBwbGljYWJsZSB3aGVuIG9wdGlvbiBmb2N1cyBpcyB0cnVlXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKGlkLCBvcHRpb25zKSB7XG4gIGlmICghdGhpcy5pdGVtc0RhdGEgfHwgaWQgPT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgdmFyIGlkcyA9IEFycmF5LmlzQXJyYXkoaWQpID8gaWQgOiBbaWRdO1xuXG4gIC8vIGdldCB0aGUgc3BlY2lmaWVkIGl0ZW0ocylcbiAgdmFyIGl0ZW1zRGF0YSA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKS5nZXQoaWRzLCB7XG4gICAgdHlwZToge1xuICAgICAgc3RhcnQ6ICdEYXRlJyxcbiAgICAgIGVuZDogJ0RhdGUnXG4gICAgfVxuICB9KTtcblxuICAvLyBjYWxjdWxhdGUgbWluaW11bSBzdGFydCBhbmQgbWF4aW11bSBlbmQgb2Ygc3BlY2lmaWVkIGl0ZW1zXG4gIHZhciBzdGFydCA9IG51bGw7XG4gIHZhciBlbmQgPSBudWxsO1xuICBpdGVtc0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICB2YXIgcyA9IGl0ZW1EYXRhLnN0YXJ0LnZhbHVlT2YoKTtcbiAgICB2YXIgZSA9ICdlbmQnIGluIGl0ZW1EYXRhID8gaXRlbURhdGEuZW5kLnZhbHVlT2YoKSA6IGl0ZW1EYXRhLnN0YXJ0LnZhbHVlT2YoKTtcblxuICAgIGlmIChzdGFydCA9PT0gbnVsbCB8fCBzIDwgc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gcztcbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSBudWxsIHx8IGUgPiBlbmQpIHtcbiAgICAgIGVuZCA9IGU7XG4gICAgfVxuICB9KTtcblxuICBpZiAoc3RhcnQgIT09IG51bGwgJiYgZW5kICE9PSBudWxsKSB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBuZXcgbWlkZGxlIGFuZCBpbnRlcnZhbCBmb3IgdGhlIHdpbmRvd1xuICAgIHZhciBtaWRkbGUgPSAoc3RhcnQgKyBlbmQpIC8gMjtcbiAgICB2YXIgaW50ZXJ2YWwgPSBNYXRoLm1heCgodGhpcy5yYW5nZS5lbmQgLSB0aGlzLnJhbmdlLnN0YXJ0KSwgKGVuZCAtIHN0YXJ0KSAqIDEuMSk7XG5cbiAgICB2YXIgYW5pbWF0ZSA9IChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuYW5pbWF0ZSA6IHRydWU7XG4gICAgdGhpcy5yYW5nZS5zZXRSYW5nZShtaWRkbGUgLSBpbnRlcnZhbCAvIDIsIG1pZGRsZSArIGludGVydmFsIC8gMiwgYW5pbWF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBkYXRhIHJhbmdlIG9mIHRoZSBpdGVtIHNldC5cbiAqIEByZXR1cm5zIHt7bWluOiBEYXRlLCBtYXg6IERhdGV9fSByYW5nZSAgQSByYW5nZSB3aXRoIGEgc3RhcnQgYW5kIGVuZCBEYXRlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIG5vIG1pbmltdW0gaXMgZm91bmQsIG1pbj09bnVsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIG5vIG1heGltdW0gaXMgZm91bmQsIG1heD09bnVsbFxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuZ2V0SXRlbVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNhbGN1bGF0ZSBtaW4gZnJvbSBzdGFydCBmaWxlZFxuICB2YXIgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKSxcbiAgICBtaW4gPSBudWxsLFxuICAgIG1heCA9IG51bGw7XG5cbiAgaWYgKGRhdGFzZXQpIHtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIG1pbmltdW0gdmFsdWUgb2YgdGhlIGZpZWxkICdzdGFydCdcbiAgICB2YXIgbWluSXRlbSA9IGRhdGFzZXQubWluKCdzdGFydCcpO1xuICAgIG1pbiA9IG1pbkl0ZW0gPyB1dGlsLmNvbnZlcnQobWluSXRlbS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiBudWxsO1xuICAgIC8vIE5vdGU6IHdlIGNvbnZlcnQgZmlyc3QgdG8gRGF0ZSBhbmQgdGhlbiB0byBudW1iZXIgYmVjYXVzZSBlbHNlXG4gICAgLy8gYSBjb252ZXJzaW9uIGZyb20gSVNPRGF0ZSB0byBOdW1iZXIgd2lsbCBmYWlsXG5cbiAgICAvLyBjYWxjdWxhdGUgbWF4aW11bSB2YWx1ZSBvZiBmaWVsZHMgJ3N0YXJ0JyBhbmQgJ2VuZCdcbiAgICB2YXIgbWF4U3RhcnRJdGVtID0gZGF0YXNldC5tYXgoJ3N0YXJ0Jyk7XG4gICAgaWYgKG1heFN0YXJ0SXRlbSkge1xuICAgICAgbWF4ID0gdXRpbC5jb252ZXJ0KG1heFN0YXJ0SXRlbS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgfVxuICAgIHZhciBtYXhFbmRJdGVtID0gZGF0YXNldC5tYXgoJ2VuZCcpO1xuICAgIGlmIChtYXhFbmRJdGVtKSB7XG4gICAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgICAgbWF4ID0gdXRpbC5jb252ZXJ0KG1heEVuZEl0ZW0uZW5kLCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHV0aWwuY29udmVydChtYXhFbmRJdGVtLmVuZCwgJ0RhdGUnKS52YWx1ZU9mKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiAobWluICE9IG51bGwpID8gbmV3IERhdGUobWluKSA6IG51bGwsXG4gICAgbWF4OiAobWF4ICE9IG51bGwpID8gbmV3IERhdGUobWF4KSA6IG51bGxcbiAgfTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lbGluZTtcbiIsIi8qKlxuICogUHJvdG90eXBlIGZvciB2aXN1YWwgY29tcG9uZW50c1xuICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXIsIHJhbmdlOiBSYW5nZX19IFtib2R5XVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG5mdW5jdGlvbiBDb21wb25lbnQgKGJvZHksIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgdGhpcy5wcm9wcyA9IG51bGw7XG59XG5cbi8qKlxuICogU2V0IG9wdGlvbnMgZm9yIHRoZSBjb21wb25lbnQuIFRoZSBuZXcgb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoZVxuICogY3VycmVudCBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgY29tcG9uZW50XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgY29tcG9uZW50LiBDbGVhbnVwIERPTSBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGNvbXBvbmVudFxufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgX2lzUmVzaXplZCgpIHdhc1xuICogY2FsbGVkLlxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLl9pc1Jlc2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc2l6ZWQgPSAodGhpcy5wcm9wcy5fcHJldmlvdXNXaWR0aCAhPT0gdGhpcy5wcm9wcy53aWR0aCB8fFxuICAgICAgdGhpcy5wcm9wcy5fcHJldmlvdXNIZWlnaHQgIT09IHRoaXMucHJvcHMuaGVpZ2h0KTtcblxuICB0aGlzLnByb3BzLl9wcmV2aW91c1dpZHRoID0gdGhpcy5wcm9wcy53aWR0aDtcbiAgdGhpcy5wcm9wcy5fcHJldmlvdXNIZWlnaHQgPSB0aGlzLnByb3BzLmhlaWdodDtcblxuICByZXR1cm4gcmVzaXplZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGUvbW9tZW50Jyk7XG52YXIgbG9jYWxlcyA9IHJlcXVpcmUoJy4uL2xvY2FsZXMnKTtcblxuLyoqXG4gKiBBIGN1cnJlbnQgdGltZSBiYXJcbiAqIEBwYXJhbSB7e3JhbmdlOiBSYW5nZSwgZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3R9fSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBbc2hvd0N1cnJlbnRUaW1lXVxuICogQGNvbnN0cnVjdG9yIEN1cnJlbnRUaW1lXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gQ3VycmVudFRpbWUgKGJvZHksIG9wdGlvbnMpIHtcbiAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBzaG93Q3VycmVudFRpbWU6IHRydWUsXG5cbiAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgIGxvY2FsZTogJ2VuJ1xuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gIHRoaXMub2Zmc2V0ID0gMDtcblxuICB0aGlzLl9jcmVhdGUoKTtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbkN1cnJlbnRUaW1lLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgY3VycmVudCB0aW1lIGJhclxuICogQHByaXZhdGVcbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBiYXIuY2xhc3NOYW1lID0gJ2N1cnJlbnR0aW1lJztcbiAgYmFyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgYmFyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICBiYXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gIHRoaXMuYmFyID0gYmFyO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBDdXJyZW50VGltZSBiYXJcbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub3B0aW9ucy5zaG93Q3VycmVudFRpbWUgPSBmYWxzZTtcbiAgdGhpcy5yZWRyYXcoKTsgLy8gd2lsbCByZW1vdmUgdGhlIGJhciBmcm9tIHRoZSBET00gYW5kIHN0b3AgcmVmcmVzaGluZ1xuXG4gIHRoaXMuYm9keSA9IG51bGw7XG59O1xuXG4vKipcbiAqIFNldCBvcHRpb25zIGZvciB0aGUgY29tcG9uZW50LiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIGluIGN1cnJlbnQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gW3Nob3dDdXJyZW50VGltZV1cbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ3Nob3dDdXJyZW50VGltZScsICdsb2NhbGUnLCAnbG9jYWxlcyddLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICovXG5DdXJyZW50VGltZS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuc2hvd0N1cnJlbnRUaW1lKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsO1xuICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlICE9IHBhcmVudCkge1xuICAgICAgLy8gYXR0YWNoIHRvIHRoZSBkb21cbiAgICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuYmFyKTtcblxuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpLnZhbHVlT2YoKSArIHRoaXMub2Zmc2V0KTtcbiAgICB2YXIgeCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKG5vdyk7XG5cbiAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgdmFyIHRpdGxlID0gbG9jYWxlLmN1cnJlbnQgKyAnICcgKyBsb2NhbGUudGltZSArICc6ICcgKyBtb21lbnQobm93KS5mb3JtYXQoJ2RkZGQsIE1NTU0gRG8gWVlZWSwgSDptbTpzcycpO1xuICAgIHRpdGxlID0gdGl0bGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aXRsZS5zdWJzdHJpbmcoMSk7XG5cbiAgICB0aGlzLmJhci5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgdGhpcy5iYXIudGl0bGUgPSB0aXRsZTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyByZW1vdmUgdGhlIGxpbmUgZnJvbSB0aGUgRE9NXG4gICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgIH1cbiAgICB0aGlzLnN0b3AoKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU3RhcnQgYXV0byByZWZyZXNoaW5nIHRoZSBjdXJyZW50IHRpbWUgYmFyXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgbWUuc3RvcCgpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGludGVydmFsIHRvIHJlZnJlc2hcbiAgICB2YXIgc2NhbGUgPSBtZS5ib2R5LnJhbmdlLmNvbnZlcnNpb24obWUuYm9keS5kb21Qcm9wcy5jZW50ZXIud2lkdGgpLnNjYWxlO1xuICAgIHZhciBpbnRlcnZhbCA9IDEgLyBzY2FsZSAvIDEwO1xuICAgIGlmIChpbnRlcnZhbCA8IDMwKSAgIGludGVydmFsID0gMzA7XG4gICAgaWYgKGludGVydmFsID4gMTAwMCkgaW50ZXJ2YWwgPSAxMDAwO1xuXG4gICAgbWUucmVkcmF3KCk7XG5cbiAgICAvLyBzdGFydCBhIHRpbWVyIHRvIGFkanVzdCBmb3IgdGhlIG5ldyB0aW1lXG4gICAgbWUuY3VycmVudFRpbWVUaW1lciA9IHNldFRpbWVvdXQodXBkYXRlLCBpbnRlcnZhbCk7XG4gIH1cblxuICB1cGRhdGUoKTtcbn07XG5cbi8qKlxuICogU3RvcCBhdXRvIHJlZnJlc2hpbmcgdGhlIGN1cnJlbnQgdGltZSBiYXJcbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY3VycmVudFRpbWVUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudFRpbWVUaW1lcik7XG4gICAgZGVsZXRlIHRoaXMuY3VycmVudFRpbWVUaW1lcjtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgYSBjdXJyZW50IHRpbWUuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGV4YW1wbGUgdG8gZW5zdXJlIHRoYXQgYSBjbGllbnQnc1xuICogdGltZSBpcyBzeW5jaHJvbml6ZWQgd2l0aCBhIHNoYXJlZCBzZXJ2ZXIgdGltZS5cbiAqIEBwYXJhbSB7RGF0ZSB8IFN0cmluZyB8IE51bWJlcn0gdGltZSAgICAgQSBEYXRlLCB1bml4IHRpbWVzdGFtcCwgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSVNPIGRhdGUgc3RyaW5nLlxuICovXG5DdXJyZW50VGltZS5wcm90b3R5cGUuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbih0aW1lKSB7XG4gIHZhciB0ID0gdXRpbC5jb252ZXJ0KHRpbWUsICdEYXRlJykudmFsdWVPZigpO1xuICB2YXIgbm93ID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gIHRoaXMub2Zmc2V0ID0gdCAtIG5vdztcbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHRpbWUuXG4gKiBAcmV0dXJuIHtEYXRlfSBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUuXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5nZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IERhdGUobmV3IERhdGUoKS52YWx1ZU9mKCkgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1cnJlbnRUaW1lO1xuIiwidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlL21vbWVudCcpO1xudmFyIGxvY2FsZXMgPSByZXF1aXJlKCcuLi9sb2NhbGVzJyk7XG5cbi8qKlxuICogQSBjdXN0b20gdGltZSBiYXJcbiAqIEBwYXJhbSB7e3JhbmdlOiBSYW5nZSwgZG9tOiBPYmplY3R9fSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBbc2hvd0N1c3RvbVRpbWVdXG4gKiBAY29uc3RydWN0b3IgQ3VzdG9tVGltZVxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxuZnVuY3Rpb24gQ3VzdG9tVGltZSAoYm9keSwgb3B0aW9ucykge1xuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIHNob3dDdXN0b21UaW1lOiBmYWxzZSxcbiAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgIGxvY2FsZTogJ2VuJ1xuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgdGhpcy5jdXN0b21UaW1lID0gbmV3IERhdGUoKTtcbiAgdGhpcy5ldmVudFBhcmFtcyA9IHt9OyAvLyBzdG9yZXMgc3RhdGUgcGFyYW1ldGVycyB3aGlsZSBkcmFnZ2luZyB0aGUgYmFyXG5cbiAgLy8gY3JlYXRlIHRoZSBET01cbiAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xufVxuXG5DdXN0b21UaW1lLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBmb3IgdGhlIGNvbXBvbmVudC4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCBpbiBjdXJyZW50IG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgQXZhaWxhYmxlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93Q3VzdG9tVGltZV1cbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBjb3B5IGFsbCBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnc2hvd0N1c3RvbVRpbWUnLCAnbG9jYWxlJywgJ2xvY2FsZXMnXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIERPTSBmb3IgdGhlIGN1c3RvbSB0aW1lXG4gKiBAcHJpdmF0ZVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYmFyLmNsYXNzTmFtZSA9ICdjdXN0b210aW1lJztcbiAgYmFyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgYmFyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICBiYXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICB0aGlzLmJhciA9IGJhcjtcblxuICB2YXIgZHJhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkcmFnLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgZHJhZy5zdHlsZS50b3AgPSAnMHB4JztcbiAgZHJhZy5zdHlsZS5sZWZ0ID0gJy0xMHB4JztcbiAgZHJhZy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gIGRyYWcuc3R5bGUud2lkdGggPSAnMjBweCc7XG4gIGJhci5hcHBlbmRDaGlsZChkcmFnKTtcblxuICAvLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gIHRoaXMuaGFtbWVyID0gSGFtbWVyKGJhciwge1xuICAgIHByZXZlbnRfZGVmYXVsdDogdHJ1ZVxuICB9KTtcbiAgdGhpcy5oYW1tZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5vbignZHJhZycsICAgICAgdGhpcy5fb25EcmFnLmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5vbignZHJhZ2VuZCcsICAgdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBDdXN0b21UaW1lIGJhclxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm9wdGlvbnMuc2hvd0N1c3RvbVRpbWUgPSBmYWxzZTtcbiAgdGhpcy5yZWRyYXcoKTsgLy8gd2lsbCByZW1vdmUgdGhlIGJhciBmcm9tIHRoZSBET01cblxuICB0aGlzLmhhbW1lci5lbmFibGUoZmFsc2UpO1xuICB0aGlzLmhhbW1lciA9IG51bGw7XG5cbiAgdGhpcy5ib2R5ID0gbnVsbDtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5zaG93Q3VzdG9tVGltZSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbDtcbiAgICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSAhPSBwYXJlbnQpIHtcbiAgICAgIC8vIGF0dGFjaCB0byB0aGUgZG9tXG4gICAgICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmJhci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmFyKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmJhcik7XG4gICAgfVxuXG4gICAgdmFyIHggPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbih0aGlzLmN1c3RvbVRpbWUpO1xuXG4gICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgIHZhciB0aXRsZSA9IGxvY2FsZS50aW1lICsgJzogJyArIG1vbWVudCh0aGlzLmN1c3RvbVRpbWUpLmZvcm1hdCgnZGRkZCwgTU1NTSBEbyBZWVlZLCBIOm1tOnNzJyk7XG4gICAgdGl0bGUgPSB0aXRsZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRpdGxlLnN1YnN0cmluZygxKTtcblxuICAgIHRoaXMuYmFyLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICB0aGlzLmJhci50aXRsZSA9IHRpdGxlO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIHJlbW92ZSB0aGUgbGluZSBmcm9tIHRoZSBET01cbiAgICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5iYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXQgY3VzdG9tIHRpbWUuXG4gKiBAcGFyYW0ge0RhdGUgfCBudW1iZXIgfCBzdHJpbmd9IHRpbWVcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuc2V0Q3VzdG9tVGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgdGhpcy5jdXN0b21UaW1lID0gdXRpbC5jb252ZXJ0KHRpbWUsICdEYXRlJyk7XG4gIHRoaXMucmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGN1c3RvbSB0aW1lLlxuICogQHJldHVybiB7RGF0ZX0gY3VzdG9tVGltZVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5nZXRDdXN0b21UaW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgRGF0ZSh0aGlzLmN1c3RvbVRpbWUudmFsdWVPZigpKTtcbn07XG5cbi8qKlxuICogU3RhcnQgbW92aW5nIGhvcml6b250YWxseVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHRoaXMuZXZlbnRQYXJhbXMuZHJhZ2dpbmcgPSB0cnVlO1xuICB0aGlzLmV2ZW50UGFyYW1zLmN1c3RvbVRpbWUgPSB0aGlzLmN1c3RvbVRpbWU7XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gbW92aW5nIG9wZXJhdGluZy5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghdGhpcy5ldmVudFBhcmFtcy5kcmFnZ2luZykgcmV0dXJuO1xuXG4gIHZhciBkZWx0YVggPSBldmVudC5nZXN0dXJlLmRlbHRhWCxcbiAgICAgIHggPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbih0aGlzLmV2ZW50UGFyYW1zLmN1c3RvbVRpbWUpICsgZGVsdGFYLFxuICAgICAgdGltZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4KTtcblxuICB0aGlzLnNldEN1c3RvbVRpbWUodGltZSk7XG5cbiAgLy8gZmlyZSBhIHRpbWVjaGFuZ2UgZXZlbnRcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgndGltZWNoYW5nZScsIHtcbiAgICB0aW1lOiBuZXcgRGF0ZSh0aGlzLmN1c3RvbVRpbWUudmFsdWVPZigpKVxuICB9KTtcblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn07XG5cbi8qKlxuICogU3RvcCBtb3Zpbmcgb3BlcmF0aW5nLlxuICogQHBhcmFtIHtldmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLmV2ZW50UGFyYW1zLmRyYWdnaW5nKSByZXR1cm47XG5cbiAgLy8gZmlyZSBhIHRpbWVjaGFuZ2VkIGV2ZW50XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3RpbWVjaGFuZ2VkJywge1xuICAgIHRpbWU6IG5ldyBEYXRlKHRoaXMuY3VzdG9tVGltZS52YWx1ZU9mKCkpXG4gIH0pO1xuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDdXN0b21UaW1lO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgc3RhY2sgPSByZXF1aXJlKCcuLi9TdGFjaycpO1xudmFyIFJhbmdlSXRlbSA9IHJlcXVpcmUoJy4vaXRlbS9SYW5nZUl0ZW0nKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgR3JvdXBcbiAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nfSBncm91cElkXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtJdGVtU2V0fSBpdGVtU2V0XG4gKi9cbmZ1bmN0aW9uIEdyb3VwIChncm91cElkLCBkYXRhLCBpdGVtU2V0KSB7XG4gIHRoaXMuZ3JvdXBJZCA9IGdyb3VwSWQ7XG5cbiAgdGhpcy5pdGVtU2V0ID0gaXRlbVNldDtcblxuICB0aGlzLmRvbSA9IHt9O1xuICB0aGlzLnByb3BzID0ge1xuICAgIGxhYmVsOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH1cbiAgfTtcbiAgdGhpcy5jbGFzc05hbWUgPSBudWxsO1xuXG4gIHRoaXMuaXRlbXMgPSB7fTsgICAgICAgIC8vIGl0ZW1zIGZpbHRlcmVkIGJ5IGdyb3VwSWQgb2YgdGhpcyBncm91cFxuICB0aGlzLnZpc2libGVJdGVtcyA9IFtdOyAvLyBpdGVtcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB3aW5kb3dcbiAgdGhpcy5vcmRlcmVkSXRlbXMgPSB7ICAgLy8gaXRlbXMgc29ydGVkIGJ5IHN0YXJ0IGFuZCBieSBlbmRcbiAgICBieVN0YXJ0OiBbXSxcbiAgICBieUVuZDogW11cbiAgfTtcblxuICB0aGlzLl9jcmVhdGUoKTtcblxuICB0aGlzLnNldERhdGEoZGF0YSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIERPTSBlbGVtZW50cyBmb3IgdGhlIGdyb3VwXG4gKiBAcHJpdmF0ZVxuICovXG5Hcm91cC5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgbGFiZWwuY2xhc3NOYW1lID0gJ3ZsYWJlbCc7XG4gIHRoaXMuZG9tLmxhYmVsID0gbGFiZWw7XG5cbiAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlubmVyLmNsYXNzTmFtZSA9ICdpbm5lcic7XG4gIGxhYmVsLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgdGhpcy5kb20uaW5uZXIgPSBpbm5lcjtcblxuICB2YXIgZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBmb3JlZ3JvdW5kLmNsYXNzTmFtZSA9ICdncm91cCc7XG4gIGZvcmVncm91bmRbJ3RpbWVsaW5lLWdyb3VwJ10gPSB0aGlzO1xuICB0aGlzLmRvbS5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcblxuICB0aGlzLmRvbS5iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQuY2xhc3NOYW1lID0gJ2dyb3VwJztcblxuICB0aGlzLmRvbS5heGlzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmF4aXMuY2xhc3NOYW1lID0gJ2dyb3VwJztcblxuICAvLyBjcmVhdGUgYSBoaWRkZW4gbWFya2VyIHRvIGRldGVjdCB3aGVuIHRoZSBUaW1lbGluZXMgY29udGFpbmVyIGlzIGF0dGFjaGVkXG4gIC8vIHRvIHRoZSBET00sIG9yIHRoZSBzdHlsZSBvZiBhIHBhcmVudCBvZiB0aGUgVGltZWxpbmUgaXMgY2hhbmdlZCBmcm9tXG4gIC8vIGRpc3BsYXk6bm9uZSBpcyBjaGFuZ2VkIHRvIHZpc2libGUuXG4gIHRoaXMuZG9tLm1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5tYXJrZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICB0aGlzLmRvbS5tYXJrZXIuaW5uZXJIVE1MID0gJz8nO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLm1hcmtlcik7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZ3JvdXAgZGF0YSBmb3IgdGhpcyBncm91cFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICBHcm91cCBkYXRhLCBjYW4gY29udGFpbiBwcm9wZXJ0aWVzIGNvbnRlbnQgYW5kIGNsYXNzTmFtZVxuICovXG5Hcm91cC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gdXBkYXRlIGNvbnRlbnRzXG4gIHZhciBjb250ZW50ID0gZGF0YSAmJiBkYXRhLmNvbnRlbnQ7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIHRoaXMuZG9tLmlubmVyLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICB9XG4gIGVsc2UgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZCAmJiBjb250ZW50ICE9PSBudWxsKSB7XG4gICAgdGhpcy5kb20uaW5uZXIuaW5uZXJIVE1MID0gY29udGVudDtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmRvbS5pbm5lci5pbm5lckhUTUwgPSB0aGlzLmdyb3VwSWQgfHwgJyc7IC8vIGdyb3VwSWQgY2FuIGJlIG51bGxcbiAgfVxuXG4gIC8vIHVwZGF0ZSB0aXRsZVxuICB0aGlzLmRvbS5sYWJlbC50aXRsZSA9IGRhdGEgJiYgZGF0YS50aXRsZSB8fCAnJztcblxuICBpZiAoIXRoaXMuZG9tLmlubmVyLmZpcnN0Q2hpbGQpIHtcbiAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5pbm5lciwgJ2hpZGRlbicpO1xuICB9XG4gIGVsc2Uge1xuICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmlubmVyLCAnaGlkZGVuJyk7XG4gIH1cblxuICAvLyB1cGRhdGUgY2xhc3NOYW1lXG4gIHZhciBjbGFzc05hbWUgPSBkYXRhICYmIGRhdGEuY2xhc3NOYW1lIHx8IG51bGw7XG4gIGlmIChjbGFzc05hbWUgIT0gdGhpcy5jbGFzc05hbWUpIHtcbiAgICBpZiAodGhpcy5jbGFzc05hbWUpIHtcbiAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmxhYmVsLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5mb3JlZ3JvdW5kLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5iYWNrZ3JvdW5kLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5heGlzLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmxhYmVsLCBjbGFzc05hbWUpO1xuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmZvcmVncm91bmQsIGNsYXNzTmFtZSk7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uYmFja2dyb3VuZCwgY2xhc3NOYW1lKTtcbiAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5heGlzLCBjbGFzc05hbWUpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgd2lkdGggb2YgdGhlIGdyb3VwIGxhYmVsXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5nZXRMYWJlbFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmxhYmVsLndpZHRoO1xufTtcblxuXG4vKipcbiAqIFJlcGFpbnQgdGhpcyBncm91cFxuICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZVxuICogQHBhcmFtIHt7aXRlbToge2hvcml6b250YWw6IG51bWJlciwgdmVydGljYWw6IG51bWJlcn0sIGF4aXM6IG51bWJlcn19IG1hcmdpblxuICogQHBhcmFtIHtib29sZWFufSBbcmVzdGFjaz1mYWxzZV0gIEZvcmNlIHJlc3RhY2tpbmcgb2YgYWxsIGl0ZW1zXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGdyb3VwIGlzIHJlc2l6ZWRcbiAqL1xuR3JvdXAucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKHJhbmdlLCBtYXJnaW4sIHJlc3RhY2spIHtcbiAgdmFyIHJlc2l6ZWQgPSBmYWxzZTtcblxuICB0aGlzLnZpc2libGVJdGVtcyA9IHRoaXMuX3VwZGF0ZVZpc2libGVJdGVtcyh0aGlzLm9yZGVyZWRJdGVtcywgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcblxuICAvLyBmb3JjZSByZWNhbGN1bGF0aW9uIG9mIHRoZSBoZWlnaHQgb2YgdGhlIGl0ZW1zIHdoZW4gdGhlIG1hcmtlciBoZWlnaHQgY2hhbmdlZFxuICAvLyAoZHVlIHRvIHRoZSBUaW1lbGluZSBiZWluZyBhdHRhY2hlZCB0byB0aGUgRE9NIG9yIGNoYW5nZWQgZnJvbSBkaXNwbGF5Om5vbmUgdG8gdmlzaWJsZSlcbiAgdmFyIG1hcmtlckhlaWdodCA9IHRoaXMuZG9tLm1hcmtlci5jbGllbnRIZWlnaHQ7XG4gIGlmIChtYXJrZXJIZWlnaHQgIT0gdGhpcy5sYXN0TWFya2VySGVpZ2h0KSB7XG4gICAgdGhpcy5sYXN0TWFya2VySGVpZ2h0ID0gbWFya2VySGVpZ2h0O1xuXG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpdGVtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5yZWRyYXcoKTtcbiAgICB9KTtcblxuICAgIHJlc3RhY2sgPSB0cnVlO1xuICB9XG5cbiAgLy8gcmVwb3NpdGlvbiB2aXNpYmxlIGl0ZW1zIHZlcnRpY2FsbHlcbiAgaWYgKHRoaXMuaXRlbVNldC5vcHRpb25zLnN0YWNrKSB7IC8vIFRPRE86IHVnbHkgd2F5IHRvIGFjY2VzcyBvcHRpb25zLi4uXG4gICAgc3RhY2suc3RhY2sodGhpcy52aXNpYmxlSXRlbXMsIG1hcmdpbiwgcmVzdGFjayk7XG4gIH1cbiAgZWxzZSB7IC8vIG5vIHN0YWNraW5nXG4gICAgc3RhY2subm9zdGFjayh0aGlzLnZpc2libGVJdGVtcywgbWFyZ2luKTtcbiAgfVxuXG4gIC8vIHJlY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhlIGdyb3VwXG4gIHZhciBoZWlnaHQ7XG4gIHZhciB2aXNpYmxlSXRlbXMgPSB0aGlzLnZpc2libGVJdGVtcztcbiAgaWYgKHZpc2libGVJdGVtcy5sZW5ndGgpIHtcbiAgICB2YXIgbWluID0gdmlzaWJsZUl0ZW1zWzBdLnRvcDtcbiAgICB2YXIgbWF4ID0gdmlzaWJsZUl0ZW1zWzBdLnRvcCArIHZpc2libGVJdGVtc1swXS5oZWlnaHQ7XG4gICAgdXRpbC5mb3JFYWNoKHZpc2libGVJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgaXRlbS50b3ApO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCAoaXRlbS50b3AgKyBpdGVtLmhlaWdodCkpO1xuICAgIH0pO1xuICAgIGlmIChtaW4gPiBtYXJnaW4uYXhpcykge1xuICAgICAgLy8gdGhlcmUgaXMgYW4gZW1wdHkgZ2FwIGJldHdlZW4gdGhlIGxvd2VzdCBpdGVtIGFuZCB0aGUgYXhpc1xuICAgICAgdmFyIG9mZnNldCA9IG1pbiAtIG1hcmdpbi5heGlzO1xuICAgICAgbWF4IC09IG9mZnNldDtcbiAgICAgIHV0aWwuZm9yRWFjaCh2aXNpYmxlSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGl0ZW0udG9wIC09IG9mZnNldDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBoZWlnaHQgPSBtYXggKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbCAvIDI7XG4gIH1cbiAgZWxzZSB7XG4gICAgaGVpZ2h0ID0gbWFyZ2luLmF4aXMgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgfVxuICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHRoaXMucHJvcHMubGFiZWwuaGVpZ2h0KTtcblxuICAvLyBjYWxjdWxhdGUgYWN0dWFsIHNpemUgYW5kIHBvc2l0aW9uXG4gIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5kb20uZm9yZWdyb3VuZDtcbiAgdGhpcy50b3AgPSBmb3JlZ3JvdW5kLm9mZnNldFRvcDtcbiAgdGhpcy5sZWZ0ID0gZm9yZWdyb3VuZC5vZmZzZXRMZWZ0O1xuICB0aGlzLndpZHRoID0gZm9yZWdyb3VuZC5vZmZzZXRXaWR0aDtcbiAgcmVzaXplZCA9IHV0aWwudXBkYXRlUHJvcGVydHkodGhpcywgJ2hlaWdodCcsIGhlaWdodCkgfHwgcmVzaXplZDtcblxuICAvLyByZWNhbGN1bGF0ZSBzaXplIG9mIGxhYmVsXG4gIHJlc2l6ZWQgPSB1dGlsLnVwZGF0ZVByb3BlcnR5KHRoaXMucHJvcHMubGFiZWwsICd3aWR0aCcsIHRoaXMuZG9tLmlubmVyLmNsaWVudFdpZHRoKSB8fCByZXNpemVkO1xuICByZXNpemVkID0gdXRpbC51cGRhdGVQcm9wZXJ0eSh0aGlzLnByb3BzLmxhYmVsLCAnaGVpZ2h0JywgdGhpcy5kb20uaW5uZXIuY2xpZW50SGVpZ2h0KSB8fCByZXNpemVkO1xuXG4gIC8vIGFwcGx5IG5ldyBoZWlnaHRcbiAgdGhpcy5kb20uYmFja2dyb3VuZC5zdHlsZS5oZWlnaHQgID0gaGVpZ2h0ICsgJ3B4JztcbiAgdGhpcy5kb20uZm9yZWdyb3VuZC5zdHlsZS5oZWlnaHQgID0gaGVpZ2h0ICsgJ3B4JztcbiAgdGhpcy5kb20ubGFiZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAvLyB1cGRhdGUgdmVydGljYWwgcG9zaXRpb24gb2YgaXRlbXMgYWZ0ZXIgdGhleSBhcmUgcmUtc3RhY2tlZCBhbmQgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXAgaXMgY2FsY3VsYXRlZFxuICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLnZpc2libGVJdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLnZpc2libGVJdGVtc1tpXTtcbiAgICBpdGVtLnJlcG9zaXRpb25ZKCk7XG4gIH1cblxuICByZXR1cm4gcmVzaXplZDtcbn07XG5cbi8qKlxuICogU2hvdyB0aGlzIGdyb3VwOiBhdHRhY2ggdG8gdGhlIERPTVxuICovXG5Hcm91cC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZG9tLmxhYmVsLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLml0ZW1TZXQuZG9tLmxhYmVsU2V0LmFwcGVuZENoaWxkKHRoaXMuZG9tLmxhYmVsKTtcbiAgfVxuXG4gIGlmICghdGhpcy5kb20uZm9yZWdyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5pdGVtU2V0LmRvbS5mb3JlZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLmZvcmVncm91bmQpO1xuICB9XG5cbiAgaWYgKCF0aGlzLmRvbS5iYWNrZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLml0ZW1TZXQuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZCk7XG4gIH1cblxuICBpZiAoIXRoaXMuZG9tLmF4aXMucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuaXRlbVNldC5kb20uYXhpcy5hcHBlbmRDaGlsZCh0aGlzLmRvbS5heGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIaWRlIHRoaXMgZ3JvdXA6IHJlbW92ZSBmcm9tIHRoZSBET01cbiAqL1xuR3JvdXAucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxhYmVsID0gdGhpcy5kb20ubGFiZWw7XG4gIGlmIChsYWJlbC5wYXJlbnROb2RlKSB7XG4gICAgbGFiZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsYWJlbCk7XG4gIH1cblxuICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMuZG9tLmZvcmVncm91bmQ7XG4gIGlmIChmb3JlZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICBmb3JlZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZm9yZWdyb3VuZCk7XG4gIH1cblxuICB2YXIgYmFja2dyb3VuZCA9IHRoaXMuZG9tLmJhY2tncm91bmQ7XG4gIGlmIChiYWNrZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICBiYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFja2dyb3VuZCk7XG4gIH1cblxuICB2YXIgYXhpcyA9IHRoaXMuZG9tLmF4aXM7XG4gIGlmIChheGlzLnBhcmVudE5vZGUpIHtcbiAgICBheGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYXhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGFuIGl0ZW0gdG8gdGhlIGdyb3VwXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqL1xuR3JvdXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5pdGVtc1tpdGVtLmlkXSA9IGl0ZW07XG4gIGl0ZW0uc2V0UGFyZW50KHRoaXMpO1xuXG4gIGlmICh0aGlzLnZpc2libGVJdGVtcy5pbmRleE9mKGl0ZW0pID09IC0xKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5pdGVtU2V0LmJvZHkucmFuZ2U7IC8vIFRPRE86IG5vdCBuaWNlIGFjY2Vzc2luZyB0aGUgcmFuZ2UgbGlrZSB0aGlzXG4gICAgdGhpcy5fY2hlY2tJZlZpc2libGUoaXRlbSwgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIHRoZSBncm91cFxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGRlbGV0ZSB0aGlzLml0ZW1zW2l0ZW0uaWRdO1xuICBpdGVtLnNldFBhcmVudCh0aGlzLml0ZW1TZXQpO1xuXG4gIC8vIHJlbW92ZSBmcm9tIHZpc2libGUgaXRlbXNcbiAgdmFyIGluZGV4ID0gdGhpcy52aXNpYmxlSXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGluZGV4ICE9IC0xKSB0aGlzLnZpc2libGVJdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIC8vIFRPRE86IGFsc28gcmVtb3ZlIGZyb20gb3JkZXJlZCBpdGVtcz9cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgY29ycmVzcG9uZGluZyBEYXRhU2V0XG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqL1xuR3JvdXAucHJvdG90eXBlLnJlbW92ZUZyb21EYXRhU2V0ID0gZnVuY3Rpb24oaXRlbSkge1xuICB0aGlzLml0ZW1TZXQucmVtb3ZlSXRlbShpdGVtLmlkKTtcbn07XG5cbi8qKlxuICogUmVvcmRlciB0aGUgaXRlbXNcbiAqL1xuR3JvdXAucHJvdG90eXBlLm9yZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLml0ZW1zKTtcbiAgdGhpcy5vcmRlcmVkSXRlbXMuYnlTdGFydCA9IGFycmF5O1xuICB0aGlzLm9yZGVyZWRJdGVtcy5ieUVuZCA9IHRoaXMuX2NvbnN0cnVjdEJ5RW5kQXJyYXkoYXJyYXkpO1xuXG4gIHN0YWNrLm9yZGVyQnlTdGFydCh0aGlzLm9yZGVyZWRJdGVtcy5ieVN0YXJ0KTtcbiAgc3RhY2sub3JkZXJCeUVuZCh0aGlzLm9yZGVyZWRJdGVtcy5ieUVuZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBjb250YWluaW5nIGFsbCBpdGVtcyBiZWluZyBhIHJhbmdlIChoYXZpbmcgYW4gZW5kIGRhdGUpXG4gKiBAcGFyYW0ge0l0ZW1bXX0gYXJyYXlcbiAqIEByZXR1cm5zIHtSYW5nZUl0ZW1bXX1cbiAqIEBwcml2YXRlXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5fY29uc3RydWN0QnlFbmRBcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIHZhciBlbmRBcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gaW5zdGFuY2VvZiBSYW5nZUl0ZW0pIHtcbiAgICAgIGVuZEFycmF5LnB1c2goYXJyYXlbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kQXJyYXk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdmlzaWJsZSBpdGVtc1xuICogQHBhcmFtIHt7YnlTdGFydDogSXRlbVtdLCBieUVuZDogSXRlbVtdfX0gb3JkZXJlZEl0ZW1zICAgQWxsIGl0ZW1zIG9yZGVyZWQgYnkgc3RhcnQgZGF0ZSBhbmQgYnkgZW5kIGRhdGVcbiAqIEBwYXJhbSB7SXRlbVtdfSB2aXNpYmxlSXRlbXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBwcmV2aW91c2x5IHZpc2libGUgaXRlbXMuXG4gKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlICAgICAgICAgICAgICBWaXNpYmxlIHJhbmdlXG4gKiBAcmV0dXJuIHtJdGVtW119IHZpc2libGVJdGVtcyAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbmV3IHZpc2libGUgaXRlbXMuXG4gKiBAcHJpdmF0ZVxuICovXG5Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVZpc2libGVJdGVtcyA9IGZ1bmN0aW9uKG9yZGVyZWRJdGVtcywgdmlzaWJsZUl0ZW1zLCByYW5nZSkge1xuICB2YXIgaW5pdGlhbFBvc0J5U3RhcnQsXG4gICAgICBuZXdWaXNpYmxlSXRlbXMgPSBbXSxcbiAgICAgIGk7XG5cbiAgLy8gZmlyc3QgY2hlY2sgaWYgdGhlIGl0ZW1zIHRoYXQgd2VyZSBpbiB2aWV3IHByZXZpb3VzbHkgYXJlIHN0aWxsIGluIHZpZXcuXG4gIC8vIHRoaXMgaGFuZGxlcyB0aGUgY2FzZSBmb3IgdGhlIFJhbmdlSXRlbSB0aGF0IGlzIGJvdGggYmVmb3JlIGFuZCBhZnRlciB0aGUgY3VycmVudCBvbmUuXG4gIGlmICh2aXNpYmxlSXRlbXMubGVuZ3RoID4gMCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCB2aXNpYmxlSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NoZWNrSWZWaXNpYmxlKHZpc2libGVJdGVtc1tpXSwgbmV3VmlzaWJsZUl0ZW1zLCByYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlcmUgd2VyZSBubyB2aXNpYmxlIGl0ZW1zIHByZXZpb3VzbHksIHVzZSBiaW5hcnlTZWFyY2ggdG8gZmluZCBhIHZpc2libGUgUG9pbnRJdGVtIG9yIFJhbmdlSXRlbSAoYmFzZWQgb24gc3RhcnRUaW1lKVxuICBpZiAobmV3VmlzaWJsZUl0ZW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgaW5pdGlhbFBvc0J5U3RhcnQgPSB1dGlsLmJpbmFyeVNlYXJjaChvcmRlcmVkSXRlbXMuYnlTdGFydCwgcmFuZ2UsICdkYXRhJywnc3RhcnQnKTtcbiAgfVxuICBlbHNlIHtcbiAgICBpbml0aWFsUG9zQnlTdGFydCA9IG9yZGVyZWRJdGVtcy5ieVN0YXJ0LmluZGV4T2YobmV3VmlzaWJsZUl0ZW1zWzBdKTtcbiAgfVxuXG4gIC8vIHVzZSB2aXNpYmxlIHNlYXJjaCB0byBmaW5kIGEgdmlzaWJsZSBSYW5nZUl0ZW0gKG9ubHkgYmFzZWQgb24gZW5kVGltZSlcbiAgdmFyIGluaXRpYWxQb3NCeUVuZCA9IHV0aWwuYmluYXJ5U2VhcmNoKG9yZGVyZWRJdGVtcy5ieUVuZCwgcmFuZ2UsICdkYXRhJywnZW5kJyk7XG5cbiAgLy8gaWYgd2UgZm91bmQgYSBpbml0aWFsIElEIHRvIHVzZSwgdHJhY2UgaXQgdXAgYW5kIGRvd24gdW50aWwgd2UgbWVldCBhbiBpbnZpc2libGUgaXRlbS5cbiAgaWYgKGluaXRpYWxQb3NCeVN0YXJ0ICE9IC0xKSB7XG4gICAgZm9yIChpID0gaW5pdGlhbFBvc0J5U3RhcnQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy5fY2hlY2tJZkludmlzaWJsZShvcmRlcmVkSXRlbXMuYnlTdGFydFtpXSwgbmV3VmlzaWJsZUl0ZW1zLCByYW5nZSkpIHticmVhazt9XG4gICAgfVxuICAgIGZvciAoaSA9IGluaXRpYWxQb3NCeVN0YXJ0ICsgMTsgaSA8IG9yZGVyZWRJdGVtcy5ieVN0YXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5fY2hlY2tJZkludmlzaWJsZShvcmRlcmVkSXRlbXMuYnlTdGFydFtpXSwgbmV3VmlzaWJsZUl0ZW1zLCByYW5nZSkpIHticmVhazt9XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgd2UgZm91bmQgYSBpbml0aWFsIElEIHRvIHVzZSwgdHJhY2UgaXQgdXAgYW5kIGRvd24gdW50aWwgd2UgbWVldCBhbiBpbnZpc2libGUgaXRlbS5cbiAgaWYgKGluaXRpYWxQb3NCeUVuZCAhPSAtMSkge1xuICAgIGZvciAoaSA9IGluaXRpYWxQb3NCeUVuZDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLl9jaGVja0lmSW52aXNpYmxlKG9yZGVyZWRJdGVtcy5ieUVuZFtpXSwgbmV3VmlzaWJsZUl0ZW1zLCByYW5nZSkpIHticmVhazt9XG4gICAgfVxuICAgIGZvciAoaSA9IGluaXRpYWxQb3NCeUVuZCArIDE7IGkgPCBvcmRlcmVkSXRlbXMuYnlFbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9jaGVja0lmSW52aXNpYmxlKG9yZGVyZWRJdGVtcy5ieUVuZFtpXSwgbmV3VmlzaWJsZUl0ZW1zLCByYW5nZSkpIHticmVhazt9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1Zpc2libGVJdGVtcztcbn07XG5cblxuXG4vKipcbiAqIHRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIGFuIGl0ZW0gaXMgaW52aXNpYmxlLiBJZiBpdCBpcyBOT1Qgd2UgbWFrZSBpdCB2aXNpYmxlXG4gKiBhbmQgYWRkIGl0IHRvIHRoZSBnbG9iYWwgdmlzaWJsZSBpdGVtcy4gSWYgaXQgaXMsIHJldHVybiB0cnVlLlxuICpcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtJdGVtW119IHZpc2libGVJdGVtc1xuICogQHBhcmFtIHt7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2VcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuR3JvdXAucHJvdG90eXBlLl9jaGVja0lmSW52aXNpYmxlID0gZnVuY3Rpb24oaXRlbSwgdmlzaWJsZUl0ZW1zLCByYW5nZSkge1xuICBpZiAoaXRlbS5pc1Zpc2libGUocmFuZ2UpKSB7XG4gICAgaWYgKCFpdGVtLmRpc3BsYXllZCkgaXRlbS5zaG93KCk7XG4gICAgaXRlbS5yZXBvc2l0aW9uWCgpO1xuICAgIGlmICh2aXNpYmxlSXRlbXMuaW5kZXhPZihpdGVtKSA9PSAtMSkge1xuICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uaGlkZSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBzaW1pbGFyIHRvIHRoZSBfY2hlY2tJZkludmlzaWJsZSgpIGJ1dCBpdCBkb2VzIG5vdFxuICogcmV0dXJuIGJvb2xlYW5zLCBoaWRlcyB0aGUgaXRlbSBpZiBpdCBzaG91bGQgbm90IGJlIHNlZW4gYW5kIGFsd2F5cyBhZGRzIHRvXG4gKiB0aGUgdmlzaWJsZUl0ZW1zLlxuICogdGhpcyBvbmUgaXMgZm9yIGJydXRlIGZvcmNpbmcgYW5kIGhpZGluZy5cbiAqXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7QXJyYXl9IHZpc2libGVJdGVtc1xuICogQHBhcmFtIHt7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2VcbiAqIEBwcml2YXRlXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5fY2hlY2tJZlZpc2libGUgPSBmdW5jdGlvbihpdGVtLCB2aXNpYmxlSXRlbXMsIHJhbmdlKSB7XG4gIGlmIChpdGVtLmlzVmlzaWJsZShyYW5nZSkpIHtcbiAgICBpZiAoIWl0ZW0uZGlzcGxheWVkKSBpdGVtLnNob3coKTtcbiAgICAvLyByZXBvc2l0aW9uIGl0ZW0gaG9yaXpvbnRhbGx5XG4gICAgaXRlbS5yZXBvc2l0aW9uWCgpO1xuICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5oaWRlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXA7XG4iLCJ2YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgRGF0YVNldCA9IHJlcXVpcmUoJy4uLy4uL0RhdGFTZXQnKTtcbnZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4uLy4uL0RhdGFWaWV3Jyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbnZhciBHcm91cCA9IHJlcXVpcmUoJy4vR3JvdXAnKTtcbnZhciBCb3hJdGVtID0gcmVxdWlyZSgnLi9pdGVtL0JveEl0ZW0nKTtcbnZhciBQb2ludEl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0vUG9pbnRJdGVtJyk7XG52YXIgUmFuZ2VJdGVtID0gcmVxdWlyZSgnLi9pdGVtL1JhbmdlSXRlbScpO1xudmFyIEJhY2tncm91bmRJdGVtID0gcmVxdWlyZSgnLi9pdGVtL0JhY2tncm91bmRJdGVtJyk7XG5cblxudmFyIFVOR1JPVVBFRCA9ICdfX3VuZ3JvdXBlZF9fJzsgLy8gcmVzZXJ2ZWQgZ3JvdXAgaWQgZm9yIHVuZ3JvdXBlZCBpdGVtc1xuXG4vKipcbiAqIEFuIEl0ZW1TZXQgaG9sZHMgYSBzZXQgb2YgaXRlbXMgYW5kIHJhbmdlcyB3aGljaCBjYW4gYmUgZGlzcGxheWVkIGluIGFcbiAqIHJhbmdlLiBUaGUgd2lkdGggaXMgZGV0ZXJtaW5lZCBieSB0aGUgcGFyZW50IG9mIHRoZSBJdGVtU2V0LCBhbmQgdGhlIGhlaWdodFxuICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgc2l6ZSBvZiB0aGUgaXRlbXMuXG4gKiBAcGFyYW0ge3tkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdCwgZW1pdHRlcjogRW1pdHRlciwgcmFuZ2U6IFJhbmdlfX0gYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgIFNlZSBJdGVtU2V0LnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvciBJdGVtU2V0XG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gSXRlbVNldChib2R5LCBvcHRpb25zKSB7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICB0eXBlOiBudWxsLCAgLy8gJ2JveCcsICdwb2ludCcsICdyYW5nZScsICdiYWNrZ3JvdW5kJ1xuICAgIG9yaWVudGF0aW9uOiAnYm90dG9tJywgIC8vICd0b3AnIG9yICdib3R0b20nXG4gICAgYWxpZ246ICdhdXRvJywgLy8gYWxpZ25tZW50IG9mIGJveCBpdGVtc1xuICAgIHN0YWNrOiB0cnVlLFxuICAgIGdyb3VwT3JkZXI6IG51bGwsXG5cbiAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgIGVkaXRhYmxlOiB7XG4gICAgICB1cGRhdGVUaW1lOiBmYWxzZSxcbiAgICAgIHVwZGF0ZUdyb3VwOiBmYWxzZSxcbiAgICAgIGFkZDogZmFsc2UsXG4gICAgICByZW1vdmU6IGZhbHNlXG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG4gICAgb25VcGRhdGU6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcbiAgICBvbk1vdmU6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcbiAgICBvblJlbW92ZTogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuICAgIG9uTW92aW5nOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG5cbiAgICBtYXJnaW46IHtcbiAgICAgIGl0ZW06IHtcbiAgICAgICAgaG9yaXpvbnRhbDogMTAsXG4gICAgICAgIHZlcnRpY2FsOiAxMFxuICAgICAgfSxcbiAgICAgIGF4aXM6IDIwXG4gICAgfSxcbiAgICBwYWRkaW5nOiA1XG4gIH07XG5cbiAgLy8gb3B0aW9ucyBpcyBzaGFyZWQgYnkgdGhpcyBJdGVtU2V0IGFuZCBhbGwgaXRzIGl0ZW1zXG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAvLyBvcHRpb25zIGZvciBnZXR0aW5nIGl0ZW1zIGZyb20gdGhlIERhdGFTZXQgd2l0aCB0aGUgY29ycmVjdCB0eXBlXG4gIHRoaXMuaXRlbU9wdGlvbnMgPSB7XG4gICAgdHlwZToge3N0YXJ0OiAnRGF0ZScsIGVuZDogJ0RhdGUnfVxuICB9O1xuXG4gIHRoaXMuY29udmVyc2lvbiA9IHtcbiAgICB0b1NjcmVlbjogYm9keS51dGlsLnRvU2NyZWVuLFxuICAgIHRvVGltZTogYm9keS51dGlsLnRvVGltZVxuICB9O1xuICB0aGlzLmRvbSA9IHt9O1xuICB0aGlzLnByb3BzID0ge307XG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICB2YXIgbWUgPSB0aGlzO1xuICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7ICAgIC8vIERhdGFTZXRcbiAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDsgICAvLyBEYXRhU2V0XG5cbiAgLy8gbGlzdGVuZXJzIGZvciB0aGUgRGF0YVNldCBvZiB0aGUgaXRlbXNcbiAgdGhpcy5pdGVtTGlzdGVuZXJzID0ge1xuICAgICdhZGQnOiBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgIG1lLl9vbkFkZChwYXJhbXMuaXRlbXMpO1xuICAgIH0sXG4gICAgJ3VwZGF0ZSc6IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgbWUuX29uVXBkYXRlKHBhcmFtcy5pdGVtcyk7XG4gICAgfSxcbiAgICAncmVtb3ZlJzogZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICBtZS5fb25SZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gbGlzdGVuZXJzIGZvciB0aGUgRGF0YVNldCBvZiB0aGUgZ3JvdXBzXG4gIHRoaXMuZ3JvdXBMaXN0ZW5lcnMgPSB7XG4gICAgJ2FkZCc6IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgbWUuX29uQWRkR3JvdXBzKHBhcmFtcy5pdGVtcyk7XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICBtZS5fb25VcGRhdGVHcm91cHMocGFyYW1zLml0ZW1zKTtcbiAgICB9LFxuICAgICdyZW1vdmUnOiBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgIG1lLl9vblJlbW92ZUdyb3VwcyhwYXJhbXMuaXRlbXMpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLml0ZW1zID0ge307ICAgICAgLy8gb2JqZWN0IHdpdGggYW4gSXRlbSBmb3IgZXZlcnkgZGF0YSBpdGVtXG4gIHRoaXMuZ3JvdXBzID0ge307ICAgICAvLyBHcm91cCBvYmplY3QgZm9yIGV2ZXJ5IGdyb3VwXG4gIHRoaXMuZ3JvdXBJZHMgPSBbXTtcblxuICB0aGlzLnNlbGVjdGlvbiA9IFtdOyAgLy8gbGlzdCB3aXRoIHRoZSBpZHMgb2YgYWxsIHNlbGVjdGVkIG5vZGVzXG4gIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGlmIHRydWUsIGFsbCBpdGVtcyB3aWxsIGJlIHJlc3RhY2tlZCBvbiBuZXh0IHJlZHJhd1xuXG4gIHRoaXMudG91Y2hQYXJhbXMgPSB7fTsgLy8gc3RvcmVzIHByb3BlcnRpZXMgd2hpbGUgZHJhZ2dpbmdcbiAgLy8gY3JlYXRlIHRoZSBIVE1MIERPTVxuXG4gIHRoaXMuX2NyZWF0ZSgpO1xuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbn1cblxuSXRlbVNldC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8vIGF2YWlsYWJsZSBpdGVtIHR5cGVzIHdpbGwgYmUgcmVnaXN0ZXJlZCBoZXJlXG5JdGVtU2V0LnR5cGVzID0ge1xuICBiYWNrZ3JvdW5kOiBCYWNrZ3JvdW5kSXRlbSxcbiAgYm94OiBCb3hJdGVtLFxuICByYW5nZTogUmFuZ2VJdGVtLFxuICBwb2ludDogUG9pbnRJdGVtXG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgSFRNTCBET00gZm9yIHRoZSBJdGVtU2V0XG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZnJhbWUuY2xhc3NOYW1lID0gJ2l0ZW1zZXQnO1xuICBmcmFtZVsndGltZWxpbmUtaXRlbXNldCddID0gdGhpcztcbiAgdGhpcy5kb20uZnJhbWUgPSBmcmFtZTtcblxuICAvLyBjcmVhdGUgYmFja2dyb3VuZCBwYW5lbFxuICB2YXIgYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBiYWNrZ3JvdW5kLmNsYXNzTmFtZSA9ICdiYWNrZ3JvdW5kJztcbiAgZnJhbWUuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZCk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXG4gIC8vIGNyZWF0ZSBmb3JlZ3JvdW5kIHBhbmVsXG4gIHZhciBmb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGZvcmVncm91bmQuY2xhc3NOYW1lID0gJ2ZvcmVncm91bmQnO1xuICBmcmFtZS5hcHBlbmRDaGlsZChmb3JlZ3JvdW5kKTtcbiAgdGhpcy5kb20uZm9yZWdyb3VuZCA9IGZvcmVncm91bmQ7XG5cbiAgLy8gY3JlYXRlIGF4aXMgcGFuZWxcbiAgdmFyIGF4aXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYXhpcy5jbGFzc05hbWUgPSAnYXhpcyc7XG4gIHRoaXMuZG9tLmF4aXMgPSBheGlzO1xuXG4gIC8vIGNyZWF0ZSBsYWJlbHNldFxuICB2YXIgbGFiZWxTZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgbGFiZWxTZXQuY2xhc3NOYW1lID0gJ2xhYmVsc2V0JztcbiAgdGhpcy5kb20ubGFiZWxTZXQgPSBsYWJlbFNldDtcblxuICAvLyBjcmVhdGUgdW5ncm91cGVkIEdyb3VwXG4gIHRoaXMuX3VwZGF0ZVVuZ3JvdXBlZCgpO1xuXG4gIC8vIGF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgLy8gTm90ZTogd2UgYmluZCB0byB0aGUgY2VudGVyQ29udGFpbmVyIGZvciB0aGUgY2FzZSB3aGVyZSB0aGUgaGVpZ2h0XG4gIC8vICAgICAgIG9mIHRoZSBjZW50ZXIgY29udGFpbmVyIGlzIGxhcmdlciB0aGFuIG9mIHRoZSBJdGVtU2V0LCBzbyB3ZVxuICAvLyAgICAgICBjYW4gY2xpY2sgaW4gdGhlIGVtcHR5IGFyZWEgdG8gY3JlYXRlIGEgbmV3IGl0ZW0gb3IgZGVzZWxlY3QgYW4gaXRlbS5cbiAgdGhpcy5oYW1tZXIgPSBIYW1tZXIodGhpcy5ib2R5LmRvbS5jZW50ZXJDb250YWluZXIsIHtcbiAgICBwcmV2ZW50X2RlZmF1bHQ6IHRydWVcbiAgfSk7XG5cbiAgLy8gZHJhZyBpdGVtcyB3aGVuIHNlbGVjdGVkXG4gIHRoaXMuaGFtbWVyLm9uKCd0b3VjaCcsICAgICB0aGlzLl9vblRvdWNoLmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5vbignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gIHRoaXMuaGFtbWVyLm9uKCdkcmFnJywgICAgICB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG4gIHRoaXMuaGFtbWVyLm9uKCdkcmFnZW5kJywgICB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKSk7XG5cbiAgLy8gc2luZ2xlIHNlbGVjdCAob3IgdW5zZWxlY3QpIHdoZW4gdGFwcGluZyBhbiBpdGVtXG4gIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCAgdGhpcy5fb25TZWxlY3RJdGVtLmJpbmQodGhpcykpO1xuXG4gIC8vIG11bHRpIHNlbGVjdCB3aGVuIGhvbGRpbmcgbW91c2UvdG91Y2gsIG9yIG9uIGN0cmwrY2xpY2tcbiAgdGhpcy5oYW1tZXIub24oJ2hvbGQnLCB0aGlzLl9vbk11bHRpU2VsZWN0SXRlbS5iaW5kKHRoaXMpKTtcblxuICAvLyBhZGQgaXRlbSBvbiBkb3VibGV0YXBcbiAgdGhpcy5oYW1tZXIub24oJ2RvdWJsZXRhcCcsIHRoaXMuX29uQWRkSXRlbS5iaW5kKHRoaXMpKTtcblxuICAvLyBhdHRhY2ggdG8gdGhlIERPTVxuICB0aGlzLnNob3coKTtcbn07XG5cbi8qKlxuICogU2V0IG9wdGlvbnMgZm9yIHRoZSBJdGVtU2V0LiBFeGlzdGluZyBvcHRpb25zIHdpbGwgYmUgZXh0ZW5kZWQvb3ZlcndyaXR0ZW4uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSB0eXBlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdHlwZSBmb3IgdGhlIGl0ZW1zLiBDaG9vc2UgZnJvbSAnYm94J1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGVmYXVsdCksICdwb2ludCcsICdyYW5nZScsIG9yICdiYWNrZ3JvdW5kJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgc3R5bGUgY2FuIGJlIG92ZXJ3cml0dGVuIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGl2aWR1YWwgaXRlbXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGFsaWduXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsaWdubWVudCBmb3IgdGhlIGl0ZW1zLCBvbmx5IGFwcGxpY2FibGUgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJveEl0ZW0uIENob29zZSAnY2VudGVyJyAoZGVmYXVsdCksICdsZWZ0Jywgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JpZ2h0Jy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gb3JpZW50YXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3JpZW50YXRpb24gb2YgdGhlIGl0ZW0gc2V0LiBDaG9vc2UgJ3RvcCcgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JvdHRvbScgKGRlZmF1bHQpLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb259IGdyb3VwT3JkZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBzb3J0aW5nIGZ1bmN0aW9uIGZvciBvcmRlcmluZyBncm91cHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IHN0YWNrXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlYWZ1bHQpLCBpdGVtcyB3aWxsIGJlIHN0YWNrZWQgb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wIG9mIGVhY2ggb3RoZXIuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpbi5heGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hcmdpbiBiZXR3ZWVuIHRoZSBheGlzIGFuZCB0aGUgaXRlbXMgaW4gcGl4ZWxzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIDIwLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uaXRlbS5ob3Jpem9udGFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhvcml6b250YWwgbWFyZ2luIGJldHdlZW4gaXRlbXMgaW4gcGl4ZWxzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIDEwLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uaXRlbS52ZXJ0aWNhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZXJ0aWNhbCBNYXJnaW4gYmV0d2VlbiBpdGVtcyBpbiBwaXhlbHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgMTAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpbi5pdGVtXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hcmdpbiBiZXR3ZWVuIGl0ZW1zIGluIHBpeGVscyBpbiBib3RoIGhvcml6b250YWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHZlcnRpY2FsIGRpcmVjdGlvbi4gRGVmYXVsdCBpcyAxMC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldCBtYXJnaW4gZm9yIGJvdGggYXhpcyBhbmQgaXRlbXMgaW4gcGl4ZWxzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBwYWRkaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhZGRpbmcgb2YgdGhlIGNvbnRlbnRzIG9mIGFuIGl0ZW0gaW4gcGl4ZWxzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNdXN0IGNvcnJlc3BvbmQgd2l0aCB0aGUgaXRlbXMgY3NzLiBEZWZhdWx0IGlzIDUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBzZWxlY3RhYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCBpdGVtcyBjYW4gYmUgc2VsZWN0ZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXQgYWxsIGVkaXRhYmxlIG9wdGlvbnMgdG8gdHJ1ZSBvciBmYWxzZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUudXBkYXRlVGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGxvdyBkcmFnZ2luZyBhbiBpdGVtIHRvIGFuIG90aGVyIG1vbWVudCBpbiB0aW1lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZS51cGRhdGVHcm91cFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGxvdyBkcmFnZ2luZyBhbiBpdGVtIHRvIGFuIG90aGVyIGdyb3VwXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZS5hZGRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxsb3cgY3JlYXRpbmcgbmV3IGl0ZW1zIG9uIGRvdWJsZSB0YXBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlLnJlbW92ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGxvdyByZW1vdmluZyBpdGVtcyBieSBjbGlja2luZyB0aGUgZGVsZXRlIGJ1dHRvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AgcmlnaHQgb2YgYSBzZWxlY3RlZCBpdGVtLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb24oaXRlbTogSXRlbSwgY2FsbGJhY2s6IEZ1bmN0aW9uKX0gb25BZGRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIHdoZW4gYW4gaXRlbSBpcyBhYm91dCB0byBiZSBhZGRlZDpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgdXNlciBkb3VibGUgdGFwcyBhbiBlbXB0eSBzcGFjZSBpbiB0aGUgVGltZWxpbmUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvblVwZGF0ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBmdW5jdGlvbiBmaXJlZCB3aGVuIGFuIGl0ZW0gaXMgYWJvdXQgdG8gYmUgdXBkYXRlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBmdW5jdGlvbiB0eXBpY2FsbHkgaGFzIHRvIHNob3cgYSBkaWFsb2cgd2hlcmUgdGhlIHVzZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlIHRoZSBpdGVtLiBJZiBub3QgaW1wbGVtZW50ZWQsIG5vdGhpbmcgaGFwcGVucy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9uKGl0ZW06IEl0ZW0sIGNhbGxiYWNrOiBGdW5jdGlvbil9IG9uTW92ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGFuIGl0ZW0gaGFzIGJlZW4gbW92ZWQuIElmIG5vdCBpbXBsZW1lbnRlZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG1vdmUgYWN0aW9uIHdpbGwgYmUgYWNjZXB0ZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvblJlbW92ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGFuIGl0ZW0gaXMgYWJvdXQgdG8gYmUgZGVsZXRlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IGltcGxlbWVudGVkLCB0aGUgaXRlbSB3aWxsIGJlIGFsd2F5cyByZW1vdmVkLlxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIC8vIGNvcHkgYWxsIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgdmFyIGZpZWxkcyA9IFsndHlwZScsICdhbGlnbicsICdvcmllbnRhdGlvbicsICdwYWRkaW5nJywgJ3N0YWNrJywgJ3NlbGVjdGFibGUnLCAnZ3JvdXBPcmRlcicsICdkYXRhQXR0cmlidXRlcycsICd0ZW1wbGF0ZSddO1xuICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICgnbWFyZ2luJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWFyZ2luID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLmF4aXMgPSBvcHRpb25zLm1hcmdpbjtcbiAgICAgICAgdGhpcy5vcHRpb25zLm1hcmdpbi5pdGVtLmhvcml6b250YWwgPSBvcHRpb25zLm1hcmdpbjtcbiAgICAgICAgdGhpcy5vcHRpb25zLm1hcmdpbi5pdGVtLnZlcnRpY2FsID0gb3B0aW9ucy5tYXJnaW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnYXhpcyddLCB0aGlzLm9wdGlvbnMubWFyZ2luLCBvcHRpb25zLm1hcmdpbik7XG4gICAgICAgIGlmICgnaXRlbScgaW4gb3B0aW9ucy5tYXJnaW4pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWFyZ2luLml0ZW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0uaG9yaXpvbnRhbCA9IG9wdGlvbnMubWFyZ2luLml0ZW07XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0udmVydGljYWwgPSBvcHRpb25zLm1hcmdpbi5pdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW4uaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddLCB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0sIG9wdGlvbnMubWFyZ2luLml0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgnZWRpdGFibGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lICA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS5hZGQgICAgICAgICA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS5yZW1vdmUgICAgICA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGl0YWJsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWyd1cGRhdGVUaW1lJywgJ3VwZGF0ZUdyb3VwJywgJ2FkZCcsICdyZW1vdmUnXSwgdGhpcy5vcHRpb25zLmVkaXRhYmxlLCBvcHRpb25zLmVkaXRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICB2YXIgYWRkQ2FsbGJhY2sgPSAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBmbiA9IG9wdGlvbnNbbmFtZV07XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgaWYgKCEoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbiAnICsgbmFtZSArICcgbXVzdCBiZSBhIGZ1bmN0aW9uICcgKyBuYW1lICsgJyhpdGVtLCBjYWxsYmFjayknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0gPSBmbjtcbiAgICAgIH1cbiAgICB9KS5iaW5kKHRoaXMpO1xuICAgIFsnb25BZGQnLCAnb25VcGRhdGUnLCAnb25SZW1vdmUnLCAnb25Nb3ZlJywgJ29uTW92aW5nJ10uZm9yRWFjaChhZGRDYWxsYmFjayk7XG5cbiAgICAvLyBmb3JjZSB0aGUgaXRlbVNldCB0byByZWZyZXNoOiBvcHRpb25zIGxpa2Ugb3JpZW50YXRpb24gYW5kIG1hcmdpbnMgbWF5IGJlIGNoYW5nZWRcbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICB9XG59O1xuXG4vKipcbiAqIE1hcmsgdGhlIEl0ZW1TZXQgZGlydHkgc28gaXQgd2lsbCByZWZyZXNoIGV2ZXJ5dGhpbmcgd2l0aCBuZXh0IHJlZHJhd1xuICovXG5JdGVtU2V0LnByb3RvdHlwZS5tYXJrRGlydHkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncm91cElkcyA9IFtdO1xuICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBJdGVtU2V0XG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oaWRlKCk7XG4gIHRoaXMuc2V0SXRlbXMobnVsbCk7XG4gIHRoaXMuc2V0R3JvdXBzKG51bGwpO1xuXG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICB0aGlzLmJvZHkgPSBudWxsO1xuICB0aGlzLmNvbnZlcnNpb24gPSBudWxsO1xufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmVtb3ZlIHRoZSBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICBpZiAodGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZnJhbWUpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHRoZSBheGlzIHdpdGggZG90c1xuICBpZiAodGhpcy5kb20uYXhpcy5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5kb20uYXhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmF4aXMpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHRoZSBsYWJlbHNldCBjb250YWluaW5nIGFsbCBncm91cCBsYWJlbHNcbiAgaWYgKHRoaXMuZG9tLmxhYmVsU2V0LnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmRvbS5sYWJlbFNldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmxhYmVsU2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTaG93IHRoZSBjb21wb25lbnQgaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAvLyBzaG93IGZyYW1lIGNvbnRhaW5pbmcgdGhlIGl0ZW1zXG4gIGlmICghdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuYm9keS5kb20uY2VudGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgfVxuXG4gIC8vIHNob3cgYXhpcyB3aXRoIGRvdHNcbiAgaWYgKCF0aGlzLmRvbS5heGlzLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5heGlzKTtcbiAgfVxuXG4gIC8vIHNob3cgbGFiZWxzZXQgY29udGFpbmluZyBsYWJlbHNcbiAgaWYgKCF0aGlzLmRvbS5sYWJlbFNldC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5ib2R5LmRvbS5sZWZ0LmFwcGVuZENoaWxkKHRoaXMuZG9tLmxhYmVsU2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWQuIFJlcGxhY2VzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICogVW5rbm93biBpZCdzIGFyZSBzaWxlbnRseSBpZ25vcmVkLlxuICogQHBhcmFtIHtzdHJpbmdbXSB8IHN0cmluZ30gW2lkc10gQW4gYXJyYXkgd2l0aCB6ZXJvIG9yIG1vcmUgaWQncyBvZiB0aGUgaXRlbXMgdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLCBvciBhIHNpbmdsZSBpdGVtIGlkLiBJZiBpZHMgaXMgdW5kZWZpbmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhbiBlbXB0eSBhcnJheSwgYWxsIGl0ZW1zIHdpbGwgYmUgdW5zZWxlY3RlZC5cbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oaWRzKSB7XG4gIHZhciBpLCBpaSwgaWQsIGl0ZW07XG5cbiAgaWYgKGlkcyA9PSB1bmRlZmluZWQpIGlkcyA9IFtdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaWRzKSkgaWRzID0gW2lkc107XG5cbiAgLy8gdW5zZWxlY3QgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zXG4gIGZvciAoaSA9IDAsIGlpID0gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlkID0gdGhpcy5zZWxlY3Rpb25baV07XG4gICAgaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgIGlmIChpdGVtKSBpdGVtLnVuc2VsZWN0KCk7XG4gIH1cblxuICAvLyBzZWxlY3QgaXRlbXNcbiAgdGhpcy5zZWxlY3Rpb24gPSBbXTtcbiAgZm9yIChpID0gMCwgaWkgPSBpZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlkID0gaWRzW2ldO1xuICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2lkXTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24ucHVzaChpZCk7XG4gICAgICBpdGVtLnNlbGVjdCgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNlbGVjdGVkIGl0ZW1zIGJ5IHRoZWlyIGlkXG4gKiBAcmV0dXJuIHtBcnJheX0gaWRzICBUaGUgaWRzIG9mIHRoZSBzZWxlY3RlZCBpdGVtc1xuICovXG5JdGVtU2V0LnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmNvbmNhdChbXSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaWQncyBvZiB0aGUgY3VycmVudGx5IHZpc2libGUgaXRlbXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBpZHMgb2YgdGhlIHZpc2libGUgaXRlbXNcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ2V0VmlzaWJsZUl0ZW1zID0gZnVuY3Rpb24oKSB7XG4gIHZhciByYW5nZSA9IHRoaXMuYm9keS5yYW5nZS5nZXRSYW5nZSgpO1xuICB2YXIgbGVmdCAgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihyYW5nZS5zdGFydCk7XG4gIHZhciByaWdodCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHJhbmdlLmVuZCk7XG5cbiAgdmFyIGlkcyA9IFtdO1xuICBmb3IgKHZhciBncm91cElkIGluIHRoaXMuZ3JvdXBzKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGdyb3VwSWQpKSB7XG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICAgIHZhciByYXdWaXNpYmxlSXRlbXMgPSBncm91cC52aXNpYmxlSXRlbXM7XG5cbiAgICAgIC8vIGZpbHRlciB0aGUgXCJyYXdcIiBzZXQgd2l0aCB2aXNpYmxlSXRlbXMgaW50byBhIHNldCB3aGljaCBpcyByZWFsbHlcbiAgICAgIC8vIHZpc2libGUgYnkgcGl4ZWxzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd1Zpc2libGVJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IHJhd1Zpc2libGVJdGVtc1tpXTtcbiAgICAgICAgLy8gVE9ETzogYWxzbyBjaGVjayB3aGV0aGVyIHZpc2libGUgdmVydGljYWxseVxuICAgICAgICBpZiAoKGl0ZW0ubGVmdCA8IHJpZ2h0KSAmJiAoaXRlbS5sZWZ0ICsgaXRlbS53aWR0aCA+IGxlZnQpKSB7XG4gICAgICAgICAgaWRzLnB1c2goaXRlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWRzO1xufTtcblxuLyoqXG4gKiBEZXNlbGVjdCBhIHNlbGVjdGVkIGl0ZW1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBpZFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2Rlc2VsZWN0ID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBzZWxlY3Rpb24ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlmIChzZWxlY3Rpb25baV0gPT0gaWQpIHsgLy8gbm9uLXN0cmljdCBjb21wYXJpc29uIVxuICAgICAgc2VsZWN0aW9uLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtYXJnaW4gPSB0aGlzLm9wdGlvbnMubWFyZ2luLFxuICAgICAgcmFuZ2UgPSB0aGlzLmJvZHkucmFuZ2UsXG4gICAgICBhc1NpemUgPSB1dGlsLm9wdGlvbi5hc1NpemUsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgb3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uLFxuICAgICAgcmVzaXplZCA9IGZhbHNlLFxuICAgICAgZnJhbWUgPSB0aGlzLmRvbS5mcmFtZSxcbiAgICAgIGVkaXRhYmxlID0gb3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lIHx8IG9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXA7XG5cbiAgLy8gcmVjYWxjdWxhdGUgYWJzb2x1dGUgcG9zaXRpb24gKGJlZm9yZSByZWRyYXdpbmcgZ3JvdXBzKVxuICB0aGlzLnByb3BzLnRvcCA9IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci50b3A7XG4gIHRoaXMucHJvcHMubGVmdCA9IHRoaXMuYm9keS5kb21Qcm9wcy5sZWZ0LndpZHRoICsgdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci5sZWZ0O1xuXG4gIC8vIHVwZGF0ZSBjbGFzcyBuYW1lXG4gIGZyYW1lLmNsYXNzTmFtZSA9ICdpdGVtc2V0JyArIChlZGl0YWJsZSA/ICcgZWRpdGFibGUnIDogJycpO1xuXG4gIC8vIHJlb3JkZXIgdGhlIGdyb3VwcyAoaWYgbmVlZGVkKVxuICByZXNpemVkID0gdGhpcy5fb3JkZXJHcm91cHMoKSB8fCByZXNpemVkO1xuXG4gIC8vIGNoZWNrIHdoZXRoZXIgem9vbWVkIChpbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byByZS1zdGFjayBldmVyeXRoaW5nKVxuICAvLyBUT0RPOiB3b3VsZCBiZSBuaWNlciB0byBnZXQgdGhpcyBhcyBhIHRyaWdnZXIgZnJvbSBSYW5nZVxuICB2YXIgdmlzaWJsZUludGVydmFsID0gcmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQ7XG4gIHZhciB6b29tZWQgPSAodmlzaWJsZUludGVydmFsICE9IHRoaXMubGFzdFZpc2libGVJbnRlcnZhbCkgfHwgKHRoaXMucHJvcHMud2lkdGggIT0gdGhpcy5wcm9wcy5sYXN0V2lkdGgpO1xuICBpZiAoem9vbWVkKSB0aGlzLnN0YWNrRGlydHkgPSB0cnVlO1xuICB0aGlzLmxhc3RWaXNpYmxlSW50ZXJ2YWwgPSB2aXNpYmxlSW50ZXJ2YWw7XG4gIHRoaXMucHJvcHMubGFzdFdpZHRoID0gdGhpcy5wcm9wcy53aWR0aDtcblxuICAvLyByZWRyYXcgYWxsIGdyb3Vwc1xuICB2YXIgcmVzdGFjayA9IHRoaXMuc3RhY2tEaXJ0eSxcbiAgICAgIGZpcnN0R3JvdXAgPSB0aGlzLl9maXJzdEdyb3VwKCksXG4gICAgICBmaXJzdE1hcmdpbiA9IHtcbiAgICAgICAgaXRlbTogbWFyZ2luLml0ZW0sXG4gICAgICAgIGF4aXM6IG1hcmdpbi5heGlzXG4gICAgICB9LFxuICAgICAgbm9uRmlyc3RNYXJnaW4gPSB7XG4gICAgICAgIGl0ZW06IG1hcmdpbi5pdGVtLFxuICAgICAgICBheGlzOiBtYXJnaW4uaXRlbS52ZXJ0aWNhbCAvIDJcbiAgICAgIH0sXG4gICAgICBoZWlnaHQgPSAwLFxuICAgICAgbWluSGVpZ2h0ID0gbWFyZ2luLmF4aXMgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgdXRpbC5mb3JFYWNoKHRoaXMuZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICB2YXIgZ3JvdXBNYXJnaW4gPSAoZ3JvdXAgPT0gZmlyc3RHcm91cCkgPyBmaXJzdE1hcmdpbiA6IG5vbkZpcnN0TWFyZ2luO1xuICAgIHZhciBncm91cFJlc2l6ZWQgPSBncm91cC5yZWRyYXcocmFuZ2UsIGdyb3VwTWFyZ2luLCByZXN0YWNrKTtcbiAgICByZXNpemVkID0gZ3JvdXBSZXNpemVkIHx8IHJlc2l6ZWQ7XG4gICAgaGVpZ2h0ICs9IGdyb3VwLmhlaWdodDtcbiAgfSk7XG4gIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgbWluSGVpZ2h0KTtcbiAgdGhpcy5zdGFja0RpcnR5ID0gZmFsc2U7XG5cbiAgLy8gdXBkYXRlIGZyYW1lIGhlaWdodFxuICBmcmFtZS5zdHlsZS5oZWlnaHQgID0gYXNTaXplKGhlaWdodCk7XG5cbiAgLy8gY2FsY3VsYXRlIGFjdHVhbCBzaXplXG4gIHRoaXMucHJvcHMud2lkdGggPSBmcmFtZS5vZmZzZXRXaWR0aDtcbiAgdGhpcy5wcm9wcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgLy8gcmVwb3NpdGlvbiBheGlzXG5cbiAgLy8gcmVwb3NpdGlvbiBheGlzXG4gIHRoaXMuZG9tLmF4aXMuc3R5bGUudG9wID0gYXNTaXplKChvcmllbnRhdGlvbiA9PSAndG9wJykgP1xuICAgICAgKHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci50b3ApIDpcbiAgICAgICh0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArIHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0KSk7XG4gIHRoaXMuZG9tLmF4aXMuc3R5bGUubGVmdCA9ICcwJztcblxuICAvLyBjaGVjayBpZiB0aGlzIGNvbXBvbmVudCBpcyByZXNpemVkXG4gIHJlc2l6ZWQgPSB0aGlzLl9pc1Jlc2l6ZWQoKSB8fCByZXNpemVkO1xuXG4gIHJldHVybiByZXNpemVkO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGdyb3VwLCBhbGlnbmVkIHdpdGggdGhlIGF4aXNcbiAqIEByZXR1cm4ge0dyb3VwIHwgbnVsbH0gZmlyc3RHcm91cFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2ZpcnN0R3JvdXAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZpcnN0R3JvdXBJbmRleCA9ICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPT0gJ3RvcCcpID8gMCA6ICh0aGlzLmdyb3VwSWRzLmxlbmd0aCAtIDEpO1xuICB2YXIgZmlyc3RHcm91cElkID0gdGhpcy5ncm91cElkc1tmaXJzdEdyb3VwSW5kZXhdO1xuICB2YXIgZmlyc3RHcm91cCA9IHRoaXMuZ3JvdXBzW2ZpcnN0R3JvdXBJZF0gfHwgdGhpcy5ncm91cHNbVU5HUk9VUEVEXTtcblxuICByZXR1cm4gZmlyc3RHcm91cCB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgb3IgZGVsZXRlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXMuIFRoaXMgZ3JvdXAgaXMgdXNlZCB3aGVuXG4gKiB0aGVyZSBhcmUgbm8gZ3JvdXBzIHNwZWNpZmllZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX3VwZGF0ZVVuZ3JvdXBlZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdW5ncm91cGVkID0gdGhpcy5ncm91cHNbVU5HUk9VUEVEXTtcblxuICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXNcbiAgICBpZiAodW5ncm91cGVkKSB7XG4gICAgICB1bmdyb3VwZWQuaGlkZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF07XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBhIGdyb3VwIGhvbGRpbmcgYWxsICh1bmZpbHRlcmVkKSBpdGVtc1xuICAgIGlmICghdW5ncm91cGVkKSB7XG4gICAgICB2YXIgaWQgPSBudWxsO1xuICAgICAgdmFyIGRhdGEgPSBudWxsO1xuICAgICAgdW5ncm91cGVkID0gbmV3IEdyb3VwKGlkLCBkYXRhLCB0aGlzKTtcbiAgICAgIHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF0gPSB1bmdyb3VwZWQ7XG5cbiAgICAgIGZvciAodmFyIGl0ZW1JZCBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgICB1bmdyb3VwZWQuYWRkKHRoaXMuaXRlbXNbaXRlbUlkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdW5ncm91cGVkLnNob3coKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBlbGVtZW50IGZvciB0aGUgbGFiZWxzZXRcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBsYWJlbFNldFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5nZXRMYWJlbFNldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kb20ubGFiZWxTZXQ7XG59O1xuXG4vKipcbiAqIFNldCBpdGVtc1xuICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IG51bGx9IGl0ZW1zXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLnNldEl0ZW1zID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgdmFyIG1lID0gdGhpcyxcbiAgICAgIGlkcyxcbiAgICAgIG9sZEl0ZW1zRGF0YSA9IHRoaXMuaXRlbXNEYXRhO1xuXG4gIC8vIHJlcGxhY2UgdGhlIGRhdGFzZXRcbiAgaWYgKCFpdGVtcykge1xuICAgIHRoaXMuaXRlbXNEYXRhID0gbnVsbDtcbiAgfVxuICBlbHNlIGlmIChpdGVtcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgaXRlbXMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHRoaXMuaXRlbXNEYXRhID0gaXRlbXM7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIERhdGFTZXQgb3IgRGF0YVZpZXcnKTtcbiAgfVxuXG4gIGlmIChvbGRJdGVtc0RhdGEpIHtcbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbUxpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgb2xkSXRlbXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGFsbCBkcmF3biBpdGVtc1xuICAgIGlkcyA9IG9sZEl0ZW1zRGF0YS5nZXRJZHMoKTtcbiAgICB0aGlzLl9vblJlbW92ZShpZHMpO1xuICB9XG5cbiAgaWYgKHRoaXMuaXRlbXNEYXRhKSB7XG4gICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICBtZS5pdGVtc0RhdGEub24oZXZlbnQsIGNhbGxiYWNrLCBpZCk7XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgYWxsIG5ldyBpdGVtc1xuICAgIGlkcyA9IHRoaXMuaXRlbXNEYXRhLmdldElkcygpO1xuICAgIHRoaXMuX29uQWRkKGlkcyk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIGdyb3VwIGhvbGRpbmcgYWxsIHVuZ3JvdXBlZCBpdGVtc1xuICAgIHRoaXMuX3VwZGF0ZVVuZ3JvdXBlZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBpdGVtc1xuICogQHJldHVybnMge3Zpcy5EYXRhU2V0IHwgbnVsbH1cbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ2V0SXRlbXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXRlbXNEYXRhO1xufTtcblxuLyoqXG4gKiBTZXQgZ3JvdXBzXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0fSBncm91cHNcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuc2V0R3JvdXBzID0gZnVuY3Rpb24oZ3JvdXBzKSB7XG4gIHZhciBtZSA9IHRoaXMsXG4gICAgICBpZHM7XG5cbiAgLy8gdW5zdWJzY3JpYmUgZnJvbSBjdXJyZW50IGRhdGFzZXRcbiAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgIHV0aWwuZm9yRWFjaCh0aGlzLmdyb3VwTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICBtZS5ncm91cHNEYXRhLnVuc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgYWxsIGRyYXduIGdyb3Vwc1xuICAgIGlkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoKTtcbiAgICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsO1xuICAgIHRoaXMuX29uUmVtb3ZlR3JvdXBzKGlkcyk7IC8vIG5vdGU6IHRoaXMgd2lsbCBjYXVzZSBhIHJlZHJhd1xuICB9XG5cbiAgLy8gcmVwbGFjZSB0aGUgZGF0YXNldFxuICBpZiAoIWdyb3Vwcykge1xuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7XG4gIH1cbiAgZWxzZSBpZiAoZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IGdyb3VwcztcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEYXRhIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRGF0YVNldCBvciBEYXRhVmlldycpO1xuICB9XG5cbiAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuZ3JvdXBMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgIG1lLmdyb3Vwc0RhdGEub24oZXZlbnQsIGNhbGxiYWNrLCBpZCk7XG4gICAgfSk7XG5cbiAgICAvLyBkcmF3IGFsbCBtc1xuICAgIGlkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoKTtcbiAgICB0aGlzLl9vbkFkZEdyb3VwcyhpZHMpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXNcbiAgdGhpcy5fdXBkYXRlVW5ncm91cGVkKCk7XG5cbiAgLy8gdXBkYXRlIHRoZSBvcmRlciBvZiBhbGwgaXRlbXMgaW4gZWFjaCBncm91cFxuICB0aGlzLl9vcmRlcigpO1xuXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgZ3JvdXBzXG4gKiBAcmV0dXJucyB7dmlzLkRhdGFTZXQgfCBudWxsfSBncm91cHNcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ2V0R3JvdXBzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdyb3Vwc0RhdGE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGJ5IGl0cyBpZFxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGlkXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbihpZCkge1xuICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNEYXRhLmdldChpZCksXG4gICAgICBkYXRhc2V0ID0gdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpO1xuXG4gIGlmIChpdGVtKSB7XG4gICAgLy8gY29uZmlybSBkZWxldGlvblxuICAgIHRoaXMub3B0aW9ucy5vblJlbW92ZShpdGVtLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgLy8gcmVtb3ZlIGJ5IGlkIGhlcmUsIGl0IGlzIHBvc3NpYmxlIHRoYXQgYW4gaXRlbSBoYXMgbm8gaWQgZGVmaW5lZFxuICAgICAgICAvLyBpdHNlbGYsIHNvIGJldHRlciBub3QgZGVsZXRlIGJ5IHRoZSBpdGVtIGl0c2VsZlxuICAgICAgICBkYXRhc2V0LnJlbW92ZShpZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIHVwZGF0ZWQgaXRlbXNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByb3RlY3RlZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25VcGRhdGUgPSBmdW5jdGlvbihpZHMpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbURhdGEgPSBtZS5pdGVtc0RhdGEuZ2V0KGlkLCBtZS5pdGVtT3B0aW9ucyksXG4gICAgICAgIGl0ZW0gPSBtZS5pdGVtc1tpZF0sXG4gICAgICAgIHR5cGUgPSBpdGVtRGF0YS50eXBlIHx8IG1lLm9wdGlvbnMudHlwZSB8fCAoaXRlbURhdGEuZW5kID8gJ3JhbmdlJyA6ICdib3gnKTtcblxuICAgIHZhciBjb25zdHJ1Y3RvciA9IEl0ZW1TZXQudHlwZXNbdHlwZV07XG5cbiAgICBpZiAoaXRlbSkge1xuICAgICAgLy8gdXBkYXRlIGl0ZW1cbiAgICAgIGlmICghY29uc3RydWN0b3IgfHwgIShpdGVtIGluc3RhbmNlb2YgY29uc3RydWN0b3IpKSB7XG4gICAgICAgIC8vIGl0ZW0gdHlwZSBoYXMgY2hhbmdlZCwgZGVsZXRlIHRoZSBpdGVtIGFuZCByZWNyZWF0ZSBpdFxuICAgICAgICBtZS5fcmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgaXRlbSA9IG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWUuX3VwZGF0ZUl0ZW0oaXRlbSwgaXRlbURhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXRlbSkge1xuICAgICAgLy8gY3JlYXRlIGl0ZW1cbiAgICAgIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICBpdGVtID0gbmV3IGNvbnN0cnVjdG9yKGl0ZW1EYXRhLCBtZS5jb252ZXJzaW9uLCBtZS5vcHRpb25zKTtcbiAgICAgICAgaXRlbS5pZCA9IGlkOyAvLyBUT0RPOiBub3Qgc28gbmljZSBzZXR0aW5nIGlkIGFmdGVyd2FyZHNcbiAgICAgICAgbWUuX2FkZEl0ZW0oaXRlbSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlID09ICdyYW5nZW92ZXJmbG93Jykge1xuICAgICAgICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjAgKG9yIDMuMC4wPykuIGNsZWFudXAgc29tZSBkYXlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXRlbSB0eXBlIFwicmFuZ2VvdmVyZmxvd1wiIGlzIGRlcHJlY2F0ZWQuIFVzZSBjc3Mgc3R5bGluZyBpbnN0ZWFkOiAnICtcbiAgICAgICAgICAgICcudmlzLnRpbWVsaW5lIC5pdGVtLnJhbmdlIC5jb250ZW50IHtvdmVyZmxvdzogdmlzaWJsZTt9Jyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBpdGVtIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5fb3JkZXIoKTtcbiAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScpO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYWRkZWQgaXRlbXNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByb3RlY3RlZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25BZGQgPSBJdGVtU2V0LnByb3RvdHlwZS5fb25VcGRhdGU7XG5cbi8qKlxuICogSGFuZGxlIHJlbW92ZWQgaXRlbXNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByb3RlY3RlZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25SZW1vdmUgPSBmdW5jdGlvbihpZHMpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIG1lID0gdGhpcztcbiAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBtZS5pdGVtc1tpZF07XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvdW50Kys7XG4gICAgICBtZS5fcmVtb3ZlSXRlbShpdGVtKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChjb3VudCkge1xuICAgIC8vIHVwZGF0ZSBvcmRlclxuICAgIHRoaXMuX29yZGVyKCk7XG4gICAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBvcmRlciBvZiBpdGVtIGluIGFsbCBncm91cHNcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vcmRlciA9IGZ1bmN0aW9uKCkge1xuICAvLyByZW9yZGVyIHRoZSBpdGVtcyBpbiBhbGwgZ3JvdXBzXG4gIC8vIFRPRE86IG9wdGltaXphdGlvbjogb25seSByZW9yZGVyIGdyb3VwcyBhZmZlY3RlZCBieSB0aGUgY2hhbmdlZCBpdGVtc1xuICB1dGlsLmZvckVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgIGdyb3VwLm9yZGVyKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgdXBkYXRlZCBncm91cHNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uVXBkYXRlR3JvdXBzID0gZnVuY3Rpb24oaWRzKSB7XG4gIHRoaXMuX29uQWRkR3JvdXBzKGlkcyk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBjaGFuZ2VkIGdyb3Vwc1xuICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25BZGRHcm91cHMgPSBmdW5jdGlvbihpZHMpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZ3JvdXBEYXRhID0gbWUuZ3JvdXBzRGF0YS5nZXQoaWQpO1xuICAgIHZhciBncm91cCA9IG1lLmdyb3Vwc1tpZF07XG5cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAvLyBjaGVjayBmb3IgcmVzZXJ2ZWQgaWRzXG4gICAgICBpZiAoaWQgPT0gVU5HUk9VUEVEKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBncm91cCBpZC4gJyArIGlkICsgJyBpcyBhIHJlc2VydmVkIGlkLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXBPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShtZS5vcHRpb25zKTtcbiAgICAgIHV0aWwuZXh0ZW5kKGdyb3VwT3B0aW9ucywge1xuICAgICAgICBoZWlnaHQ6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBncm91cCA9IG5ldyBHcm91cChpZCwgZ3JvdXBEYXRhLCBtZSk7XG4gICAgICBtZS5ncm91cHNbaWRdID0gZ3JvdXA7XG5cbiAgICAgIC8vIGFkZCBpdGVtcyB3aXRoIHRoaXMgZ3JvdXBJZCB0byB0aGUgbmV3IGdyb3VwXG4gICAgICBmb3IgKHZhciBpdGVtSWQgaW4gbWUuaXRlbXMpIHtcbiAgICAgICAgaWYgKG1lLml0ZW1zLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IG1lLml0ZW1zW2l0ZW1JZF07XG4gICAgICAgICAgaWYgKGl0ZW0uZGF0YS5ncm91cCA9PSBpZCkge1xuICAgICAgICAgICAgZ3JvdXAuYWRkKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBncm91cC5vcmRlcigpO1xuICAgICAgZ3JvdXAuc2hvdygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZSBncm91cFxuICAgICAgZ3JvdXAuc2V0RGF0YShncm91cERhdGEpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJyk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSByZW1vdmVkIGdyb3Vwc1xuICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25SZW1vdmVHcm91cHMgPSBmdW5jdGlvbihpZHMpIHtcbiAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZ3JvdXAgPSBncm91cHNbaWRdO1xuXG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICBncm91cC5oaWRlKCk7XG4gICAgICBkZWxldGUgZ3JvdXBzW2lkXTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMubWFya0RpcnR5KCk7XG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJyk7XG59O1xuXG4vKipcbiAqIFJlb3JkZXIgdGhlIGdyb3VwcyBpZiBuZWVkZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGNoYW5nZWRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vcmRlckdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgIC8vIHJlb3JkZXIgdGhlIGdyb3Vwc1xuICAgIHZhciBncm91cElkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoe1xuICAgICAgb3JkZXI6IHRoaXMub3B0aW9ucy5ncm91cE9yZGVyXG4gICAgfSk7XG5cbiAgICB2YXIgY2hhbmdlZCA9ICF1dGlsLmVxdWFsQXJyYXkoZ3JvdXBJZHMsIHRoaXMuZ3JvdXBJZHMpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAvLyBoaWRlIGFsbCBncm91cHMsIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBET01cbiAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgICAgIGdyb3VwSWRzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdLmhpZGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBzaG93IHRoZSBncm91cHMgYWdhaW4sIGF0dGFjaCB0aGVtIHRvIHRoZSBET00gaW4gY29ycmVjdCBvcmRlclxuICAgICAgZ3JvdXBJZHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICBncm91cHNbZ3JvdXBJZF0uc2hvdygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZ3JvdXBJZHMgPSBncm91cElkcztcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGEgbmV3IGl0ZW1cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2FkZEl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuaXRlbXNbaXRlbS5pZF0gPSBpdGVtO1xuXG4gIC8vIGFkZCB0byBncm91cFxuICB2YXIgZ3JvdXBJZCA9IHRoaXMuZ3JvdXBzRGF0YSA/IGl0ZW0uZGF0YS5ncm91cCA6IFVOR1JPVVBFRDtcbiAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gIGlmIChncm91cCkgZ3JvdXAuYWRkKGl0ZW0pO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgaXRlbVxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGFcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl91cGRhdGVJdGVtID0gZnVuY3Rpb24oaXRlbSwgaXRlbURhdGEpIHtcbiAgdmFyIG9sZEdyb3VwSWQgPSBpdGVtLmRhdGEuZ3JvdXA7XG5cbiAgLy8gdXBkYXRlIHRoZSBpdGVtcyBkYXRhICh3aWxsIHJlZHJhdyB0aGUgaXRlbSB3aGVuIGRpc3BsYXllZClcbiAgaXRlbS5zZXREYXRhKGl0ZW1EYXRhKTtcblxuICAvLyB1cGRhdGUgZ3JvdXBcbiAgaWYgKG9sZEdyb3VwSWQgIT0gaXRlbS5kYXRhLmdyb3VwKSB7XG4gICAgdmFyIG9sZEdyb3VwID0gdGhpcy5ncm91cHNbb2xkR3JvdXBJZF07XG4gICAgaWYgKG9sZEdyb3VwKSBvbGRHcm91cC5yZW1vdmUoaXRlbSk7XG5cbiAgICB2YXIgZ3JvdXBJZCA9IHRoaXMuZ3JvdXBzRGF0YSA/IGl0ZW0uZGF0YS5ncm91cCA6IFVOR1JPVVBFRDtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICBpZiAoZ3JvdXApIGdyb3VwLmFkZChpdGVtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWxldGUgYW4gaXRlbSBmcm9tIHRoZSBJdGVtU2V0OiByZW1vdmUgaXQgZnJvbSB0aGUgRE9NLCBmcm9tIHRoZSBtYXBcbiAqIHdpdGggaXRlbXMsIGFuZCBmcm9tIHRoZSBtYXAgd2l0aCB2aXNpYmxlIGl0ZW1zLCBhbmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9yZW1vdmVJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICAvLyByZW1vdmUgZnJvbSBET01cbiAgaXRlbS5oaWRlKCk7XG5cbiAgLy8gcmVtb3ZlIGZyb20gaXRlbXNcbiAgZGVsZXRlIHRoaXMuaXRlbXNbaXRlbS5pZF07XG5cbiAgLy8gcmVtb3ZlIGZyb20gc2VsZWN0aW9uXG4gIHZhciBpbmRleCA9IHRoaXMuc2VsZWN0aW9uLmluZGV4T2YoaXRlbS5pZCk7XG4gIGlmIChpbmRleCAhPSAtMSkgdGhpcy5zZWxlY3Rpb24uc3BsaWNlKGluZGV4LCAxKTtcblxuICAvLyByZW1vdmUgZnJvbSBncm91cFxuICB2YXIgZ3JvdXBJZCA9IHRoaXMuZ3JvdXBzRGF0YSA/IGl0ZW0uZGF0YS5ncm91cCA6IFVOR1JPVVBFRDtcbiAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gIGlmIChncm91cCkgZ3JvdXAucmVtb3ZlKGl0ZW0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgaXRlbXMgYmVpbmcgYSByYW5nZSAoaGF2aW5nIGFuIGVuZCBkYXRlKVxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fY29uc3RydWN0QnlFbmRBcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIHZhciBlbmRBcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gaW5zdGFuY2VvZiBSYW5nZUl0ZW0pIHtcbiAgICAgIGVuZEFycmF5LnB1c2goYXJyYXlbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kQXJyYXk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBjbGlja2VkIGl0ZW0gb24gdG91Y2gsIGJlZm9yZSBkcmFnU3RhcnQgaXMgaW5pdGlhdGVkLlxuICpcbiAqIGRyYWdTdGFydCBpcyBpbml0aWF0ZWQgZnJvbSBhIG1vdXNlbW92ZSBldmVudCwgd2hpY2ggY2FuIGhhdmUgbGVmdCB0aGUgaXRlbVxuICogYWxyZWFkeSByZXN1bHRpbmcgaW4gYW4gaXRlbSA9PSBudWxsXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vblRvdWNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIHN0b3JlIHRoZSB0b3VjaGVkIGl0ZW0sIHVzZWQgaW4gX29uRHJhZ1N0YXJ0XG4gIHRoaXMudG91Y2hQYXJhbXMuaXRlbSA9IEl0ZW1TZXQuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xufTtcblxuLyoqXG4gKiBTdGFydCBkcmFnZ2luZyB0aGUgc2VsZWN0ZWQgZXZlbnRzXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgJiYgIXRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpdGVtID0gdGhpcy50b3VjaFBhcmFtcy5pdGVtIHx8IG51bGwsXG4gICAgICBtZSA9IHRoaXMsXG4gICAgICBwcm9wcztcblxuICBpZiAoaXRlbSAmJiBpdGVtLnNlbGVjdGVkKSB7XG4gICAgdmFyIGRyYWdMZWZ0SXRlbSA9IGV2ZW50LnRhcmdldC5kcmFnTGVmdEl0ZW07XG4gICAgdmFyIGRyYWdSaWdodEl0ZW0gPSBldmVudC50YXJnZXQuZHJhZ1JpZ2h0SXRlbTtcblxuICAgIGlmIChkcmFnTGVmdEl0ZW0pIHtcbiAgICAgIHByb3BzID0ge1xuICAgICAgICBpdGVtOiBkcmFnTGVmdEl0ZW1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtZS5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUpIHtcbiAgICAgICAgcHJvcHMuc3RhcnQgPSBpdGVtLmRhdGEuc3RhcnQudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKG1lLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXApIHtcbiAgICAgICAgaWYgKCdncm91cCcgaW4gaXRlbS5kYXRhKSBwcm9wcy5ncm91cCA9IGl0ZW0uZGF0YS5ncm91cDtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBbcHJvcHNdO1xuICAgIH1cbiAgICBlbHNlIGlmIChkcmFnUmlnaHRJdGVtKSB7XG4gICAgICBwcm9wcyA9IHtcbiAgICAgICAgaXRlbTogZHJhZ1JpZ2h0SXRlbVxuICAgICAgfTtcblxuICAgICAgaWYgKG1lLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSkge1xuICAgICAgICBwcm9wcy5lbmQgPSBpdGVtLmRhdGEuZW5kLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZS5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwKSB7XG4gICAgICAgIGlmICgnZ3JvdXAnIGluIGl0ZW0uZGF0YSkgcHJvcHMuZ3JvdXAgPSBpdGVtLmRhdGEuZ3JvdXA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gW3Byb3BzXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgaXRlbSA9IG1lLml0ZW1zW2lkXTtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWUub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lKSB7XG4gICAgICAgICAgaWYgKCdzdGFydCcgaW4gaXRlbS5kYXRhKSBwcm9wcy5zdGFydCA9IGl0ZW0uZGF0YS5zdGFydC52YWx1ZU9mKCk7XG4gICAgICAgICAgaWYgKCdlbmQnIGluIGl0ZW0uZGF0YSkgICBwcm9wcy5lbmQgPSBpdGVtLmRhdGEuZW5kLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWUub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCkge1xuICAgICAgICAgIGlmICgnZ3JvdXAnIGluIGl0ZW0uZGF0YSkgcHJvcHMuZ3JvdXAgPSBpdGVtLmRhdGEuZ3JvdXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEcmFnIHNlbGVjdGVkIGl0ZW1zXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAodGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByYW5nZSA9IHRoaXMuYm9keS5yYW5nZTtcbiAgICB2YXIgc25hcCA9IHRoaXMuYm9keS51dGlsLnNuYXAgfHwgbnVsbDtcbiAgICB2YXIgZGVsdGFYID0gZXZlbnQuZ2VzdHVyZS5kZWx0YVg7XG4gICAgdmFyIHNjYWxlID0gKHRoaXMucHJvcHMud2lkdGggLyAocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQpKTtcbiAgICB2YXIgb2Zmc2V0ID0gZGVsdGFYIC8gc2NhbGU7XG5cbiAgICAvLyBtb3ZlXG4gICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgIHZhciBuZXdQcm9wcyA9IHt9O1xuXG4gICAgICBpZiAoJ3N0YXJ0JyBpbiBwcm9wcykge1xuICAgICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShwcm9wcy5zdGFydCArIG9mZnNldCk7XG4gICAgICAgIG5ld1Byb3BzLnN0YXJ0ID0gc25hcCA/IHNuYXAoc3RhcnQpIDogc3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICgnZW5kJyBpbiBwcm9wcykge1xuICAgICAgICB2YXIgZW5kID0gbmV3IERhdGUocHJvcHMuZW5kICsgb2Zmc2V0KTtcbiAgICAgICAgbmV3UHJvcHMuZW5kID0gc25hcCA/IHNuYXAoZW5kKSA6IGVuZDtcbiAgICAgIH1cblxuICAgICAgaWYgKCdncm91cCcgaW4gcHJvcHMpIHtcbiAgICAgICAgLy8gZHJhZyBmcm9tIG9uZSBncm91cCB0byBhbm90aGVyXG4gICAgICAgIHZhciBncm91cCA9IEl0ZW1TZXQuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgbmV3UHJvcHMuZ3JvdXAgPSBncm91cCAmJiBncm91cC5ncm91cElkO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25maXJtIG1vdmluZyB0aGUgaXRlbVxuICAgICAgdmFyIGl0ZW1EYXRhID0gdXRpbC5leHRlbmQoe30sIHByb3BzLml0ZW0uZGF0YSwgbmV3UHJvcHMpO1xuICAgICAgbWUub3B0aW9ucy5vbk1vdmluZyhpdGVtRGF0YSwgZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICAgIG1lLl91cGRhdGVJdGVtUHJvcHMocHJvcHMuaXRlbSwgaXRlbURhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScpO1xuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGFuIGl0ZW1zIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzICBDYW4gY29udGFpbiBwcm9wZXJ0aWVzIHN0YXJ0LCBlbmQsIGFuZCBncm91cC5cbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl91cGRhdGVJdGVtUHJvcHMgPSBmdW5jdGlvbihpdGVtLCBwcm9wcykge1xuICAvLyBUT0RPOiBjb3B5IGFsbCBwcm9wZXJ0aWVzIGZyb20gcHJvcHMgdG8gaXRlbT8gKGFsc28gbmV3IG9uZXMpXG4gIGlmICgnc3RhcnQnIGluIHByb3BzKSBpdGVtLmRhdGEuc3RhcnQgPSBwcm9wcy5zdGFydDtcbiAgaWYgKCdlbmQnIGluIHByb3BzKSAgIGl0ZW0uZGF0YS5lbmQgICA9IHByb3BzLmVuZDtcbiAgaWYgKCdncm91cCcgaW4gcHJvcHMgJiYgaXRlbS5kYXRhLmdyb3VwICE9IHByb3BzLmdyb3VwKSB7XG4gICAgdGhpcy5fbW92ZVRvR3JvdXAoaXRlbSwgcHJvcHMuZ3JvdXApXG4gIH1cbn07XG5cbi8qKlxuICogTW92ZSBhbiBpdGVtIHRvIGFub3RoZXIgZ3JvdXBcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGdyb3VwSWRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9tb3ZlVG9Hcm91cCA9IGZ1bmN0aW9uKGl0ZW0sIGdyb3VwSWQpIHtcbiAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gIGlmIChncm91cCAmJiBncm91cC5ncm91cElkICE9IGl0ZW0uZGF0YS5ncm91cCkge1xuICAgIHZhciBvbGRHcm91cCA9IGl0ZW0ucGFyZW50O1xuICAgIG9sZEdyb3VwLnJlbW92ZShpdGVtKTtcbiAgICBvbGRHcm91cC5vcmRlcigpO1xuICAgIGdyb3VwLmFkZChpdGVtKTtcbiAgICBncm91cC5vcmRlcigpO1xuXG4gICAgaXRlbS5kYXRhLmdyb3VwID0gZ3JvdXAuZ3JvdXBJZDtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmQgb2YgZHJhZ2dpbmcgc2VsZWN0ZWQgaXRlbXNcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICh0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcykge1xuICAgIC8vIHByZXBhcmUgYSBjaGFuZ2Ugc2V0IGZvciB0aGUgY2hhbmdlZCBpdGVtc1xuICAgIHZhciBjaGFuZ2VzID0gW10sXG4gICAgICAgIG1lID0gdGhpcyxcbiAgICAgICAgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKTtcblxuICAgIHZhciBpdGVtUHJvcHMgPSB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA7XG4gICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBudWxsO1xuICAgIGl0ZW1Qcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgdmFyIGlkID0gcHJvcHMuaXRlbS5pZCxcbiAgICAgICAgICBpdGVtRGF0YSA9IG1lLml0ZW1zRGF0YS5nZXQoaWQsIG1lLml0ZW1PcHRpb25zKTtcblxuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGlmICgnc3RhcnQnIGluIHByb3BzLml0ZW0uZGF0YSkge1xuICAgICAgICBjaGFuZ2VkID0gKHByb3BzLnN0YXJ0ICE9IHByb3BzLml0ZW0uZGF0YS5zdGFydC52YWx1ZU9mKCkpO1xuICAgICAgICBpdGVtRGF0YS5zdGFydCA9IHV0aWwuY29udmVydChwcm9wcy5pdGVtLmRhdGEuc3RhcnQsXG4gICAgICAgICAgICAgICAgZGF0YXNldC5fb3B0aW9ucy50eXBlICYmIGRhdGFzZXQuX29wdGlvbnMudHlwZS5zdGFydCB8fCAnRGF0ZScpO1xuICAgICAgfVxuICAgICAgaWYgKCdlbmQnIGluIHByb3BzLml0ZW0uZGF0YSkge1xuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCAgfHwgKHByb3BzLmVuZCAhPSBwcm9wcy5pdGVtLmRhdGEuZW5kLnZhbHVlT2YoKSk7XG4gICAgICAgIGl0ZW1EYXRhLmVuZCA9IHV0aWwuY29udmVydChwcm9wcy5pdGVtLmRhdGEuZW5kLFxuICAgICAgICAgICAgICAgIGRhdGFzZXQuX29wdGlvbnMudHlwZSAmJiBkYXRhc2V0Ll9vcHRpb25zLnR5cGUuZW5kIHx8ICdEYXRlJyk7XG4gICAgICB9XG4gICAgICBpZiAoJ2dyb3VwJyBpbiBwcm9wcy5pdGVtLmRhdGEpIHtcbiAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgIHx8IChwcm9wcy5ncm91cCAhPSBwcm9wcy5pdGVtLmRhdGEuZ3JvdXApO1xuICAgICAgICBpdGVtRGF0YS5ncm91cCA9IHByb3BzLml0ZW0uZGF0YS5ncm91cDtcbiAgICAgIH1cblxuICAgICAgLy8gb25seSBhcHBseSBjaGFuZ2VzIHdoZW4gc3RhcnQgb3IgZW5kIGlzIGFjdHVhbGx5IGNoYW5nZWRcbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIG1lLm9wdGlvbnMub25Nb3ZlKGl0ZW1EYXRhLCBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICAgICAgICBpZiAoaXRlbURhdGEpIHtcbiAgICAgICAgICAgIC8vIGFwcGx5IGNoYW5nZXNcbiAgICAgICAgICAgIGl0ZW1EYXRhW2RhdGFzZXQuX2ZpZWxkSWRdID0gaWQ7IC8vIGVuc3VyZSB0aGUgaXRlbSBjb250YWlucyBpdHMgaWQgKGNhbiBiZSB1bmRlZmluZWQpXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goaXRlbURhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgICBtZS5fdXBkYXRlSXRlbVByb3BzKHByb3BzLml0ZW0sIHByb3BzKTtcblxuICAgICAgICAgICAgbWUuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICAgICAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSB0aGUgY2hhbmdlcyB0byB0aGUgZGF0YSAoaWYgdGhlcmUgYXJlIGNoYW5nZXMpXG4gICAgaWYgKGNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICBkYXRhc2V0LnVwZGF0ZShjaGFuZ2VzKTtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgc2VsZWN0aW5nL2Rlc2VsZWN0aW5nIGFuIGl0ZW0gd2hlbiB0YXBwaW5nIGl0XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uU2VsZWN0SXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKSByZXR1cm47XG5cbiAgdmFyIGN0cmxLZXkgID0gZXZlbnQuZ2VzdHVyZS5zcmNFdmVudCAmJiBldmVudC5nZXN0dXJlLnNyY0V2ZW50LmN0cmxLZXk7XG4gIHZhciBzaGlmdEtleSA9IGV2ZW50Lmdlc3R1cmUuc3JjRXZlbnQgJiYgZXZlbnQuZ2VzdHVyZS5zcmNFdmVudC5zaGlmdEtleTtcbiAgaWYgKGN0cmxLZXkgfHwgc2hpZnRLZXkpIHtcbiAgICB0aGlzLl9vbk11bHRpU2VsZWN0SXRlbShldmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9sZFNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgdmFyIGl0ZW0gPSBJdGVtU2V0Lml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcbiAgdmFyIHNlbGVjdGlvbiA9IGl0ZW0gPyBbaXRlbS5pZF0gOiBbXTtcbiAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcblxuICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICAvLyBlbWl0IGEgc2VsZWN0IGV2ZW50LFxuICAvLyBleGNlcHQgd2hlbiBvbGQgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBuZXcgc2VsZWN0aW9uIGlzIHN0aWxsIGVtcHR5XG4gIGlmIChuZXdTZWxlY3Rpb24ubGVuZ3RoID4gMCB8fCBvbGRTZWxlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3NlbGVjdCcsIHtcbiAgICAgIGl0ZW1zOiB0aGlzLmdldFNlbGVjdGlvbigpXG4gICAgfSk7XG4gIH1cblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGNyZWF0aW9uIGFuZCB1cGRhdGVzIG9mIGFuIGl0ZW0gb24gZG91YmxlIHRhcFxuICogQHBhcmFtIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25BZGRJdGVtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLnNlbGVjdGFibGUpIHJldHVybjtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuZWRpdGFibGUuYWRkKSByZXR1cm47XG5cbiAgdmFyIG1lID0gdGhpcyxcbiAgICAgIHNuYXAgPSB0aGlzLmJvZHkudXRpbC5zbmFwIHx8IG51bGwsXG4gICAgICBpdGVtID0gSXRlbVNldC5pdGVtRnJvbVRhcmdldChldmVudCk7XG5cbiAgaWYgKGl0ZW0pIHtcbiAgICAvLyB1cGRhdGUgaXRlbVxuXG4gICAgLy8gZXhlY3V0ZSBhc3luYyBoYW5kbGVyIHRvIHVwZGF0ZSB0aGUgaXRlbSAob3IgY2FuY2VsIGl0KVxuICAgIHZhciBpdGVtRGF0YSA9IG1lLml0ZW1zRGF0YS5nZXQoaXRlbS5pZCk7IC8vIGdldCBhIGNsb25lIG9mIHRoZSBkYXRhIGZyb20gdGhlIGRhdGFzZXRcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoaXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgaWYgKGl0ZW1EYXRhKSB7XG4gICAgICAgIG1lLml0ZW1zRGF0YS51cGRhdGUoaXRlbURhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGFkZCBpdGVtXG4gICAgdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgdmFyIHggPSBldmVudC5nZXN0dXJlLmNlbnRlci5wYWdlWCAtIHhBYnM7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuICAgIHZhciBuZXdJdGVtID0ge1xuICAgICAgc3RhcnQ6IHNuYXAgPyBzbmFwKHN0YXJ0KSA6IHN0YXJ0LFxuICAgICAgY29udGVudDogJ25ldyBpdGVtJ1xuICAgIH07XG5cbiAgICAvLyB3aGVuIGRlZmF1bHQgdHlwZSBpcyBhIHJhbmdlLCBhZGQgYSBkZWZhdWx0IGVuZCBkYXRlIHRvIHRoZSBuZXcgaXRlbVxuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgdmFyIGVuZCA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4ICsgdGhpcy5wcm9wcy53aWR0aCAvIDUpO1xuICAgICAgbmV3SXRlbS5lbmQgPSBzbmFwID8gc25hcChlbmQpIDogZW5kO1xuICAgIH1cblxuICAgIG5ld0l0ZW1bdGhpcy5pdGVtc0RhdGEuX2ZpZWxkSWRdID0gdXRpbC5yYW5kb21VVUlEKCk7XG5cbiAgICB2YXIgZ3JvdXAgPSBJdGVtU2V0Lmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICBuZXdJdGVtLmdyb3VwID0gZ3JvdXAuZ3JvdXBJZDtcbiAgICB9XG5cbiAgICAvLyBleGVjdXRlIGFzeW5jIGhhbmRsZXIgdG8gY3VzdG9taXplIChvciBjYW5jZWwpIGFkZGluZyBhbiBpdGVtXG4gICAgdGhpcy5vcHRpb25zLm9uQWRkKG5ld0l0ZW0sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBtZS5pdGVtc0RhdGEuYWRkKGl0ZW0pO1xuICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIHRyaWdnZXIgYSByZWRyYXc/XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIHNlbGVjdGluZy9kZXNlbGVjdGluZyBtdWx0aXBsZSBpdGVtcyB3aGVuIGhvbGRpbmcgYW4gaXRlbVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vbk11bHRpU2VsZWN0SXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKSByZXR1cm47XG5cbiAgdmFyIHNlbGVjdGlvbixcbiAgICAgIGl0ZW0gPSBJdGVtU2V0Lml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcblxuICBpZiAoaXRlbSkge1xuICAgIC8vIG11bHRpIHNlbGVjdCBpdGVtc1xuICAgIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7IC8vIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgdmFyIGluZGV4ID0gc2VsZWN0aW9uLmluZGV4T2YoaXRlbS5pZCk7XG4gICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAvLyBpdGVtIGlzIG5vdCB5ZXQgc2VsZWN0ZWQgLT4gc2VsZWN0IGl0XG4gICAgICBzZWxlY3Rpb24ucHVzaChpdGVtLmlkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBpdGVtIGlzIGFscmVhZHkgc2VsZWN0ZWQgLT4gZGVzZWxlY3QgaXRcbiAgICAgIHNlbGVjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc2VsZWN0Jywge1xuICAgICAgaXRlbXM6IHRoaXMuZ2V0U2VsZWN0aW9uKClcbiAgICB9KTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbmQgYW4gaXRlbSBmcm9tIGFuIGV2ZW50IHRhcmdldDpcbiAqIHNlYXJjaGVzIGZvciB0aGUgYXR0cmlidXRlICd0aW1lbGluZS1pdGVtJyBpbiB0aGUgZXZlbnQgdGFyZ2V0J3MgZWxlbWVudCB0cmVlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7SXRlbSB8IG51bGx9IGl0ZW1cbiAqL1xuSXRlbVNldC5pdGVtRnJvbVRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCd0aW1lbGluZS1pdGVtJykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRbJ3RpbWVsaW5lLWl0ZW0nXTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogRmluZCB0aGUgR3JvdXAgZnJvbSBhbiBldmVudCB0YXJnZXQ6XG4gKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAndGltZWxpbmUtZ3JvdXAnIGluIHRoZSBldmVudCB0YXJnZXQncyBlbGVtZW50IHRyZWVcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtHcm91cCB8IG51bGx9IGdyb3VwXG4gKi9cbkl0ZW1TZXQuZ3JvdXBGcm9tVGFyZ2V0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgd2hpbGUgKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ3RpbWVsaW5lLWdyb3VwJykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRbJ3RpbWVsaW5lLWdyb3VwJ107XG4gICAgfVxuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIEl0ZW1TZXQgZnJvbSBhbiBldmVudCB0YXJnZXQ6XG4gKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAndGltZWxpbmUtaXRlbXNldCcgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge0l0ZW1TZXQgfCBudWxsfSBpdGVtXG4gKi9cbkl0ZW1TZXQuaXRlbVNldEZyb21UYXJnZXQgPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICB3aGlsZSAodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgndGltZWxpbmUtaXRlbXNldCcpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Wyd0aW1lbGluZS1pdGVtc2V0J107XG4gICAgfVxuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZW1TZXQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xudmFyIFRpbWVTdGVwID0gcmVxdWlyZSgnLi4vVGltZVN0ZXAnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGUvbW9tZW50Jyk7XG5cbi8qKlxuICogQSBob3Jpem9udGFsIHRpbWUgYXhpc1xuICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXIsIHJhbmdlOiBSYW5nZX19IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIFNlZSBUaW1lQXhpcy5zZXRPcHRpb25zIGZvciB0aGUgYXZhaWxhYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yIFRpbWVBeGlzXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gVGltZUF4aXMgKGJvZHksIG9wdGlvbnMpIHtcbiAgdGhpcy5kb20gPSB7XG4gICAgZm9yZWdyb3VuZDogbnVsbCxcbiAgICBtYWpvckxpbmVzOiBbXSxcbiAgICBtYWpvclRleHRzOiBbXSxcbiAgICBtaW5vckxpbmVzOiBbXSxcbiAgICBtaW5vclRleHRzOiBbXSxcbiAgICByZWR1bmRhbnQ6IHtcbiAgICAgIG1ham9yTGluZXM6IFtdLFxuICAgICAgbWFqb3JUZXh0czogW10sXG4gICAgICBtaW5vckxpbmVzOiBbXSxcbiAgICAgIG1pbm9yVGV4dHM6IFtdXG4gICAgfVxuICB9O1xuICB0aGlzLnByb3BzID0ge1xuICAgIHJhbmdlOiB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogMCxcbiAgICAgIG1pbmltdW1TdGVwOiAwXG4gICAgfSxcbiAgICBsaW5lVG9wOiAwXG4gIH07XG5cbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBvcmllbnRhdGlvbjogJ2JvdHRvbScsICAvLyBzdXBwb3J0ZWQ6ICd0b3AnLCAnYm90dG9tJ1xuICAgIC8vIFRPRE86IGltcGxlbWVudCB0aW1lYXhpcyBvcmllbnRhdGlvbnMgJ2xlZnQnIGFuZCAncmlnaHQnXG4gICAgc2hvd01pbm9yTGFiZWxzOiB0cnVlLFxuICAgIHNob3dNYWpvckxhYmVsczogdHJ1ZVxuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAvLyBjcmVhdGUgdGhlIEhUTUwgRE9NXG4gIHRoaXMuX2NyZWF0ZSgpO1xuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbn1cblxuVGltZUF4aXMucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIFNldCBvcHRpb25zIGZvciB0aGUgVGltZUF4aXMuXG4gKiBQYXJhbWV0ZXJzIHdpbGwgYmUgbWVyZ2VkIGluIGN1cnJlbnQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBbb3JpZW50YXRpb25dXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93TWlub3JMYWJlbHNdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93TWFqb3JMYWJlbHNdXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIC8vIGNvcHkgYWxsIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydvcmllbnRhdGlvbicsICdzaG93TWlub3JMYWJlbHMnLCAnc2hvd01ham9yTGFiZWxzJ10sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAvLyBhcHBseSBsb2NhbGUgdG8gbW9tZW50LmpzXG4gICAgLy8gVE9ETzogbm90IHNvIG5pY2UsIHRoaXMgaXMgYXBwbGllZCBnbG9iYWxseSB0byBtb21lbnQuanNcbiAgICBpZiAoJ2xvY2FsZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBtb21lbnQubG9jYWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG1vbWVudC5qcyAyLjguMStcbiAgICAgICAgbW9tZW50LmxvY2FsZShvcHRpb25zLmxvY2FsZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbW9tZW50Lmxhbmcob3B0aW9ucy5sb2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgVGltZUF4aXNcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kb20uZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgdGhpcy5kb20uZm9yZWdyb3VuZC5jbGFzc05hbWUgPSAndGltZWF4aXMgZm9yZWdyb3VuZCc7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQuY2xhc3NOYW1lID0gJ3RpbWVheGlzIGJhY2tncm91bmQnO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBUaW1lQXhpc1xuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAvLyByZW1vdmUgZnJvbSBET01cbiAgaWYgKHRoaXMuZG9tLmZvcmVncm91bmQucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5mb3JlZ3JvdW5kKTtcbiAgfVxuICBpZiAodGhpcy5kb20uYmFja2dyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICB9XG5cbiAgdGhpcy5ib2R5ID0gbnVsbDtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgZm9yZWdyb3VuZCA9IHRoaXMuZG9tLmZvcmVncm91bmQsXG4gICAgICBiYWNrZ3JvdW5kID0gdGhpcy5kb20uYmFja2dyb3VuZDtcblxuICAvLyBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgcGFyZW50IERPTSBlbGVtZW50IChkZXBlbmRpbmcgb24gb3B0aW9uIG9yaWVudGF0aW9uKVxuICB2YXIgcGFyZW50ID0gKG9wdGlvbnMub3JpZW50YXRpb24gPT0gJ3RvcCcpID8gdGhpcy5ib2R5LmRvbS50b3AgOiB0aGlzLmJvZHkuZG9tLmJvdHRvbTtcbiAgdmFyIHBhcmVudENoYW5nZWQgPSAoZm9yZWdyb3VuZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpO1xuXG4gIC8vIGNhbGN1bGF0ZSBjaGFyYWN0ZXIgd2lkdGggYW5kIGhlaWdodFxuICB0aGlzLl9jYWxjdWxhdGVDaGFyU2l6ZSgpO1xuXG4gIC8vIFRPRE86IHJlY2FsY3VsYXRlIHNpemVzIG9ubHkgbmVlZGVkIHdoZW4gcGFyZW50IGlzIHJlc2l6ZWQgb3Igb3B0aW9ucyBpcyBjaGFuZ2VkXG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbixcbiAgICAgIHNob3dNaW5vckxhYmVscyA9IHRoaXMub3B0aW9ucy5zaG93TWlub3JMYWJlbHMsXG4gICAgICBzaG93TWFqb3JMYWJlbHMgPSB0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzO1xuXG4gIC8vIGRldGVybWluZSB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZWxlbWVucyBmb3IgdGhlIGF4aXNcbiAgcHJvcHMubWlub3JMYWJlbEhlaWdodCA9IHNob3dNaW5vckxhYmVscyA/IHByb3BzLm1pbm9yQ2hhckhlaWdodCA6IDA7XG4gIHByb3BzLm1ham9yTGFiZWxIZWlnaHQgPSBzaG93TWFqb3JMYWJlbHMgPyBwcm9wcy5tYWpvckNoYXJIZWlnaHQgOiAwO1xuICBwcm9wcy5oZWlnaHQgPSBwcm9wcy5taW5vckxhYmVsSGVpZ2h0ICsgcHJvcHMubWFqb3JMYWJlbEhlaWdodDtcbiAgcHJvcHMud2lkdGggPSBmb3JlZ3JvdW5kLm9mZnNldFdpZHRoO1xuXG4gIHByb3BzLm1pbm9yTGluZUhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5yb290LmhlaWdodCAtIHByb3BzLm1ham9yTGFiZWxIZWlnaHQgLVxuICAgICAgKG9wdGlvbnMub3JpZW50YXRpb24gPT0gJ3RvcCcgPyB0aGlzLmJvZHkuZG9tUHJvcHMuYm90dG9tLmhlaWdodCA6IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0KTtcbiAgcHJvcHMubWlub3JMaW5lV2lkdGggPSAxOyAvLyBUT0RPOiByZWFsbHkgY2FsY3VsYXRlIHdpZHRoXG4gIHByb3BzLm1ham9yTGluZUhlaWdodCA9IHByb3BzLm1pbm9yTGluZUhlaWdodCArIHByb3BzLm1ham9yTGFiZWxIZWlnaHQ7XG4gIHByb3BzLm1ham9yTGluZVdpZHRoID0gMTsgLy8gVE9ETzogcmVhbGx5IGNhbGN1bGF0ZSB3aWR0aFxuXG4gIC8vICB0YWtlIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgb2ZmbGluZSB3aGlsZSB1cGRhdGluZyAoaXMgYWxtb3N0IHR3aWNlIGFzIGZhc3QpXG4gIHZhciBmb3JlZ3JvdW5kTmV4dFNpYmxpbmcgPSBmb3JlZ3JvdW5kLm5leHRTaWJsaW5nO1xuICB2YXIgYmFja2dyb3VuZE5leHRTaWJsaW5nID0gYmFja2dyb3VuZC5uZXh0U2libGluZztcbiAgZm9yZWdyb3VuZC5wYXJlbnROb2RlICYmIGZvcmVncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmb3JlZ3JvdW5kKTtcbiAgYmFja2dyb3VuZC5wYXJlbnROb2RlICYmIGJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiYWNrZ3JvdW5kKTtcblxuICBmb3JlZ3JvdW5kLnN0eWxlLmhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0ICsgJ3B4JztcblxuICB0aGlzLl9yZXBhaW50TGFiZWxzKCk7XG5cbiAgLy8gcHV0IERPTSBvbmxpbmUgYWdhaW4gKGF0IHRoZSBzYW1lIHBsYWNlKVxuICBpZiAoZm9yZWdyb3VuZE5leHRTaWJsaW5nKSB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShmb3JlZ3JvdW5kLCBmb3JlZ3JvdW5kTmV4dFNpYmxpbmcpO1xuICB9XG4gIGVsc2Uge1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChmb3JlZ3JvdW5kKVxuICB9XG4gIGlmIChiYWNrZ3JvdW5kTmV4dFNpYmxpbmcpIHtcbiAgICB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5pbnNlcnRCZWZvcmUoYmFja2dyb3VuZCwgYmFja2dyb3VuZE5leHRTaWJsaW5nKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5hcHBlbmRDaGlsZChiYWNrZ3JvdW5kKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2lzUmVzaXplZCgpIHx8IHBhcmVudENoYW5nZWQ7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgbWFqb3IgYW5kIG1pbm9yIHRleHQgbGFiZWxzIGFuZCB2ZXJ0aWNhbCBncmlkIGxpbmVzXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbjtcblxuICAvLyBjYWxjdWxhdGUgcmFuZ2UgYW5kIHN0ZXAgKHN0ZXAgc3VjaCB0aGF0IHdlIGhhdmUgc3BhY2UgZm9yIDcgY2hhcmFjdGVycyBwZXIgbGFiZWwpXG4gIHZhciBzdGFydCA9IHV0aWwuY29udmVydCh0aGlzLmJvZHkucmFuZ2Uuc3RhcnQsICdOdW1iZXInKSxcbiAgICAgIGVuZCA9IHV0aWwuY29udmVydCh0aGlzLmJvZHkucmFuZ2UuZW5kLCAnTnVtYmVyJyksXG4gICAgICBtaW5pbXVtU3RlcCA9IHRoaXMuYm9keS51dGlsLnRvVGltZSgodGhpcy5wcm9wcy5taW5vckNoYXJXaWR0aCB8fCAxMCkgKiA3KS52YWx1ZU9mKClcbiAgICAgICAgICAtdGhpcy5ib2R5LnV0aWwudG9UaW1lKDApLnZhbHVlT2YoKTtcbiAgdmFyIHN0ZXAgPSBuZXcgVGltZVN0ZXAobmV3IERhdGUoc3RhcnQpLCBuZXcgRGF0ZShlbmQpLCBtaW5pbXVtU3RlcCk7XG4gIHRoaXMuc3RlcCA9IHN0ZXA7XG5cbiAgLy8gTW92ZSBhbGwgRE9NIGVsZW1lbnRzIHRvIGEgXCJyZWR1bmRhbnRcIiBsaXN0LCB3aGVyZSB0aGV5XG4gIC8vIGNhbiBiZSBwaWNrZWQgZm9yIHJlLXVzZSwgYW5kIGNsZWFyIHRoZSBsaXN0cyB3aXRoIGxpbmVzIGFuZCB0ZXh0cy5cbiAgLy8gQXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24gX3JlcGFpbnRMYWJlbHMsIGxlZnQgb3ZlciBlbGVtZW50cyB3aWxsIGJlIGNsZWFuZWQgdXBcbiAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICBkb20ucmVkdW5kYW50Lm1ham9yTGluZXMgPSBkb20ubWFqb3JMaW5lcztcbiAgZG9tLnJlZHVuZGFudC5tYWpvclRleHRzID0gZG9tLm1ham9yVGV4dHM7XG4gIGRvbS5yZWR1bmRhbnQubWlub3JMaW5lcyA9IGRvbS5taW5vckxpbmVzO1xuICBkb20ucmVkdW5kYW50Lm1pbm9yVGV4dHMgPSBkb20ubWlub3JUZXh0cztcbiAgZG9tLm1ham9yTGluZXMgPSBbXTtcbiAgZG9tLm1ham9yVGV4dHMgPSBbXTtcbiAgZG9tLm1pbm9yTGluZXMgPSBbXTtcbiAgZG9tLm1pbm9yVGV4dHMgPSBbXTtcblxuICBzdGVwLmZpcnN0KCk7XG4gIHZhciB4Rmlyc3RNYWpvckxhYmVsID0gdW5kZWZpbmVkO1xuICB2YXIgbWF4ID0gMDtcbiAgd2hpbGUgKHN0ZXAuaGFzTmV4dCgpICYmIG1heCA8IDEwMDApIHtcbiAgICBtYXgrKztcbiAgICB2YXIgY3VyID0gc3RlcC5nZXRDdXJyZW50KCksXG4gICAgICAgIHggPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihjdXIpLFxuICAgICAgICBpc01ham9yID0gc3RlcC5pc01ham9yKCk7XG5cbiAgICAvLyBUT0RPOiBsaW5lcyBtdXN0IGhhdmUgYSB3aWR0aCwgc3VjaCB0aGF0IHdlIGNhbiBjcmVhdGUgY3NzIGJhY2tncm91bmRzXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dNaW5vckxhYmVscykge1xuICAgICAgdGhpcy5fcmVwYWludE1pbm9yVGV4dCh4LCBzdGVwLmdldExhYmVsTWlub3IoKSwgb3JpZW50YXRpb24pO1xuICAgIH1cblxuICAgIGlmIChpc01ham9yICYmIHRoaXMub3B0aW9ucy5zaG93TWFqb3JMYWJlbHMpIHtcbiAgICAgIGlmICh4ID4gMCkge1xuICAgICAgICBpZiAoeEZpcnN0TWFqb3JMYWJlbCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB4Rmlyc3RNYWpvckxhYmVsID0geDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXBhaW50TWFqb3JUZXh0KHgsIHN0ZXAuZ2V0TGFiZWxNYWpvcigpLCBvcmllbnRhdGlvbik7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXBhaW50TWFqb3JMaW5lKHgsIG9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9yZXBhaW50TWlub3JMaW5lKHgsIG9yaWVudGF0aW9uKTtcbiAgICB9XG5cbiAgICBzdGVwLm5leHQoKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBhIG1ham9yIGxhYmVsIG9uIHRoZSBsZWZ0IHdoZW4gbmVlZGVkXG4gIGlmICh0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzKSB7XG4gICAgdmFyIGxlZnRUaW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKDApLFxuICAgICAgICBsZWZ0VGV4dCA9IHN0ZXAuZ2V0TGFiZWxNYWpvcihsZWZ0VGltZSksXG4gICAgICAgIHdpZHRoVGV4dCA9IGxlZnRUZXh0Lmxlbmd0aCAqICh0aGlzLnByb3BzLm1ham9yQ2hhcldpZHRoIHx8IDEwKSArIDEwOyAvLyB1cHBlciBib3VuZCBlc3RpbWF0aW9uXG5cbiAgICBpZiAoeEZpcnN0TWFqb3JMYWJlbCA9PSB1bmRlZmluZWQgfHwgd2lkdGhUZXh0IDwgeEZpcnN0TWFqb3JMYWJlbCkge1xuICAgICAgdGhpcy5fcmVwYWludE1ham9yVGV4dCgwLCBsZWZ0VGV4dCwgb3JpZW50YXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFudXAgbGVmdG92ZXIgRE9NIGVsZW1lbnRzIGZyb20gdGhlIHJlZHVuZGFudCBsaXN0XG4gIHV0aWwuZm9yRWFjaCh0aGlzLmRvbS5yZWR1bmRhbnQsIGZ1bmN0aW9uIChhcnIpIHtcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCkge1xuICAgICAgdmFyIGVsZW0gPSBhcnIucG9wKCk7XG4gICAgICBpZiAoZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG1pbm9yIGxhYmVsIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAgIFwidG9wXCIgb3IgXCJib3R0b21cIiAoZGVmYXVsdClcbiAqIEBwcml2YXRlXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5fcmVwYWludE1pbm9yVGV4dCA9IGZ1bmN0aW9uICh4LCB0ZXh0LCBvcmllbnRhdGlvbikge1xuICAvLyByZXVzZSByZWR1bmRhbnQgbGFiZWxcbiAgdmFyIGxhYmVsID0gdGhpcy5kb20ucmVkdW5kYW50Lm1pbm9yVGV4dHMuc2hpZnQoKTtcblxuICBpZiAoIWxhYmVsKSB7XG4gICAgLy8gY3JlYXRlIG5ldyBsYWJlbFxuICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGFiZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgbGFiZWwuY2xhc3NOYW1lID0gJ3RleHQgbWlub3InO1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICB9XG4gIHRoaXMuZG9tLm1pbm9yVGV4dHMucHVzaChsYWJlbCk7XG5cbiAgbGFiZWwuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgPSB0ZXh0O1xuXG4gIGxhYmVsLnN0eWxlLnRvcCA9IChvcmllbnRhdGlvbiA9PSAndG9wJykgPyAodGhpcy5wcm9wcy5tYWpvckxhYmVsSGVpZ2h0ICsgJ3B4JykgOiAnMCc7XG4gIGxhYmVsLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgLy9sYWJlbC50aXRsZSA9IHRpdGxlOyAgLy8gVE9ETzogdGhpcyBpcyBhIGhlYXZ5IG9wZXJhdGlvblxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBNYWpvciBsYWJlbCBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge1N0cmluZ30gb3JpZW50YXRpb24gICBcInRvcFwiIG9yIFwiYm90dG9tXCIgKGRlZmF1bHQpXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNYWpvclRleHQgPSBmdW5jdGlvbiAoeCwgdGV4dCwgb3JpZW50YXRpb24pIHtcbiAgLy8gcmV1c2UgcmVkdW5kYW50IGxhYmVsXG4gIHZhciBsYWJlbCA9IHRoaXMuZG9tLnJlZHVuZGFudC5tYWpvclRleHRzLnNoaWZ0KCk7XG5cbiAgaWYgKCFsYWJlbCkge1xuICAgIC8vIGNyZWF0ZSBsYWJlbFxuICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsYWJlbC5jbGFzc05hbWUgPSAndGV4dCBtYWpvcic7XG4gICAgbGFiZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gIH1cbiAgdGhpcy5kb20ubWFqb3JUZXh0cy5wdXNoKGxhYmVsKTtcblxuICBsYWJlbC5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA9IHRleHQ7XG4gIC8vbGFiZWwudGl0bGUgPSB0aXRsZTsgLy8gVE9ETzogdGhpcyBpcyBhIGhlYXZ5IG9wZXJhdGlvblxuXG4gIGxhYmVsLnN0eWxlLnRvcCA9IChvcmllbnRhdGlvbiA9PSAndG9wJykgPyAnMCcgOiAodGhpcy5wcm9wcy5taW5vckxhYmVsSGVpZ2h0ICArICdweCcpO1xuICBsYWJlbC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG1pbm9yIGxpbmUgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge1N0cmluZ30gb3JpZW50YXRpb24gICBcInRvcFwiIG9yIFwiYm90dG9tXCIgKGRlZmF1bHQpXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNaW5vckxpbmUgPSBmdW5jdGlvbiAoeCwgb3JpZW50YXRpb24pIHtcbiAgLy8gcmV1c2UgcmVkdW5kYW50IGxpbmVcbiAgdmFyIGxpbmUgPSB0aGlzLmRvbS5yZWR1bmRhbnQubWlub3JMaW5lcy5zaGlmdCgpO1xuXG4gIGlmICghbGluZSkge1xuICAgIC8vIGNyZWF0ZSB2ZXJ0aWNhbCBsaW5lXG4gICAgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxpbmUuY2xhc3NOYW1lID0gJ2dyaWQgdmVydGljYWwgbWlub3InO1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQobGluZSk7XG4gIH1cbiAgdGhpcy5kb20ubWlub3JMaW5lcy5wdXNoKGxpbmUpO1xuXG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgIGxpbmUuc3R5bGUudG9wID0gcHJvcHMubWFqb3JMYWJlbEhlaWdodCArICdweCc7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGluZS5zdHlsZS50b3AgPSB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIH1cbiAgbGluZS5zdHlsZS5oZWlnaHQgPSBwcm9wcy5taW5vckxpbmVIZWlnaHQgKyAncHgnO1xuICBsaW5lLnN0eWxlLmxlZnQgPSAoeCAtIHByb3BzLm1pbm9yTGluZVdpZHRoIC8gMikgKyAncHgnO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBNYWpvciBsaW5lIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICogQHByaXZhdGVcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TWFqb3JMaW5lID0gZnVuY3Rpb24gKHgsIG9yaWVudGF0aW9uKSB7XG4gIC8vIHJldXNlIHJlZHVuZGFudCBsaW5lXG4gIHZhciBsaW5lID0gdGhpcy5kb20ucmVkdW5kYW50Lm1ham9yTGluZXMuc2hpZnQoKTtcblxuICBpZiAoIWxpbmUpIHtcbiAgICAvLyBjcmVhdGUgdmVydGljYWwgbGluZVxuICAgIGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICBsaW5lLmNsYXNzTmFtZSA9ICdncmlkIHZlcnRpY2FsIG1ham9yJztcbiAgICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKGxpbmUpO1xuICB9XG4gIHRoaXMuZG9tLm1ham9yTGluZXMucHVzaChsaW5lKTtcblxuICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICBsaW5lLnN0eWxlLnRvcCA9ICcwJztcbiAgfVxuICBlbHNlIHtcbiAgICBsaW5lLnN0eWxlLnRvcCA9IHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgfVxuICBsaW5lLnN0eWxlLmxlZnQgPSAoeCAtIHByb3BzLm1ham9yTGluZVdpZHRoIC8gMikgKyAncHgnO1xuICBsaW5lLnN0eWxlLmhlaWdodCA9IHByb3BzLm1ham9yTGluZUhlaWdodCArICdweCc7XG59O1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgc2l6ZSBvZiB0ZXh0IG9uIHRoZSBheGlzIChib3RoIG1ham9yIGFuZCBtaW5vciBheGlzKS5cbiAqIFRoZSBzaXplIGlzIGNhbGN1bGF0ZWQgb25seSBvbmNlIGFuZCB0aGVuIGNhY2hlZCBpbiB0aGlzLnByb3BzLlxuICogQHByaXZhdGVcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9jYWxjdWxhdGVDaGFyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gTm90ZTogV2UgY2FsY3VsYXRlIGNoYXIgc2l6ZSB3aXRoIGV2ZXJ5IHJlZHJhdy4gU2l6ZSBtYXkgY2hhbmdlLCBmb3JcbiAgLy8gZXhhbXBsZSB3aGVuIGFueSBvZiB0aGUgdGltZWxpbmVzIHBhcmVudHMgaGFkIGRpc3BsYXk6bm9uZSBmb3IgZXhhbXBsZS5cblxuICAvLyBkZXRlcm1pbmUgdGhlIGNoYXIgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbWlub3IgYXhpc1xuICBpZiAoIXRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IpIHtcbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5jbGFzc05hbWUgPSAndGV4dCBtaW5vciBtZWFzdXJlJztcbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJzAnKSk7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yKTtcbiAgfVxuICB0aGlzLnByb3BzLm1pbm9yQ2hhckhlaWdodCA9IHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuY2xpZW50SGVpZ2h0O1xuICB0aGlzLnByb3BzLm1pbm9yQ2hhcldpZHRoID0gdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5jbGllbnRXaWR0aDtcblxuICAvLyBkZXRlcm1pbmUgdGhlIGNoYXIgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbWFqb3IgYXhpc1xuICBpZiAoIXRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IpIHtcbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5jbGFzc05hbWUgPSAndGV4dCBtaW5vciBtZWFzdXJlJztcbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJzAnKSk7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yKTtcbiAgfVxuICB0aGlzLnByb3BzLm1ham9yQ2hhckhlaWdodCA9IHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IuY2xpZW50SGVpZ2h0O1xuICB0aGlzLnByb3BzLm1ham9yQ2hhcldpZHRoID0gdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5jbGllbnRXaWR0aDtcbn07XG5cbi8qKlxuICogU25hcCBhIGRhdGUgdG8gYSByb3VuZGVkIHZhbHVlLlxuICogVGhlIHNuYXAgaW50ZXJ2YWxzIGFyZSBkZXBlbmRlbnQgb24gdGhlIGN1cnJlbnQgc2NhbGUgYW5kIHN0ZXAuXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGUgICB0aGUgZGF0ZSB0byBiZSBzbmFwcGVkLlxuICogQHJldHVybiB7RGF0ZX0gc25hcHBlZERhdGVcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLnNuYXAgPSBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiB0aGlzLnN0ZXAuc25hcChkYXRlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZUF4aXM7XG4iLCJ2YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIEl0ZW0gPSByZXF1aXJlKCcuL0l0ZW0nKTtcbnZhciBSYW5nZUl0ZW0gPSByZXF1aXJlKCcuL1JhbmdlSXRlbScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBCYWNrZ3JvdW5kSXRlbVxuICogQGV4dGVuZHMgSXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBzdGFydCwgZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIG9wdGlvbnNcbiAqL1xuLy8gVE9ETzogaW1wbGVtZW50IHN1cHBvcnQgZm9yIHRoZSBCYWNrZ3JvdW5kSXRlbSBqdXN0IGhhdmluZyBhIHN0YXJ0LCB0aGVuIGJlaW5nIGRpc3BsYXllZCBhcyBhIHNvcnQgb2YgYW4gYW5ub3RhdGlvblxuZnVuY3Rpb24gQmFja2dyb3VuZEl0ZW0gKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdGhpcy5wcm9wcyA9IHtcbiAgICBjb250ZW50OiB7XG4gICAgICB3aWR0aDogMFxuICAgIH1cbiAgfTtcbiAgdGhpcy5vdmVyZmxvdyA9IGZhbHNlOyAvLyBpZiBjb250ZW50cyBjYW4gb3ZlcmZsb3cgKGNzcyBzdHlsaW5nKSwgdGhpcyBmbGFnIGlzIHNldCB0byB0cnVlXG5cbiAgLy8gdmFsaWRhdGUgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcInN0YXJ0XCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhLmlkKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuZW5kID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcImVuZFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgfVxuICB9XG5cbiAgSXRlbS5jYWxsKHRoaXMsIGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpO1xufVxuXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUgPSBuZXcgSXRlbSAobnVsbCwgbnVsbCwgbnVsbCk7XG5cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5iYXNlQ2xhc3NOYW1lID0gJ2l0ZW0gYmFja2dyb3VuZCc7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gKi9cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbihyYW5nZSkge1xuICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICByZXR1cm4gKHRoaXMuZGF0YS5zdGFydCA8IHJhbmdlLmVuZCkgJiYgKHRoaXMuZGF0YS5lbmQgPiByYW5nZS5zdGFydCk7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAqL1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZG9tID0gdGhpcy5kb207XG4gIGlmICghZG9tKSB7XG4gICAgLy8gY3JlYXRlIERPTVxuICAgIHRoaXMuZG9tID0ge307XG4gICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgZG9tLmJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vIGNsYXNzTmFtZSBpcyB1cGRhdGVkIGluIHJlZHJhdygpXG5cbiAgICAvLyBjb250ZW50cyBib3hcbiAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5jb250ZW50LmNsYXNzTmFtZSA9ICdjb250ZW50JztcbiAgICBkb20uYm94LmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgIC8vIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlXG4gICAgZG9tLmJveFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogbm8gcGFyZW50IGF0dGFjaGVkJyk7XG4gIH1cbiAgaWYgKCFkb20uYm94LnBhcmVudE5vZGUpIHtcbiAgICB2YXIgYmFja2dyb3VuZCA9IHRoaXMucGFyZW50LmRvbS5iYWNrZ3JvdW5kO1xuICAgIGlmICghYmFja2dyb3VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IHRpbWUgYXhpczogcGFyZW50IGhhcyBubyBiYWNrZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgfVxuICAgIGJhY2tncm91bmQuYXBwZW5kQ2hpbGQoZG9tLmJveCk7XG4gIH1cbiAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gIC8vIFVwZGF0ZSBET00gd2hlbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eS4gQW4gaXRlbSBpcyBtYXJrZWQgZGlydHkgd2hlbjpcbiAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgLy8gLSB0aGUgaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgdGhpcy5fdXBkYXRlVGl0bGUodGhpcy5kb20uY29udGVudCk7XG4gICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20uY29udGVudCk7XG5cbiAgICAvLyB1cGRhdGUgY2xhc3NcbiAgICB2YXIgY2xhc3NOYW1lID0gKHRoaXMuZGF0YS5jbGFzc05hbWUgPyAoJyAnICsgdGhpcy5kYXRhLmNsYXNzTmFtZSkgOiAnJykgK1xuICAgICAgICAodGhpcy5zZWxlY3RlZCA/ICcgc2VsZWN0ZWQnIDogJycpO1xuICAgIGRvbS5ib3guY2xhc3NOYW1lID0gdGhpcy5iYXNlQ2xhc3NOYW1lICsgY2xhc3NOYW1lO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGZyb20gY3NzIHdoZXRoZXIgdGhpcyBib3ggaGFzIG92ZXJmbG93XG4gICAgdGhpcy5vdmVyZmxvdyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbS5jb250ZW50KS5vdmVyZmxvdyAhPT0gJ2hpZGRlbic7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBzaXplXG4gICAgdGhpcy5wcm9wcy5jb250ZW50LndpZHRoID0gdGhpcy5kb20uY29udGVudC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IDA7IC8vIHNldCBoZWlnaHQgemVybywgc28gdGhpcyBpdGVtIHdpbGwgYmUgaWdub3JlZCB3aGVuIHN0YWNraW5nIGl0ZW1zXG5cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gKi9cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5zaG93ID0gUmFuZ2VJdGVtLnByb3RvdHlwZS5zaG93O1xuXG4vKipcbiAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5oaWRlID0gUmFuZ2VJdGVtLnByb3RvdHlwZS5oaWRlO1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gaG9yaXpvbnRhbGx5XG4gKiBAT3ZlcnJpZGVcbiAqL1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gUmFuZ2VJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWDtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAqIEBPdmVycmlkZVxuICovXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9uVG9wID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSAndG9wJztcbiAgdGhpcy5kb20uY29udGVudC5zdHlsZS50b3AgPSBvblRvcCA/ICcnIDogJzAnO1xuICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmJvdHRvbSA9IG9uVG9wID8gJzAnIDogJyc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tncm91bmRJdGVtO1xuIiwidmFyIEl0ZW0gPSByZXF1aXJlKCcuL0l0ZW0nKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgQm94SXRlbVxuICogQGV4dGVuZHMgSXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBzdGFydFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCwgY2xhc3NOYW1lLlxuICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBhdmFpbGFibGUgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBCb3hJdGVtIChkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgZG90OiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH0sXG4gICAgbGluZToge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9XG4gIH07XG5cbiAgLy8gdmFsaWRhdGUgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcInN0YXJ0XCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhKTtcbiAgICB9XG4gIH1cblxuICBJdGVtLmNhbGwodGhpcywgZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucyk7XG59XG5cbkJveEl0ZW0ucHJvdG90eXBlID0gbmV3IEl0ZW0gKG51bGwsIG51bGwsIG51bGwpO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhpcyBpdGVtIGlzIHZpc2libGUgaW5zaWRlIGdpdmVuIHJhbmdlXG4gKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyfX0gcmFuZ2Ugd2l0aCBhIHRpbWVzdGFtcCBmb3Igc3RhcnQgYW5kIGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICovXG5Cb3hJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbihyYW5nZSkge1xuICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICAvLyBUT0RPOiBhY2NvdW50IGZvciB0aGUgcmVhbCB3aWR0aCBvZiB0aGUgaXRlbS4gUmlnaHQgbm93IHdlIGp1c3QgYWRkIDEvNCB0byB0aGUgd2luZG93XG4gIHZhciBpbnRlcnZhbCA9IChyYW5nZS5lbmQgLSByYW5nZS5zdGFydCkgLyA0O1xuICByZXR1cm4gKHRoaXMuZGF0YS5zdGFydCA+IHJhbmdlLnN0YXJ0IC0gaW50ZXJ2YWwpICYmICh0aGlzLmRhdGEuc3RhcnQgPCByYW5nZS5lbmQgKyBpbnRlcnZhbCk7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAqL1xuQm94SXRlbS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgaWYgKCFkb20pIHtcbiAgICAvLyBjcmVhdGUgRE9NXG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICBkb20gPSB0aGlzLmRvbTtcblxuICAgIC8vIGNyZWF0ZSBtYWluIGJveFxuICAgIGRvbS5ib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcblxuICAgIC8vIGNvbnRlbnRzIGJveCAoaW5zaWRlIHRoZSBiYWNrZ3JvdW5kIGJveCkuIHVzZWQgZm9yIG1ha2luZyBtYXJnaW5zXG4gICAgZG9tLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICBkb20uY29udGVudC5jbGFzc05hbWUgPSAnY29udGVudCc7XG4gICAgZG9tLmJveC5hcHBlbmRDaGlsZChkb20uY29udGVudCk7XG5cbiAgICAvLyBsaW5lIHRvIGF4aXNcbiAgICBkb20ubGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIGRvbS5saW5lLmNsYXNzTmFtZSA9ICdsaW5lJztcblxuICAgIC8vIGRvdCBvbiBheGlzXG4gICAgZG9tLmRvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIGRvbS5kb3QuY2xhc3NOYW1lID0gJ2RvdCc7XG5cbiAgICAvLyBhdHRhY2ggdGhpcyBpdGVtIGFzIGF0dHJpYnV0ZVxuICAgIGRvbS5ib3hbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IG5vIHBhcmVudCBhdHRhY2hlZCcpO1xuICB9XG4gIGlmICghZG9tLmJveC5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLnBhcmVudC5kb20uZm9yZWdyb3VuZDtcbiAgICBpZiAoIWZvcmVncm91bmQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyB0aW1lIGF4aXM6IHBhcmVudCBoYXMgbm8gZm9yZWdyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgIGZvcmVncm91bmQuYXBwZW5kQ2hpbGQoZG9tLmJveCk7XG4gIH1cbiAgaWYgKCFkb20ubGluZS5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGJhY2tncm91bmQgPSB0aGlzLnBhcmVudC5kb20uYmFja2dyb3VuZDtcbiAgICBpZiAoIWJhY2tncm91bmQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyB0aW1lIGF4aXM6IHBhcmVudCBoYXMgbm8gYmFja2dyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgIGJhY2tncm91bmQuYXBwZW5kQ2hpbGQoZG9tLmxpbmUpO1xuICB9XG4gIGlmICghZG9tLmRvdC5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGF4aXMgPSB0aGlzLnBhcmVudC5kb20uYXhpcztcbiAgICBpZiAoIWJhY2tncm91bmQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyB0aW1lIGF4aXM6IHBhcmVudCBoYXMgbm8gYXhpcyBjb250YWluZXIgZWxlbWVudCcpO1xuICAgIGF4aXMuYXBwZW5kQ2hpbGQoZG9tLmRvdCk7XG4gIH1cbiAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gIC8vIFVwZGF0ZSBET00gd2hlbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eS4gQW4gaXRlbSBpcyBtYXJrZWQgZGlydHkgd2hlbjpcbiAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgLy8gLSB0aGUgaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgdGhpcy5fdXBkYXRlVGl0bGUodGhpcy5kb20uYm94KTtcbiAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5ib3gpO1xuXG4gICAgLy8gdXBkYXRlIGNsYXNzXG4gICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lPyAnICcgKyB0aGlzLmRhdGEuY2xhc3NOYW1lIDogJycpICtcbiAgICAgICAgKHRoaXMuc2VsZWN0ZWQgPyAnIHNlbGVjdGVkJyA6ICcnKTtcbiAgICBkb20uYm94LmNsYXNzTmFtZSA9ICdpdGVtIGJveCcgKyBjbGFzc05hbWU7XG4gICAgZG9tLmxpbmUuY2xhc3NOYW1lID0gJ2l0ZW0gbGluZScgKyBjbGFzc05hbWU7XG4gICAgZG9tLmRvdC5jbGFzc05hbWUgID0gJ2l0ZW0gZG90JyArIGNsYXNzTmFtZTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICB0aGlzLnByb3BzLmRvdC5oZWlnaHQgPSBkb20uZG90Lm9mZnNldEhlaWdodDtcbiAgICB0aGlzLnByb3BzLmRvdC53aWR0aCA9IGRvbS5kb3Qub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5wcm9wcy5saW5lLndpZHRoID0gZG9tLmxpbmUub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy53aWR0aCA9IGRvbS5ib3gub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBkb20uYm94Lm9mZnNldEhlaWdodDtcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuX3JlcGFpbnREZWxldGVCdXR0b24oZG9tLmJveCk7XG59O1xuXG4vKipcbiAqIFNob3cgdGhlIGl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSBkaXNwbGF5ZWQpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRpc3BsYXllZCkge1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH1cbn07XG5cbi8qKlxuICogSGlkZSB0aGUgaXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAqL1xuQm94SXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG5cbiAgICBpZiAoZG9tLmJveC5wYXJlbnROb2RlKSAgIGRvbS5ib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20uYm94KTtcbiAgICBpZiAoZG9tLmxpbmUucGFyZW50Tm9kZSkgIGRvbS5saW5lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tLmxpbmUpO1xuICAgIGlmIChkb20uZG90LnBhcmVudE5vZGUpICAgZG9tLmRvdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbS5kb3QpO1xuXG4gICAgdGhpcy50b3AgPSBudWxsO1xuICAgIHRoaXMubGVmdCA9IG51bGw7XG5cbiAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gaG9yaXpvbnRhbGx5XG4gKiBAT3ZlcnJpZGVcbiAqL1xuQm94SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5zdGFydCk7XG4gIHZhciBhbGlnbiA9IHRoaXMub3B0aW9ucy5hbGlnbjtcbiAgdmFyIGxlZnQ7XG4gIHZhciBib3ggPSB0aGlzLmRvbS5ib3g7XG4gIHZhciBsaW5lID0gdGhpcy5kb20ubGluZTtcbiAgdmFyIGRvdCA9IHRoaXMuZG9tLmRvdDtcblxuICAvLyBjYWxjdWxhdGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgYm94XG4gIGlmIChhbGlnbiA9PSAncmlnaHQnKSB7XG4gICAgdGhpcy5sZWZ0ID0gc3RhcnQgLSB0aGlzLndpZHRoO1xuICB9XG4gIGVsc2UgaWYgKGFsaWduID09ICdsZWZ0Jykge1xuICAgIHRoaXMubGVmdCA9IHN0YXJ0O1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGRlZmF1bHQgb3IgJ2NlbnRlcidcbiAgICB0aGlzLmxlZnQgPSBzdGFydCAtIHRoaXMud2lkdGggLyAyO1xuICB9XG5cbiAgLy8gcmVwb3NpdGlvbiBib3hcbiAgYm94LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xuXG4gIC8vIHJlcG9zaXRpb24gbGluZVxuICBsaW5lLnN0eWxlLmxlZnQgPSAoc3RhcnQgLSB0aGlzLnByb3BzLmxpbmUud2lkdGggLyAyKSArICdweCc7XG5cbiAgLy8gcmVwb3NpdGlvbiBkb3RcbiAgZG90LnN0eWxlLmxlZnQgPSAoc3RhcnQgLSB0aGlzLnByb3BzLmRvdC53aWR0aCAvIDIpICsgJ3B4Jztcbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSB2ZXJ0aWNhbGx5XG4gKiBAT3ZlcnJpZGVcbiAqL1xuQm94SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uO1xuICB2YXIgYm94ID0gdGhpcy5kb20uYm94O1xuICB2YXIgbGluZSA9IHRoaXMuZG9tLmxpbmU7XG4gIHZhciBkb3QgPSB0aGlzLmRvbS5kb3Q7XG5cbiAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgYm94LnN0eWxlLnRvcCAgICAgPSAodGhpcy50b3AgfHwgMCkgKyAncHgnO1xuXG4gICAgbGluZS5zdHlsZS50b3AgICAgPSAnMCc7XG4gICAgbGluZS5zdHlsZS5oZWlnaHQgPSAodGhpcy5wYXJlbnQudG9wICsgdGhpcy50b3AgKyAxKSArICdweCc7XG4gICAgbGluZS5zdHlsZS5ib3R0b20gPSAnJztcbiAgfVxuICBlbHNlIHsgLy8gb3JpZW50YXRpb24gJ2JvdHRvbSdcbiAgICB2YXIgaXRlbVNldEhlaWdodCA9IHRoaXMucGFyZW50Lml0ZW1TZXQucHJvcHMuaGVpZ2h0OyAvLyBUT0RPOiB0aGlzIGlzIG5hc3R5XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBpdGVtU2V0SGVpZ2h0IC0gdGhpcy5wYXJlbnQudG9wIC0gdGhpcy5wYXJlbnQuaGVpZ2h0ICsgdGhpcy50b3A7XG5cbiAgICBib3guc3R5bGUudG9wICAgICA9ICh0aGlzLnBhcmVudC5oZWlnaHQgLSB0aGlzLnRvcCAtIHRoaXMuaGVpZ2h0IHx8IDApICsgJ3B4JztcbiAgICBsaW5lLnN0eWxlLnRvcCAgICA9IChpdGVtU2V0SGVpZ2h0IC0gbGluZUhlaWdodCkgKyAncHgnO1xuICAgIGxpbmUuc3R5bGUuYm90dG9tID0gJzAnO1xuICB9XG5cbiAgZG90LnN0eWxlLnRvcCA9ICgtdGhpcy5wcm9wcy5kb3QuaGVpZ2h0IC8gMikgKyAncHgnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3hJdGVtO1xuIiwidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZS9oYW1tZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgSXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgKG9wdGlvbmFsKSBwYXJhbWV0ZXJzIHR5cGUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCwgZW5kLCBjb250ZW50LCBncm91cCwgY2xhc3NOYW1lLlxuICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBhdmFpbGFibGUgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBJdGVtIChkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHRoaXMuaWQgPSBudWxsO1xuICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuZG9tID0gbnVsbDtcbiAgdGhpcy5jb252ZXJzaW9uID0gY29udmVyc2lvbiB8fCB7fTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzcGxheWVkID0gZmFsc2U7XG4gIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gIHRoaXMudG9wID0gbnVsbDtcbiAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgdGhpcy53aWR0aCA9IG51bGw7XG4gIHRoaXMuaGVpZ2h0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTZWxlY3QgY3VycmVudCBpdGVtXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIGlmICh0aGlzLmRpc3BsYXllZCkgdGhpcy5yZWRyYXcoKTtcbn07XG5cbi8qKlxuICogVW5zZWxlY3QgY3VycmVudCBpdGVtXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnVuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIGlmICh0aGlzLmRpc3BsYXllZCkgdGhpcy5yZWRyYXcoKTtcbn07XG5cbi8qKlxuICogU2V0IGRhdGEgZm9yIHRoZSBpdGVtLiBFeGlzdGluZyBkYXRhIHdpbGwgYmUgdXBkYXRlZC4gVGhlIGlkIHNob3VsZCBub3RcbiAqIGJlIGNoYW5nZWQuIFdoZW4gdGhlIGl0ZW0gaXMgZGlzcGxheWVkLCBpdCB3aWxsIGJlIHJlZHJhd24gaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICovXG5JdGVtLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgaWYgKHRoaXMuZGlzcGxheWVkKSB0aGlzLnJlZHJhdygpO1xufTtcblxuLyoqXG4gKiBTZXQgYSBwYXJlbnQgZm9yIHRoZSBpdGVtXG4gKiBAcGFyYW0ge0l0ZW1TZXQgfCBHcm91cH0gcGFyZW50XG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB0aGlzLmhpZGUoKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAqL1xuSXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IEl0ZW0gaW1wbGVtZW50YXRpb25zXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2hvdyB0aGUgSXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBJdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICovXG5JdGVtLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgaXRlbVxuICovXG5JdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBpdGVtXG59O1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIEl0ZW0gaG9yaXpvbnRhbGx5XG4gKi9cbkl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgaXRlbVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBJdGVtIHZlcnRpY2FsbHlcbiAqL1xuSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBpdGVtXG59O1xuXG4vKipcbiAqIFJlcGFpbnQgYSBkZWxldGUgYnV0dG9uIG9uIHRoZSB0b3AgcmlnaHQgb2YgdGhlIGl0ZW0gd2hlbiB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYW5jaG9yXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkl0ZW0ucHJvdG90eXBlLl9yZXBhaW50RGVsZXRlQnV0dG9uID0gZnVuY3Rpb24gKGFuY2hvcikge1xuICBpZiAodGhpcy5zZWxlY3RlZCAmJiB0aGlzLm9wdGlvbnMuZWRpdGFibGUucmVtb3ZlICYmICF0aGlzLmRvbS5kZWxldGVCdXR0b24pIHtcbiAgICAvLyBjcmVhdGUgYW5kIHNob3cgYnV0dG9uXG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIHZhciBkZWxldGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWxldGVCdXR0b24uY2xhc3NOYW1lID0gJ2RlbGV0ZSc7XG4gICAgZGVsZXRlQnV0dG9uLnRpdGxlID0gJ0RlbGV0ZSB0aGlzIGl0ZW0nO1xuXG4gICAgSGFtbWVyKGRlbGV0ZUJ1dHRvbiwge1xuICAgICAgcHJldmVudERlZmF1bHQ6IHRydWVcbiAgICB9KS5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBtZS5wYXJlbnQucmVtb3ZlRnJvbURhdGFTZXQobWUpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG5cbiAgICBhbmNob3IuYXBwZW5kQ2hpbGQoZGVsZXRlQnV0dG9uKTtcbiAgICB0aGlzLmRvbS5kZWxldGVCdXR0b24gPSBkZWxldGVCdXR0b247XG4gIH1cbiAgZWxzZSBpZiAoIXRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5kb20uZGVsZXRlQnV0dG9uKSB7XG4gICAgLy8gcmVtb3ZlIGJ1dHRvblxuICAgIGlmICh0aGlzLmRvbS5kZWxldGVCdXR0b24ucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uZGVsZXRlQnV0dG9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZGVsZXRlQnV0dG9uKTtcbiAgICB9XG4gICAgdGhpcy5kb20uZGVsZXRlQnV0dG9uID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgSFRNTCBjb250ZW50cyBmb3IgdGhlIGl0ZW1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAgIEhUTUwgZWxlbWVudCB0byBmaWxsIHdpdGggdGhlIGNvbnRlbnRzXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtLnByb3RvdHlwZS5fdXBkYXRlQ29udGVudHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgY29udGVudDtcbiAgaWYgKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgIHZhciBpdGVtRGF0YSA9IHRoaXMucGFyZW50Lml0ZW1TZXQuaXRlbXNEYXRhLmdldCh0aGlzLmlkKTsgLy8gZ2V0IGEgY2xvbmUgb2YgdGhlIGRhdGEgZnJvbSB0aGUgZGF0YXNldFxuICAgIGNvbnRlbnQgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUoaXRlbURhdGEpO1xuICB9XG4gIGVsc2Uge1xuICAgIGNvbnRlbnQgPSB0aGlzLmRhdGEuY29udGVudDtcbiAgfVxuXG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgfVxuICBlbHNlIGlmIChjb250ZW50ICE9IHVuZGVmaW5lZCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gY29udGVudDtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwiY29udGVudFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgdGhpcy5kYXRhLmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgSFRNTCBjb250ZW50cyBmb3IgdGhlIGl0ZW1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAgIEhUTUwgZWxlbWVudCB0byBmaWxsIHdpdGggdGhlIGNvbnRlbnRzXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtLnByb3RvdHlwZS5fdXBkYXRlVGl0bGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBpZiAodGhpcy5kYXRhLnRpdGxlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnRpdGxlID0gdGhpcy5kYXRhLnRpdGxlIHx8ICcnO1xuICB9XG4gIGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgZGF0YUF0dHJpYnV0ZXMgdGltZWxpbmUgb3B0aW9uIGFuZCBzZXQgYXMgZGF0YS0gYXR0cmlidXRlcyBvbiBkb20uY29udGVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgSFRNTCBlbGVtZW50IHRvIHdoaWNoIHRoZSBhdHRyaWJ1dGVzIHdpbGwgYmUgYXR0YWNoZWRcbiAqIEBwcml2YXRlXG4gKi9cbiBJdGVtLnByb3RvdHlwZS5fdXBkYXRlRGF0YUF0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXMgJiYgdGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmRhdGFbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLScgKyBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtJyArIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJdGVtO1xuIiwidmFyIEl0ZW0gPSByZXF1aXJlKCcuL0l0ZW0nKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUG9pbnRJdGVtXG4gKiBAZXh0ZW5kcyBJdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHN0YXJ0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIGF2YWlsYWJsZSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFBvaW50SXRlbSAoZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICB0aGlzLnByb3BzID0ge1xuICAgIGRvdDoge1xuICAgICAgdG9wOiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9LFxuICAgIGNvbnRlbnQ6IHtcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIG1hcmdpbkxlZnQ6IDBcbiAgICB9XG4gIH07XG5cbiAgLy8gdmFsaWRhdGUgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcInN0YXJ0XCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhKTtcbiAgICB9XG4gIH1cblxuICBJdGVtLmNhbGwodGhpcywgZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucyk7XG59XG5cblBvaW50SXRlbS5wcm90b3R5cGUgPSBuZXcgSXRlbSAobnVsbCwgbnVsbCwgbnVsbCk7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgLy8gZGV0ZXJtaW5lIHZpc2liaWxpdHlcbiAgLy8gVE9ETzogYWNjb3VudCBmb3IgdGhlIHJlYWwgd2lkdGggb2YgdGhlIGl0ZW0uIFJpZ2h0IG5vdyB3ZSBqdXN0IGFkZCAxLzQgdG8gdGhlIHdpbmRvd1xuICB2YXIgaW50ZXJ2YWwgPSAocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQpIC8gNDtcbiAgcmV0dXJuICh0aGlzLmRhdGEuc3RhcnQgPiByYW5nZS5zdGFydCAtIGludGVydmFsKSAmJiAodGhpcy5kYXRhLnN0YXJ0IDwgcmFuZ2UuZW5kICsgaW50ZXJ2YWwpO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBpdGVtXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgaWYgKCFkb20pIHtcbiAgICAvLyBjcmVhdGUgRE9NXG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICBkb20gPSB0aGlzLmRvbTtcblxuICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgZG9tLnBvaW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gY2xhc3NOYW1lIGlzIHVwZGF0ZWQgaW4gcmVkcmF3KClcblxuICAgIC8vIGNvbnRlbnRzIGJveCwgcmlnaHQgZnJvbSB0aGUgZG90XG4gICAgZG9tLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uY29udGVudC5jbGFzc05hbWUgPSAnY29udGVudCc7XG4gICAgZG9tLnBvaW50LmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgIC8vIGRvdCBhdCBzdGFydFxuICAgIGRvbS5kb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20ucG9pbnQuYXBwZW5kQ2hpbGQoZG9tLmRvdCk7XG5cbiAgICAvLyBhdHRhY2ggdGhpcyBpdGVtIGFzIGF0dHJpYnV0ZVxuICAgIGRvbS5wb2ludFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogbm8gcGFyZW50IGF0dGFjaGVkJyk7XG4gIH1cbiAgaWYgKCFkb20ucG9pbnQucGFyZW50Tm9kZSkge1xuICAgIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmZvcmVncm91bmQ7XG4gICAgaWYgKCFmb3JlZ3JvdW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgdGltZSBheGlzOiBwYXJlbnQgaGFzIG5vIGZvcmVncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICB9XG4gICAgZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChkb20ucG9pbnQpO1xuICB9XG4gIHRoaXMuZGlzcGxheWVkID0gdHJ1ZTtcblxuICAvLyBVcGRhdGUgRE9NIHdoZW4gaXRlbSBpcyBtYXJrZWQgZGlydHkuIEFuIGl0ZW0gaXMgbWFya2VkIGRpcnR5IHdoZW46XG4gIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAvLyAtIHRoZSBpdGVtJ3MgZGF0YSBpcyBjaGFuZ2VkXG4gIC8vIC0gdGhlIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICBpZiAodGhpcy5kaXJ0eSkge1xuICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnRzKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHRoaXMuZG9tLnBvaW50KTtcbiAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5wb2ludCk7XG5cbiAgICAvLyB1cGRhdGUgY2xhc3NcbiAgICB2YXIgY2xhc3NOYW1lID0gKHRoaXMuZGF0YS5jbGFzc05hbWU/ICcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUgOiAnJykgK1xuICAgICAgICAodGhpcy5zZWxlY3RlZCA/ICcgc2VsZWN0ZWQnIDogJycpO1xuICAgIGRvbS5wb2ludC5jbGFzc05hbWUgID0gJ2l0ZW0gcG9pbnQnICsgY2xhc3NOYW1lO1xuICAgIGRvbS5kb3QuY2xhc3NOYW1lICA9ICdpdGVtIGRvdCcgKyBjbGFzc05hbWU7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBzaXplXG4gICAgdGhpcy53aWR0aCA9IGRvbS5wb2ludC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGRvbS5wb2ludC5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5wcm9wcy5kb3Qud2lkdGggPSBkb20uZG90Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMucHJvcHMuZG90LmhlaWdodCA9IGRvbS5kb3Qub2Zmc2V0SGVpZ2h0O1xuICAgIHRoaXMucHJvcHMuY29udGVudC5oZWlnaHQgPSBkb20uY29udGVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyByZXNpemUgY29udGVudHNcbiAgICBkb20uY29udGVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gMiAqIHRoaXMucHJvcHMuZG90LndpZHRoICsgJ3B4JztcbiAgICAvL2RvbS5jb250ZW50LnN0eWxlLm1hcmdpblJpZ2h0ID0gLi4uICsgJ3B4JzsgLy8gVE9ETzogbWFyZ2luIHJpZ2h0XG5cbiAgICBkb20uZG90LnN0eWxlLnRvcCA9ICgodGhpcy5oZWlnaHQgLSB0aGlzLnByb3BzLmRvdC5oZWlnaHQpIC8gMikgKyAncHgnO1xuICAgIGRvbS5kb3Quc3R5bGUubGVmdCA9ICh0aGlzLnByb3BzLmRvdC53aWR0aCAvIDIpICsgJ3B4JztcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuX3JlcGFpbnREZWxldGVCdXR0b24oZG9tLnBvaW50KTtcbn07XG5cbi8qKlxuICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZGlzcGxheWVkKSB7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBpdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZGlzcGxheWVkKSB7XG4gICAgaWYgKHRoaXMuZG9tLnBvaW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLnBvaW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ucG9pbnQpO1xuICAgIH1cblxuICAgIHRoaXMudG9wID0gbnVsbDtcbiAgICB0aGlzLmxlZnQgPSBudWxsO1xuXG4gICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIGhvcml6b250YWxseVxuICogQE92ZXJyaWRlXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5zdGFydCk7XG5cbiAgdGhpcy5sZWZ0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmRvdC53aWR0aDtcblxuICAvLyByZXBvc2l0aW9uIHBvaW50XG4gIHRoaXMuZG9tLnBvaW50LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAqIEBPdmVycmlkZVxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbixcbiAgICAgIHBvaW50ID0gdGhpcy5kb20ucG9pbnQ7XG5cbiAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgcG9pbnQuc3R5bGUudG9wID0gdGhpcy50b3AgKyAncHgnO1xuICB9XG4gIGVsc2Uge1xuICAgIHBvaW50LnN0eWxlLnRvcCA9ICh0aGlzLnBhcmVudC5oZWlnaHQgLSB0aGlzLnRvcCAtIHRoaXMuaGVpZ2h0KSArICdweCc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRJdGVtO1xuIiwidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciBJdGVtID0gcmVxdWlyZSgnLi9JdGVtJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIFJhbmdlSXRlbVxuICogQGV4dGVuZHMgSXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBzdGFydCwgZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmFuZ2VJdGVtIChkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgY29udGVudDoge1xuICAgICAgd2lkdGg6IDBcbiAgICB9XG4gIH07XG4gIHRoaXMub3ZlcmZsb3cgPSBmYWxzZTsgLy8gaWYgY29udGVudHMgY2FuIG92ZXJmbG93IChjc3Mgc3R5bGluZyksIHRoaXMgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuXG4gIC8vIHZhbGlkYXRlIGRhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgfVxuICAgIGlmIChkYXRhLmVuZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJlbmRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEuaWQpO1xuICAgIH1cbiAgfVxuXG4gIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbn1cblxuUmFuZ2VJdGVtLnByb3RvdHlwZSA9IG5ldyBJdGVtIChudWxsLCBudWxsLCBudWxsKTtcblxuUmFuZ2VJdGVtLnByb3RvdHlwZS5iYXNlQ2xhc3NOYW1lID0gJ2l0ZW0gcmFuZ2UnO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhpcyBpdGVtIGlzIHZpc2libGUgaW5zaWRlIGdpdmVuIHJhbmdlXG4gKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyfX0gcmFuZ2Ugd2l0aCBhIHRpbWVzdGFtcCBmb3Igc3RhcnQgYW5kIGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIC8vIGRldGVybWluZSB2aXNpYmlsaXR5XG4gIHJldHVybiAodGhpcy5kYXRhLnN0YXJ0IDwgcmFuZ2UuZW5kKSAmJiAodGhpcy5kYXRhLmVuZCA+IHJhbmdlLnN0YXJ0KTtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgaXRlbVxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZG9tID0gdGhpcy5kb207XG4gIGlmICghZG9tKSB7XG4gICAgLy8gY3JlYXRlIERPTVxuICAgIHRoaXMuZG9tID0ge307XG4gICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgZG9tLmJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vIGNsYXNzTmFtZSBpcyB1cGRhdGVkIGluIHJlZHJhdygpXG5cbiAgICAvLyBjb250ZW50cyBib3hcbiAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5jb250ZW50LmNsYXNzTmFtZSA9ICdjb250ZW50JztcbiAgICBkb20uYm94LmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgIC8vIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlXG4gICAgZG9tLmJveFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogbm8gcGFyZW50IGF0dGFjaGVkJyk7XG4gIH1cbiAgaWYgKCFkb20uYm94LnBhcmVudE5vZGUpIHtcbiAgICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMucGFyZW50LmRvbS5mb3JlZ3JvdW5kO1xuICAgIGlmICghZm9yZWdyb3VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IHRpbWUgYXhpczogcGFyZW50IGhhcyBubyBmb3JlZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgfVxuICAgIGZvcmVncm91bmQuYXBwZW5kQ2hpbGQoZG9tLmJveCk7XG4gIH1cbiAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gIC8vIFVwZGF0ZSBET00gd2hlbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eS4gQW4gaXRlbSBpcyBtYXJrZWQgZGlydHkgd2hlbjpcbiAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgLy8gLSB0aGUgaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgdGhpcy5fdXBkYXRlVGl0bGUodGhpcy5kb20uYm94KTtcbiAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5ib3gpO1xuXG4gICAgLy8gdXBkYXRlIGNsYXNzXG4gICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lID8gKCcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUpIDogJycpICtcbiAgICAgICAgKHRoaXMuc2VsZWN0ZWQgPyAnIHNlbGVjdGVkJyA6ICcnKTtcbiAgICBkb20uYm94LmNsYXNzTmFtZSA9IHRoaXMuYmFzZUNsYXNzTmFtZSArIGNsYXNzTmFtZTtcblxuICAgIC8vIGRldGVybWluZSBmcm9tIGNzcyB3aGV0aGVyIHRoaXMgYm94IGhhcyBvdmVyZmxvd1xuICAgIHRoaXMub3ZlcmZsb3cgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20uY29udGVudCkub3ZlcmZsb3cgIT09ICdoaWRkZW4nO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgc2l6ZVxuICAgIHRoaXMucHJvcHMuY29udGVudC53aWR0aCA9IHRoaXMuZG9tLmNvbnRlbnQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmRvbS5ib3gub2Zmc2V0SGVpZ2h0O1xuXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5fcmVwYWludERlbGV0ZUJ1dHRvbihkb20uYm94KTtcbiAgdGhpcy5fcmVwYWludERyYWdMZWZ0KCk7XG4gIHRoaXMuX3JlcGFpbnREcmFnUmlnaHQoKTtcbn07XG5cbi8qKlxuICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZGlzcGxheWVkKSB7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBpdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZGlzcGxheWVkKSB7XG4gICAgdmFyIGJveCA9IHRoaXMuZG9tLmJveDtcblxuICAgIGlmIChib3gucGFyZW50Tm9kZSkge1xuICAgICAgYm94LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYm94KTtcbiAgICB9XG5cbiAgICB0aGlzLnRvcCA9IG51bGw7XG4gICAgdGhpcy5sZWZ0ID0gbnVsbDtcblxuICAgIHRoaXMuZGlzcGxheWVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAqIEBPdmVycmlkZVxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJlbnRXaWR0aCA9IHRoaXMucGFyZW50LndpZHRoO1xuICB2YXIgc3RhcnQgPSB0aGlzLmNvbnZlcnNpb24udG9TY3JlZW4odGhpcy5kYXRhLnN0YXJ0KTtcbiAgdmFyIGVuZCA9IHRoaXMuY29udmVyc2lvbi50b1NjcmVlbih0aGlzLmRhdGEuZW5kKTtcbiAgdmFyIGNvbnRlbnRMZWZ0O1xuICB2YXIgY29udGVudFdpZHRoO1xuXG4gIC8vIGxpbWl0IHRoZSB3aWR0aCBvZiB0aGUgdGhpcywgYXMgYnJvd3NlcnMgY2Fubm90IGRyYXcgdmVyeSB3aWRlIGRpdnNcbiAgaWYgKHN0YXJ0IDwgLXBhcmVudFdpZHRoKSB7XG4gICAgc3RhcnQgPSAtcGFyZW50V2lkdGg7XG4gIH1cbiAgaWYgKGVuZCA+IDIgKiBwYXJlbnRXaWR0aCkge1xuICAgIGVuZCA9IDIgKiBwYXJlbnRXaWR0aDtcbiAgfVxuICB2YXIgYm94V2lkdGggPSBNYXRoLm1heChlbmQgLSBzdGFydCwgMSk7XG5cbiAgaWYgKHRoaXMub3ZlcmZsb3cpIHtcbiAgICB0aGlzLmxlZnQgPSBzdGFydDtcbiAgICB0aGlzLndpZHRoID0gYm94V2lkdGggKyB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGg7XG4gICAgY29udGVudFdpZHRoID0gdGhpcy5wcm9wcy5jb250ZW50LndpZHRoO1xuXG4gICAgLy8gTm90ZTogVGhlIGNhbGN1bGF0aW9uIG9mIHdpZHRoIGlzIGFuIG9wdGltaXN0aWMgY2FsY3VsYXRpb24sIGdpdmluZ1xuICAgIC8vICAgICAgIGEgd2lkdGggd2hpY2ggd2lsbCBub3QgY2hhbmdlIHdoZW4gbW92aW5nIHRoZSBUaW1lbGluZVxuICAgIC8vICAgICAgIFNvIG5vIHJlLXN0YWNraW5nIG5lZWRlZCwgd2hpY2ggaXMgbmljZXIgZm9yIHRoZSBleWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5sZWZ0ID0gc3RhcnQ7XG4gICAgdGhpcy53aWR0aCA9IGJveFdpZHRoO1xuICAgIGNvbnRlbnRXaWR0aCA9IE1hdGgubWluKGVuZCAtIHN0YXJ0LCB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGgpO1xuICB9XG5cbiAgdGhpcy5kb20uYm94LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xuICB0aGlzLmRvbS5ib3guc3R5bGUud2lkdGggPSBib3hXaWR0aCArICdweCc7XG5cbiAgc3dpdGNoICh0aGlzLm9wdGlvbnMuYWxpZ24pIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gTWF0aC5tYXgoKGJveFdpZHRoIC0gY29udGVudFdpZHRoIC0gMiAqIHRoaXMub3B0aW9ucy5wYWRkaW5nKSwgMCkgKyAncHgnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gTWF0aC5tYXgoKGJveFdpZHRoIC0gY29udGVudFdpZHRoIC0gMiAqIHRoaXMub3B0aW9ucy5wYWRkaW5nKSAvIDIsIDApICsgJ3B4JztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDogLy8gJ2F1dG8nXG4gICAgICBpZiAodGhpcy5vdmVyZmxvdykge1xuICAgICAgICAvLyB3aGVuIHJhbmdlIGV4Y2VlZHMgbGVmdCBvZiB0aGUgd2luZG93LCBwb3NpdGlvbiB0aGUgY29udGVudHMgYXQgdGhlIGxlZnQgb2YgdGhlIHZpc2libGUgYXJlYVxuICAgICAgICBjb250ZW50TGVmdCA9IE1hdGgubWF4KC1zdGFydCwgMCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gd2hlbiByYW5nZSBleGNlZWRzIGxlZnQgb2YgdGhlIHdpbmRvdywgcG9zaXRpb24gdGhlIGNvbnRlbnRzIGF0IHRoZSBsZWZ0IG9mIHRoZSB2aXNpYmxlIGFyZWFcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgIGNvbnRlbnRMZWZ0ID0gTWF0aC5taW4oLXN0YXJ0LFxuICAgICAgICAgICAgICAoZW5kIC0gc3RhcnQgLSB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGggLSAyICogdGhpcy5vcHRpb25zLnBhZGRpbmcpKTtcbiAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhlIG5lZWQgZm9yIG9wdGlvbnMucGFkZGluZy4gaXQncyB0ZXJyaWJsZS5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZW50TGVmdCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubGVmdCA9IGNvbnRlbnRMZWZ0ICsgJ3B4JztcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAqIEBPdmVycmlkZVxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbixcbiAgICAgIGJveCA9IHRoaXMuZG9tLmJveDtcblxuICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICBib3guc3R5bGUudG9wID0gdGhpcy50b3AgKyAncHgnO1xuICB9XG4gIGVsc2Uge1xuICAgIGJveC5zdHlsZS50b3AgPSAodGhpcy5wYXJlbnQuaGVpZ2h0IC0gdGhpcy50b3AgLSB0aGlzLmhlaWdodCkgKyAncHgnO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgYSBkcmFnIGFyZWEgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgcmFuZ2Ugd2hlbiB0aGUgcmFuZ2UgaXMgc2VsZWN0ZWRcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5fcmVwYWludERyYWdMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zZWxlY3RlZCAmJiB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSAmJiAhdGhpcy5kb20uZHJhZ0xlZnQpIHtcbiAgICAvLyBjcmVhdGUgYW5kIHNob3cgZHJhZyBhcmVhXG4gICAgdmFyIGRyYWdMZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZHJhZ0xlZnQuY2xhc3NOYW1lID0gJ2RyYWctbGVmdCc7XG4gICAgZHJhZ0xlZnQuZHJhZ0xlZnRJdGVtID0gdGhpcztcblxuICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIHJlZHVuZGFudD9cbiAgICBIYW1tZXIoZHJhZ0xlZnQsIHtcbiAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXG4gICAgfSkub24oJ2RyYWcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnZHJhZyBsZWZ0JylcbiAgICAgICAgfSk7XG5cbiAgICB0aGlzLmRvbS5ib3guYXBwZW5kQ2hpbGQoZHJhZ0xlZnQpO1xuICAgIHRoaXMuZG9tLmRyYWdMZWZ0ID0gZHJhZ0xlZnQ7XG4gIH1cbiAgZWxzZSBpZiAoIXRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5kb20uZHJhZ0xlZnQpIHtcbiAgICAvLyBkZWxldGUgZHJhZyBhcmVhXG4gICAgaWYgKHRoaXMuZG9tLmRyYWdMZWZ0LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmRyYWdMZWZ0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZHJhZ0xlZnQpO1xuICAgIH1cbiAgICB0aGlzLmRvbS5kcmFnTGVmdCA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwYWludCBhIGRyYWcgYXJlYSBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgcmFuZ2Ugd2hlbiB0aGUgcmFuZ2UgaXMgc2VsZWN0ZWRcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5fcmVwYWludERyYWdSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgJiYgIXRoaXMuZG9tLmRyYWdSaWdodCkge1xuICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyBkcmFnIGFyZWFcbiAgICB2YXIgZHJhZ1JpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZHJhZ1JpZ2h0LmNsYXNzTmFtZSA9ICdkcmFnLXJpZ2h0JztcbiAgICBkcmFnUmlnaHQuZHJhZ1JpZ2h0SXRlbSA9IHRoaXM7XG5cbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSByZWR1bmRhbnQ/XG4gICAgSGFtbWVyKGRyYWdSaWdodCwge1xuICAgICAgcHJldmVudERlZmF1bHQ6IHRydWVcbiAgICB9KS5vbignZHJhZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coJ2RyYWcgcmlnaHQnKVxuICAgIH0pO1xuXG4gICAgdGhpcy5kb20uYm94LmFwcGVuZENoaWxkKGRyYWdSaWdodCk7XG4gICAgdGhpcy5kb20uZHJhZ1JpZ2h0ID0gZHJhZ1JpZ2h0O1xuICB9XG4gIGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLmRyYWdSaWdodCkge1xuICAgIC8vIGRlbGV0ZSBkcmFnIGFyZWFcbiAgICBpZiAodGhpcy5kb20uZHJhZ1JpZ2h0LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmRyYWdSaWdodC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmRyYWdSaWdodCk7XG4gICAgfVxuICAgIHRoaXMuZG9tLmRyYWdSaWdodCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VJdGVtO1xuIiwiLy8gRW5nbGlzaFxuZXhwb3J0c1snZW4nXSA9IHtcbiAgY3VycmVudDogJ2N1cnJlbnQnLFxuICB0aW1lOiAndGltZSdcbn07XG5leHBvcnRzWydlbl9FTiddID0gZXhwb3J0c1snZW4nXTtcbmV4cG9ydHNbJ2VuX1VTJ10gPSBleHBvcnRzWydlbiddO1xuXG4vLyBEdXRjaFxuZXhwb3J0c1snbmwnXSA9IHtcbiAgY3VzdG9tOiAnYWFuZ2VwYXN0ZScsXG4gIHRpbWU6ICd0aWpkJ1xufTtcbmV4cG9ydHNbJ25sX05MJ10gPSBleHBvcnRzWydubCddO1xuZXhwb3J0c1snbmxfQkUnXSA9IGV4cG9ydHNbJ25sJ107XG4iLCIvLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4vLyBmaXJzdCBjaGVjayBpZiBtb21lbnQuanMgaXMgYWxyZWFkeSBsb2FkZWQgaW4gdGhlIGJyb3dzZXIgd2luZG93LCBpZiBzbyxcbi8vIHVzZSB0aGlzIGluc3RhbmNlLiBFbHNlLCBsb2FkIHZpYSBjb21tb25qcy5cbnZhciBtb21lbnQgPSByZXF1aXJlKCcuL21vZHVsZS9tb21lbnQnKTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgbnVtYmVyXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNOdW1iZXJcbiAqL1xuZXhwb3J0cy5pc051bWJlciA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gKG9iamVjdCBpbnN0YW5jZW9mIE51bWJlciB8fCB0eXBlb2Ygb2JqZWN0ID09ICdudW1iZXInKTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIHN0cmluZ1xuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzU3RyaW5nXG4gKi9cbmV4cG9ydHMuaXNTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuIChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIG9iamVjdCA9PSAnc3RyaW5nJyk7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBEYXRlLCBvciBhIFN0cmluZyBjb250YWluaW5nIGEgRGF0ZVxuICogQHBhcmFtIHtEYXRlIHwgU3RyaW5nfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzRGF0ZVxuICovXG5leHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2UgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgIC8vIHRlc3Qgd2hldGhlciB0aGlzIHN0cmluZyBjb250YWlucyBhIGRhdGVcbiAgICB2YXIgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc05hTihEYXRlLnBhcnNlKG9iamVjdCkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGF0YVRhYmxlXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNEYXRhVGFibGVcbiAqL1xuZXhwb3J0cy5pc0RhdGFUYWJsZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiAoZ29vZ2xlKSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAoZ29vZ2xlLnZpc3VhbGl6YXRpb24pICYmXG4gICAgICAoZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGF0YVRhYmxlKSAmJlxuICAgICAgKG9iamVjdCBpbnN0YW5jZW9mIGdvb2dsZS52aXN1YWxpemF0aW9uLkRhdGFUYWJsZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHNlbWkgVVVJRFxuICogc291cmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDUwNzQvMTI2Mjc1M1xuICogQHJldHVybiB7U3RyaW5nfSB1dWlkXG4gKi9cbmV4cG9ydHMucmFuZG9tVVVJRCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgUzQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiAweDEwMDAwIC8qIDY1NTM2ICovXG4gICAgKS50b1N0cmluZygxNik7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICAgIFM0KCkgKyBTNCgpICsgJy0nICtcbiAgICAgICAgICBTNCgpICsgJy0nICtcbiAgICAgICAgICBTNCgpICsgJy0nICtcbiAgICAgICAgICBTNCgpICsgJy0nICtcbiAgICAgICAgICBTNCgpICsgUzQoKSArIFM0KClcbiAgICAgICk7XG59O1xuXG4vKipcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0gey4uLiBPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvdGhlcikge1xuICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGFbcHJvcF0gPSBvdGhlcltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7Li4uIE9iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlRXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzLCBhLCBiKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IHdpdGggcHJvcGVydHkgbmFtZXMgZXhwZWN0ZWQgYXMgZmlyc3QgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG90aGVyID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1twXTtcbiAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBhW3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHByb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHsuLi4gT2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqL1xuZXhwb3J0cy5zZWxlY3RpdmVEZWVwRXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzLCBhLCBiKSB7XG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBBcnJheXMgdG8gZGVlcEV4dGVuZFxuICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kJyk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1twXTtcbiAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7Li4uIE9iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlTm90RGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcywgYSwgYikge1xuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICB9XG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBpZiAocHJvcHMuaW5kZXhPZihwcm9wKSA9PSAtMSkge1xuICAgICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIERlZXAgZXh0ZW5kIGFuIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5kZWVwRXh0ZW5kID0gZnVuY3Rpb24oYSwgYikge1xuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICB9XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBleHBvcnRzLmRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYWxsIGVsZW1lbnRzIGluIHR3byBhcnJheXMgYXJlIGVxdWFsLlxuICogQHBhcmFtIHtBcnJheX0gYVxuICogQHBhcmFtIHtBcnJheX0gYlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGJvdGggYXJyYXlzIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFuZCBzYW1lXG4gKiAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5cbiAqL1xuZXhwb3J0cy5lcXVhbEFycmF5ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgdG8gYW5vdGhlciB0eXBlXG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBOdW1iZXIgfCBTdHJpbmcgfCBEYXRlIHwgTW9tZW50IHwgTnVsbCB8IHVuZGVmaW5lZH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZyB8IHVuZGVmaW5lZH0gdHlwZSAgIE5hbWUgb2YgdGhlIHR5cGUuIEF2YWlsYWJsZSB0eXBlczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Jvb2xlYW4nLCAnTnVtYmVyJywgJ1N0cmluZycsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdEYXRlJywgJ01vbWVudCcsIElTT0RhdGUnLCAnQVNQRGF0ZScuXG4gKiBAcmV0dXJuIHsqfSBvYmplY3RcbiAqIEB0aHJvd3MgRXJyb3JcbiAqL1xuZXhwb3J0cy5jb252ZXJ0ID0gZnVuY3Rpb24ob2JqZWN0LCB0eXBlKSB7XG4gIHZhciBtYXRjaDtcblxuICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghdHlwZSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgaWYgKCEodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSAmJiAhKHR5cGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgIHJldHVybiBCb29sZWFuKG9iamVjdCk7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ051bWJlcic6XG4gICAgICByZXR1cm4gTnVtYmVyKG9iamVjdC52YWx1ZU9mKCkpO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgcmV0dXJuIFN0cmluZyhvYmplY3QpO1xuXG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIobWF0Y2hbMV0pKTsgLy8gcGFyc2UgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpLnRvRGF0ZSgpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgK1xuICAgICAgICAgICAgICAgICcgdG8gdHlwZSBEYXRlJyk7XG4gICAgICB9XG5cbiAgICBjYXNlICdNb21lbnQnOlxuICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgIHJldHVybiBtb21lbnQoTnVtYmVyKG1hdGNoWzFdKSk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICtcbiAgICAgICAgICAgICAgICAnIHRvIHR5cGUgRGF0ZScpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnSVNPRGF0ZSc6XG4gICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChtb21lbnQuaXNNb21lbnQob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0LnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAvLyBvYmplY3QgaXMgYW4gQVNQIGRhdGVcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKG1hdGNoWzFdKSkudG9JU09TdHJpbmcoKTsgLy8gcGFyc2UgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdCkudG9JU09TdHJpbmcoKTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICtcbiAgICAgICAgICAgICAgICAnIHRvIHR5cGUgSVNPRGF0ZScpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnQVNQRGF0ZSc6XG4gICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiAnL0RhdGUoJyArIG9iamVjdCArICcpLyc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnL0RhdGUoJyArIG9iamVjdC52YWx1ZU9mKCkgKyAnKS8nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAvLyBvYmplY3QgaXMgYW4gQVNQIGRhdGVcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpLnZhbHVlT2YoKTsgLy8gcGFyc2UgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShvYmplY3QpLnZhbHVlT2YoKTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcvRGF0ZSgnICsgdmFsdWUgKyAnKS8nO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgK1xuICAgICAgICAgICAgICAgICcgdG8gdHlwZSBBU1BEYXRlJyk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICB9XG59O1xuXG4vLyBwYXJzZSBBU1AuTmV0IERhdGUgcGF0dGVybixcbi8vIGZvciBleGFtcGxlICcvRGF0ZSgxMTk4OTA4NzE3MDU2KS8nIG9yICcvRGF0ZSgxMTk4OTA4NzE3MDU2LTA3MDApLydcbi8vIGNvZGUgZnJvbSBodHRwOi8vbW9tZW50anMuY29tL1xudmFyIEFTUERhdGVSZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIGFuIG9iamVjdCwgZm9yIGV4YW1wbGUgZXhwb3J0cy5nZXRUeXBlKFtdKSByZXR1cm5zICdBcnJheSdcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuZXhwb3J0cy5nZXRUeXBlID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIG9iamVjdDtcblxuICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgcmV0dXJuICdTdHJpbmcnO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHJldHVybiAnQXJyYXknO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuICdEYXRlJztcbiAgICB9XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gJ051bWJlcic7XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gJ1N0cmluZyc7XG4gIH1cblxuICByZXR1cm4gdHlwZTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIGxlZnQgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtICAgICAgICBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdlxuICogQHJldHVybiB7bnVtYmVyfSBsZWZ0ICAgICAgICBUaGUgYWJzb2x1dGUgbGVmdCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGJyb3dzZXIgcGFnZS5cbiAqL1xuZXhwb3J0cy5nZXRBYnNvbHV0ZUxlZnQgPSBmdW5jdGlvbihlbGVtKSB7XG4gIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSB0b3AgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtICAgICAgICBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdlxuICogQHJldHVybiB7bnVtYmVyfSB0b3AgICAgICAgIFRoZSBhYnNvbHV0ZSB0b3AgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBicm93c2VyIHBhZ2UuXG4gKi9cbmV4cG9ydHMuZ2V0QWJzb2x1dGVUb3AgPSBmdW5jdGlvbihlbGVtKSB7XG4gIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldDtcbn07XG5cbi8qKlxuICogYWRkIGEgY2xhc3NOYW1lIHRvIHRoZSBnaXZlbiBlbGVtZW50cyBzdHlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKi9cbmV4cG9ydHMuYWRkQ2xhc3NOYW1lID0gZnVuY3Rpb24oZWxlbSwgY2xhc3NOYW1lKSB7XG4gIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID09IC0xKSB7XG4gICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7IC8vIGFkZCB0aGUgY2xhc3MgdG8gdGhlIGFycmF5XG4gICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBhZGQgYSBjbGFzc05hbWUgdG8gdGhlIGdpdmVuIGVsZW1lbnRzIHN0eWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqL1xuZXhwb3J0cy5yZW1vdmVDbGFzc05hbWUgPSBmdW5jdGlvbihlbGVtLCBjbGFzc05hbWUpIHtcbiAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcbiAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpOyAvLyByZW1vdmUgdGhlIGNsYXNzIGZyb20gdGhlIGFycmF5XG4gICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgZWFjaCBtZXRob2QgZm9yIGJvdGggYXJyYXlzIGFuZCBvYmplY3RzLlxuICogSW4gY2FzZSBvZiBhbiBhcnJheSwgdGhlIGJ1aWx0LWluIEFycmF5LmZvckVhY2goKSBpcyBhcHBsaWVkLlxuICogSW4gY2FzZSBvZiBhbiBPYmplY3QsIHRoZSBtZXRob2QgbG9vcHMgb3ZlciBhbGwgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3QgfCBBcnJheX0gb2JqZWN0ICAgQW4gT2JqZWN0IG9yIEFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICBDYWxsYmFjayBtZXRob2QsIGNhbGxlZCBmb3IgZWFjaCBpdGVtIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb2JqZWN0IG9yIGFycmF5IHdpdGggdGhyZWUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgb2JqZWN0KVxuICovXG5leHBvcnRzLmZvckVhY2ggPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gIHZhciBpLFxuICAgICAgbGVuO1xuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAvLyBhcnJheVxuICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FsbGJhY2sob2JqZWN0W2ldLCBpLCBvYmplY3QpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBvYmplY3RcbiAgICBmb3IgKGkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtpXSwgaSwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgaW50byBhbiBhcnJheTogYWxsIG9iamVjdHMgcHJvcGVydGllcyBhcmUgcHV0IGludG8gdGhlXG4gKiBhcnJheS4gVGhlIHJlc3VsdGluZyBhcnJheSBpcyB1bm9yZGVyZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICovXG5leHBvcnRzLnRvQXJyYXkgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIGFycmF5ID0gW107XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApKSBhcnJheS5wdXNoKG9iamVjdFtwcm9wXSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogVXBkYXRlIGEgcHJvcGVydHkgaW4gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cbmV4cG9ydHMudXBkYXRlUHJvcGVydHkgPSBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKG9iamVjdFtrZXldICE9PSB2YWx1ZSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZCBhbmQgZXZlbnQgbGlzdGVuZXIuIFdvcmtzIGZvciBhbGwgYnJvd3NlcnNcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgIGVsZW1lbnQgICAgQW4gaHRtbCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICBhY3Rpb24gICAgIFRoZSBhY3Rpb24sIGZvciBleGFtcGxlIFwiY2xpY2tcIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCB0aGUgcHJlZml4IFwib25cIlxuICogQHBhcmFtIHtmdW5jdGlvbn0gICAgbGlzdGVuZXIgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFt1c2VDYXB0dXJlXVxuICovXG5leHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihlbGVtZW50LCBhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgdXNlQ2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gXCJtb3VzZXdoZWVsXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+PSAwKSB7XG4gICAgICBhY3Rpb24gPSBcIkRPTU1vdXNlU2Nyb2xsXCI7ICAvLyBGb3IgRmlyZWZveFxuICAgIH1cblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGFjdGlvbiwgbGlzdGVuZXIpOyAgLy8gSUUgYnJvd3NlcnNcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9ICAgICBlbGVtZW50ICAgICAgICAgQW4gaHRtbCBkb20gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgYWN0aW9uICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCwgZm9yIGV4YW1wbGUgXCJtb3VzZWRvd25cIlxuICogQHBhcmFtIHtmdW5jdGlvbn0gICAgbGlzdGVuZXIgICAgICAgIFRoZSBsaXN0ZW5lciBmdW5jdGlvblxuICogQHBhcmFtIHtib29sZWFufSAgICAgW3VzZUNhcHR1cmVdXG4gKi9cbmV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIC8vIG5vbi1JRSBicm93c2Vyc1xuICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpXG4gICAgICB1c2VDYXB0dXJlID0gZmFsc2U7XG5cbiAgICBpZiAoYWN0aW9uID09PSBcIm1vdXNld2hlZWxcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID49IDApIHtcbiAgICAgIGFjdGlvbiA9IFwiRE9NTW91c2VTY3JvbGxcIjsgIC8vIEZvciBGaXJlZm94XG4gICAgfVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIC8vIElFIGJyb3dzZXJzXG4gICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyBhY3Rpb24sIGxpc3RlbmVyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYW5jZWxzIHRoZSBldmVudCBpZiBpdCBpcyBjYW5jZWxhYmxlLCB3aXRob3V0IHN0b3BwaW5nIGZ1cnRoZXIgcHJvcGFnYXRpb24gb2YgdGhlIGV2ZW50LlxuICovXG5leHBvcnRzLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghZXZlbnQpXG4gICAgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG5cbiAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgIC8vIG5vbi1JRSBicm93c2Vyc1xuICB9XG4gIGVsc2Uge1xuICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7ICAvLyBJRSBicm93c2Vyc1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBIVE1MIGVsZW1lbnQgd2hpY2ggaXMgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtFbGVtZW50fSB0YXJnZXQgZWxlbWVudFxuICovXG5leHBvcnRzLmdldFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIC8vIGNvZGUgZnJvbSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgaWYgKCFldmVudCkge1xuICAgIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuICB9XG5cbiAgdmFyIHRhcmdldDtcblxuICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICB9XG4gIGVsc2UgaWYgKGV2ZW50LnNyY0VsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSBldmVudC5zcmNFbGVtZW50O1xuICB9XG5cbiAgaWYgKHRhcmdldC5ub2RlVHlwZSAhPSB1bmRlZmluZWQgJiYgdGFyZ2V0Lm5vZGVUeXBlID09IDMpIHtcbiAgICAvLyBkZWZlYXQgU2FmYXJpIGJ1Z1xuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydHMub3B0aW9uID0ge307XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBib29sZWFuXG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtCb29sZWFufSBib29sXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgbnVtYmVyXG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge051bWJlcn0gbnVtYmVyXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKSB8fCBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nIHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0clxuICovXG5leHBvcnRzLm9wdGlvbi5hc1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBzaXplIG9yIGxvY2F0aW9uIGludG8gYSBzdHJpbmcgd2l0aCBwaXhlbHMgb3IgYSBwZXJjZW50YWdlXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlciB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IFtkZWZhdWx0VmFsdWVdXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzaXplXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzU2l6ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIGlmIChleHBvcnRzLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBlbHNlIGlmIChleHBvcnRzLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtkZWZhdWx0VmFsdWVdXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfSBkb21cbiAqL1xuZXhwb3J0cy5vcHRpb24uYXNFbGVtZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlIHx8IGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xufTtcblxuXG5cbmV4cG9ydHMuR2l2ZURlYyA9IGZ1bmN0aW9uKEhleCkge1xuICB2YXIgVmFsdWU7XG5cbiAgaWYgKEhleCA9PSBcIkFcIilcbiAgICBWYWx1ZSA9IDEwO1xuICBlbHNlIGlmIChIZXggPT0gXCJCXCIpXG4gICAgVmFsdWUgPSAxMTtcbiAgZWxzZSBpZiAoSGV4ID09IFwiQ1wiKVxuICAgIFZhbHVlID0gMTI7XG4gIGVsc2UgaWYgKEhleCA9PSBcIkRcIilcbiAgICBWYWx1ZSA9IDEzO1xuICBlbHNlIGlmIChIZXggPT0gXCJFXCIpXG4gICAgVmFsdWUgPSAxNDtcbiAgZWxzZSBpZiAoSGV4ID09IFwiRlwiKVxuICAgIFZhbHVlID0gMTU7XG4gIGVsc2VcbiAgICBWYWx1ZSA9IGV2YWwoSGV4KTtcblxuICByZXR1cm4gVmFsdWU7XG59O1xuXG5leHBvcnRzLkdpdmVIZXggPSBmdW5jdGlvbihEZWMpIHtcbiAgdmFyIFZhbHVlO1xuXG4gIGlmKERlYyA9PSAxMClcbiAgICBWYWx1ZSA9IFwiQVwiO1xuICBlbHNlIGlmIChEZWMgPT0gMTEpXG4gICAgVmFsdWUgPSBcIkJcIjtcbiAgZWxzZSBpZiAoRGVjID09IDEyKVxuICAgIFZhbHVlID0gXCJDXCI7XG4gIGVsc2UgaWYgKERlYyA9PSAxMylcbiAgICBWYWx1ZSA9IFwiRFwiO1xuICBlbHNlIGlmIChEZWMgPT0gMTQpXG4gICAgVmFsdWUgPSBcIkVcIjtcbiAgZWxzZSBpZiAoRGVjID09IDE1KVxuICAgIFZhbHVlID0gXCJGXCI7XG4gIGVsc2VcbiAgICBWYWx1ZSA9IFwiXCIgKyBEZWM7XG5cbiAgcmV0dXJuIFZhbHVlO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGNvbG9yIHByb3BlcnR5IGludG8gYW4gb2JqZWN0IHdpdGggYm9yZGVyLCBiYWNrZ3JvdW5kLCBhbmRcbiAqIGhpZ2hsaWdodCBjb2xvcnNcbiAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nfSBjb2xvclxuICogQHJldHVybiB7T2JqZWN0fSBjb2xvck9iamVjdFxuICovXG5leHBvcnRzLnBhcnNlQ29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xuICB2YXIgYztcbiAgaWYgKGV4cG9ydHMuaXNTdHJpbmcoY29sb3IpKSB7XG4gICAgaWYgKGV4cG9ydHMuaXNWYWxpZFJHQihjb2xvcikpIHtcbiAgICAgIHZhciByZ2IgPSBjb2xvci5zdWJzdHIoNCkuc3Vic3RyKDAsY29sb3IubGVuZ3RoLTUpLnNwbGl0KCcsJyk7XG4gICAgICBjb2xvciA9IGV4cG9ydHMuUkdCVG9IZXgocmdiWzBdLHJnYlsxXSxyZ2JbMl0pO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5pc1ZhbGlkSGV4KGNvbG9yKSkge1xuICAgICAgdmFyIGhzdiA9IGV4cG9ydHMuaGV4VG9IU1YoY29sb3IpO1xuICAgICAgdmFyIGxpZ2h0ZXJDb2xvckhTViA9IHtoOmhzdi5oLHM6aHN2LnMgKiAwLjQ1LHY6TWF0aC5taW4oMSxoc3YudiAqIDEuMDUpfTtcbiAgICAgIHZhciBkYXJrZXJDb2xvckhTViAgPSB7aDpoc3YuaCxzOk1hdGgubWluKDEsaHN2LnYgKiAxLjI1KSx2Omhzdi52KjAuNn07XG4gICAgICB2YXIgZGFya2VyQ29sb3JIZXggID0gZXhwb3J0cy5IU1ZUb0hleChkYXJrZXJDb2xvckhTVi5oICxkYXJrZXJDb2xvckhTVi5oICxkYXJrZXJDb2xvckhTVi52KTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIZXggPSBleHBvcnRzLkhTVlRvSGV4KGxpZ2h0ZXJDb2xvckhTVi5oLGxpZ2h0ZXJDb2xvckhTVi5zLGxpZ2h0ZXJDb2xvckhTVi52KTtcblxuICAgICAgYyA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgIGJvcmRlcjpkYXJrZXJDb2xvckhleCxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYmFja2dyb3VuZDpsaWdodGVyQ29sb3JIZXgsXG4gICAgICAgICAgYm9yZGVyOmRhcmtlckNvbG9ySGV4XG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDpsaWdodGVyQ29sb3JIZXgsXG4gICAgICAgICAgYm9yZGVyOmRhcmtlckNvbG9ySGV4XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYyA9IHtcbiAgICAgICAgYmFja2dyb3VuZDpjb2xvcixcbiAgICAgICAgYm9yZGVyOmNvbG9yLFxuICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOmNvbG9yLFxuICAgICAgICAgIGJvcmRlcjpjb2xvclxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJhY2tncm91bmQ6Y29sb3IsXG4gICAgICAgICAgYm9yZGVyOmNvbG9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGMgPSB7fTtcbiAgICBjLmJhY2tncm91bmQgPSBjb2xvci5iYWNrZ3JvdW5kIHx8ICd3aGl0ZSc7XG4gICAgYy5ib3JkZXIgPSBjb2xvci5ib3JkZXIgfHwgYy5iYWNrZ3JvdW5kO1xuXG4gICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcoY29sb3IuaGlnaGxpZ2h0KSkge1xuICAgICAgYy5oaWdobGlnaHQgPSB7XG4gICAgICAgIGJvcmRlcjogY29sb3IuaGlnaGxpZ2h0LFxuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvci5oaWdobGlnaHRcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjLmhpZ2hsaWdodCA9IHt9O1xuICAgICAgYy5oaWdobGlnaHQuYmFja2dyb3VuZCA9IGNvbG9yLmhpZ2hsaWdodCAmJiBjb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCB8fCBjLmJhY2tncm91bmQ7XG4gICAgICBjLmhpZ2hsaWdodC5ib3JkZXIgPSBjb2xvci5oaWdobGlnaHQgJiYgY29sb3IuaGlnaGxpZ2h0LmJvcmRlciB8fCBjLmJvcmRlcjtcbiAgICB9XG5cbiAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhjb2xvci5ob3ZlcikpIHtcbiAgICAgIGMuaG92ZXIgPSB7XG4gICAgICAgIGJvcmRlcjogY29sb3IuaG92ZXIsXG4gICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLmhvdmVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYy5ob3ZlciA9IHt9O1xuICAgICAgYy5ob3Zlci5iYWNrZ3JvdW5kID0gY29sb3IuaG92ZXIgJiYgY29sb3IuaG92ZXIuYmFja2dyb3VuZCB8fCBjLmJhY2tncm91bmQ7XG4gICAgICBjLmhvdmVyLmJvcmRlciA9IGNvbG9yLmhvdmVyICYmIGNvbG9yLmhvdmVyLmJvcmRlciB8fCBjLmJvcmRlcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogaHR0cDovL3d3dy55ZWxsb3dwaXBlLmNvbS95aXMvdG9vbHMvaGV4LXRvLXJnYi9jb2xvci1jb252ZXJ0ZXIucGhwXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhleFxuICogQHJldHVybnMge3tyOiAqLCBnOiAqLCBiOiAqfX1cbiAqL1xuZXhwb3J0cy5oZXhUb1JHQiA9IGZ1bmN0aW9uKGhleCkge1xuICBoZXggPSBoZXgucmVwbGFjZShcIiNcIixcIlwiKS50b1VwcGVyQ2FzZSgpO1xuXG4gIHZhciBhID0gZXhwb3J0cy5HaXZlRGVjKGhleC5zdWJzdHJpbmcoMCwgMSkpO1xuICB2YXIgYiA9IGV4cG9ydHMuR2l2ZURlYyhoZXguc3Vic3RyaW5nKDEsIDIpKTtcbiAgdmFyIGMgPSBleHBvcnRzLkdpdmVEZWMoaGV4LnN1YnN0cmluZygyLCAzKSk7XG4gIHZhciBkID0gZXhwb3J0cy5HaXZlRGVjKGhleC5zdWJzdHJpbmcoMywgNCkpO1xuICB2YXIgZSA9IGV4cG9ydHMuR2l2ZURlYyhoZXguc3Vic3RyaW5nKDQsIDUpKTtcbiAgdmFyIGYgPSBleHBvcnRzLkdpdmVEZWMoaGV4LnN1YnN0cmluZyg1LCA2KSk7XG5cbiAgdmFyIHIgPSAoYSAqIDE2KSArIGI7XG4gIHZhciBnID0gKGMgKiAxNikgKyBkO1xuICB2YXIgYiA9IChlICogMTYpICsgZjtcblxuICByZXR1cm4ge3I6cixnOmcsYjpifTtcbn07XG5cbmV4cG9ydHMuUkdCVG9IZXggPSBmdW5jdGlvbihyZWQsZ3JlZW4sYmx1ZSkge1xuICB2YXIgYSA9IGV4cG9ydHMuR2l2ZUhleChNYXRoLmZsb29yKHJlZCAvIDE2KSk7XG4gIHZhciBiID0gZXhwb3J0cy5HaXZlSGV4KHJlZCAlIDE2KTtcbiAgdmFyIGMgPSBleHBvcnRzLkdpdmVIZXgoTWF0aC5mbG9vcihncmVlbiAvIDE2KSk7XG4gIHZhciBkID0gZXhwb3J0cy5HaXZlSGV4KGdyZWVuICUgMTYpO1xuICB2YXIgZSA9IGV4cG9ydHMuR2l2ZUhleChNYXRoLmZsb29yKGJsdWUgLyAxNikpO1xuICB2YXIgZiA9IGV4cG9ydHMuR2l2ZUhleChibHVlICUgMTYpO1xuXG4gIHZhciBoZXggPSBhICsgYiArIGMgKyBkICsgZSArIGY7XG4gIHJldHVybiBcIiNcIiArIGhleDtcbn07XG5cblxuLyoqXG4gKiBodHRwOi8vd3d3LmphdmFzY3JpcHRlci5uZXQvZmFxL3JnYjJoc3YuaHRtXG4gKlxuICogQHBhcmFtIHJlZFxuICogQHBhcmFtIGdyZWVuXG4gKiBAcGFyYW0gYmx1ZVxuICogQHJldHVybnMgeyp9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0cy5SR0JUb0hTViA9IGZ1bmN0aW9uKHJlZCxncmVlbixibHVlKSB7XG4gIHJlZD1yZWQvMjU1OyBncmVlbj1ncmVlbi8yNTU7IGJsdWU9Ymx1ZS8yNTU7XG4gIHZhciBtaW5SR0IgPSBNYXRoLm1pbihyZWQsTWF0aC5taW4oZ3JlZW4sYmx1ZSkpO1xuICB2YXIgbWF4UkdCID0gTWF0aC5tYXgocmVkLE1hdGgubWF4KGdyZWVuLGJsdWUpKTtcblxuICAvLyBCbGFjay1ncmF5LXdoaXRlXG4gIGlmIChtaW5SR0IgPT0gbWF4UkdCKSB7XG4gICAgcmV0dXJuIHtoOjAsczowLHY6bWluUkdCfTtcbiAgfVxuXG4gIC8vIENvbG9ycyBvdGhlciB0aGFuIGJsYWNrLWdyYXktd2hpdGU6XG4gIHZhciBkID0gKHJlZD09bWluUkdCKSA/IGdyZWVuLWJsdWUgOiAoKGJsdWU9PW1pblJHQikgPyByZWQtZ3JlZW4gOiBibHVlLXJlZCk7XG4gIHZhciBoID0gKHJlZD09bWluUkdCKSA/IDMgOiAoKGJsdWU9PW1pblJHQikgPyAxIDogNSk7XG4gIHZhciBodWUgPSA2MCooaCAtIGQvKG1heFJHQiAtIG1pblJHQikpLzM2MDtcbiAgdmFyIHNhdHVyYXRpb24gPSAobWF4UkdCIC0gbWluUkdCKS9tYXhSR0I7XG4gIHZhciB2YWx1ZSA9IG1heFJHQjtcbiAgcmV0dXJuIHtoOmh1ZSxzOnNhdHVyYXRpb24sdjp2YWx1ZX07XG59O1xuXG5cbi8qKlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWppamFja3Nvbi81MzExMjU2XG4gKiBAcGFyYW0gaFxuICogQHBhcmFtIHNcbiAqIEBwYXJhbSB2XG4gKiBAcmV0dXJucyB7e3I6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXJ9fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydHMuSFNWVG9SR0IgPSBmdW5jdGlvbihoLCBzLCB2KSB7XG4gIHZhciByLCBnLCBiO1xuXG4gIHZhciBpID0gTWF0aC5mbG9vcihoICogNik7XG4gIHZhciBmID0gaCAqIDYgLSBpO1xuICB2YXIgcCA9IHYgKiAoMSAtIHMpO1xuICB2YXIgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgdmFyIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgc3dpdGNoIChpICUgNikge1xuICAgIGNhc2UgMDogciA9IHYsIGcgPSB0LCBiID0gcDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gcSwgZyA9IHYsIGIgPSBwOyBicmVhaztcbiAgICBjYXNlIDI6IHIgPSBwLCBnID0gdiwgYiA9IHQ7IGJyZWFrO1xuICAgIGNhc2UgMzogciA9IHAsIGcgPSBxLCBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gdCwgZyA9IHAsIGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDU6IHIgPSB2LCBnID0gcCwgYiA9IHE7IGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHtyOk1hdGguZmxvb3IociAqIDI1NSksIGc6TWF0aC5mbG9vcihnICogMjU1KSwgYjpNYXRoLmZsb29yKGIgKiAyNTUpIH07XG59O1xuXG5leHBvcnRzLkhTVlRvSGV4ID0gZnVuY3Rpb24oaCwgcywgdikge1xuICB2YXIgcmdiID0gZXhwb3J0cy5IU1ZUb1JHQihoLCBzLCB2KTtcbiAgcmV0dXJuIGV4cG9ydHMuUkdCVG9IZXgocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59O1xuXG5leHBvcnRzLmhleFRvSFNWID0gZnVuY3Rpb24oaGV4KSB7XG4gIHZhciByZ2IgPSBleHBvcnRzLmhleFRvUkdCKGhleCk7XG4gIHJldHVybiBleHBvcnRzLlJHQlRvSFNWKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xufTtcblxuZXhwb3J0cy5pc1ZhbGlkSGV4ID0gZnVuY3Rpb24oaGV4KSB7XG4gIHZhciBpc09rID0gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QoaGV4KTtcbiAgcmV0dXJuIGlzT2s7XG59O1xuXG5leHBvcnRzLmlzVmFsaWRSR0IgPSBmdW5jdGlvbihyZ2IpIHtcbiAgcmdiID0gcmdiLnJlcGxhY2UoXCIgXCIsXCJcIik7XG4gIHZhciBpc09rID0gL3JnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpL2kudGVzdChyZ2IpO1xuICByZXR1cm4gaXNPaztcbn1cblxuLyoqXG4gKiBUaGlzIHJlY3Vyc2l2ZWx5IHJlZGlyZWN0cyB0aGUgcHJvdG90eXBlIG9mIEpTT04gb2JqZWN0cyB0byB0aGUgcmVmZXJlbmNlT2JqZWN0XG4gKiBUaGlzIGlzIHVzZWQgZm9yIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gcmVmZXJlbmNlT2JqZWN0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5zZWxlY3RpdmVCcmlkZ2VPYmplY3QgPSBmdW5jdGlvbihmaWVsZHMsIHJlZmVyZW5jZU9iamVjdCkge1xuICBpZiAodHlwZW9mIHJlZmVyZW5jZU9iamVjdCA9PSBcIm9iamVjdFwiKSB7XG4gICAgdmFyIG9iamVjdFRvID0gT2JqZWN0LmNyZWF0ZShyZWZlcmVuY2VPYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVmZXJlbmNlT2JqZWN0Lmhhc093blByb3BlcnR5KGZpZWxkc1tpXSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2VPYmplY3RbZmllbGRzW2ldXSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgb2JqZWN0VG9bZmllbGRzW2ldXSA9IGV4cG9ydHMuYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdFtmaWVsZHNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0VG87XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdFxuICogVGhpcyBpcyB1c2VkIGZvciBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHJlZmVyZW5jZU9iamVjdFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuYnJpZGdlT2JqZWN0ID0gZnVuY3Rpb24ocmVmZXJlbmNlT2JqZWN0KSB7XG4gIGlmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0ID09IFwib2JqZWN0XCIpIHtcbiAgICB2YXIgb2JqZWN0VG8gPSBPYmplY3QuY3JlYXRlKHJlZmVyZW5jZU9iamVjdCk7XG4gICAgZm9yICh2YXIgaSBpbiByZWZlcmVuY2VPYmplY3QpIHtcbiAgICAgIGlmIChyZWZlcmVuY2VPYmplY3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2VPYmplY3RbaV0gPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG9iamVjdFRvW2ldID0gZXhwb3J0cy5icmlkZ2VPYmplY3QocmVmZXJlbmNlT2JqZWN0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0VG87XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiB0aGlzIGlzIHVzZWQgdG8gc2V0IHRoZSBvcHRpb25zIG9mIHN1Ym9iamVjdHMgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LiBBIHJlcXVpcmVtZW50IG9mIHRoZXNlIHN1Ym9iamVjdHNcbiAqIGlzIHRoYXQgdGhleSBoYXZlIGFuICdlbmFibGVkJyBlbGVtZW50IHdoaWNoIGlzIG9wdGlvbmFsIGZvciB0aGUgdXNlciBidXQgbWFuZGF0b3J5IGZvciB0aGUgcHJvZ3JhbS5cbiAqXG4gKiBAcGFyYW0gW29iamVjdF0gbWVyZ2VUYXJnZXQgfCB0aGlzIGlzIGVpdGhlciB0aGlzLm9wdGlvbnMgb3IgdGhlIG9wdGlvbnMgdXNlZCBmb3IgdGhlIGdyb3Vwcy5cbiAqIEBwYXJhbSBbb2JqZWN0XSBvcHRpb25zICAgICB8IG9wdGlvbnNcbiAqIEBwYXJhbSBbU3RyaW5nXSBvcHRpb24gICAgICB8IHRoaXMgaXMgdGhlIG9wdGlvbiBrZXkgaW4gdGhlIG9wdGlvbnMgYXJndW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG1lcmdlVGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pIHtcbiAgaWYgKG9wdGlvbnNbb3B0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zW29wdGlvbl0gPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSBvcHRpb25zW29wdGlvbl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgIGZvciAocHJvcCBpbiBvcHRpb25zW29wdGlvbl0pIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl1bcHJvcF0gPSBvcHRpb25zW29wdGlvbl1bcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIHRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIG9wdGlvbnMgb2Ygc3Vib2JqZWN0cyBpbiB0aGUgb3B0aW9ucyBvYmplY3QuIEEgcmVxdWlyZW1lbnQgb2YgdGhlc2Ugc3Vib2JqZWN0c1xuICogaXMgdGhhdCB0aGV5IGhhdmUgYW4gJ2VuYWJsZWQnIGVsZW1lbnQgd2hpY2ggaXMgb3B0aW9uYWwgZm9yIHRoZSB1c2VyIGJ1dCBtYW5kYXRvcnkgZm9yIHRoZSBwcm9ncmFtLlxuICpcbiAqIEBwYXJhbSBbb2JqZWN0XSBtZXJnZVRhcmdldCB8IHRoaXMgaXMgZWl0aGVyIHRoaXMub3B0aW9ucyBvciB0aGUgb3B0aW9ucyB1c2VkIGZvciB0aGUgZ3JvdXBzLlxuICogQHBhcmFtIFtvYmplY3RdIG9wdGlvbnMgICAgIHwgb3B0aW9uc1xuICogQHBhcmFtIFtTdHJpbmddIG9wdGlvbiAgICAgIHwgdGhpcyBpcyB0aGUgb3B0aW9uIGtleSBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAobWVyZ2VUYXJnZXQsIG9wdGlvbnMsIG9wdGlvbikge1xuICBpZiAob3B0aW9uc1tvcHRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNbb3B0aW9uXSA9PSAnYm9vbGVhbicpIHtcbiAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0uZW5hYmxlZCA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgZm9yIChwcm9wIGluIG9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgICBpZiAob3B0aW9uc1tvcHRpb25dLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXVtwcm9wXSA9IG9wdGlvbnNbb3B0aW9uXVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBhIGJpbmFyeSBzZWFyY2ggZm9yIGEgdmlzaWJsZSBpdGVtLiBUaGUgdXNlciBjYW4gc2VsZWN0IGVpdGhlciB0aGUgdGhpcy5vcmRlcmVkSXRlbXMuYnlTdGFydCBvciAuYnlFbmRcbiAqIGFycmF5cy4gVGhpcyBpcyBkb25lIGJ5IGdpdmluZyBhIGJvb2xlYW4gdmFsdWUgdHJ1ZSBpZiB5b3Ugd2FudCB0byB1c2UgdGhlIGJ5RW5kLlxuICogVGhpcyBpcyBkb25lIHRvIGJlIGFibGUgdG8gc2VsZWN0IHRoZSBjb3JyZWN0IGlmIHN0YXRlbWVudCAod2UgZG8gbm90IHdhbnQgdG8gY2hlY2sgaWYgYW4gaXRlbSBpcyB2aXNpYmxlLCB3ZSB3YW50IHRvIGNoZWNrXG4gKiBpZiB0aGUgdGltZSB3ZSBzZWxlY3RlZCAoc3RhcnQgb3IgZW5kKSBpcyB3aXRoaW4gdGhlIGN1cnJlbnQgcmFuZ2UpLlxuICpcbiAqIFRoZSB0cmljayBpcyB0aGF0IGV2ZXJ5IGludGVydmFsIGhhcyB0byBlaXRoZXIgZW50ZXIgdGhlIHNjcmVlbiBhdCB0aGUgaW5pdGlhbCBsb2FkIG9yIGJ5IGRyYWdnaW5nLiBUaGUgY2FzZSBvZiB0aGUgUmFuZ2VJdGVtIHRoYXQgaXNcbiAqIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGN1cnJlbnQgcmFuZ2UgaXMgaGFuZGxlZCBieSBzaW1wbHkgY2hlY2tpbmcgaWYgaXQgd2FzIGluIHZpZXcgYmVmb3JlIGFuZCBpZiBpdCBpcyBhZ2Fpbi4gRm9yIGFsbCB0aGUgcmVzdCxcbiAqIGVpdGhlciB0aGUgc3RhcnQgT1IgZW5kIHRpbWUgaGFzIHRvIGJlIGluIHRoZSByYW5nZS5cbiAqXG4gKiBAcGFyYW0ge0l0ZW1bXX0gb3JkZXJlZEl0ZW1zICBJdGVtcyBvcmRlcmVkIGJ5IHN0YXJ0XG4gKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZDJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmFyeVNlYXJjaCA9IGZ1bmN0aW9uKG9yZGVyZWRJdGVtcywgcmFuZ2UsIGZpZWxkLCBmaWVsZDIpIHtcbiAgdmFyIGFycmF5ID0gb3JkZXJlZEl0ZW1zO1xuXG4gIHZhciBtYXhJdGVyYXRpb25zID0gMTAwMDA7XG4gIHZhciBpdGVyYXRpb24gPSAwO1xuICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgdmFyIGxvdyA9IDA7XG4gIHZhciBoaWdoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbmV3TG93ID0gbG93O1xuICB2YXIgbmV3SGlnaCA9IGhpZ2g7XG4gIHZhciBndWVzcyA9IE1hdGguZmxvb3IoMC41KihoaWdoK2xvdykpO1xuICB2YXIgdmFsdWU7XG5cbiAgaWYgKGhpZ2ggPT0gMCkge1xuICAgIGd1ZXNzID0gLTE7XG4gIH1cbiAgZWxzZSBpZiAoaGlnaCA9PSAxKSB7XG4gICAgaWYgKGFycmF5W2d1ZXNzXS5pc1Zpc2libGUocmFuZ2UpKSB7XG4gICAgICBndWVzcyA9ICAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGd1ZXNzID0gLTE7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGhpZ2ggLT0gMTtcblxuICAgIHdoaWxlIChmb3VuZCA9PSBmYWxzZSAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICB2YWx1ZSA9IGZpZWxkMiA9PT0gdW5kZWZpbmVkID8gYXJyYXlbZ3Vlc3NdW2ZpZWxkXSA6IGFycmF5W2d1ZXNzXVtmaWVsZF1bZmllbGQyXTtcblxuICAgICAgaWYgKGFycmF5W2d1ZXNzXS5pc1Zpc2libGUocmFuZ2UpKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodmFsdWUgPCByYW5nZS5zdGFydCkgeyAvLyBpdCBpcyB0b28gc21hbGwgLS0+IGluY3JlYXNlIGxvd1xuICAgICAgICAgIG5ld0xvdyA9IE1hdGguZmxvb3IoMC41KihoaWdoK2xvdykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgLy8gaXQgaXMgdG9vIGJpZyAtLT4gZGVjcmVhc2UgaGlnaFxuICAgICAgICAgIG5ld0hpZ2ggPSBNYXRoLmZsb29yKDAuNSooaGlnaCtsb3cpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QgaW4gbGlzdDtcbiAgICAgICAgaWYgKGxvdyA9PSBuZXdMb3cgJiYgaGlnaCA9PSBuZXdIaWdoKSB7XG4gICAgICAgICAgZ3Vlc3MgPSAtMTtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG5ld0hpZ2g7IGxvdyA9IG5ld0xvdztcbiAgICAgICAgICBndWVzcyA9IE1hdGguZmxvb3IoMC41KihoaWdoK2xvdykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpdGVyYXRpb24rKztcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGlvbiA+PSBtYXhJdGVyYXRpb25zKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkJpbmFyeVNlYXJjaCB0b28gbWFueSBpdGVyYXRpb25zLiBBYm9ydGluZy5cIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBndWVzcztcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIGEgYmluYXJ5IHNlYXJjaCBmb3IgYSB2aXNpYmxlIGl0ZW0uIFRoZSB1c2VyIGNhbiBzZWxlY3QgZWl0aGVyIHRoZSB0aGlzLm9yZGVyZWRJdGVtcy5ieVN0YXJ0IG9yIC5ieUVuZFxuICogYXJyYXlzLiBUaGlzIGlzIGRvbmUgYnkgZ2l2aW5nIGEgYm9vbGVhbiB2YWx1ZSB0cnVlIGlmIHlvdSB3YW50IHRvIHVzZSB0aGUgYnlFbmQuXG4gKiBUaGlzIGlzIGRvbmUgdG8gYmUgYWJsZSB0byBzZWxlY3QgdGhlIGNvcnJlY3QgaWYgc3RhdGVtZW50ICh3ZSBkbyBub3Qgd2FudCB0byBjaGVjayBpZiBhbiBpdGVtIGlzIHZpc2libGUsIHdlIHdhbnQgdG8gY2hlY2tcbiAqIGlmIHRoZSB0aW1lIHdlIHNlbGVjdGVkIChzdGFydCBvciBlbmQpIGlzIHdpdGhpbiB0aGUgY3VycmVudCByYW5nZSkuXG4gKlxuICogVGhlIHRyaWNrIGlzIHRoYXQgZXZlcnkgaW50ZXJ2YWwgaGFzIHRvIGVpdGhlciBlbnRlciB0aGUgc2NyZWVuIGF0IHRoZSBpbml0aWFsIGxvYWQgb3IgYnkgZHJhZ2dpbmcuIFRoZSBjYXNlIG9mIHRoZSBSYW5nZUl0ZW0gdGhhdCBpc1xuICogYmVmb3JlIGFuZCBhZnRlciB0aGUgY3VycmVudCByYW5nZSBpcyBoYW5kbGVkIGJ5IHNpbXBseSBjaGVja2luZyBpZiBpdCB3YXMgaW4gdmlldyBiZWZvcmUgYW5kIGlmIGl0IGlzIGFnYWluLiBGb3IgYWxsIHRoZSByZXN0LFxuICogZWl0aGVyIHRoZSBzdGFydCBPUiBlbmQgdGltZSBoYXMgdG8gYmUgaW4gdGhlIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG9yZGVyZWRJdGVtc1xuICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHNpZGVQcmVmZXJlbmNlICAgJ2JlZm9yZScgb3IgJ2FmdGVyJ1xuICogQHJldHVybnMge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmluYXJ5U2VhcmNoR2VuZXJpYyA9IGZ1bmN0aW9uKG9yZGVyZWRJdGVtcywgdGFyZ2V0LCBmaWVsZCwgc2lkZVByZWZlcmVuY2UpIHtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gIHZhciBhcnJheSA9IG9yZGVyZWRJdGVtcztcbiAgdmFyIGZvdW5kID0gZmFsc2U7XG4gIHZhciBsb3cgPSAwO1xuICB2YXIgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIG5ld0xvdyA9IGxvdztcbiAgdmFyIG5ld0hpZ2ggPSBoaWdoO1xuICB2YXIgZ3Vlc3MgPSBNYXRoLmZsb29yKDAuNSooaGlnaCtsb3cpKTtcbiAgdmFyIG5ld0d1ZXNzO1xuICB2YXIgcHJldlZhbHVlLCB2YWx1ZSwgbmV4dFZhbHVlO1xuXG4gIGlmIChoaWdoID09IDApIHtndWVzcyA9IC0xO31cbiAgZWxzZSBpZiAoaGlnaCA9PSAxKSB7XG4gICAgdmFsdWUgPSBhcnJheVtndWVzc11bZmllbGRdO1xuICAgIGlmICh2YWx1ZSA9PSB0YXJnZXQpIHtcbiAgICAgIGd1ZXNzID0gIDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZ3Vlc3MgPSAtMTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaGlnaCAtPSAxO1xuICAgIHdoaWxlIChmb3VuZCA9PSBmYWxzZSAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICBwcmV2VmFsdWUgPSBhcnJheVtNYXRoLm1heCgwLGd1ZXNzIC0gMSldW2ZpZWxkXTtcbiAgICAgIHZhbHVlID0gYXJyYXlbZ3Vlc3NdW2ZpZWxkXTtcbiAgICAgIG5leHRWYWx1ZSA9IGFycmF5W01hdGgubWluKGFycmF5Lmxlbmd0aC0xLGd1ZXNzICsgMSldW2ZpZWxkXTtcblxuICAgICAgaWYgKHZhbHVlID09IHRhcmdldCB8fCBwcmV2VmFsdWUgPCB0YXJnZXQgJiYgdmFsdWUgPiB0YXJnZXQgfHwgdmFsdWUgPCB0YXJnZXQgJiYgbmV4dFZhbHVlID4gdGFyZ2V0KSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbHVlICE9IHRhcmdldCkge1xuICAgICAgICAgIGlmIChzaWRlUHJlZmVyZW5jZSA9PSAnYmVmb3JlJykge1xuICAgICAgICAgICAgaWYgKHByZXZWYWx1ZSA8IHRhcmdldCAmJiB2YWx1ZSA+IHRhcmdldCkge1xuICAgICAgICAgICAgICBndWVzcyA9IE1hdGgubWF4KDAsZ3Vlc3MgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCB0YXJnZXQgJiYgbmV4dFZhbHVlID4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgIGd1ZXNzID0gTWF0aC5taW4oYXJyYXkubGVuZ3RoLTEsZ3Vlc3MgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodmFsdWUgPCB0YXJnZXQpIHsgLy8gaXQgaXMgdG9vIHNtYWxsIC0tPiBpbmNyZWFzZSBsb3dcbiAgICAgICAgICBuZXdMb3cgPSBNYXRoLmZsb29yKDAuNSooaGlnaCtsb3cpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgIC8vIGl0IGlzIHRvbyBiaWcgLS0+IGRlY3JlYXNlIGhpZ2hcbiAgICAgICAgICBuZXdIaWdoID0gTWF0aC5mbG9vcigwLjUqKGhpZ2grbG93KSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3R3Vlc3MgPSBNYXRoLmZsb29yKDAuNSooaGlnaCtsb3cpKTtcbiAgICAgICAgLy8gbm90IGluIGxpc3Q7XG4gICAgICAgIGlmIChsb3cgPT0gbmV3TG93ICYmIGhpZ2ggPT0gbmV3SGlnaCkge1xuICAgICAgICAgIGd1ZXNzID0gLTE7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGhpZ2ggPSBuZXdIaWdoOyBsb3cgPSBuZXdMb3c7XG4gICAgICAgICAgZ3Vlc3MgPSBNYXRoLmZsb29yKDAuNSooaGlnaCtsb3cpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXRlcmF0aW9uKys7XG4gICAgfVxuICAgIGlmIChpdGVyYXRpb24gPj0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgY29uc29sZS5sb2coXCJCaW5hcnlTZWFyY2ggdG9vIG1hbnkgaXRlcmF0aW9ucy4gQWJvcnRpbmcuXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ3Vlc3M7XG59O1xuXG4vKipcbiAqIFF1YWRyYXRpYyBlYXNlLWluLW91dFxuICogaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXG4gKiBAcGFyYW0ge251bWJlcn0gdCAgICAgICAgQ3VycmVudCB0aW1lXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgICAgU3RhcnQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgICAgICBFbmQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgY29ycmVzcG9uZGluZyB3aXRoIGN1cnJlbnQgdGltZVxuICovXG5leHBvcnRzLmVhc2VJbk91dFF1YWQgPSBmdW5jdGlvbiAodCwgc3RhcnQsIGVuZCwgZHVyYXRpb24pIHtcbiAgdmFyIGNoYW5nZSA9IGVuZCAtIHN0YXJ0O1xuICB0IC89IGR1cmF0aW9uLzI7XG4gIGlmICh0IDwgMSkgcmV0dXJuIGNoYW5nZS8yKnQqdCArIHN0YXJ0O1xuICB0LS07XG4gIHJldHVybiAtY2hhbmdlLzIgKiAodCoodC0yKSAtIDEpICsgc3RhcnQ7XG59O1xuXG5cblxuLypcbiAqIEVhc2luZyBGdW5jdGlvbnMgLSBpbnNwaXJlZCBmcm9tIGh0dHA6Ly9naXptYS5jb20vZWFzaW5nL1xuICogb25seSBjb25zaWRlcmluZyB0aGUgdCB2YWx1ZSBmb3IgdGhlIHJhbmdlIFswLCAxXSA9PiBbMCwgMV1cbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dyZS8xNjUwMjk0XG4gKi9cbmV4cG9ydHMuZWFzaW5nRnVuY3Rpb25zID0ge1xuICAvLyBubyBlYXNpbmcsIG5vIGFjY2VsZXJhdGlvblxuICBsaW5lYXI6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHRcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWFkOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogdFxuICB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVhZDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqICgyIC0gdClcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgPCAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdFxuICB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuICgtLXQpICogdCAqIHQgKyAxXG4gIH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMVxuICB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gMSAtICgtLXQpICogdCAqIHQgKiB0XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IC41ID8gOCAqIHQgKiB0ICogdCAqIHQgOiAxIC0gOCAqICgtLXQpICogdCAqIHQgKiB0XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWludDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gMSArICgtLXQpICogdCAqIHQgKiB0ICogdFxuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgPCAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAoLS10KSAqIHQgKiB0ICogdCAqIHRcbiAgfVxufTsiLCJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICBmdW5jdGlvbiBvbigpIHtcbiAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iLCIvKiEgSGFtbWVyLkpTIC0gdjEuMS4zIC0gMjAxNC0wNS0yMFxuICogaHR0cDovL2VpZ2h0bWVkaWEuZ2l0aHViLmlvL2hhbW1lci5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb3JpayBUYW5nZWxkZXIgPGoudGFuZ2VsZGVyQGdtYWlsLmNvbT47XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cblxuKGZ1bmN0aW9uKHdpbmRvdywgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbWFpblxuICogQG1vZHVsZSBoYW1tZXJcbiAqXG4gKiBAY2xhc3MgSGFtbWVyXG4gKiBAc3RhdGljXG4gKi9cblxuLyoqXG4gKiBIYW1tZXIsIHVzZSB0aGlzIHRvIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGBgYGBcbiAqIHZhciBoYW1tZXJ0aW1lID0gbmV3IEhhbW1lcihteUVsZW1lbnQpO1xuICogYGBgYFxuICpcbiAqIEBtZXRob2QgSGFtbWVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gKiBAcmV0dXJuIHtIYW1tZXIuSW5zdGFuY2V9XG4gKi9cbnZhciBIYW1tZXIgPSBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgSGFtbWVyLkluc3RhbmNlKGVsZW1lbnQsIG9wdGlvbnMgfHwge30pO1xufTtcblxuLyoqXG4gKiB2ZXJzaW9uLCBhcyBkZWZpbmVkIGluIHBhY2thZ2UuanNvblxuICogdGhlIHZhbHVlIHdpbGwgYmUgc2V0IGF0IGVhY2ggYnVpbGRcbiAqIEBwcm9wZXJ0eSBWRVJTSU9OXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkhhbW1lci5WRVJTSU9OID0gJzEuMS4zJztcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICogbW9yZSBzZXR0aW5ncyBhcmUgZGVmaW5lZCBwZXIgZ2VzdHVyZSBhdCBgL2dlc3R1cmVzYC4gRWFjaCBnZXN0dXJlIGNhbiBiZSBkaXNhYmxlZC9lbmFibGVkXG4gKiBieSBzZXR0aW5nIGl0J3MgbmFtZSAobGlrZSBgc3dpcGVgKSB0byBmYWxzZS5cbiAqIFlvdSBjYW4gc2V0IHRoZSBkZWZhdWx0cyBmb3IgYWxsIGluc3RhbmNlcyBieSBjaGFuZ2luZyB0aGlzIG9iamVjdCBiZWZvcmUgY3JlYXRpbmcgYW4gaW5zdGFuY2UuXG4gKiBAZXhhbXBsZVxuICogYGBgYFxuICogIEhhbW1lci5kZWZhdWx0cy5kcmFnID0gZmFsc2U7XG4gKiAgSGFtbWVyLmRlZmF1bHRzLmJlaGF2aW9yLnRvdWNoQWN0aW9uID0gJ3Bhbi15JztcbiAqICBkZWxldGUgSGFtbWVyLmRlZmF1bHRzLmJlaGF2aW9yLnVzZXJTZWxlY3Q7XG4gKiBgYGBgXG4gKiBAcHJvcGVydHkgZGVmYXVsdHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiB0aGlzIHNldHRpbmcgb2JqZWN0IGFkZHMgc3R5bGVzIGFuZCBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBkb2luZ1xuICAgICAqIGl0cyBuYXRpdmUgYmVoYXZpb3IuIFRoZSBjc3MgcHJvcGVydGllcyBhcmUgYXV0byBwcmVmaXhlZCBmb3IgdGhlIGJyb3dzZXJzIHdoZW4gbmVlZGVkLlxuICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0cy5iZWhhdmlvclxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgYmVoYXZpb3I6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIFdoZW4gdGhlIHZhbHVlIGlzIGBub25lYCBpdCBhbHNvIHNldHNcbiAgICAgICAgICogYG9uc2VsZWN0c3RhcnQ9ZmFsc2VgIGZvciBJRSBvbiB0aGUgZWxlbWVudC4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAcHJvcGVydHkgZGVmYXVsdHMuYmVoYXZpb3IudXNlclNlbGVjdFxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgYW5kIGhvdyBhIGdpdmVuIHJlZ2lvbiBjYW4gYmUgbWFuaXB1bGF0ZWQgYnkgdGhlIHVzZXIgKGZvciBpbnN0YW5jZSwgYnkgcGFubmluZyBvciB6b29taW5nKS5cbiAgICAgICAgICogVXNlZCBieSBDaHJvbWUgMzU+IGFuZCBJRTEwPi4gQnkgZGVmYXVsdCB0aGlzIG1ha2VzIHRoZSBlbGVtZW50IGJsb2NraW5nIGFueSB0b3VjaCBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IGRlZmF1bHRzLmJlaGF2aW9yLnRvdWNoQWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0OiAncGFuLXknXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaEFjdGlvbjogJ3Bhbi15JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0cy5iZWhhdmlvci50b3VjaENhbGxvdXRcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG4gICAgICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0cy5iZWhhdmlvci5jb250ZW50Wm9vbWluZ1xuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuXG4gICAgICAgICAqIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHByb3BlcnR5IGRlZmF1bHRzLmJlaGF2aW9yLnVzZXJEcmFnXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gU2FmYXJpIG9uIGlQaG9uZS4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgeW91IGRvbid0IHNwZWNpZnkgYW4gYWxwaGEgdmFsdWUsIFNhZmFyaSBvbiBpUGhvbmUgYXBwbGllcyBhIGRlZmF1bHQgYWxwaGEgdmFsdWVcbiAgICAgICAgICogdG8gdGhlIGNvbG9yLiBUbyBkaXNhYmxlIHRhcCBoaWdobGlnaHRpbmcsIHNldCB0aGUgYWxwaGEgdmFsdWUgdG8gMCAoaW52aXNpYmxlKS5cbiAgICAgICAgICogSWYgeW91IHNldCB0aGUgYWxwaGEgdmFsdWUgdG8gMS4wIChvcGFxdWUpLCB0aGUgZWxlbWVudCBpcyBub3QgdmlzaWJsZSB3aGVuIHRhcHBlZC5cbiAgICAgICAgICogQHByb3BlcnR5IGRlZmF1bHRzLmJlaGF2aW9yLnRhcEhpZ2hsaWdodENvbG9yXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH1cbn07XG5cbi8qKlxuICogaGFtbWVyIGRvY3VtZW50IHdoZXJlIHRoZSBiYXNlIGV2ZW50cyBhcmUgYWRkZWQgYXRcbiAqIEBwcm9wZXJ0eSBET0NVTUVOVFxuICogQHR5cGUge0hUTUxFbGVtZW50fVxuICogQGRlZmF1bHQgd2luZG93LmRvY3VtZW50XG4gKi9cbkhhbW1lci5ET0NVTUVOVCA9IGRvY3VtZW50O1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciBwb2ludGVyIGV2ZW50c1xuICogQHByb3BlcnR5IEhBU19QT0lOVEVSRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuSGFtbWVyLkhBU19QT0lOVEVSRVZFTlRTID0gbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciB0b3VjaCBldmVudHNcbiAqIEBwcm9wZXJ0eSBIQVNfVE9VQ0hFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5IYW1tZXIuSEFTX1RPVUNIRVZFTlRTID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG5cbi8qKlxuICogZGV0ZWN0IG1vYmlsZSBicm93c2Vyc1xuICogQHByb3BlcnR5IElTX01PQklMRVxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkhhbW1lci5JU19NT0JJTEUgPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIGRldGVjdCBpZiB3ZSB3YW50IHRvIHN1cHBvcnQgbW91c2VldmVudHMgYXQgYWxsXG4gKiBAcHJvcGVydHkgTk9fTU9VU0VFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5IYW1tZXIuTk9fTU9VU0VFVkVOVFMgPSAoSGFtbWVyLkhBU19UT1VDSEVWRU5UUyAmJiBIYW1tZXIuSVNfTU9CSUxFKSB8fCBIYW1tZXIuSEFTX1BPSU5URVJFVkVOVFM7XG5cbi8qKlxuICogaW50ZXJ2YWwgaW4gd2hpY2ggSGFtbWVyIHJlY2FsY3VsYXRlcyBjdXJyZW50IHZlbG9jaXR5L2RpcmVjdGlvbi9hbmdsZSBpbiBtc1xuICogQHByb3BlcnR5IENBTENVTEFURV9JTlRFUlZBTFxuICogQHR5cGUge051bWJlcn1cbiAqIEBkZWZhdWx0IDI1XG4gKi9cbkhhbW1lci5DQUxDVUxBVEVfSU5URVJWQUwgPSAyNTtcblxuLyoqXG4gKiBldmVudHR5cGVzIHBlciB0b3VjaGV2ZW50IChzdGFydCwgbW92ZSwgZW5kKSBhcmUgZmlsbGVkIGJ5IGBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzYCBvbiBgc2V0dXBgXG4gKiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBET00gZXZlbnQgbmFtZXMgcGVyIHR5cGUgKGBFVkVOVF9TVEFSVGAsIGBFVkVOVF9NT1ZFYCwgYEVWRU5UX0VORGApXG4gKiBAcHJvcGVydHkgRVZFTlRfVFlQRVNcbiAqIEBwcml2YXRlXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgRVZFTlRfVFlQRVMgPSB7fTtcblxuLyoqXG4gKiBkaXJlY3Rpb24gc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBESVJFQ1RJT05fRE9XTnxMRUZUfFVQfFJJR0hUXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnZG93bicgJ2xlZnQnICd1cCcgJ3JpZ2h0J1xuICovXG52YXIgRElSRUNUSU9OX0RPV04gPSBIYW1tZXIuRElSRUNUSU9OX0RPV04gPSAnZG93bic7XG52YXIgRElSRUNUSU9OX0xFRlQgPSBIYW1tZXIuRElSRUNUSU9OX0xFRlQgPSAnbGVmdCc7XG52YXIgRElSRUNUSU9OX1VQID0gSGFtbWVyLkRJUkVDVElPTl9VUCA9ICd1cCc7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gSGFtbWVyLkRJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XG5cbi8qKlxuICogcG9pbnRlcnR5cGUgc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBQT0lOVEVSX01PVVNFfFRPVUNIfFBFTlxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ21vdXNlJyAndG91Y2gnICdwZW4nXG4gKi9cbnZhciBQT0lOVEVSX01PVVNFID0gSGFtbWVyLlBPSU5URVJfTU9VU0UgPSAnbW91c2UnO1xudmFyIFBPSU5URVJfVE9VQ0ggPSBIYW1tZXIuUE9JTlRFUl9UT1VDSCA9ICd0b3VjaCc7XG52YXIgUE9JTlRFUl9QRU4gPSBIYW1tZXIuUE9JTlRFUl9QRU4gPSAncGVuJztcblxuLyoqXG4gKiBldmVudHR5cGVzXG4gKiBAcHJvcGVydHkgRVZFTlRfU1RBUlR8TU9WRXxFTkR8UkVMRUFTRXxUT1VDSFxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ3N0YXJ0JyAnY2hhbmdlJyAnbW92ZScgJ2VuZCcgJ3JlbGVhc2UnICd0b3VjaCdcbiAqL1xudmFyIEVWRU5UX1NUQVJUID0gSGFtbWVyLkVWRU5UX1NUQVJUID0gJ3N0YXJ0JztcbnZhciBFVkVOVF9NT1ZFID0gSGFtbWVyLkVWRU5UX01PVkUgPSAnbW92ZSc7XG52YXIgRVZFTlRfRU5EID0gSGFtbWVyLkVWRU5UX0VORCA9ICdlbmQnO1xudmFyIEVWRU5UX1JFTEVBU0UgPSBIYW1tZXIuRVZFTlRfUkVMRUFTRSA9ICdyZWxlYXNlJztcbnZhciBFVkVOVF9UT1VDSCA9IEhhbW1lci5FVkVOVF9UT1VDSCA9ICd0b3VjaCc7XG5cbi8qKlxuICogaWYgdGhlIHdpbmRvdyBldmVudHMgYXJlIHNldC4uLlxuICogQHByb3BlcnR5IFJFQURZXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKi9cbkhhbW1lci5SRUFEWSA9IGZhbHNlO1xuXG4vKipcbiAqIHBsdWdpbnMgbmFtZXNwYWNlXG4gKiBAcHJvcGVydHkgcGx1Z2luc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuSGFtbWVyLnBsdWdpbnMgPSBIYW1tZXIucGx1Z2lucyB8fCB7fTtcblxuLyoqXG4gKiBnZXN0dXJlcyBuYW1lc3BhY2VcbiAqIHNlZSBgL2dlc3R1cmVzYCBmb3IgdGhlIGRlZmluaXRpb25zXG4gKiBAcHJvcGVydHkgZ2VzdHVyZXNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkhhbW1lci5nZXN0dXJlcyA9IEhhbW1lci5nZXN0dXJlcyB8fCB7fTtcblxuLyoqXG4gKiBzZXR1cCBldmVudHMgdG8gZGV0ZWN0IGdlc3R1cmVzIG9uIHRoZSBkb2N1bWVudFxuICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBjcmVhdGluZyBhbiBuZXcgaW5zdGFuY2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgIGlmKEhhbW1lci5SRUFEWSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZmluZCB3aGF0IGV2ZW50dHlwZXMgd2UgYWRkIGxpc3RlbmVycyB0b1xuICAgIEV2ZW50LmRldGVybWluZUV2ZW50VHlwZXMoKTtcblxuICAgIC8vIFJlZ2lzdGVyIGFsbCBnZXN0dXJlcyBpbnNpZGUgSGFtbWVyLmdlc3R1cmVzXG4gICAgVXRpbHMuZWFjaChIYW1tZXIuZ2VzdHVyZXMsIGZ1bmN0aW9uKGdlc3R1cmUpIHtcbiAgICAgICAgRGV0ZWN0aW9uLnJlZ2lzdGVyKGdlc3R1cmUpO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnRcbiAgICBFdmVudC5vblRvdWNoKEhhbW1lci5ET0NVTUVOVCwgRVZFTlRfTU9WRSwgRGV0ZWN0aW9uLmRldGVjdCk7XG4gICAgRXZlbnQub25Ub3VjaChIYW1tZXIuRE9DVU1FTlQsIEVWRU5UX0VORCwgRGV0ZWN0aW9uLmRldGVjdCk7XG5cbiAgICAvLyBIYW1tZXIgaXMgcmVhZHkuLi4hXG4gICAgSGFtbWVyLlJFQURZID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAbW9kdWxlIGhhbW1lclxuICpcbiAqIEBjbGFzcyBVdGlsc1xuICogQHN0YXRpY1xuICovXG52YXIgVXRpbHMgPSBIYW1tZXIudXRpbHMgPSB7XG4gICAgLyoqXG4gICAgICogZXh0ZW5kIG1ldGhvZCwgY291bGQgYWxzbyBiZSB1c2VkIGZvciBjbG9uaW5nIHdoZW4gYGRlc3RgIGlzIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgKiBjaGFuZ2VzIHRoZSBkZXN0IG9iamVjdFxuICAgICAqIEBtZXRob2QgZXh0ZW5kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdICBkbyBhIG1lcmdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBkZXN0XG4gICAgICovXG4gICAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgICAgICAgIGlmKCFzcmMuaGFzT3duUHJvcGVydHkoa2V5KSB8fCAoZGVzdFtrZXldICE9PSB1bmRlZmluZWQgJiYgbWVyZ2UpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2ltcGxlIGFkZEV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2ltcGxlIHJlbW92ZUV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZm9yRWFjaCBvdmVyIGFycmF5cyBhbmQgb2JqZWN0c1xuICAgICAqIEBtZXRob2QgZWFjaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgICAqIEBwYXJhbSB7YW55fSBpdGVyYXRvci5pdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZXJhdG9yLmluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGl0ZXJhdG9yLm9iaiB0aGUgc291cmNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IHZhbHVlIHRvIHVzZSBhcyBgdGhpc2AgaW4gdGhlIGl0ZXJhdG9yXG4gICAgICovXG4gICAgZWFjaDogZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpLCBsZW47XG5cbiAgICAgICAgLy8gbmF0aXZlIGZvckVhY2ggb24gYXJyYXlzXG4gICAgICAgIGlmKCdmb3JFYWNoJyBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgLy8gYXJyYXlzXG4gICAgICAgIH0gZWxzZSBpZihvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvcihpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcihpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBmaW5kIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHRoZSBzdHJpbmcgdXNpbmcgaW5kZXhPZlxuICAgICAqIEBtZXRob2QgaW5TdHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgICAqL1xuICAgIGluU3RyOiBmdW5jdGlvbiBpblN0cihzcmMsIGZpbmQpIHtcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpID4gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seWZpbGxcbiAgICAgKiBAbWV0aG9kIGluQXJyYXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICAgICAqL1xuICAgIGluQXJyYXk6IGZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kKSB7XG4gICAgICAgIGlmKHNyYy5pbmRleE9mKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICAgICAgICAgIHJldHVybiAoaW5kZXggPT09IC0xKSA/IGZhbHNlIDogaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBzcmMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZihzcmNbaV0gPT09IGZpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QgKGBhcmd1bWVudHNgLCBgdG91Y2hsaXN0YCkgdG8gYW4gYXJyYXlcbiAgICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAgICAgKiBAbWV0aG9kIGhhc1BhcmVudFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgICAqL1xuICAgIGhhc1BhcmVudDogZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgICAgICB3aGlsZShub2RlKSB7XG4gICAgICAgICAgICBpZihub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgdG91Y2hlc1xuICAgICAqIEBtZXRob2QgZ2V0Q2VudGVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGBwYWdlWGAsIGBwYWdlWWAsIGBjbGllbnRYYCBhbmQgYGNsaWVudFlgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uIGdldENlbnRlcih0b3VjaGVzKSB7XG4gICAgICAgIHZhciBwYWdlWCA9IFtdLFxuICAgICAgICAgICAgcGFnZVkgPSBbXSxcbiAgICAgICAgICAgIGNsaWVudFggPSBbXSxcbiAgICAgICAgICAgIGNsaWVudFkgPSBbXSxcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluLFxuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgICAgICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICAgICAgaWYodG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGFnZVg6IHRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgICAgICAgICAgcGFnZVk6IHRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIFV0aWxzLmVhY2godG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgICAgIHBhZ2VYLnB1c2godG91Y2gucGFnZVgpO1xuICAgICAgICAgICAgcGFnZVkucHVzaCh0b3VjaC5wYWdlWSk7XG4gICAgICAgICAgICBjbGllbnRYLnB1c2godG91Y2guY2xpZW50WCk7XG4gICAgICAgICAgICBjbGllbnRZLnB1c2godG91Y2guY2xpZW50WSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWdlWDogKG1pbi5hcHBseShNYXRoLCBwYWdlWCkgKyBtYXguYXBwbHkoTWF0aCwgcGFnZVgpKSAvIDIsXG4gICAgICAgICAgICBwYWdlWTogKG1pbi5hcHBseShNYXRoLCBwYWdlWSkgKyBtYXguYXBwbHkoTWF0aCwgcGFnZVkpKSAvIDIsXG4gICAgICAgICAgICBjbGllbnRYOiAobWluLmFwcGx5KE1hdGgsIGNsaWVudFgpICsgbWF4LmFwcGx5KE1hdGgsIGNsaWVudFgpKSAvIDIsXG4gICAgICAgICAgICBjbGllbnRZOiAobWluLmFwcGx5KE1hdGgsIGNsaWVudFkpICsgbWF4LmFwcGx5KE1hdGgsIGNsaWVudFkpKSAvIDJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICAgICAqIEBtZXRob2QgZ2V0VmVsb2NpdHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gICAgICovXG4gICAgZ2V0VmVsb2NpdHk6IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IE1hdGguYWJzKGRlbHRhWCAvIGRlbHRhVGltZSkgfHwgMCxcbiAgICAgICAgICAgIHk6IE1hdGguYWJzKGRlbHRhWSAvIGRlbHRhVGltZSkgfHwgMFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gICAgICogQG1ldGhvZCBnZXRBbmdsZVxuICAgICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICBnZXRBbmdsZTogZnVuY3Rpb24gZ2V0QW5nbGUodG91Y2gxLCB0b3VjaDIpIHtcbiAgICAgICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkbyBhIHNtYWxsIGNvbXBhcmlzaW9uIHRvIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHRvdWNoZXMuXG4gICAgICogQG1ldGhvZCBnZXREaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGRpcmVjdGlvbiBtYXRjaGVzIGBESVJFQ1RJT05fTEVGVHxSSUdIVHxVUHxET1dOYFxuICAgICAqL1xuICAgIGdldERpcmVjdGlvbjogZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgICAgIHZhciB4ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCksXG4gICAgICAgICAgICB5ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFkgLSB0b3VjaDIuY2xpZW50WSk7XG5cbiAgICAgICAgaWYoeCA+PSB5KSB7XG4gICAgICAgICAgICByZXR1cm4gdG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCA+IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG91Y2gxLmNsaWVudFkgLSB0b3VjaDIuY2xpZW50WSA+IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0b3VjaGVzXG4gICAgICogQG1ldGhvZCBnZXREaXN0YW5jZVxuICAgICAqIEBwYXJhbSB7VG91Y2h9dG91Y2gxXG4gICAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICAgICAqL1xuICAgIGdldERpc3RhbmNlOiBmdW5jdGlvbiBnZXREaXN0YW5jZSh0b3VjaDEsIHRvdWNoMikge1xuICAgICAgICB2YXIgeCA9IHRvdWNoMi5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFgsXG4gICAgICAgICAgICB5ID0gdG91Y2gyLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xuICAgICAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICAgICAqIEBtZXRob2QgZ2V0U2NhbGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiB0b3VjaGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHRvdWNoZXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gICAgICovXG4gICAgZ2V0U2NhbGU6IGZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgLy8gbmVlZCB0d28gZmluZ2Vycy4uLlxuICAgICAgICBpZihzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdKSAvIHRoaXMuZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcbiAgICAgKiBAbWV0aG9kIGdldFJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiB0b3VjaGVzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICAgICAqL1xuICAgIGdldFJvdGF0aW9uOiBmdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIG5lZWQgdHdvIGZpbmdlcnNcbiAgICAgICAgaWYoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbmdsZShlbmRbMV0sIGVuZFswXSkgLSB0aGlzLmdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGZpbmQgb3V0IGlmIHRoZSBkaXJlY3Rpb24gaXMgdmVydGljYWwgICAqXG4gICAgICogQG1ldGhvZCBpc1ZlcnRpY2FsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiBtYXRjaGVzIGBESVJFQ1RJT05fVVB8RE9XTmBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBpc192ZXJ0aWNhbFxuICAgICAqL1xuICAgIGlzVmVydGljYWw6IGZ1bmN0aW9uIGlzVmVydGljYWwoZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQIHx8IGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IGNzcyBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgcHJlZml4ZXNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0b2dnbGU9dHJ1ZV1cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldFByZWZpeGVkQ3NzOiBmdW5jdGlvbiBzZXRQcmVmaXhlZENzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSwgdG9nZ2xlKSB7XG4gICAgICAgIHZhciBwcmVmaXhlcyA9IFsnJywgJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddO1xuICAgICAgICBwcm9wID0gVXRpbHMudG9DYW1lbENhc2UocHJvcCk7XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHByb3A7XG4gICAgICAgICAgICAvLyBwcmVmaXhlc1xuICAgICAgICAgICAgaWYocHJlZml4ZXNbaV0pIHtcbiAgICAgICAgICAgICAgICBwID0gcHJlZml4ZXNbaV0gKyBwLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBwLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSBzdHlsZVxuICAgICAgICAgICAgaWYocCBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwXSA9ICh0b2dnbGUgPT0gbnVsbCB8fCB0b2dnbGUpICYmIHZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRvZ2dsZSBicm93c2VyIGRlZmF1bHQgYmVoYXZpb3IgYnkgc2V0dGluZyBjc3MgcHJvcGVydGllcy5cbiAgICAgKiBgdXNlclNlbGVjdD0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbnNlbGVjdHN0YXJ0YCB0byBmYWxzZVxuICAgICAqIGB1c2VyRHJhZz0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbmRyYWdzdGFydGAgdG8gZmFsc2VcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9nZ2xlQmVoYXZpb3JcbiAgICAgKiBAcGFyYW0ge0h0bWxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAgICovXG4gICAgdG9nZ2xlQmVoYXZpb3I6IGZ1bmN0aW9uIHRvZ2dsZUJlaGF2aW9yKGVsZW1lbnQsIHByb3BzLCB0b2dnbGUpIHtcbiAgICAgICAgaWYoIXByb3BzIHx8ICFlbGVtZW50IHx8ICFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIGNzcyBwcm9wZXJ0aWVzXG4gICAgICAgIFV0aWxzLmVhY2gocHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwcm9wKSB7XG4gICAgICAgICAgICBVdGlscy5zZXRQcmVmaXhlZENzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSwgdG9nZ2xlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZhbHNlRm4gPSB0b2dnbGUgJiYgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYWxzbyB0aGUgZGlzYWJsZSBvbnNlbGVjdHN0YXJ0XG4gICAgICAgIGlmKHByb3BzLnVzZXJTZWxlY3QgPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuZCBkaXNhYmxlIG9uZHJhZ3N0YXJ0XG4gICAgICAgIGlmKHByb3BzLnVzZXJEcmFnID09ICdub25lJykge1xuICAgICAgICAgICAgZWxlbWVudC5vbmRyYWdzdGFydCA9IGZhbHNlRm47XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBhIHN0cmluZyB3aXRoIHVuZGVyc2NvcmVzIHRvIGNhbWVsQ2FzZVxuICAgICAqIHNvIHByZXZlbnRfZGVmYXVsdCBiZWNvbWVzIHByZXZlbnREZWZhdWx0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gY2FtZWxDYXNlU3RyXG4gICAgICovXG4gICAgdG9DYW1lbENhc2U6IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tfLV0oW2Etel0pL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIGhhbW1lclxuICovXG4vKipcbiAqIEBjbGFzcyBFdmVudFxuICogQHN0YXRpY1xuICovXG52YXIgRXZlbnQgPSBIYW1tZXIuZXZlbnQgPSB7XG4gICAgLyoqXG4gICAgICogd2hlbiB0b3VjaCBldmVudHMgaGF2ZSBiZWVuIGZpcmVkLCB0aGlzIGlzIHRydWVcbiAgICAgKiB0aGlzIGlzIHVzZWQgdG8gc3RvcCBtb3VzZSBldmVudHNcbiAgICAgKiBAcHJvcGVydHkgcHJldmVudF9tb3VzZWV2ZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgcHJldmVudE1vdXNlRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGlmIEVWRU5UX1NUQVJUIGhhcyBiZWVuIGZpcmVkXG4gICAgICogQHByb3BlcnR5IHN0YXJ0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogd2hlbiB0aGUgbW91c2UgaXMgaG9sZCBkb3duLCB0aGlzIGlzIHRydWVcbiAgICAgKiBAcHJvcGVydHkgc2hvdWxkX2RldGVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkRGV0ZWN0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIHNpbXBsZSBldmVudCBiaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaG9vay50eXBlXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGhvb2spIHtcbiAgICAgICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgICAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICBVdGlscy5vbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNpbXBsZSBldmVudCB1bmJpbmRlciB3aXRoIGEgaG9vayBhbmQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgdHlwZXNcbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaG9vay50eXBlXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgaG9vaykge1xuICAgICAgICB2YXIgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XG4gICAgICAgIFV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIFV0aWxzLm9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjb3JlIHRvdWNoIGV2ZW50IGhhbmRsZXIuXG4gICAgICogdGhpcyBmaW5kcyBvdXQgaWYgd2Ugc2hvdWxkIHRvIGRldGVjdCBnZXN0dXJlc1xuICAgICAqIEBtZXRob2Qgb25Ub3VjaFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJuIG9uVG91Y2hIYW5kbGVyIHtGdW5jdGlvbn0gdGhlIGNvcmUgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goZWxlbWVudCwgZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgb25Ub3VjaEhhbmRsZXIgPSBmdW5jdGlvbiBvblRvdWNoSGFuZGxlcihldikge1xuICAgICAgICAgICAgdmFyIHNyY1R5cGUgPSBldi50eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgaXNQb2ludGVyID0gSGFtbWVyLkhBU19QT0lOVEVSRVZFTlRTLFxuICAgICAgICAgICAgICAgIGlzTW91c2UgPSBVdGlscy5pblN0cihzcmNUeXBlLCAnbW91c2UnKSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVHlwZTtcblxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGluIGEgbW91c2VldmVudCwgYnV0IHRoZXJlIGhhcyBiZWVuIGEgdG91Y2hldmVudCB0cmlnZ2VyZWQgaW4gdGhpcyBzZXNzaW9uXG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGRvIG5vdGhpbmcuIHNpbXBseSBicmVhayBvdXQgb2YgdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYoaXNNb3VzZSAmJiBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLy8gbW91c2VidXR0b24gbXVzdCBiZSBkb3duXG4gICAgICAgICAgICB9IGVsc2UgaWYoaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYoaXNQb2ludGVyICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gKGV2LmJ1dHRvbnMgPT09IDEgfHwgUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX1RPVUNILCBldikpO1xuICAgICAgICAgICAgLy8ganVzdCBhIHZhbGlkIHN0YXJ0IGV2ZW50LCBidXQgbm8gbW91c2VcbiAgICAgICAgICAgIH0gZWxzZSBpZighaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXIgZXZlbnQgYmVmb3JlIGVudGVyaW5nIHRoZSBkZXRlY3Rpb25cbiAgICAgICAgICAgIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICAgICAgICAgUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdlIGFyZSBpbiBhIHRvdWNoL2Rvd24gc3RhdGUsIHNvIGFsbG93ZWQgZGV0ZWN0aW9uIG9mIGdlc3R1cmVzXG4gICAgICAgICAgICBpZihzZWxmLnNob3VsZERldGVjdCkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJUeXBlID0gc2VsZi5kb0RldGVjdC5jYWxsKHNlbGYsIGV2LCBldmVudFR5cGUsIGVsZW1lbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAgICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcbiAgICAgICAgICAgIGlmKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBQb2ludGVyRXZlbnQucmVzZXQoKTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9pbnRlcmV2ZW50IG9iamVjdCBhZnRlciB0aGUgZGV0ZWN0aW9uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICAgICAgICAgUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vbihlbGVtZW50LCBFVkVOVF9UWVBFU1tldmVudFR5cGVdLCBvblRvdWNoSGFuZGxlcik7XG4gICAgICAgIHJldHVybiBvblRvdWNoSGFuZGxlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNvcmUgZGV0ZWN0aW9uIG1ldGhvZFxuICAgICAqIHRoaXMgZmluZHMgb3V0IHdoYXQgaGFtbWVyLXRvdWNoLWV2ZW50cyB0byB0cmlnZ2VyXG4gICAgICogQG1ldGhvZCBkb0RldGVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRyaWdnZXJUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgICAqL1xuICAgIGRvRGV0ZWN0OiBmdW5jdGlvbiBkb0RldGVjdChldiwgZXZlbnRUeXBlLCBlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciB0b3VjaExpc3QgPSB0aGlzLmdldFRvdWNoTGlzdChldiwgZXZlbnRUeXBlKTtcbiAgICAgICAgdmFyIHRvdWNoTGlzdExlbmd0aCA9IHRvdWNoTGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciB0cmlnZ2VyVHlwZSA9IGV2ZW50VHlwZTtcbiAgICAgICAgdmFyIHRyaWdnZXJDaGFuZ2UgPSB0b3VjaExpc3QudHJpZ2dlcjsgLy8gdXNlZCBieSBmYWtlTXVsdGl0b3VjaCBwbHVnaW5cbiAgICAgICAgdmFyIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3RMZW5ndGg7XG5cbiAgICAgICAgLy8gYXQgZWFjaCB0b3VjaHN0YXJ0LWxpa2UgZXZlbnQgd2Ugd2FudCBhbHNvIHdhbnQgdG8gdHJpZ2dlciBhIFRPVUNIIGV2ZW50Li4uXG4gICAgICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSA9IEVWRU5UX1RPVUNIO1xuICAgICAgICAvLyAuLi50aGUgc2FtZSBmb3IgYSB0b3VjaGVuZC1saWtlIGV2ZW50XG4gICAgICAgIH0gZWxzZSBpZihldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfUkVMRUFTRTtcblxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0b3VjaGVzIGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0Lmxlbmd0aCAtICgoZXYuY2hhbmdlZFRvdWNoZXMpID8gZXYuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDogMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZnRlciB0aGVyZSBhcmUgc3RpbGwgdG91Y2hlcyBvbiB0aGUgc2NyZWVuLFxuICAgICAgICAvLyB3ZSBqdXN0IHdhbnQgdG8gdHJpZ2dlciBhIE1PVkUgZXZlbnQuIHNvIGNoYW5nZSB0aGUgU1RBUlQgb3IgRU5EIHRvIGEgTU9WRVxuICAgICAgICAvLyBidXQgb25seSBhZnRlciBkZXRlY3Rpb24gaGFzIGJlZW4gc3RhcnRlZCwgdGhlIGZpcnN0IHRpbWUgd2UgYWN0dWFseSB3YW50IGEgU1RBUlRcbiAgICAgICAgaWYoY2hhbmdlZExlbmd0aCA+IDAgJiYgdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0cmlnZ2VyVHlwZSA9IEVWRU5UX01PVkU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXRlY3Rpb24gaGFzIGJlZW4gc3RhcnRlZCwgd2Uga2VlcCB0cmFjayBvZiB0aGlzLCBzZWUgYWJvdmVcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBnZW5lcmF0ZSBzb21lIGV2ZW50IGRhdGEsIHNvbWUgYmFzaWMgaW5mb3JtYXRpb25cbiAgICAgICAgdmFyIGV2RGF0YSA9IHRoaXMuY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCB0cmlnZ2VyVHlwZSwgdG91Y2hMaXN0LCBldik7XG5cbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgdHJpZ2dlclR5cGUgZXZlbnQgYmVmb3JlIHRoZSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudHNcbiAgICAgICAgLy8gYnV0IHRoZSBFTkQgZXZlbnQgc2hvdWxkIGJlIGF0IGxhc3RcbiAgICAgICAgaWYoZXZlbnRUeXBlICE9IEVWRU5UX0VORCkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgYSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudCwgdGhpcyBtZWFucyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaGVzIGNoYW5nZWRcbiAgICAgICAgaWYodHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgZXZEYXRhLmNoYW5nZWRMZW5ndGggPSBjaGFuZ2VkTGVuZ3RoO1xuICAgICAgICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJDaGFuZ2U7XG5cbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG5cbiAgICAgICAgICAgIGV2RGF0YS5ldmVudFR5cGUgPSB0cmlnZ2VyVHlwZTtcbiAgICAgICAgICAgIGRlbGV0ZSBldkRhdGEuY2hhbmdlZExlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIEVORCBldmVudFxuICAgICAgICBpZih0cmlnZ2VyVHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG5cbiAgICAgICAgICAgIC8vIC4uLmFuZCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBkZXRlY3Rpb25cbiAgICAgICAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJpZ2dlclR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHdlIGhhdmUgZGlmZmVyZW50IGV2ZW50cyBmb3IgZWFjaCBkZXZpY2UvYnJvd3NlclxuICAgICAqIGRldGVybWluZSB3aGF0IHdlIG5lZWQgYW5kIHNldCB0aGVtIGluIHRoZSBFVkVOVF9UWVBFUyBjb25zdGFudFxuICAgICAqIHRoZSBgb25Ub3VjaGAgbWV0aG9kIGlzIGJpbmQgdG8gdGhlc2UgcHJvcGVydGllcy5cbiAgICAgKiBAbWV0aG9kIGRldGVybWluZUV2ZW50VHlwZXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2ZW50c1xuICAgICAqL1xuICAgIGRldGVybWluZUV2ZW50VHlwZXM6IGZ1bmN0aW9uIGRldGVybWluZUV2ZW50VHlwZXMoKSB7XG4gICAgICAgIHZhciB0eXBlcztcbiAgICAgICAgaWYoSGFtbWVyLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICAgICAgICBpZih3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICdwb2ludGVyZG93bicsXG4gICAgICAgICAgICAgICAgICAgICdwb2ludGVybW92ZScsXG4gICAgICAgICAgICAgICAgICAgICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBsb3N0cG9pbnRlcmNhcHR1cmUnXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICdNU1BvaW50ZXJEb3duJyxcbiAgICAgICAgICAgICAgICAgICAgJ01TUG9pbnRlck1vdmUnLFxuICAgICAgICAgICAgICAgICAgICAnTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsIE1TTG9zdFBvaW50ZXJDYXB0dXJlJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihIYW1tZXIuTk9fTU9VU0VFVkVOVFMpIHtcbiAgICAgICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgICAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwnXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICAndG91Y2htb3ZlIG1vdXNlbW92ZScsXG4gICAgICAgICAgICAgICAgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIG1vdXNldXAnXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdID0gdHlwZXNbMF07XG4gICAgICAgIEVWRU5UX1RZUEVTW0VWRU5UX01PVkVdID0gdHlwZXNbMV07XG4gICAgICAgIEVWRU5UX1RZUEVTW0VWRU5UX0VORF0gPSB0eXBlc1syXTtcbiAgICAgICAgcmV0dXJuIEVWRU5UX1RZUEVTO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgdG91Y2hMaXN0IGRlcGVuZGluZyBvbiB0aGUgZXZlbnRcbiAgICAgKiBAbWV0aG9kIGdldFRvdWNoTGlzdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gdG91Y2hlc1xuICAgICAqL1xuICAgIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBmYWtlIHBvaW50ZXJFdmVudCB0b3VjaGxpc3RcbiAgICAgICAgaWYoSGFtbWVyLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnRlckV2ZW50LmdldFRvdWNoTGlzdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0b3VjaGxpc3RcbiAgICAgICAgaWYoZXYudG91Y2hlcykge1xuICAgICAgICAgICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX01PVkUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXYudG91Y2hlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gICAgICAgICAgICB2YXIgY29uY2F0ID0gW10uY29uY2F0KFV0aWxzLnRvQXJyYXkoZXYudG91Y2hlcyksIFV0aWxzLnRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpKTtcbiAgICAgICAgICAgIHZhciB0b3VjaExpc3QgPSBbXTtcblxuICAgICAgICAgICAgVXRpbHMuZWFjaChjb25jYXQsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgICAgICAgICAgaWYoVXRpbHMuaW5BcnJheShpZGVudGlmaWVycywgdG91Y2guaWRlbnRpZmllcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoTGlzdC5wdXNoKHRvdWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0b3VjaC5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdG91Y2hMaXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBmYWtlIHRvdWNoTGlzdCBmcm9tIG1vdXNlIHBvc2l0aW9uXG4gICAgICAgIGV2LmlkZW50aWZpZXIgPSAxO1xuICAgICAgICByZXR1cm4gW2V2XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29sbGVjdCBiYXNpYyBldmVudCBkYXRhXG4gICAgICogQG1ldGhvZCBjb2xsZWN0RXZlbnREYXRhXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBjb2xsZWN0RXZlbnREYXRhOiBmdW5jdGlvbiBjb2xsZWN0RXZlbnREYXRhKGVsZW1lbnQsIGV2ZW50VHlwZSwgdG91Y2hlcywgZXYpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgcG9pbnRlclR5cGVcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9UT1VDSDtcbiAgICAgICAgaWYoVXRpbHMuaW5TdHIoZXYudHlwZSwgJ21vdXNlJykgfHwgUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX01PVVNFLCBldikpIHtcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9NT1VTRTtcbiAgICAgICAgfSBlbHNlIGlmKFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9QRU4sIGV2KSkge1xuICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1BFTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjZW50ZXI6IFV0aWxzLmdldENlbnRlcih0b3VjaGVzKSxcbiAgICAgICAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHRhcmdldDogZXYudGFyZ2V0LFxuICAgICAgICAgICAgdG91Y2hlczogdG91Y2hlcyxcbiAgICAgICAgICAgIGV2ZW50VHlwZTogZXZlbnRUeXBlLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHByZXZlbnQgdGhlIGJyb3dzZXIgZGVmYXVsdCBhY3Rpb25zXG4gICAgICAgICAgICAgKiBtb3N0bHkgdXNlZCB0byBkaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNyY0V2ZW50ID0gdGhpcy5zcmNFdmVudDtcbiAgICAgICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uICYmIHNyY0V2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24oKTtcbiAgICAgICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzdG9wIGJ1YmJsaW5nIHRoZSBldmVudCB1cCB0byBpdHMgcGFyZW50c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGltbWVkaWF0ZWx5IHN0b3AgZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICAgICAgICAgICAqIG1pZ2h0IGJlIHVzZWZ1bCBhZnRlciBhIHN3aXBlIHdhcyBkZXRlY3RlZFxuICAgICAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3RvcERldGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERldGVjdGlvbi5zdG9wRGV0ZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgaGFtbWVyXG4gKlxuICogQGNsYXNzIFBvaW50ZXJFdmVudFxuICogQHN0YXRpY1xuICovXG52YXIgUG9pbnRlckV2ZW50ID0gSGFtbWVyLlBvaW50ZXJFdmVudCA9IHtcbiAgICAvKipcbiAgICAgKiBob2xkcyBhbGwgcG9pbnRlcnMsIGJ5IGBpZGVudGlmaWVyYFxuICAgICAqIEBwcm9wZXJ0eSBwb2ludGVyc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgcG9pbnRlcnM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBwb2ludGVycyBhcyBhbiBhcnJheVxuICAgICAqIEBtZXRob2QgZ2V0VG91Y2hMaXN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IHRvdWNobGlzdFxuICAgICAqL1xuICAgIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KCkge1xuICAgICAgICB2YXIgdG91Y2hsaXN0ID0gW107XG4gICAgICAgIC8vIHdlIGNhbiB1c2UgZm9yRWFjaCBzaW5jZSBwb2ludGVyRXZlbnRzIG9ubHkgaXMgaW4gSUUxMFxuICAgICAgICBVdGlscy5lYWNoKHRoaXMucG9pbnRlcnMsIGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgICAgICAgIHRvdWNobGlzdC5wdXNoKHBvaW50ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvdWNobGlzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBhIHBvaW50ZXJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVBvaW50ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyRXZlbnRcbiAgICAgKi9cbiAgICB1cGRhdGVQb2ludGVyOiBmdW5jdGlvbiB1cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgcG9pbnRlckV2ZW50KSB7XG4gICAgICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQgfHwgKGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQgJiYgcG9pbnRlckV2ZW50LmJ1dHRvbnMgIT09IDEpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudC5pZGVudGlmaWVyID0gcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlcnNbcG9pbnRlckV2ZW50LnBvaW50ZXJJZF0gPSBwb2ludGVyRXZlbnQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2hlY2sgaWYgZXYgbWF0Y2hlcyBwb2ludGVydHlwZVxuICAgICAqIEBtZXRob2QgbWF0Y2hUeXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50ZXJUeXBlIG1hdGNoZXMgYFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOYFxuICAgICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBldlxuICAgICAqL1xuICAgIG1hdGNoVHlwZTogZnVuY3Rpb24gbWF0Y2hUeXBlKHBvaW50ZXJUeXBlLCBldikge1xuICAgICAgICBpZighZXYucG9pbnRlclR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwdCA9IGV2LnBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgdHlwZXMgPSB7fTtcblxuICAgICAgICB0eXBlc1tQT0lOVEVSX01PVVNFXSA9IChwdCA9PT0gKGV2Lk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IFBPSU5URVJfTU9VU0UpKTtcbiAgICAgICAgdHlwZXNbUE9JTlRFUl9UT1VDSF0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9UT1VDSCB8fCBQT0lOVEVSX1RPVUNIKSk7XG4gICAgICAgIHR5cGVzW1BPSU5URVJfUEVOXSA9IChwdCA9PT0gKGV2Lk1TUE9JTlRFUl9UWVBFX1BFTiB8fCBQT0lOVEVSX1BFTikpO1xuICAgICAgICByZXR1cm4gdHlwZXNbcG9pbnRlclR5cGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXNldCB0aGUgc3RvcmVkIHBvaW50ZXJzXG4gICAgICogQG1ldGhvZCByZXNldFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldExpc3QoKSB7XG4gICAgICAgIHRoaXMucG9pbnRlcnMgPSB7fTtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBoYW1tZXJcbiAqXG4gKiBAY2xhc3MgRGV0ZWN0aW9uXG4gKiBAc3RhdGljXG4gKi9cbnZhciBEZXRlY3Rpb24gPSBIYW1tZXIuZGV0ZWN0aW9uID0ge1xuICAgIC8vIGNvbnRhaW5zIGFsbCByZWdpc3RyZWQgSGFtbWVyLmdlc3R1cmVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gICAgZ2VzdHVyZXM6IFtdLFxuXG4gICAgLy8gZGF0YSBvZiB0aGUgY3VycmVudCBIYW1tZXIuZ2VzdHVyZSBkZXRlY3Rpb24gc2Vzc2lvblxuICAgIGN1cnJlbnQ6IG51bGwsXG5cbiAgICAvLyB0aGUgcHJldmlvdXMgSGFtbWVyLmdlc3R1cmUgc2Vzc2lvbiBkYXRhXG4gICAgLy8gaXMgYSBmdWxsIGNsb25lIG9mIHRoZSBwcmV2aW91cyBnZXN0dXJlLmN1cnJlbnQgb2JqZWN0XG4gICAgcHJldmlvdXM6IG51bGwsXG5cbiAgICAvLyB3aGVuIHRoaXMgYmVjb21lcyB0cnVlLCBubyBnZXN0dXJlcyBhcmUgZmlyZWRcbiAgICBzdG9wcGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIHN0YXJ0IEhhbW1lci5nZXN0dXJlIGRldGVjdGlvblxuICAgICAqIEBtZXRob2Qgc3RhcnREZXRlY3RcbiAgICAgKiBAcGFyYW0ge0hhbW1lci5JbnN0YW5jZX0gaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudERhdGFcbiAgICAgKi9cbiAgICBzdGFydERldGVjdDogZnVuY3Rpb24gc3RhcnREZXRlY3QoaW5zdCwgZXZlbnREYXRhKSB7XG4gICAgICAgIC8vIGFscmVhZHkgYnVzeSB3aXRoIGEgSGFtbWVyLmdlc3R1cmUgZGV0ZWN0aW9uIG9uIGFuIGVsZW1lbnRcbiAgICAgICAgaWYodGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBob2xkcyBjdXJyZW50IHNlc3Npb25cbiAgICAgICAgdGhpcy5jdXJyZW50ID0ge1xuICAgICAgICAgICAgaW5zdDogaW5zdCwgLy8gcmVmZXJlbmNlIHRvIEhhbW1lckluc3RhbmNlIHdlJ3JlIHdvcmtpbmcgZm9yXG4gICAgICAgICAgICBzdGFydEV2ZW50OiBVdGlscy5leHRlbmQoe30sIGV2ZW50RGF0YSksIC8vIHN0YXJ0IGV2ZW50RGF0YSBmb3IgZGlzdGFuY2VzLCB0aW1pbmcgZXRjXG4gICAgICAgICAgICBsYXN0RXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YVxuICAgICAgICAgICAgbGFzdENhbGNFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhIGZvciBjYWxjdWxhdGlvbnMuXG4gICAgICAgICAgICBmdXR1cmVDYWxjRXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YSBmb3IgY2FsY3VsYXRpb25zLlxuICAgICAgICAgICAgbGFzdENhbGNEYXRhOiB7fSwgLy8gbGFzdCBsYXN0Q2FsY0RhdGFcbiAgICAgICAgICAgIG5hbWU6ICcnIC8vIGN1cnJlbnQgZ2VzdHVyZSB3ZSdyZSBpbi9kZXRlY3RlZCwgY2FuIGJlICd0YXAnLCAnaG9sZCcgZXRjXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kZXRlY3QoZXZlbnREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFtbWVyLmdlc3R1cmUgZGV0ZWN0aW9uXG4gICAgICogQG1ldGhvZCBkZXRlY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIGRldGVjdDogZnVuY3Rpb24gZGV0ZWN0KGV2ZW50RGF0YSkge1xuICAgICAgICBpZighdGhpcy5jdXJyZW50IHx8IHRoaXMuc3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXh0ZW5kIGV2ZW50IGRhdGEgd2l0aCBjYWxjdWxhdGlvbnMgYWJvdXQgc2NhbGUsIGRpc3RhbmNlIGV0Y1xuICAgICAgICBldmVudERhdGEgPSB0aGlzLmV4dGVuZEV2ZW50RGF0YShldmVudERhdGEpO1xuXG4gICAgICAgIC8vIGhhbW1lciBpbnN0YW5jZSBhbmQgaW5zdGFuY2Ugb3B0aW9uc1xuICAgICAgICB2YXIgaW5zdCA9IHRoaXMuY3VycmVudC5pbnN0LFxuICAgICAgICAgICAgaW5zdE9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAgICAgLy8gY2FsbCBIYW1tZXIuZ2VzdHVyZSBoYW5kbGVyc1xuICAgICAgICBVdGlscy5lYWNoKHRoaXMuZ2VzdHVyZXMsIGZ1bmN0aW9uIHRyaWdnZXJHZXN0dXJlKGdlc3R1cmUpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgd2hlbiB0aGUgaW5zdGFuY2Ugb3B0aW9ucyBoYXZlIGVuYWJsZWQgdGhpcyBnZXN0dXJlXG4gICAgICAgICAgICBpZighdGhpcy5zdG9wcGVkICYmIGluc3QuZW5hYmxlZCAmJiBpbnN0T3B0aW9uc1tnZXN0dXJlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZS5oYW5kbGVyLmNhbGwoZ2VzdHVyZSwgZXZlbnREYXRhLCBpbnN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gc3RvcmUgYXMgcHJldmlvdXMgZXZlbnQgZXZlbnRcbiAgICAgICAgaWYodGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQubGFzdEV2ZW50ID0gZXZlbnREYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZXZlbnREYXRhLmV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcERldGVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50RGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2xlYXIgdGhlIEhhbW1lci5nZXN0dXJlIHZhcnNcbiAgICAgKiB0aGlzIGlzIGNhbGxlZCBvbiBlbmREZXRlY3QsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIHdoZW4gYSBmaW5hbCBIYW1tZXIuZ2VzdHVyZSBoYXMgYmVlbiBkZXRlY3RlZFxuICAgICAqIHRvIHN0b3Agb3RoZXIgSGFtbWVyLmdlc3R1cmVzIGZyb20gYmVpbmcgZmlyZWRcbiAgICAgKiBAbWV0aG9kIHN0b3BEZXRlY3RcbiAgICAgKi9cbiAgICBzdG9wRGV0ZWN0OiBmdW5jdGlvbiBzdG9wRGV0ZWN0KCkge1xuICAgICAgICAvLyBjbG9uZSBjdXJyZW50IGRhdGEgdG8gdGhlIHN0b3JlIGFzIHRoZSBwcmV2aW91cyBnZXN0dXJlXG4gICAgICAgIC8vIHVzZWQgZm9yIHRoZSBkb3VibGUgdGFwIGdlc3R1cmUsIHNpbmNlIHRoaXMgaXMgYW4gb3RoZXIgZ2VzdHVyZSBkZXRlY3Qgc2Vzc2lvblxuICAgICAgICB0aGlzLnByZXZpb3VzID0gVXRpbHMuZXh0ZW5kKHt9LCB0aGlzLmN1cnJlbnQpO1xuXG4gICAgICAgIC8vIHJlc2V0IHRoZSBjdXJyZW50XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB2ZWxvY2l0eSwgYW5nbGUgYW5kIGRpcmVjdGlvblxuICAgICAqIEBtZXRob2QgZ2V0VmVsb2NpdHlEYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNlbnRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWVxuICAgICAqL1xuICAgIGdldENhbGN1bGF0ZWREYXRhOiBmdW5jdGlvbiBnZXRDYWxjdWxhdGVkRGF0YShldiwgY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQsXG4gICAgICAgICAgICByZWNhbGMgPSBmYWxzZSxcbiAgICAgICAgICAgIGNhbGNFdiA9IGN1ci5sYXN0Q2FsY0V2ZW50LFxuICAgICAgICAgICAgY2FsY0RhdGEgPSBjdXIubGFzdENhbGNEYXRhO1xuXG4gICAgICAgIGlmKGNhbGNFdiAmJiBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wID4gSGFtbWVyLkNBTENVTEFURV9JTlRFUlZBTCkge1xuICAgICAgICAgICAgY2VudGVyID0gY2FsY0V2LmNlbnRlcjtcbiAgICAgICAgICAgIGRlbHRhVGltZSA9IGV2LnRpbWVTdGFtcCAtIGNhbGNFdi50aW1lU3RhbXA7XG4gICAgICAgICAgICBkZWx0YVggPSBldi5jZW50ZXIuY2xpZW50WCAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WDtcbiAgICAgICAgICAgIGRlbHRhWSA9IGV2LmNlbnRlci5jbGllbnRZIC0gY2FsY0V2LmNlbnRlci5jbGllbnRZO1xuICAgICAgICAgICAgcmVjYWxjID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCB8fCBldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICAgICAgY3VyLmZ1dHVyZUNhbGNFdmVudCA9IGV2O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWN1ci5sYXN0Q2FsY0V2ZW50IHx8IHJlY2FsYykge1xuICAgICAgICAgICAgY2FsY0RhdGEudmVsb2NpdHkgPSBVdGlscy5nZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgICAgIGNhbGNEYXRhLmFuZ2xlID0gVXRpbHMuZ2V0QW5nbGUoY2VudGVyLCBldi5jZW50ZXIpO1xuICAgICAgICAgICAgY2FsY0RhdGEuZGlyZWN0aW9uID0gVXRpbHMuZ2V0RGlyZWN0aW9uKGNlbnRlciwgZXYuY2VudGVyKTtcblxuICAgICAgICAgICAgY3VyLmxhc3RDYWxjRXZlbnQgPSBjdXIuZnV0dXJlQ2FsY0V2ZW50IHx8IGV2O1xuICAgICAgICAgICAgY3VyLmZ1dHVyZUNhbGNFdmVudCA9IGV2O1xuICAgICAgICB9XG5cbiAgICAgICAgZXYudmVsb2NpdHlYID0gY2FsY0RhdGEudmVsb2NpdHkueDtcbiAgICAgICAgZXYudmVsb2NpdHlZID0gY2FsY0RhdGEudmVsb2NpdHkueTtcbiAgICAgICAgZXYuaW50ZXJpbUFuZ2xlID0gY2FsY0RhdGEuYW5nbGU7XG4gICAgICAgIGV2LmludGVyaW1EaXJlY3Rpb24gPSBjYWxjRGF0YS5kaXJlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGV4dGVuZCBldmVudERhdGEgZm9yIEhhbW1lci5nZXN0dXJlc1xuICAgICAqIEBtZXRob2QgZXh0ZW5kRXZlbnREYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBldlxuICAgICAqL1xuICAgIGV4dGVuZEV2ZW50RGF0YTogZnVuY3Rpb24gZXh0ZW5kRXZlbnREYXRhKGV2KSB7XG4gICAgICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQsXG4gICAgICAgICAgICBzdGFydEV2ID0gY3VyLnN0YXJ0RXZlbnQsXG4gICAgICAgICAgICBsYXN0RXYgPSBjdXIubGFzdEV2ZW50IHx8IHN0YXJ0RXY7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdGFydCB0b3VjaGxpc3QgdG8gY2FsY3VsYXRlIHRoZSBzY2FsZS9yb3RhdGlvblxuICAgICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0ggfHwgZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgICAgIHN0YXJ0RXYudG91Y2hlcyA9IFtdO1xuICAgICAgICAgICAgVXRpbHMuZWFjaChldi50b3VjaGVzLCBmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RXYudG91Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogdG91Y2guY2xpZW50WVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsdGFUaW1lID0gZXYudGltZVN0YW1wIC0gc3RhcnRFdi50aW1lU3RhbXAsXG4gICAgICAgICAgICBkZWx0YVggPSBldi5jZW50ZXIuY2xpZW50WCAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFgsXG4gICAgICAgICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFk7XG5cbiAgICAgICAgdGhpcy5nZXRDYWxjdWxhdGVkRGF0YShldiwgbGFzdEV2LmNlbnRlciwgZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgVXRpbHMuZXh0ZW5kKGV2LCB7XG4gICAgICAgICAgICBzdGFydEV2ZW50OiBzdGFydEV2LFxuXG4gICAgICAgICAgICBkZWx0YVRpbWU6IGRlbHRhVGltZSxcbiAgICAgICAgICAgIGRlbHRhWDogZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZOiBkZWx0YVksXG5cbiAgICAgICAgICAgIGRpc3RhbmNlOiBVdGlscy5nZXREaXN0YW5jZShzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgICAgICAgIGFuZ2xlOiBVdGlscy5nZXRBbmdsZShzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogVXRpbHMuZ2V0RGlyZWN0aW9uKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgICAgICAgc2NhbGU6IFV0aWxzLmdldFNjYWxlKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcyksXG4gICAgICAgICAgICByb3RhdGlvbjogVXRpbHMuZ2V0Um90YXRpb24oc3RhcnRFdi50b3VjaGVzLCBldi50b3VjaGVzKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZXY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlZ2lzdGVyIG5ldyBnZXN0dXJlXG4gICAgICogQG1ldGhvZCByZWdpc3RlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBnZXN0dXJlIG9iamVjdCwgc2VlIGBnZXN0dXJlcy9gIGZvciBkb2N1bWVudGF0aW9uXG4gICAgICogQHJldHVybiB7QXJyYXl9IGdlc3R1cmVzXG4gICAgICovXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGdlc3R1cmUpIHtcbiAgICAgICAgLy8gYWRkIGFuIGVuYWJsZSBnZXN0dXJlIG9wdGlvbnMgaWYgdGhlcmUgaXMgbm8gZ2l2ZW5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXN0dXJlLmRlZmF1bHRzIHx8IHt9O1xuICAgICAgICBpZihvcHRpb25zW2dlc3R1cmUubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9uc1tnZXN0dXJlLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4dGVuZCBIYW1tZXIgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIEhhbW1lci5nZXN0dXJlIG9wdGlvbnNcbiAgICAgICAgVXRpbHMuZXh0ZW5kKEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgLy8gc2V0IGl0cyBpbmRleFxuICAgICAgICBnZXN0dXJlLmluZGV4ID0gZ2VzdHVyZS5pbmRleCB8fCAxMDAwO1xuXG4gICAgICAgIC8vIGFkZCBIYW1tZXIuZ2VzdHVyZSB0byB0aGUgbGlzdFxuICAgICAgICB0aGlzLmdlc3R1cmVzLnB1c2goZ2VzdHVyZSk7XG5cbiAgICAgICAgLy8gc29ydCB0aGUgbGlzdCBieSBpbmRleFxuICAgICAgICB0aGlzLmdlc3R1cmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgaWYoYS5pbmRleCA8IGIuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihhLmluZGV4ID4gYi5pbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdlc3R1cmVzO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIGhhbW1lclxuICovXG5cbi8qKlxuICogY3JlYXRlIG5ldyBoYW1tZXIgaW5zdGFuY2VcbiAqIGFsbCBtZXRob2RzIHNob3VsZCByZXR1cm4gdGhlIGluc3RhbmNlIGl0c2VsZiwgc28gaXQgaXMgY2hhaW5hYmxlLlxuICpcbiAqIEBjbGFzcyBJbnN0YW5jZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGBIYW1tZXIuZGVmYXVsdHNgXG4gKiBAcmV0dXJuIHtIYW1tZXIuSW5zdGFuY2V9XG4gKi9cbkhhbW1lci5JbnN0YW5jZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBzZXR1cCBIYW1tZXJKUyB3aW5kb3cgZXZlbnRzIGFuZCByZWdpc3RlciBhbGwgZ2VzdHVyZXNcbiAgICAvLyB0aGlzIGFsc28gc2V0cyB1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgc2V0dXAoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBlbGVtZW50XG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogb3B0aW9ucywgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHRzXG4gICAgICogb3B0aW9ucyB3aXRoIGFuIF8gYXJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2VcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgVXRpbHMuZWFjaChvcHRpb25zLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBkZWxldGUgb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgb3B0aW9uc1tVdGlscy50b0NhbWVsQ2FzZShuYW1lKV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIHRoaXMub3B0aW9ucyA9IFV0aWxzLmV4dGVuZChVdGlscy5leHRlbmQoe30sIEhhbW1lci5kZWZhdWx0cyksIG9wdGlvbnMgfHwge30pO1xuXG4gICAgLy8gYWRkIHNvbWUgY3NzIHRvIHRoZSBlbGVtZW50IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBkb2luZyBpdHMgbmF0aXZlIGJlaGF2b2lyXG4gICAgaWYodGhpcy5vcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgICAgIFV0aWxzLnRvZ2dsZUJlaGF2aW9yKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLmJlaGF2aW9yLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBldmVudCBzdGFydCBoYW5kbGVyIG9uIHRoZSBlbGVtZW50IHRvIHN0YXJ0IHRoZSBkZXRlY3Rpb25cbiAgICAgKiBAcHJvcGVydHkgZXZlbnRTdGFydEhhbmRsZXJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRTdGFydEhhbmRsZXIgPSBFdmVudC5vblRvdWNoKGVsZW1lbnQsIEVWRU5UX1NUQVJULCBmdW5jdGlvbihldikge1xuICAgICAgICBpZihzZWxmLmVuYWJsZWQgJiYgZXYuZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICAgICAgICBEZXRlY3Rpb24uc3RhcnREZXRlY3Qoc2VsZiwgZXYpO1xuICAgICAgICB9IGVsc2UgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIKSB7XG4gICAgICAgICAgICBEZXRlY3Rpb24uZGV0ZWN0KGV2KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICoga2VlcCBhIGxpc3Qgb2YgdXNlciBldmVudCBoYW5kbGVycyB3aGljaCBuZWVkcyB0byBiZSByZW1vdmVkIHdoZW4gY2FsbGluZyAnZGlzcG9zZSdcbiAgICAgKiBAcHJvcGVydHkgZXZlbnRIYW5kbGVyc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcbn07XG5cbkhhbW1lci5JbnN0YW5jZS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogYmluZCBldmVudHMgdG8gdGhlIGluc3RhbmNlXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXMgbXVsdGlwbGUgZ2VzdHVyZXMgYnkgc3BsaXR0aW5nIHdpdGggYSBzcGFjZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlci5ldiBldmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24gb25FdmVudChnZXN0dXJlcywgaGFuZGxlcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIEV2ZW50Lm9uKHNlbGYuZWxlbWVudCwgZ2VzdHVyZXMsIGhhbmRsZXIsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRIYW5kbGVycy5wdXNoKHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgZXZlbnRzIHRvIHRoZSBpbnN0YW5jZVxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uIG9mZkV2ZW50KGdlc3R1cmVzLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBFdmVudC5vZmYoc2VsZi5lbGVtZW50LCBnZXN0dXJlcywgaGFuZGxlciwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gVXRpbHMuaW5BcnJheSh7IGdlc3R1cmU6IHR5cGUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XG4gICAgICAgICAgICBpZihpbmRleCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmV2ZW50SGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0cmlnZ2VyIGdlc3R1cmUgZXZlbnRcbiAgICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50RGF0YV1cbiAgICAgKi9cbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZ2VzdHVyZSwgZXZlbnREYXRhKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgIGlmKCFldmVudERhdGEpIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIERPTSBldmVudFxuICAgICAgICB2YXIgZXZlbnQgPSBIYW1tZXIuRE9DVU1FTlQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgIGV2ZW50LmluaXRFdmVudChnZXN0dXJlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZXZlbnQuZ2VzdHVyZSA9IGV2ZW50RGF0YTtcblxuICAgICAgICAvLyB0cmlnZ2VyIG9uIHRoZSB0YXJnZXQgaWYgaXQgaXMgaW4gdGhlIGluc3RhbmNlIGVsZW1lbnQsXG4gICAgICAgIC8vIHRoaXMgaXMgZm9yIGV2ZW50IGRlbGVnYXRpb24gdHJpY2tzXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZihVdGlscy5oYXNQYXJlbnQoZXZlbnREYXRhLnRhcmdldCwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBldmVudERhdGEudGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVuYWJsZSBvZiBkaXNhYmxlIGhhbW1lci5qcyBkZXRlY3Rpb25cbiAgICAgKiBAbWV0aG9kIGVuYWJsZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXRlXG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gc3RhdGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkaXNwb3NlIHRoaXMgaGFtbWVyIGluc3RhbmNlXG4gICAgICogQG1ldGhvZCBkaXNwb3NlXG4gICAgICogQHJldHVybiB7TnVsbH1cbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICB2YXIgaSwgZWg7XG5cbiAgICAgICAgLy8gdW5kbyBhbGwgY2hhbmdlcyBtYWRlIGJ5IHN0b3BfYnJvd3Nlcl9iZWhhdmlvclxuICAgICAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgZmFsc2UpO1xuXG4gICAgICAgIC8vIHVuYmluZCBhbGwgY3VzdG9tIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGZvcihpID0gLTE7IChlaCA9IHRoaXMuZXZlbnRIYW5kbGVyc1srK2ldKTspIHtcbiAgICAgICAgICAgIFV0aWxzLm9mZih0aGlzLmVsZW1lbnQsIGVoLmdlc3R1cmUsIGVoLmhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG5cbiAgICAgICAgLy8gdW5iaW5kIHRoZSBzdGFydCBldmVudCBsaXN0ZW5lclxuICAgICAgICBFdmVudC5vZmYodGhpcy5lbGVtZW50LCBFVkVOVF9UWVBFU1tFVkVOVF9TVEFSVF0sIHRoaXMuZXZlbnRTdGFydEhhbmRsZXIpO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIGdlc3R1cmVzXG4gKi9cbi8qKlxuICogTW92ZSB3aXRoIHggZmluZ2VycyAoZGVmYXVsdCAxKSBhcm91bmQgb24gdGhlIHBhZ2UuXG4gKiBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgaXMgYSBnb29kIHdheSB0byBpbXByb3ZlIGZlZWwgYW5kIHdvcmtpbmcuXG4gKiBgYGBgXG4gKiAgaGFtbWVydGltZS5vbihcImRyYWdcIiwgZnVuY3Rpb24oZXYpIHtcbiAqICAgIGNvbnNvbGUubG9nKGV2KTtcbiAqICAgIGV2Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAqICB9KTtcbiAqIGBgYGBcbiAqXG4gKiBAY2xhc3MgRHJhZ1xuICogQHN0YXRpY1xuICovXG4vKipcbiAqIEBldmVudCBkcmFnXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3N0YXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ2VuZFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYXBsZWZ0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3JpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3VwXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ2Rvd25cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqL1xuKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBkcmFnR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgICB2YXIgY3VyID0gRGV0ZWN0aW9uLmN1cnJlbnQ7XG5cbiAgICAgICAgLy8gbWF4IHRvdWNoZXNcbiAgICAgICAgaWYoaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzID4gMCAmJlxuICAgICAgICAgICAgZXYudG91Y2hlcy5sZW5ndGggPiBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGlmKGV2LmRpc3RhbmNlIDwgaW5zdC5vcHRpb25zLmRyYWdNaW5EaXN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICBjdXIubmFtZSAhPSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDZW50ZXIgPSBjdXIuc3RhcnRFdmVudC5jZW50ZXI7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgZHJhZ2dpbmchXG4gICAgICAgICAgICAgICAgaWYoY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXIubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmKGluc3Qub3B0aW9ucy5kcmFnRGlzdGFuY2VDb3JyZWN0aW9uICYmIGV2LmRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBhIGRyYWcgaXMgdHJpZ2dlcmVkLCBzZXQgdGhlIGV2ZW50IGNlbnRlciB0byBkcmFnTWluRGlzdGFuY2UgcGl4ZWxzIGZyb20gdGhlIG9yaWdpbmFsIGV2ZW50IGNlbnRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpdGhvdXQgdGhpcyBjb3JyZWN0aW9uLCB0aGUgZHJhZ2dlZCBkaXN0YW5jZSB3b3VsZCBqdW1wc3RhcnQgYXQgZHJhZ01pbkRpc3RhbmNlIHBpeGVscyBpbnN0ZWFkIG9mIGF0IDAuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBtaWdodCBiZSB1c2VmdWwgdG8gc2F2ZSB0aGUgb3JpZ2luYWwgc3RhcnQgcG9pbnQgc29tZXdoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gTWF0aC5hYnMoaW5zdC5vcHRpb25zLmRyYWdNaW5EaXN0YW5jZSAvIGV2LmRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q2VudGVyLnBhZ2VYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q2VudGVyLnBhZ2VZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q2VudGVyLmNsaWVudFggKz0gZXYuZGVsdGFYICogZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDZW50ZXIuY2xpZW50WSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIGV2ZW50IGRhdGEgdXNpbmcgbmV3IHN0YXJ0IHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICBldiA9IERldGVjdGlvbi5leHRlbmRFdmVudERhdGEoZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbG9jayBkcmFnIHRvIGF4aXM/XG4gICAgICAgICAgICAgICAgaWYoY3VyLmxhc3RFdmVudC5kcmFnTG9ja1RvQXhpcyB8fFxuICAgICAgICAgICAgICAgICAgICAoIGluc3Qub3B0aW9ucy5kcmFnTG9ja1RvQXhpcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdC5vcHRpb25zLmRyYWdMb2NrTWluRGlzdGFuY2UgPD0gZXYuZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXYuZHJhZ0xvY2tUb0F4aXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGtlZXAgZGlyZWN0aW9uIG9uIHRoZSBheGlzIHRoYXQgdGhlIGRyYWcgZ2VzdHVyZSBzdGFydGVkIG9uXG4gICAgICAgICAgICAgICAgdmFyIGxhc3REaXJlY3Rpb24gPSBjdXIubGFzdEV2ZW50LmRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZihldi5kcmFnTG9ja1RvQXhpcyAmJiBsYXN0RGlyZWN0aW9uICE9PSBldi5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoVXRpbHMuaXNWZXJ0aWNhbChsYXN0RGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXYuZGlyZWN0aW9uID0gKGV2LmRlbHRhWSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldi5kaXJlY3Rpb24gPSAoZXYuZGVsdGFYIDwgMCkgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUsIHRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG4gICAgICAgICAgICAgICAgaWYoIXRyaWdnZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGV2ZW50c1xuICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7XG4gICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcblxuICAgICAgICAgICAgICAgIHZhciBpc1ZlcnRpY2FsID0gVXRpbHMuaXNWZXJ0aWNhbChldi5kaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gYmxvY2sgdGhlIGJyb3dzZXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYoKGluc3Qub3B0aW9ucy5kcmFnQmxvY2tWZXJ0aWNhbCAmJiBpc1ZlcnRpY2FsKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaW5zdC5vcHRpb25zLmRyYWdCbG9ja0hvcml6b250YWwgJiYgIWlzVmVydGljYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgICAgICAgICAgaWYodHJpZ2dlcmVkICYmIGV2LmNoYW5nZWRMZW5ndGggPD0gaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEVWRU5UX0VORDpcbiAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEhhbW1lci5nZXN0dXJlcy5EcmFnID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBpbmRleDogNTAsXG4gICAgICAgIGhhbmRsZXI6IGRyYWdHZXN0dXJlLFxuICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBtaW5pbWFsIG1vdmVtZW50IHRoYXQgaGF2ZSB0byBiZSBtYWRlIGJlZm9yZSB0aGUgZHJhZyBldmVudCBnZXRzIHRyaWdnZXJlZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IGRyYWdNaW5EaXN0YW5jZVxuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRyYWdNaW5EaXN0YW5jZTogMTAsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IGRyYWdEaXN0YW5jZUNvcnJlY3Rpb24gdG8gdHJ1ZSB0byBtYWtlIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgZHJhZ1xuICAgICAgICAgICAgICogYmUgY2FsY3VsYXRlZCBmcm9tIHdoZXJlIHRoZSBkcmFnIHdhcyB0cmlnZ2VyZWQsIG5vdCBmcm9tIHdoZXJlIHRoZSB0b3VjaCBzdGFydGVkLlxuICAgICAgICAgICAgICogVXNlZnVsIHRvIGF2b2lkIGEgamVyay1zdGFydGluZyBkcmFnLCB3aGljaCBjYW4gbWFrZSBmaW5lLWFkanVzdG1lbnRzXG4gICAgICAgICAgICAgKiB0aHJvdWdoIGRyYWdnaW5nIGRpZmZpY3VsdCwgYW5kIGJlIHZpc3VhbGx5IHVuYXBwZWFsaW5nLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IGRyYWdEaXN0YW5jZUNvcnJlY3Rpb25cbiAgICAgICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uOiB0cnVlLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHNldCAwIGZvciB1bmxpbWl0ZWQsIGJ1dCB0aGlzIGNhbiBjb25mbGljdCB3aXRoIHRyYW5zZm9ybVxuICAgICAgICAgICAgICogQHByb3BlcnR5IGRyYWdNYXhUb3VjaGVzXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkcmFnTWF4VG91Y2hlczogMSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBwcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciB3aGVuIGRyYWdnaW5nIG9jY3Vyc1xuICAgICAgICAgICAgICogYmUgY2FyZWZ1bCB3aXRoIGl0LCBpdCBtYWtlcyB0aGUgZWxlbWVudCBhIGJsb2NraW5nIGVsZW1lbnRcbiAgICAgICAgICAgICAqIHdoZW4geW91IGFyZSB1c2luZyB0aGUgZHJhZyBnZXN0dXJlLCBpdCBpcyBhIGdvb2QgcHJhY3RpY2UgdG8gc2V0IHRoaXMgdHJ1ZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IGRyYWdCbG9ja0hvcml6b250YWxcbiAgICAgICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZHJhZ0Jsb2NrSG9yaXpvbnRhbDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc2FtZSBhcyBgZHJhZ0Jsb2NrSG9yaXpvbnRhbGAsIGJ1dCBmb3IgdmVydGljYWwgbW92ZW1lbnRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tWZXJ0aWNhbFxuICAgICAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkcmFnQmxvY2tWZXJ0aWNhbDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogZHJhZ0xvY2tUb0F4aXMga2VlcHMgdGhlIGRyYWcgZ2VzdHVyZSBvbiB0aGUgYXhpcyB0aGF0IGl0IHN0YXJ0ZWQgb24sXG4gICAgICAgICAgICAgKiBJdCBkaXNhbGxvd3MgdmVydGljYWwgZGlyZWN0aW9ucyBpZiB0aGUgaW5pdGlhbCBkaXJlY3Rpb24gd2FzIGhvcml6b250YWwsIGFuZCB2aWNlIHZlcnNhLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IGRyYWdMb2NrVG9BeGlzXG4gICAgICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRyYWdMb2NrVG9BeGlzOiBmYWxzZSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBkcmFnIGxvY2sgb25seSBraWNrcyBpbiB3aGVuIGRpc3RhbmNlID4gZHJhZ0xvY2tNaW5EaXN0YW5jZVxuICAgICAgICAgICAgICogVGhpcyB3YXksIGxvY2tpbmcgb2NjdXJzIG9ubHkgd2hlbiB0aGUgZGlzdGFuY2UgaGFzIGJlY29tZSBsYXJnZSBlbm91Z2ggdG8gcmVsaWFibHkgZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTG9ja01pbkRpc3RhbmNlXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMjVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZHJhZ0xvY2tNaW5EaXN0YW5jZTogMjVcbiAgICAgICAgfVxuICAgIH07XG59KSgnZHJhZycpO1xuXG4vKipcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAqL1xuLyoqXG4gKiB0cmlnZ2VyIGEgc2ltcGxlIGdlc3R1cmUgZXZlbnQsIHNvIHlvdSBjYW4gZG8gYW55dGhpbmcgaW4geW91ciBoYW5kbGVyLlxuICogb25seSB1c2FibGUgaWYgeW91IGtub3cgd2hhdCB5b3VyIGRvaW5nLi4uXG4gKlxuICogQGNsYXNzIEdlc3R1cmVcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZ2VzdHVyZVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbkhhbW1lci5nZXN0dXJlcy5HZXN0dXJlID0ge1xuICAgIG5hbWU6ICdnZXN0dXJlJyxcbiAgICBpbmRleDogMTMzNyxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiByZWxlYXNlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbW9kdWxlIGdlc3R1cmVzXG4gKi9cbi8qKlxuICogVG91Y2ggc3RheXMgYXQgdGhlIHNhbWUgcGxhY2UgZm9yIHggdGltZVxuICpcbiAqIEBjbGFzcyBIb2xkXG4gKiBAc3RhdGljXG4gKi9cbi8qKlxuICogQGV2ZW50IGhvbGRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqL1xuKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdGltZXI7XG5cbiAgICBmdW5jdGlvbiBob2xkR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGluc3Qub3B0aW9ucyxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBEZXRlY3Rpb24uY3VycmVudDtcblxuICAgICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGdlc3R1cmUgc28gd2UgY2FuIGNoZWNrIGluIHRoZSB0aW1lb3V0IGlmIGl0IHN0aWxsIGlzXG4gICAgICAgICAgICAgICAgY3VycmVudC5uYW1lID0gbmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCB0aW1lciBhbmQgaWYgYWZ0ZXIgdGhlIHRpbWVvdXQgaXQgc3RpbGwgaXMgaG9sZCxcbiAgICAgICAgICAgICAgICAvLyB3ZSB0cmlnZ2VyIHRoZSBob2xkIGV2ZW50XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50ICYmIGN1cnJlbnQubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5ob2xkVGltZW91dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgICAgICAgICBpZihldi5kaXN0YW5jZSA+IG9wdGlvbnMuaG9sZFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBIYW1tZXIuZ2VzdHVyZXMuSG9sZCA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgaW5kZXg6IDEwLFxuICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgaG9sZFRpbWVvdXRcbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCA1MDBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaG9sZFRpbWVvdXQ6IDUwMCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBtb3ZlbWVudCBhbGxvd2VkIHdoaWxlIGhvbGRpbmdcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBob2xkVGhyZXNob2xkXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBob2xkVGhyZXNob2xkOiAyXG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZXI6IGhvbGRHZXN0dXJlXG4gICAgfTtcbn0pKCdob2xkJyk7XG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyByZWxlYXNlZCBmcm9tIHRoZSBwYWdlXG4gKlxuICogQGNsYXNzIFJlbGVhc2VcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgcmVsZWFzZVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbkhhbW1lci5nZXN0dXJlcy5SZWxlYXNlID0ge1xuICAgIG5hbWU6ICdyZWxlYXNlJyxcbiAgICBpbmRleDogSW5maW5pdHksXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIHRyaWdnZXJzIHN3aXBlIGV2ZW50cyB3aGVuIHRoZSBlbmQgdmVsb2NpdHkgaXMgYWJvdmUgdGhlIHRocmVzaG9sZFxuICogZm9yIGJlc3QgdXNhZ2UsIHNldCBgcHJldmVudERlZmF1bHRgIChvbiB0aGUgZHJhZyBnZXN0dXJlKSB0byBgdHJ1ZWBcbiAqIGBgYGBcbiAqICBoYW1tZXJ0aW1lLm9uKFwiZHJhZ2xlZnQgc3dpcGVsZWZ0XCIsIGZ1bmN0aW9uKGV2KSB7XG4gKiAgICBjb25zb2xlLmxvZyhldik7XG4gKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gKiAgfSk7XG4gKiBgYGBgXG4gKlxuICogQGNsYXNzIFN3aXBlXG4gKiBAc3RhdGljXG4gKi9cbi8qKlxuICogQGV2ZW50IHN3aXBlXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgc3dpcGVsZWZ0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgc3dpcGVyaWdodFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IHN3aXBldXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBzd2lwZWRvd25cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG5IYW1tZXIuZ2VzdHVyZXMuU3dpcGUgPSB7XG4gICAgbmFtZTogJ3N3aXBlJyxcbiAgICBpbmRleDogNDAsXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZU1pblRvdWNoZXNcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgc3dpcGVNaW5Ub3VjaGVzOiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgc3dpcGVNYXhUb3VjaGVzXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHN3aXBlTWF4VG91Y2hlczogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaG9yaXpvbnRhbCBzd2lwZSB2ZWxvY2l0eVxuICAgICAgICAgKiBAcHJvcGVydHkgc3dpcGVWZWxvY2l0eVhcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMC42XG4gICAgICAgICAqL1xuICAgICAgICBzd2lwZVZlbG9jaXR5WDogMC42LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2ZXJ0aWNhbCBzd2lwZSB2ZWxvY2l0eVxuICAgICAgICAgKiBAcHJvcGVydHkgc3dpcGVWZWxvY2l0eVlcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMC42XG4gICAgICAgICAqL1xuICAgICAgICBzd2lwZVZlbG9jaXR5WTogMC42XG4gICAgfSxcblxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHN3aXBlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICAgICAgdmFyIHRvdWNoZXMgPSBldi50b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gaW5zdC5vcHRpb25zO1xuXG4gICAgICAgICAgICAvLyBtYXggdG91Y2hlc1xuICAgICAgICAgICAgaWYodG91Y2hlcyA8IG9wdGlvbnMuc3dpcGVNaW5Ub3VjaGVzIHx8XG4gICAgICAgICAgICAgICAgdG91Y2hlcyA+IG9wdGlvbnMuc3dpcGVNYXhUb3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgICAgICBpZihldi52ZWxvY2l0eVggPiBvcHRpb25zLnN3aXBlVmVsb2NpdHlYIHx8XG4gICAgICAgICAgICAgICAgZXYudmVsb2NpdHlZID4gb3B0aW9ucy5zd2lwZVZlbG9jaXR5WSkge1xuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgc3dpcGUgZXZlbnRzXG4gICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIFNpbmdsZSB0YXAgYW5kIGEgZG91YmxlIHRhcCBvbiBhIHBsYWNlXG4gKlxuICogQGNsYXNzIFRhcFxuICogQHN0YXRpY1xuICovXG4vKipcbiAqIEBldmVudCB0YXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkb3VibGV0YXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqL1xuKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaGFzTW92ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRhcEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnMsXG4gICAgICAgICAgICBjdXJyZW50ID0gRGV0ZWN0aW9uLmN1cnJlbnQsXG4gICAgICAgICAgICBwcmV2ID0gRGV0ZWN0aW9uLnByZXZpb3VzLFxuICAgICAgICAgICAgc2luY2VQcmV2LFxuICAgICAgICAgICAgZGlkRG91YmxlVGFwO1xuXG4gICAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICAgICAgICAgIGhhc01vdmVkID0gaGFzTW92ZWQgfHwgKGV2LmRpc3RhbmNlID4gb3B0aW9ucy50YXBNYXhEaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRVZFTlRfRU5EOlxuICAgICAgICAgICAgICAgIGlmKCFVdGlscy5pblN0cihldi5zcmNFdmVudC50eXBlLCAnY2FuY2VsJykgJiYgZXYuZGVsdGFUaW1lIDwgb3B0aW9ucy50YXBNYXhUaW1lICYmICFoYXNNb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBnZXN0dXJlLCBmb3IgdGhlIGRvdWJsZSB0YXAgc2luY2UgdGhlc2UgYXJlIHR3byBkaWZmZXJlbnQgZ2VzdHVyZSBkZXRlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIHNpbmNlUHJldiA9IHByZXYgJiYgcHJldi5sYXN0RXZlbnQgJiYgZXYudGltZVN0YW1wIC0gcHJldi5sYXN0RXZlbnQudGltZVN0YW1wO1xuICAgICAgICAgICAgICAgICAgICBkaWREb3VibGVUYXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBkb3VibGUgdGFwXG4gICAgICAgICAgICAgICAgICAgIGlmKHByZXYgJiYgcHJldi5uYW1lID09IG5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzaW5jZVByZXYgJiYgc2luY2VQcmV2IDwgb3B0aW9ucy5kb3VibGVUYXBJbnRlcnZhbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LmRpc3RhbmNlIDwgb3B0aW9ucy5kb3VibGVUYXBEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCdkb3VibGV0YXAnLCBldik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWREb3VibGVUYXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gYSBzaW5nbGUgdGFwXG4gICAgICAgICAgICAgICAgICAgIGlmKCFkaWREb3VibGVUYXAgfHwgb3B0aW9ucy50YXBBbHdheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIoY3VycmVudC5uYW1lLCBldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBIYW1tZXIuZ2VzdHVyZXMuVGFwID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBpbmRleDogMTAwLFxuICAgICAgICBoYW5kbGVyOiB0YXBHZXN0dXJlLFxuICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBtYXggdGltZSBvZiBhIHRhcCwgdGhpcyBpcyBmb3IgdGhlIHNsb3cgdGFwcGVyc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHRhcE1heFRpbWVcbiAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAyNTBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGFwTWF4VGltZTogMjUwLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIG1heCBkaXN0YW5jZSBvZiBtb3ZlbWVudCBvZiBhIHRhcCwgdGhpcyBpcyBmb3IgdGhlIHNsb3cgdGFwcGVyc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHRhcE1heERpc3RhbmNlXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGFwTWF4RGlzdGFuY2U6IDEwLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGFsd2F5cyB0cmlnZ2VyIHRoZSBgdGFwYCBldmVudCwgZXZlbiB3aGlsZSBkb3VibGUtdGFwcGluZ1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHRhcEFsd2F5c1xuICAgICAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRhcEFsd2F5czogdHJ1ZSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBtYXggZGlzdGFuY2UgYmV0d2VlbiB0d28gdGFwc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcERpc3RhbmNlXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMjBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZG91YmxlVGFwRGlzdGFuY2U6IDIwLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIG1heCB0aW1lIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBJbnRlcnZhbFxuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDMwMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkb3VibGVUYXBJbnRlcnZhbDogMzAwXG4gICAgICAgIH1cbiAgICB9O1xufSkoJ3RhcCcpO1xuXG4vKipcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAqL1xuLyoqXG4gKiB3aGVuIGEgdG91Y2ggaXMgYmVpbmcgdG91Y2hlZCBhdCB0aGUgcGFnZVxuICpcbiAqIEBjbGFzcyBUb3VjaFxuICogQHN0YXRpY1xuICovXG4vKipcbiAqIEBldmVudCB0b3VjaFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbkhhbW1lci5nZXN0dXJlcy5Ub3VjaCA9IHtcbiAgICBuYW1lOiAndG91Y2gnLFxuICAgIGluZGV4OiAtSW5maW5pdHksXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgYXQgdG91Y2hzdGFydCwgYW5kIG1ha2VzIHRoZSBlbGVtZW50IGJsb2NraW5nIGJ5IGRpc2FibGluZyB0aGUgc2Nyb2xsaW5nIG9mIHRoZSBwYWdlLFxuICAgICAgICAgKiBidXQgaXQgaW1wcm92ZXMgZ2VzdHVyZXMgbGlrZSB0cmFuc2Zvcm1pbmcgYW5kIGRyYWdnaW5nLlxuICAgICAgICAgKiBiZSBjYXJlZnVsIHdpdGggdXNpbmcgdGhpcywgaXQgY2FuIGJlIHZlcnkgYW5ub3lpbmcgZm9yIHVzZXJzIHRvIGJlIHN0dWNrIG9uIHRoZSBwYWdlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50RGVmYXVsdFxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZGlzYWJsZSBtb3VzZSBldmVudHMsIHNvIG9ubHkgdG91Y2ggKG9yIHBlbiEpIGlucHV0IHRyaWdnZXJzIGV2ZW50c1xuICAgICAgICAgKiBAcHJvcGVydHkgcHJldmVudE1vdXNlXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcHJldmVudE1vdXNlOiBmYWxzZVxuICAgIH0sXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gdG91Y2hHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICAgIGlmKGluc3Qub3B0aW9ucy5wcmV2ZW50TW91c2UgJiYgZXYucG9pbnRlclR5cGUgPT0gUE9JTlRFUl9NT1VTRSkge1xuICAgICAgICAgICAgZXYuc3RvcERldGVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaW5zdC5vcHRpb25zLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIKSB7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3RvdWNoJywgZXYpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbW9kdWxlIGdlc3R1cmVzXG4gKi9cbi8qKlxuICogVXNlciB3YW50IHRvIHNjYWxlIG9yIHJvdGF0ZSB3aXRoIDIgZmluZ2Vyc1xuICogUHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGlzIGEgZ29vZCB3YXkgdG8gaW1wcm92ZSBmZWVsIGFuZCB3b3JraW5nLiBUaGlzIGNhbiBiZSBkb25lIHdpdGggdGhlXG4gKiBgcHJldmVudERlZmF1bHRgIG9wdGlvbi5cbiAqXG4gKiBAY2xhc3MgVHJhbnNmb3JtXG4gKiBAc3RhdGljXG4gKi9cbi8qKlxuICogQGV2ZW50IHRyYW5zZm9ybVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IHRyYW5zZm9ybXN0YXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgdHJhbnNmb3JtZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgcGluY2hpblxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IHBpbmNob3V0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgcm90YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKi9cbihmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHRyaWdnZXJlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgICAgICAgICAgLy8gYXQgbGVhc3QgbXVsdGl0b3VjaFxuICAgICAgICAgICAgICAgIGlmKGV2LnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlVGhyZXNob2xkID0gTWF0aC5hYnMoMSAtIGV2LnNjYWxlKTtcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpb25UaHJlc2hvbGQgPSBNYXRoLmFicyhldi5yb3RhdGlvbik7XG5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGlmKHNjYWxlVGhyZXNob2xkIDwgaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblNjYWxlICYmXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uVGhyZXNob2xkIDwgaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblJvdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgdHJhbnNmb3JtaW5nIVxuICAgICAgICAgICAgICAgIERldGVjdGlvbi5jdXJyZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgdGltZSwgdHJpZ2dlciBkcmFnc3RhcnQgZXZlbnRcbiAgICAgICAgICAgICAgICBpZighdHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7IC8vIGJhc2ljIHRyYW5zZm9ybSBldmVudFxuXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciByb3RhdGUgZXZlbnRcbiAgICAgICAgICAgICAgICBpZihyb3RhdGlvblRocmVzaG9sZCA+IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5Sb3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3JvdGF0ZScsIGV2KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHBpbmNoIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYoc2NhbGVUaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCdwaW5jaCcsIGV2KTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCdwaW5jaCcgKyAoZXYuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnKSwgZXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICAgICAgICAgIGlmKHRyaWdnZXJlZCAmJiBldi5jaGFuZ2VkTGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEhhbW1lci5nZXN0dXJlcy5UcmFuc2Zvcm0gPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGluZGV4OiA0NSxcbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbWluaW1hbCBzY2FsZSBmYWN0b3IsIG5vIHNjYWxlIGlzIDEsIHpvb21pbiBpcyB0byAwIGFuZCB6b29tb3V0IHVudGlsIGhpZ2hlciB0aGVuIDFcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5TY2FsZVxuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDAuMDFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHJhbnNmb3JtTWluU2NhbGU6IDAuMDEsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHRyYW5zZm9ybU1pblJvdGF0aW9uXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0cmFuc2Zvcm1NaW5Sb3RhdGlvbjogMVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXI6IHRyYW5zZm9ybUdlc3R1cmVcbiAgICB9O1xufSkoJ3RyYW5zZm9ybScpO1xuXG4vKipcbiAqIEBtb2R1bGUgaGFtbWVyXG4gKi9cblxuLy8gQU1EIGV4cG9ydFxuaWYodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW1tZXI7XG4gICAgfSk7XG4vLyBjb21tb25qcyBleHBvcnRcbn0gZWxzZSBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSGFtbWVyO1xuLy8gYnJvd3NlciBleHBvcnRcbn0gZWxzZSB7XG4gICAgd2luZG93LkhhbW1lciA9IEhhbW1lcjtcbn1cblxufSkod2luZG93KTsiLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMTYuMFxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgaG9va0NhbGxiYWNrO1xuXG5mdW5jdGlvbiBob29rcyAoKSB7XG4gICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG4vLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG5mdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICB2YXIgaztcbiAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgIC8vIGV2ZW4gaWYgaXRzIG5vdCBvd24gcHJvcGVydHkgSSdkIHN0aWxsIGNhbGwgaXQgbm9uLWVtcHR5XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgfVxuICAgIHJldHVybiBtLl9wZjtcbn1cblxudmFyIHNvbWU7XG5pZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG59IGVsc2Uge1xuICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbnZhciBzb21lJDEgPSBzb21lO1xuXG5mdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZSQxLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpc05vd1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtLl9pc1ZhbGlkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG59XG5cbi8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbi8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG52YXIgbW9tZW50UHJvcGVydGllcyA9IGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGkgaW4gbW9tZW50UHJvcGVydGllcykge1xuICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG87XG59XG5cbnZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbi8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG5mdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAvLyBvYmplY3RzLlxuICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAvLyAtMCAtPiAwXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG59XG5cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFyZztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCBmbik7XG59XG5cbnZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICB9XG4gICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgIH1cbn1cblxuaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG5ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICB2YXIgcHJvcCwgaTtcbiAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9vcmRpbmFsUGFyc2VMZW5pZW50LlxuICAgIHRoaXMuX29yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UgKyAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLCBwcm9wO1xuICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xuICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICB9XG59XG5cbnZhciBrZXlzO1xuXG5pZiAoT2JqZWN0LmtleXMpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXM7XG59IGVsc2Uge1xuICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cblxudmFyIGtleXMkMSA9IGtleXM7XG5cbnZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgc2FtZUVsc2UgOiAnTCdcbn07XG5cbmZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbn1cblxudmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgTFQgICA6ICdoOm1tIEEnLFxuICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJ1xufTtcblxuZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbn1cblxudmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG5mdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xufVxuXG52YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xudmFyIGRlZmF1bHRPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG5mdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG59XG5cbnZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgbSAgOiAnYSBtaW51dGUnLFxuICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgIGggIDogJ2FuIGhvdXInLFxuICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICBkICA6ICdhIGRheScsXG4gICAgZGQgOiAnJWQgZGF5cycsXG4gICAgTSAgOiAnYSBtb250aCcsXG4gICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICB5ICA6ICdhIHllYXInLFxuICAgIHl5IDogJyVkIHllYXJzJ1xufTtcblxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbn1cblxudmFyIGFsaWFzZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgIHByb3A7XG5cbiAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbn1cblxudmFyIHByaW9yaXRpZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xufVxuXG5mdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgdmFyIHVuaXRzID0gW107XG4gICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICB1bml0cy5wdXNoKHt1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XX0pO1xuICAgIH1cbiAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5pdHM7XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldCAobW9tLCB1bml0KSB7XG4gICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICBpZiAobW9tLmlzVmFsaWQoKSkge1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBzdHJpbmdHZXQgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuXG5mdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbn1cblxudmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG52YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxudmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG52YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuLy8gdG9rZW46ICAgICdNJ1xuLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuLy8gb3JkaW5hbDogICdNbydcbi8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0b2tlbikge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgIH1cbiAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufVxuXG4vLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbmZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xufVxuXG5mdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICB2YXIgaSA9IDU7XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgfVxuXG4gICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGkgLT0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0O1xufVxuXG52YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxudmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxudmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxudmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbnZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbnZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbnZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG52YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbnZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbnZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG52YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbnZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbnZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxudmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbnZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbnZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbi8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xudmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG5cbnZhciByZWdleGVzID0ge307XG5cbmZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbn1cblxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xufVxuXG52YXIgdG9rZW5zID0ge307XG5cbmZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgIH1cbn1cblxudmFyIFlFQVIgPSAwO1xudmFyIE1PTlRIID0gMTtcbnZhciBEQVRFID0gMjtcbnZhciBIT1VSID0gMztcbnZhciBNSU5VVEUgPSA0O1xudmFyIFNFQ09ORCA9IDU7XG52YXIgTUlMTElTRUNPTkQgPSA2O1xudmFyIFdFRUsgPSA3O1xudmFyIFdFRUtEQVkgPSA4O1xuXG52YXIgaW5kZXhPZjtcblxuaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xufSBlbHNlIHtcbiAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgLy8gSSBrbm93XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbn1cblxudmFyIGluZGV4T2YkMSA9IGluZGV4T2Y7XG5cbmZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG4vLyBMT0NBTEVTXG5cbnZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vO1xudmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHM7XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG52YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnQ7XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIC8vIE5vIG9wXG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICByZXR1cm4gbW9tO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG59XG5cbnZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgaSwgbW9tO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgfVxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbmFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbmZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xufVxuXG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG59XG5cbi8vIEhPT0tTXG5cbmhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbn07XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG5mdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgLy9jYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgLy90aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAvL3RoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cblxuLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG5hZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuLy8gUFJJT1JJVElFU1xuXG5hZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIExPQ0FMRVNcblxuZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG59O1xuXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xufVxuXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbmFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgfVxuICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG59XG5cbi8vIExPQ0FMRVNcblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXSA6XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cblxuICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG59XG5cbmZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbn1cblxuYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG5hZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG5hZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbmFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xufSk7XG5cbmZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgfSk7XG59XG5cbm1lcmlkaWVtKCdhJywgdHJ1ZSk7XG5tZXJpZGllbSgnQScsIGZhbHNlKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4vLyBQQVJTSU5HXG5cbmZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xufVxuXG5hZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbmFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG5hZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG5hZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbmFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xufSk7XG5hZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbn0pO1xuYWRkUGFyc2VUb2tlbignaG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbn0pO1xuYWRkUGFyc2VUb2tlbignaG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbn0pO1xuYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbn0pO1xuYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbn0pO1xuXG4vLyBMT0NBTEVTXG5cbmZ1bmN0aW9uIGxvY2FsZUlzUE0gKGlucHV0KSB7XG4gICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xufVxuXG52YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbmZ1bmN0aW9uIGxvY2FsZU1lcmlkaWVtIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICB9XG59XG5cblxuLy8gTU9NRU5UU1xuXG4vLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbi8vIHNwZWNpZmllZCB3aGljaCBob3VyIGhlIHdhbnRzLiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbi8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuLy8gdGhpcyBydWxlLlxudmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4vLyBtb250aHNcbi8vIHdlZWtcbi8vIHdlZWtkYXlzXG4vLyBtZXJpZGllbVxudmFyIGJhc2VDb25maWcgPSB7XG4gICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxuICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgb3JkaW5hbFBhcnNlOiBkZWZhdWx0T3JkaW5hbFBhcnNlLFxuICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcblxuICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgd2VlazogZGVmYXVsdExvY2FsZVdlZWssXG5cbiAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXG5cbiAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxufTtcblxuLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xudmFyIGxvY2FsZXMgPSB7fTtcbnZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xudmFyIGdsb2JhbExvY2FsZTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbn1cblxuLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4vLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgIHJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4vLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuLy8gbG9jYWxlIGtleS5cbmZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICB2YXIgZGF0YTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XG4gICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgbG9jYWxlIEFGVEVSIGFsbCBjaGlsZCBsb2NhbGVzIGhhdmUgYmVlblxuICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG59XG5cbi8vIHJldHVybnMgbG9jYWxlIGRhdGFcbmZ1bmN0aW9uIGdldExvY2FsZSAoa2V5KSB7XG4gICAgdmFyIGxvY2FsZTtcblxuICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgIHJldHVybiBrZXlzJDEobG9jYWxlcyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICB2YXIgb3ZlcmZsb3c7XG4gICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgIC0xO1xuXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIGlzbyA4NjAxIHJlZ2V4XG4vLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbnZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xudmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG52YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxudmFyIGlzb0RhdGVzID0gW1xuICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcbiAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgWydZWVlZREREJywgL1xcZHs3fS9dXG5dO1xuXG4vLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG52YXIgaXNvVGltZXMgPSBbXG4gICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgWydISCcsIC9cXGRcXGQvXVxuXTtcblxudmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG5mdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgIHZhciBpLCBsLFxuICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cbn1cblxuaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIElTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgIH1cbik7XG5cbi8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgIH1cbiAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbi8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG5mdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyKSB7XG4gICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICB9XG5cbiAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgIH1cblxuICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgIHcgPSBjb25maWcuX3c7XG4gICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICBkb3cgPSAxO1xuICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxuICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgIH1cbn1cblxuLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xufVxuXG5cbmZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgIHZhciBpc1BtO1xuXG4gICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG4gICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgIGksXG4gICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xufVxuXG5mdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICB9KTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9ICBlbHNlIHtcbiAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnO1xufVxuXG5mdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgIHZhciBjID0ge307XG5cbiAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgYy5fbCA9IGxvY2FsZTtcbiAgICBjLl9pID0gaW5wdXQ7XG4gICAgYy5fZiA9IGZvcm1hdDtcbiAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbn1cblxudmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG52YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbi8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4vLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4vL1xuLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbmZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgIHZhciByZXMsIGk7XG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgfVxuICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKCk7XG4gICAgfVxuICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG5mdW5jdGlvbiBtaW4gKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gbWF4ICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbn1cblxudmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbn07XG5cbmZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgd2Vla3MgKiA3O1xuICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICB0aGlzLl9idWJibGUoKTtcbn1cblxuZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBhYnNSb3VuZCAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICB9XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICB9KTtcbn1cblxub2Zmc2V0KCdaJywgJzonKTtcbm9mZnNldCgnWlonLCAnJyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbmFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG5hZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIHRpbWV6b25lIGNodW5rZXJcbi8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG52YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbmZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAwIDpcbiAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG59XG5cbi8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG5mdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgdmFyIHJlcywgZGlmZjtcbiAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xufVxuXG4vLyBIT09LU1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4vLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbmhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBNT01FTlRTXG5cbi8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbi8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbi8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbi8vXG4vLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbi8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4vLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB7fTtcblxuICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICBpZiAoYy5fYSkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xufVxuXG5mdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbn1cblxuLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG52YXIgYXNwTmV0UmVnZXggPSAvXihcXC0pPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xuXG4vLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxudmFyIGlzb1JlZ2V4ID0gL14oLSk/UCg/OigtP1swLTksLl0qKVkpPyg/OigtP1swLTksLl0qKU0pPyg/OigtP1swLTksLl0qKVcpPyg/OigtP1swLTksLl0qKUQpPyg/OlQoPzooLT9bMC05LC5dKilIKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilTKT8pPyQvO1xuXG5mdW5jdGlvbiBjcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHJldCxcbiAgICAgICAgZGlmZlJlcztcblxuICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICBoICA6IHRvSW50KG1hdGNoW0hPVVJdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICBtcyA6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24gLy8gdGhlIG1pbGxpc2Vjb25kIGRlY2ltYWwgcG9pbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG1hdGNoXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBjcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbmNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbn1cblxuZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgIH1cblxuICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbmZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKGRheXMpIHtcbiAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAobW9udGhzKSB7XG4gICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgIH1cbn1cblxudmFyIGFkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xudmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG5mdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG59XG5cbmZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSkpO1xufVxuXG5mdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShmcm9tLCB1bml0cykpICYmXG4gICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpIDogIXRoaXMuaXNBZnRlcih0bywgdW5pdHMpKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICBpbnB1dE1zO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVPckFmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVPckJlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG59XG5cbmZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgIHZhciB0aGF0LFxuICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgIGRlbHRhLCBvdXRwdXQ7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgaWYgKHVuaXRzID09PSAneWVhcicgfHwgdW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAzO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDEyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGEgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGVsdGEgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgdW5pdHMgPT09ICdob3VyJyA/IGRlbHRhIC8gMzZlNSA6IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBkZWx0YTtcbiAgICB9XG4gICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgIH1cblxuICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbn1cblxuaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG5ob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG5mdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xufVxuXG5mdW5jdGlvbiB0b0lTT1N0cmluZyAoKSB7XG4gICAgdmFyIG0gPSB0aGlzLmNsb25lKCkudXRjKCk7XG4gICAgaWYgKDAgPCBtLnllYXIoKSAmJiBtLnllYXIoKSA8PSA5OTk5KSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAqXG4gKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICovXG5mdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiAnbW9tZW50LmludmFsaWQoLyogJyArIHRoaXMuX2kgKyAnICovKSc7XG4gICAgfVxuICAgIHZhciBmdW5jID0gJ21vbWVudCc7XG4gICAgdmFyIHpvbmUgPSAnJztcbiAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICB6b25lID0gJ1onO1xuICAgIH1cbiAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICB2YXIgeWVhciA9ICgwIDwgdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xufVxuXG4vLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4vLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG5mdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxudmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG5mdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xufVxuXG5mdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgIH1cblxuICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICB9XG4gICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgIH1cblxuICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cbiAgICBpZiAodW5pdHMgPT09ICdkYXRlJykge1xuICAgICAgICB1bml0cyA9ICdkYXknO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG59XG5cbmZ1bmN0aW9uIHZhbHVlT2YgKCkge1xuICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xufVxuXG5mdW5jdGlvbiB1bml4ICgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xufVxuXG5mdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbn1cblxuZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkJDEgKCkge1xuICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbn1cblxuZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgfTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbn1cblxuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xufVxuXG5mdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbmFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbi8vIFBSSU9ST0lUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGlzU3RyaWN0ID8gbG9jYWxlLl9vcmRpbmFsUGFyc2UgOiBsb2NhbGUuX29yZGluYWxQYXJzZUxlbmllbnQ7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG5hZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbn0pO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG5hZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG59KTtcblxuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbnZhciB0b2tlbjtcbmZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xufVxuXG5mb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG59XG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbmFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xufVxuXG5mdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xufVxuXG52YXIgcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG5wcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcbnByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbnByb3RvLmNsb25lICAgICAgICAgICAgID0gY2xvbmU7XG5wcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG5wcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xucHJvdG8uZm9ybWF0ICAgICAgICAgICAgPSBmb3JtYXQ7XG5wcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG5wcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG5wcm90by50byAgICAgICAgICAgICAgICA9IHRvO1xucHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbnByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xucHJvdG8uaW52YWxpZEF0ICAgICAgICAgPSBpbnZhbGlkQXQ7XG5wcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG5wcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xucHJvdG8uaXNCZXR3ZWVuICAgICAgICAgPSBpc0JldHdlZW47XG5wcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbnByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbnByb3RvLmlzU2FtZU9yQmVmb3JlICAgID0gaXNTYW1lT3JCZWZvcmU7XG5wcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMTtcbnByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbnByb3RvLmxvY2FsZSAgICAgICAgICAgID0gbG9jYWxlO1xucHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xucHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG5wcm90by5taW4gICAgICAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbnByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xucHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG5wcm90by5zdGFydE9mICAgICAgICAgICA9IHN0YXJ0T2Y7XG5wcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xucHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xucHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbnByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xucHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbnByb3RvLmluc3BlY3QgICAgICAgICAgID0gaW5zcGVjdDtcbnByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xucHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbnByb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbnByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbnByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuXG4vLyBZZWFyXG5wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbnByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuXG4vLyBXZWVrIFllYXJcbnByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG5wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4vLyBRdWFydGVyXG5wcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4vLyBNb250aFxucHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbnByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbi8vIFdlZWtcbnByb3RvLndlZWsgICAgICAgICAgID0gcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbnByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbnByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG5wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4vLyBEYXlcbnByb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xucHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG5wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xucHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbnByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbi8vIEhvdXJcbnByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbi8vIE1pbnV0ZVxucHJvdG8ubWludXRlID0gcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcblxuLy8gU2Vjb25kXG5wcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuXG4vLyBNaWxsaXNlY29uZFxucHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcblxuLy8gT2Zmc2V0XG5wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbnByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG5wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG5wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xucHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbnByb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG5wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG5wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xucHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbnByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbi8vIFRpbWV6b25lXG5wcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xucHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcblxuLy8gRGVwcmVjYXRpb25zXG5wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG5wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbnByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xucHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsIGdldFNldFpvbmUpO1xucHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbn1cblxuZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xufVxuXG52YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbnByb3RvJDEuY2FsZW5kYXIgICAgICAgID0gY2FsZW5kYXI7XG5wcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xucHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbnByb3RvJDEub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbnByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xucHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG5wcm90byQxLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlVGltZTtcbnByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbnByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4vLyBNb250aFxucHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG5wcm90byQxLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xucHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbnByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbnByb3RvJDEubW9udGhzU2hvcnRSZWdleCAgPSBtb250aHNTaG9ydFJlZ2V4O1xuXG4vLyBXZWVrXG5wcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xucHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xucHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4vLyBEYXkgb2YgV2Vla1xucHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbnByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG5wcm90byQxLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG5wcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbnByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xucHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggID0gICAgICAgIHdlZWtkYXlzU2hvcnRSZWdleDtcbnByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4vLyBIb3Vyc1xucHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbnByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuZnVuY3Rpb24gZ2V0JDEgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8vICgpXG4vLyAoNSlcbi8vIChmbXQsIDUpXG4vLyAoZm10KVxuLy8gKHRydWUpXG4vLyAodHJ1ZSwgNSlcbi8vICh0cnVlLCBmbXQsIDUpXG4vLyAodHJ1ZSwgZm10KVxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbn1cblxuZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgIH1cbn0pO1xuXG4vLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG5ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbnZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbmZ1bmN0aW9uIGFicyAoKSB7XG4gICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgIHZhciBvdGhlciA9IGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xufVxuXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG5mdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbn1cblxuLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbmZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xufVxuXG5mdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgbW9udGhzID0gMDtcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICBtb250aHMgJT0gMTI7XG5cbiAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcbiAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xufVxuXG5mdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xufVxuXG5mdW5jdGlvbiBhcyAodW5pdHMpIHtcbiAgICB2YXIgZGF5cztcbiAgICB2YXIgbW9udGhzO1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgfTtcbn1cblxudmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xudmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG52YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbnZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xudmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG52YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbnZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xudmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbmZ1bmN0aW9uIGdldCQyICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIHJldHVybiB0aGlzW3VuaXRzICsgJ3MnXSgpO1xufVxuXG5mdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgICB9O1xufVxuXG52YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG52YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xudmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbnZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xudmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbnZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbnZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG5mdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG59XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgdGhyZXNob2xkcyA9IHtcbiAgICBzOiA0NSwgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgbTogNDUsICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICBoOiAyMiwgIC8vIGhvdXJzIHRvIGRheVxuICAgIGQ6IDI2LCAgLy8gZGF5cyB0byBtb250aFxuICAgIE06IDExICAgLy8gbW9udGhzIHRvIHllYXJcbn07XG5cbi8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG5mdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgIHZhciBhID0gc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG5mdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgIH1cbiAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG5mdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgIH1cbiAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgdmFyIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG59XG5cbnZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG5mdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBhYnMkMSh0aGlzLl9tb250aHMpO1xuICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgIHNlY29uZHMgJT0gNjA7XG4gICAgbWludXRlcyAlPSA2MDtcblxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgIHZhciBZID0geWVhcnM7XG4gICAgdmFyIE0gPSBtb250aHM7XG4gICAgdmFyIEQgPSBkYXlzO1xuICAgIHZhciBoID0gaG91cnM7XG4gICAgdmFyIG0gPSBtaW51dGVzO1xuICAgIHZhciBzID0gc2Vjb25kcztcbiAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgIH1cblxuICAgIHJldHVybiAodG90YWwgPCAwID8gJy0nIDogJycpICtcbiAgICAgICAgJ1AnICtcbiAgICAgICAgKFkgPyBZICsgJ1knIDogJycpICtcbiAgICAgICAgKE0gPyBNICsgJ00nIDogJycpICtcbiAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAoaCA/IGggKyAnSCcgOiAnJykgK1xuICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAocyA/IHMgKyAnUycgOiAnJyk7XG59XG5cbnZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG5wcm90byQyLmFicyAgICAgICAgICAgID0gYWJzO1xucHJvdG8kMi5hZGQgICAgICAgICAgICA9IGFkZCQxO1xucHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XG5wcm90byQyLmFzICAgICAgICAgICAgID0gYXM7XG5wcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG5wcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xucHJvdG8kMi5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbnByb3RvJDIuYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xucHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbnByb3RvJDIuYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xucHJvdG8kMi5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xucHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG5wcm90byQyLnZhbHVlT2YgICAgICAgID0gdmFsdWVPZiQxO1xucHJvdG8kMi5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbnByb3RvJDIuZ2V0ICAgICAgICAgICAgPSBnZXQkMjtcbnByb3RvJDIubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG5wcm90byQyLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbnByb3RvJDIubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xucHJvdG8kMi5ob3VycyAgICAgICAgICA9IGhvdXJzO1xucHJvdG8kMi5kYXlzICAgICAgICAgICA9IGRheXM7XG5wcm90byQyLndlZWtzICAgICAgICAgID0gd2Vla3M7XG5wcm90byQyLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xucHJvdG8kMi55ZWFycyAgICAgICAgICA9IHllYXJzO1xucHJvdG8kMi5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xucHJvdG8kMi50b0lTT1N0cmluZyAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLnRvU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIudG9KU09OICAgICAgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbnByb3RvJDIubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4vLyBEZXByZWNhdGlvbnNcbnByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgdG9JU09TdHJpbmckMSk7XG5wcm90byQyLmxhbmcgPSBsYW5nO1xuXG4vLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xufSk7XG5hZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbn0pO1xuXG4vLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuaG9va3MudmVyc2lvbiA9ICcyLjE2LjAnO1xuXG5zZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG5ob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBwcm90bztcbmhvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbmhvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbmhvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbmhvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVUQztcbmhvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVuaXg7XG5ob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0TW9udGhzO1xuaG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuaG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuaG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gY3JlYXRlSW52YWxpZDtcbmhvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZUR1cmF0aW9uO1xuaG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG5ob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0V2Vla2RheXM7XG5ob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBjcmVhdGVJblpvbmU7XG5ob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBnZXRMb2NhbGU7XG5ob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuaG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdE1vbnRoc1Nob3J0O1xuaG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdFdlZWtkYXlzTWluO1xuaG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuaG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xuaG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbGlzdExvY2FsZXM7XG5ob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0V2Vla2RheXNTaG9ydDtcbmhvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbmhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbmhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xuaG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gcHJvdG87XG5cbnJldHVybiBob29rcztcblxufSkpKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTIgQ3JhaWcgQ2FtcGJlbGxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBNb3VzZXRyYXAgaXMgYSBzaW1wbGUga2V5Ym9hcmQgc2hvcnRjdXQgbGlicmFyeSBmb3IgSmF2YXNjcmlwdCB3aXRoXG4gKiBubyBleHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqXG4gKiBAdmVyc2lvbiAxLjEuMlxuICogQHVybCBjcmFpZy5pcy9raWxsaW5nL21pY2VcbiAqL1xuXG4gIC8qKlxuICAgKiBtYXBwaW5nIG9mIHNwZWNpYWwga2V5Y29kZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBrZXlzXG4gICAqXG4gICAqIGV2ZXJ5dGhpbmcgaW4gdGhpcyBkaWN0aW9uYXJ5IGNhbm5vdCB1c2Uga2V5cHJlc3MgZXZlbnRzXG4gICAqIHNvIGl0IGhhcyB0byBiZSBoZXJlIHRvIG1hcCB0byB0aGUgY29ycmVjdCBrZXljb2RlcyBmb3JcbiAgICoga2V5dXAva2V5ZG93biBldmVudHNcbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBfTUFQID0ge1xuICAgICAgICAgIDg6ICdiYWNrc3BhY2UnLFxuICAgICAgICAgIDk6ICd0YWInLFxuICAgICAgICAgIDEzOiAnZW50ZXInLFxuICAgICAgICAgIDE2OiAnc2hpZnQnLFxuICAgICAgICAgIDE3OiAnY3RybCcsXG4gICAgICAgICAgMTg6ICdhbHQnLFxuICAgICAgICAgIDIwOiAnY2Fwc2xvY2snLFxuICAgICAgICAgIDI3OiAnZXNjJyxcbiAgICAgICAgICAzMjogJ3NwYWNlJyxcbiAgICAgICAgICAzMzogJ3BhZ2V1cCcsXG4gICAgICAgICAgMzQ6ICdwYWdlZG93bicsXG4gICAgICAgICAgMzU6ICdlbmQnLFxuICAgICAgICAgIDM2OiAnaG9tZScsXG4gICAgICAgICAgMzc6ICdsZWZ0JyxcbiAgICAgICAgICAzODogJ3VwJyxcbiAgICAgICAgICAzOTogJ3JpZ2h0JyxcbiAgICAgICAgICA0MDogJ2Rvd24nLFxuICAgICAgICAgIDQ1OiAnaW5zJyxcbiAgICAgICAgICA0NjogJ2RlbCcsXG4gICAgICAgICAgOTE6ICdtZXRhJyxcbiAgICAgICAgICA5MzogJ21ldGEnLFxuICAgICAgICAgIDIyNDogJ21ldGEnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIG1hcHBpbmcgZm9yIHNwZWNpYWwgY2hhcmFjdGVycyBzbyB0aGV5IGNhbiBzdXBwb3J0XG4gICAgICAgKlxuICAgICAgICogdGhpcyBkaWN0aW9uYXJ5IGlzIG9ubHkgdXNlZCBpbmNhc2UgeW91IHdhbnQgdG8gYmluZCBhXG4gICAgICAgKiBrZXl1cCBvciBrZXlkb3duIGV2ZW50IHRvIG9uZSBvZiB0aGVzZSBrZXlzXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgX0tFWUNPREVfTUFQID0ge1xuICAgICAgICAgIDEwNjogJyonLFxuICAgICAgICAgIDEwNzogJysnLFxuICAgICAgICAgIDEwOTogJy0nLFxuICAgICAgICAgIDExMDogJy4nLFxuICAgICAgICAgIDExMSA6ICcvJyxcbiAgICAgICAgICAxODY6ICc7JyxcbiAgICAgICAgICAxODc6ICc9JyxcbiAgICAgICAgICAxODg6ICcsJyxcbiAgICAgICAgICAxODk6ICctJyxcbiAgICAgICAgICAxOTA6ICcuJyxcbiAgICAgICAgICAxOTE6ICcvJyxcbiAgICAgICAgICAxOTI6ICdgJyxcbiAgICAgICAgICAyMTk6ICdbJyxcbiAgICAgICAgICAyMjA6ICdcXFxcJyxcbiAgICAgICAgICAyMjE6ICddJyxcbiAgICAgICAgICAyMjI6ICdcXCcnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHRoaXMgaXMgYSBtYXBwaW5nIG9mIGtleXMgdGhhdCByZXF1aXJlIHNoaWZ0IG9uIGEgVVMga2V5cGFkXG4gICAgICAgKiBiYWNrIHRvIHRoZSBub24gc2hpZnQgZXF1aXZlbGVudHNcbiAgICAgICAqXG4gICAgICAgKiB0aGlzIGlzIHNvIHlvdSBjYW4gdXNlIGtleXVwIGV2ZW50cyB3aXRoIHRoZXNlIGtleXNcbiAgICAgICAqXG4gICAgICAgKiBub3RlIHRoYXQgdGhpcyB3aWxsIG9ubHkgd29yayByZWxpYWJseSBvbiBVUyBrZXlib2FyZHNcbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBfU0hJRlRfTUFQID0ge1xuICAgICAgICAgICd+JzogJ2AnLFxuICAgICAgICAgICchJzogJzEnLFxuICAgICAgICAgICdAJzogJzInLFxuICAgICAgICAgICcjJzogJzMnLFxuICAgICAgICAgICckJzogJzQnLFxuICAgICAgICAgICclJzogJzUnLFxuICAgICAgICAgICdeJzogJzYnLFxuICAgICAgICAgICcmJzogJzcnLFxuICAgICAgICAgICcqJzogJzgnLFxuICAgICAgICAgICcoJzogJzknLFxuICAgICAgICAgICcpJzogJzAnLFxuICAgICAgICAgICdfJzogJy0nLFxuICAgICAgICAgICcrJzogJz0nLFxuICAgICAgICAgICc6JzogJzsnLFxuICAgICAgICAgICdcXFwiJzogJ1xcJycsXG4gICAgICAgICAgJzwnOiAnLCcsXG4gICAgICAgICAgJz4nOiAnLicsXG4gICAgICAgICAgJz8nOiAnLycsXG4gICAgICAgICAgJ3wnOiAnXFxcXCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBpcyBhIGxpc3Qgb2Ygc3BlY2lhbCBzdHJpbmdzIHlvdSBjYW4gdXNlIHRvIG1hcFxuICAgICAgICogdG8gbW9kaWZpZXIga2V5cyB3aGVuIHlvdSBzcGVjaWZ5IHlvdXIga2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgX1NQRUNJQUxfQUxJQVNFUyA9IHtcbiAgICAgICAgICAnb3B0aW9uJzogJ2FsdCcsXG4gICAgICAgICAgJ2NvbW1hbmQnOiAnbWV0YScsXG4gICAgICAgICAgJ3JldHVybic6ICdlbnRlcicsXG4gICAgICAgICAgJ2VzY2FwZSc6ICdlc2MnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBmbGlwcGVkIHZlcnNpb24gb2YgX01BUCBmcm9tIGFib3ZlXG4gICAgICAgKiBuZWVkZWQgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHVzZSBrZXlwcmVzcyBvciBub3Qgd2hlbiBubyBhY3Rpb25cbiAgICAgICAqIGlzIHNwZWNpZmllZFxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgICAgICovXG4gICAgICBfUkVWRVJTRV9NQVAsXG5cbiAgICAgIC8qKlxuICAgICAgICogYSBsaXN0IG9mIGFsbCB0aGUgY2FsbGJhY2tzIHNldHVwIHZpYSBNb3VzZXRyYXAuYmluZCgpXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgX2NhbGxiYWNrcyA9IHt9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGRpcmVjdCBtYXAgb2Ygc3RyaW5nIGNvbWJpbmF0aW9ucyB0byBjYWxsYmFja3MgdXNlZCBmb3IgdHJpZ2dlcigpXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgX2RpcmVjdF9tYXAgPSB7fSxcblxuICAgICAgLyoqXG4gICAgICAgKiBrZWVwcyB0cmFjayBvZiB3aGF0IGxldmVsIGVhY2ggc2VxdWVuY2UgaXMgYXQgc2luY2UgbXVsdGlwbGVcbiAgICAgICAqIHNlcXVlbmNlcyBjYW4gc3RhcnQgb3V0IHdpdGggdGhlIHNhbWUgc2VxdWVuY2VcbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBfc2VxdWVuY2VfbGV2ZWxzID0ge30sXG5cbiAgICAgIC8qKlxuICAgICAgICogdmFyaWFibGUgdG8gc3RvcmUgdGhlIHNldFRpbWVvdXQgY2FsbFxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtudWxsfG51bWJlcn1cbiAgICAgICAqL1xuICAgICAgX3Jlc2V0X3RpbWVyLFxuXG4gICAgICAvKipcbiAgICAgICAqIHRlbXBvcmFyeSBzdGF0ZSB3aGVyZSB3ZSB3aWxsIGlnbm9yZSB0aGUgbmV4dCBrZXl1cFxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtib29sZWFufHN0cmluZ31cbiAgICAgICAqL1xuICAgICAgX2lnbm9yZV9uZXh0X2tleXVwID0gZmFsc2UsXG5cbiAgICAgIC8qKlxuICAgICAgICogYXJlIHdlIGN1cnJlbnRseSBpbnNpZGUgb2YgYSBzZXF1ZW5jZT9cbiAgICAgICAqIHR5cGUgb2YgYWN0aW9uIChcImtleXVwXCIgb3IgXCJrZXlkb3duXCIgb3IgXCJrZXlwcmVzc1wiKSBvciBmYWxzZVxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtib29sZWFufHN0cmluZ31cbiAgICAgICAqL1xuICAgICAgX2luc2lkZV9zZXF1ZW5jZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBsb29wIHRocm91Z2ggdGhlIGYga2V5cywgZjEgdG8gZjE5IGFuZCBhZGQgdGhlbSB0byB0aGUgbWFwXG4gICAqIHByb2dyYW1hdGljYWxseVxuICAgKi9cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCAyMDsgKytpKSB7XG4gICAgICBfTUFQWzExMSArIGldID0gJ2YnICsgaTtcbiAgfVxuXG4gIC8qKlxuICAgKiBsb29wIHRocm91Z2ggdG8gbWFwIG51bWJlcnMgb24gdGhlIG51bWVyaWMga2V5cGFkXG4gICAqL1xuICBmb3IgKGkgPSAwOyBpIDw9IDk7ICsraSkge1xuICAgICAgX01BUFtpICsgOTZdID0gaTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjcm9zcyBicm93c2VyIGFkZCBldmVudCBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fEhUTUxEb2N1bWVudH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHZvaWRcbiAgICovXG4gIGZ1bmN0aW9uIF9hZGRFdmVudChvYmplY3QsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAob2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgb2JqZWN0LmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogdGFrZXMgdGhlIGV2ZW50IGFuZCByZXR1cm5zIHRoZSBrZXkgY2hhcmFjdGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gX2NoYXJhY3RlckZyb21FdmVudChlKSB7XG5cbiAgICAgIC8vIGZvciBrZXlwcmVzcyBldmVudHMgd2Ugc2hvdWxkIHJldHVybiB0aGUgY2hhcmFjdGVyIGFzIGlzXG4gICAgICBpZiAoZS50eXBlID09ICdrZXlwcmVzcycpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlLndoaWNoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIG5vbiBrZXlwcmVzcyBldmVudHMgdGhlIHNwZWNpYWwgbWFwcyBhcmUgbmVlZGVkXG4gICAgICBpZiAoX01BUFtlLndoaWNoXSkge1xuICAgICAgICAgIHJldHVybiBfTUFQW2Uud2hpY2hdO1xuICAgICAgfVxuXG4gICAgICBpZiAoX0tFWUNPREVfTUFQW2Uud2hpY2hdKSB7XG4gICAgICAgICAgcmV0dXJuIF9LRVlDT0RFX01BUFtlLndoaWNoXTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgaXQgaXMgbm90IGluIHRoZSBzcGVjaWFsIG1hcFxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZS53aGljaCkudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzaG91bGQgd2Ugc3RvcCB0aGlzIGV2ZW50IGJlZm9yZSBmaXJpbmcgb2ZmIGNhbGxiYWNrc1xuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBfc3RvcChlKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcbiAgICAgICAgICB0YWdfbmFtZSA9IGVsZW1lbnQudGFnTmFtZTtcblxuICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBcIm1vdXNldHJhcFwiIHRoZW4gbm8gbmVlZCB0byBzdG9wXG4gICAgICBpZiAoKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgbW91c2V0cmFwICcpID4gLTEpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0b3AgZm9yIGlucHV0LCBzZWxlY3QsIGFuZCB0ZXh0YXJlYVxuICAgICAgcmV0dXJuIHRhZ19uYW1lID09ICdJTlBVVCcgfHwgdGFnX25hbWUgPT0gJ1NFTEVDVCcgfHwgdGFnX25hbWUgPT0gJ1RFWFRBUkVBJyB8fCAoZWxlbWVudC5jb250ZW50RWRpdGFibGUgJiYgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPT0gJ3RydWUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVja3MgaWYgdHdvIGFycmF5cyBhcmUgZXF1YWxcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzMVxuICAgKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gX21vZGlmaWVyc01hdGNoKG1vZGlmaWVyczEsIG1vZGlmaWVyczIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllcnMxLnNvcnQoKS5qb2luKCcsJykgPT09IG1vZGlmaWVyczIuc29ydCgpLmpvaW4oJywnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXNldHMgYWxsIHNlcXVlbmNlIGNvdW50ZXJzIGV4Y2VwdCBmb3IgdGhlIG9uZXMgcGFzc2VkIGluXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkb19ub3RfcmVzZXRcbiAgICogQHJldHVybnMgdm9pZFxuICAgKi9cbiAgZnVuY3Rpb24gX3Jlc2V0U2VxdWVuY2VzKGRvX25vdF9yZXNldCkge1xuICAgICAgZG9fbm90X3Jlc2V0ID0gZG9fbm90X3Jlc2V0IHx8IHt9O1xuXG4gICAgICB2YXIgYWN0aXZlX3NlcXVlbmNlcyA9IGZhbHNlLFxuICAgICAgICAgIGtleTtcblxuICAgICAgZm9yIChrZXkgaW4gX3NlcXVlbmNlX2xldmVscykge1xuICAgICAgICAgIGlmIChkb19ub3RfcmVzZXRba2V5XSkge1xuICAgICAgICAgICAgICBhY3RpdmVfc2VxdWVuY2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9zZXF1ZW5jZV9sZXZlbHNba2V5XSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWN0aXZlX3NlcXVlbmNlcykge1xuICAgICAgICAgIF9pbnNpZGVfc2VxdWVuY2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kcyBhbGwgY2FsbGJhY2tzIHRoYXQgbWF0Y2ggYmFzZWQgb24gdGhlIGtleWNvZGUsIG1vZGlmaWVycyxcbiAgICogYW5kIGFjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyXG4gICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlbW92ZSAtIHNob3VsZCB3ZSByZW1vdmUgYW55IG1hdGNoZXNcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBjb21iaW5hdGlvblxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0TWF0Y2hlcyhjaGFyYWN0ZXIsIG1vZGlmaWVycywgYWN0aW9uLCByZW1vdmUsIGNvbWJpbmF0aW9uKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICBtYXRjaGVzID0gW107XG5cbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBldmVudHMgcmVsYXRlZCB0byB0aGlzIGtleWNvZGVcbiAgICAgIGlmICghX2NhbGxiYWNrc1tjaGFyYWN0ZXJdKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhIG1vZGlmaWVyIGtleSBpcyBjb21pbmcgdXAgb24gaXRzIG93biB3ZSBzaG91bGQgYWxsb3cgaXRcbiAgICAgIGlmIChhY3Rpb24gPT0gJ2tleXVwJyAmJiBfaXNNb2RpZmllcihjaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgbW9kaWZpZXJzID0gW2NoYXJhY3Rlcl07XG4gICAgICB9XG5cbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgY2FsbGJhY2tzIGZvciB0aGUga2V5IHRoYXQgd2FzIHByZXNzZWRcbiAgICAgIC8vIGFuZCBzZWUgaWYgYW55IG9mIHRoZW0gbWF0Y2hcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBfY2FsbGJhY2tzW2NoYXJhY3Rlcl0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IF9jYWxsYmFja3NbY2hhcmFjdGVyXVtpXTtcblxuICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBzZXF1ZW5jZSBidXQgaXQgaXMgbm90IGF0IHRoZSByaWdodCBsZXZlbFxuICAgICAgICAgIC8vIHRoZW4gbW92ZSBvbnRvIHRoZSBuZXh0IG1hdGNoXG4gICAgICAgICAgaWYgKGNhbGxiYWNrLnNlcSAmJiBfc2VxdWVuY2VfbGV2ZWxzW2NhbGxiYWNrLnNlcV0gIT0gY2FsbGJhY2subGV2ZWwpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlIGFjdGlvbiB3ZSBhcmUgbG9va2luZyBmb3IgZG9lc24ndCBtYXRjaCB0aGUgYWN0aW9uIHdlIGdvdFxuICAgICAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIGtlZXAgZ29pbmdcbiAgICAgICAgICBpZiAoYWN0aW9uICE9IGNhbGxiYWNrLmFjdGlvbikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEga2V5cHJlc3MgZXZlbnQgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gb25seVxuICAgICAgICAgIC8vIGxvb2sgYXQgdGhlIGNoYXJhY3Rlciwgb3RoZXJ3aXNlIGNoZWNrIHRoZSBtb2RpZmllcnMgYXNcbiAgICAgICAgICAvLyB3ZWxsXG4gICAgICAgICAgaWYgKGFjdGlvbiA9PSAna2V5cHJlc3MnIHx8IF9tb2RpZmllcnNNYXRjaChtb2RpZmllcnMsIGNhbGxiYWNrLm1vZGlmaWVycykpIHtcblxuICAgICAgICAgICAgICAvLyByZW1vdmUgaXMgdXNlZCBzbyBpZiB5b3UgY2hhbmdlIHlvdXIgbWluZCBhbmQgY2FsbCBiaW5kIGFcbiAgICAgICAgICAgICAgLy8gc2Vjb25kIHRpbWUgd2l0aCBhIG5ldyBmdW5jdGlvbiB0aGUgZmlyc3Qgb25lIGlzIG92ZXJ3cml0dGVuXG4gICAgICAgICAgICAgIGlmIChyZW1vdmUgJiYgY2FsbGJhY2suY29tYm8gPT0gY29tYmluYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIF9jYWxsYmFja3NbY2hhcmFjdGVyXS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICAvKipcbiAgICogdGFrZXMgYSBrZXkgZXZlbnQgYW5kIGZpZ3VyZXMgb3V0IHdoYXQgdGhlIG1vZGlmaWVycyBhcmVcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiBfZXZlbnRNb2RpZmllcnMoZSkge1xuICAgICAgdmFyIG1vZGlmaWVycyA9IFtdO1xuXG4gICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdzaGlmdCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS5hbHRLZXkpIHtcbiAgICAgICAgICBtb2RpZmllcnMucHVzaCgnYWx0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLmN0cmxLZXkpIHtcbiAgICAgICAgICBtb2RpZmllcnMucHVzaCgnY3RybCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS5tZXRhS2V5KSB7XG4gICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ21ldGEnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vZGlmaWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBhY3R1YWxseSBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICpcbiAgICogaWYgeW91ciBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGZhbHNlIHRoaXMgd2lsbCB1c2UgdGhlIGpxdWVyeVxuICAgKiBjb252ZW50aW9uIC0gcHJldmVudCBkZWZhdWx0IGFuZCBzdG9wIHByb3BvZ2F0aW9uIG9uIHRoZSBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEByZXR1cm5zIHZvaWRcbiAgICovXG4gIGZ1bmN0aW9uIF9maXJlQ2FsbGJhY2soY2FsbGJhY2ssIGUpIHtcbiAgICAgIGlmIChjYWxsYmFjayhlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBoYW5kbGVzIGEgY2hhcmFjdGVyIGtleSBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHJldHVybnMgdm9pZFxuICAgKi9cbiAgZnVuY3Rpb24gX2hhbmRsZUNoYXJhY3RlcihjaGFyYWN0ZXIsIGUpIHtcblxuICAgICAgLy8gaWYgdGhpcyBldmVudCBzaG91bGQgbm90IGhhcHBlbiBzdG9wIGhlcmVcbiAgICAgIGlmIChfc3RvcChlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbGxiYWNrcyA9IF9nZXRNYXRjaGVzKGNoYXJhY3RlciwgX2V2ZW50TW9kaWZpZXJzKGUpLCBlLnR5cGUpLFxuICAgICAgICAgIGksXG4gICAgICAgICAgZG9fbm90X3Jlc2V0ID0ge30sXG4gICAgICAgICAgcHJvY2Vzc2VkX3NlcXVlbmNlX2NhbGxiYWNrID0gZmFsc2U7XG5cbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBtYXRjaGluZyBjYWxsYmFja3MgZm9yIHRoaXMga2V5IGV2ZW50XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAvLyBmaXJlIGZvciBhbGwgc2VxdWVuY2UgY2FsbGJhY2tzXG4gICAgICAgICAgLy8gdGhpcyBpcyBiZWNhdXNlIGlmIGZvciBleGFtcGxlIHlvdSBoYXZlIG11bHRpcGxlIHNlcXVlbmNlc1xuICAgICAgICAgIC8vIGJvdW5kIHN1Y2ggYXMgXCJnIGlcIiBhbmQgXCJnIHRcIiB0aGV5IGJvdGggbmVlZCB0byBmaXJlIHRoZVxuICAgICAgICAgIC8vIGNhbGxiYWNrIGZvciBtYXRjaGluZyBnIGNhdXNlIG90aGVyd2lzZSB5b3UgY2FuIG9ubHkgZXZlclxuICAgICAgICAgIC8vIG1hdGNoIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldLnNlcSkge1xuICAgICAgICAgICAgICBwcm9jZXNzZWRfc2VxdWVuY2VfY2FsbGJhY2sgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIC8vIGtlZXAgYSBsaXN0IG9mIHdoaWNoIHNlcXVlbmNlcyB3ZXJlIG1hdGNoZXMgZm9yIGxhdGVyXG4gICAgICAgICAgICAgIGRvX25vdF9yZXNldFtjYWxsYmFja3NbaV0uc2VxXSA9IDE7XG4gICAgICAgICAgICAgIF9maXJlQ2FsbGJhY2soY2FsbGJhY2tzW2ldLmNhbGxiYWNrLCBlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUgd2VyZSBubyBzZXF1ZW5jZSBtYXRjaGVzIGJ1dCB3ZSBhcmUgc3RpbGwgaGVyZVxuICAgICAgICAgIC8vIHRoYXQgbWVhbnMgdGhpcyBpcyBhIHJlZ3VsYXIgbWF0Y2ggc28gd2Ugc2hvdWxkIGZpcmUgdGhhdFxuICAgICAgICAgIGlmICghcHJvY2Vzc2VkX3NlcXVlbmNlX2NhbGxiYWNrICYmICFfaW5zaWRlX3NlcXVlbmNlKSB7XG4gICAgICAgICAgICAgIF9maXJlQ2FsbGJhY2soY2FsbGJhY2tzW2ldLmNhbGxiYWNrLCBlKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHlvdSBhcmUgaW5zaWRlIG9mIGEgc2VxdWVuY2UgYW5kIHRoZSBrZXkgeW91IGFyZSBwcmVzc2luZ1xuICAgICAgLy8gaXMgbm90IGEgbW9kaWZpZXIga2V5IHRoZW4gd2Ugc2hvdWxkIHJlc2V0IGFsbCBzZXF1ZW5jZXNcbiAgICAgIC8vIHRoYXQgd2VyZSBub3QgbWF0Y2hlZCBieSB0aGlzIGtleSBldmVudFxuICAgICAgaWYgKGUudHlwZSA9PSBfaW5zaWRlX3NlcXVlbmNlICYmICFfaXNNb2RpZmllcihjaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgX3Jlc2V0U2VxdWVuY2VzKGRvX25vdF9yZXNldCk7XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogaGFuZGxlcyBhIGtleWRvd24gZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqL1xuICBmdW5jdGlvbiBfaGFuZGxlS2V5KGUpIHtcblxuICAgICAgLy8gbm9ybWFsaXplIGUud2hpY2ggZm9yIGtleSBldmVudHNcbiAgICAgIC8vIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80Mjg1NjI3L2phdmFzY3JpcHQta2V5Y29kZS12cy1jaGFyY29kZS11dHRlci1jb25mdXNpb25cbiAgICAgIGUud2hpY2ggPSB0eXBlb2YgZS53aGljaCA9PSBcIm51bWJlclwiID8gZS53aGljaCA6IGUua2V5Q29kZTtcblxuICAgICAgdmFyIGNoYXJhY3RlciA9IF9jaGFyYWN0ZXJGcm9tRXZlbnQoZSk7XG5cbiAgICAgIC8vIG5vIGNoYXJhY3RlciBmb3VuZCB0aGVuIHN0b3BcbiAgICAgIGlmICghY2hhcmFjdGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50eXBlID09ICdrZXl1cCcgJiYgX2lnbm9yZV9uZXh0X2tleXVwID09IGNoYXJhY3Rlcikge1xuICAgICAgICAgIF9pZ25vcmVfbmV4dF9rZXl1cCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX2hhbmRsZUNoYXJhY3RlcihjaGFyYWN0ZXIsIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRldGVybWluZXMgaWYgdGhlIGtleWNvZGUgc3BlY2lmaWVkIGlzIGEgbW9kaWZpZXIga2V5IG9yIG5vdFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gX2lzTW9kaWZpZXIoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ID09ICdzaGlmdCcgfHwga2V5ID09ICdjdHJsJyB8fCBrZXkgPT0gJ2FsdCcgfHwga2V5ID09ICdtZXRhJztcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxsZWQgdG8gc2V0IGEgMSBzZWNvbmQgdGltZW91dCBvbiB0aGUgc3BlY2lmaWVkIHNlcXVlbmNlXG4gICAqXG4gICAqIHRoaXMgaXMgc28gYWZ0ZXIgZWFjaCBrZXkgcHJlc3MgaW4gdGhlIHNlcXVlbmNlIHlvdSBoYXZlIDEgc2Vjb25kXG4gICAqIHRvIHByZXNzIHRoZSBuZXh0IGtleSBiZWZvcmUgeW91IGhhdmUgdG8gc3RhcnQgb3ZlclxuICAgKlxuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzZXRTZXF1ZW5jZVRpbWVyKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KF9yZXNldF90aW1lcik7XG4gICAgICBfcmVzZXRfdGltZXIgPSBzZXRUaW1lb3V0KF9yZXNldFNlcXVlbmNlcywgMTAwMCk7XG4gIH1cblxuICAvKipcbiAgICogcmV2ZXJzZXMgdGhlIG1hcCBsb29rdXAgc28gdGhhdCB3ZSBjYW4gbG9vayBmb3Igc3BlY2lmaWMga2V5c1xuICAgKiB0byBzZWUgd2hhdCBjYW4gYW5kIGNhbid0IHVzZSBrZXlwcmVzc1xuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0UmV2ZXJzZU1hcCgpIHtcbiAgICAgIGlmICghX1JFVkVSU0VfTUFQKSB7XG4gICAgICAgICAgX1JFVkVSU0VfTUFQID0ge307XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIF9NQVApIHtcblxuICAgICAgICAgICAgICAvLyBwdWxsIG91dCB0aGUgbnVtZXJpYyBrZXlwYWQgZnJvbSBoZXJlIGNhdXNlIGtleXByZXNzIHNob3VsZFxuICAgICAgICAgICAgICAvLyBiZSBhYmxlIHRvIGRldGVjdCB0aGUga2V5cyBmcm9tIHRoZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgaWYgKGtleSA+IDk1ICYmIGtleSA8IDExMikge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoX01BUC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICBfUkVWRVJTRV9NQVBbX01BUFtrZXldXSA9IGtleTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfUkVWRVJTRV9NQVA7XG4gIH1cblxuICAvKipcbiAgICogcGlja3MgdGhlIGJlc3QgYWN0aW9uIGJhc2VkIG9uIHRoZSBrZXkgY29tYmluYXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGNoYXJhY3RlciBmb3Iga2V5XG4gICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICAgKiBAcGFyYW0ge3N0cmluZz19IGFjdGlvbiBwYXNzZWQgaW5cbiAgICovXG4gIGZ1bmN0aW9uIF9waWNrQmVzdEFjdGlvbihrZXksIG1vZGlmaWVycywgYWN0aW9uKSB7XG5cbiAgICAgIC8vIGlmIG5vIGFjdGlvbiB3YXMgcGlja2VkIGluIHdlIHNob3VsZCB0cnkgdG8gcGljayB0aGUgb25lXG4gICAgICAvLyB0aGF0IHdlIHRoaW5rIHdvdWxkIHdvcmsgYmVzdCBmb3IgdGhpcyBrZXlcbiAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgYWN0aW9uID0gX2dldFJldmVyc2VNYXAoKVtrZXldID8gJ2tleWRvd24nIDogJ2tleXByZXNzJztcbiAgICAgIH1cblxuICAgICAgLy8gbW9kaWZpZXIga2V5cyBkb24ndCB3b3JrIGFzIGV4cGVjdGVkIHdpdGgga2V5cHJlc3MsXG4gICAgICAvLyBzd2l0Y2ggdG8ga2V5ZG93blxuICAgICAgaWYgKGFjdGlvbiA9PSAna2V5cHJlc3MnICYmIG1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgICBhY3Rpb24gPSAna2V5ZG93bic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogYmluZHMgYSBrZXkgc2VxdWVuY2UgdG8gYW4gZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbWJvIC0gY29tYm8gc3BlY2lmaWVkIGluIGJpbmQgY2FsbFxuICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uXG4gICAqIEByZXR1cm5zIHZvaWRcbiAgICovXG4gIGZ1bmN0aW9uIF9iaW5kU2VxdWVuY2UoY29tYm8sIGtleXMsIGNhbGxiYWNrLCBhY3Rpb24pIHtcblxuICAgICAgLy8gc3RhcnQgb2ZmIGJ5IGFkZGluZyBhIHNlcXVlbmNlIGxldmVsIHJlY29yZCBmb3IgdGhpcyBjb21iaW5hdGlvblxuICAgICAgLy8gYW5kIHNldHRpbmcgdGhlIGxldmVsIHRvIDBcbiAgICAgIF9zZXF1ZW5jZV9sZXZlbHNbY29tYm9dID0gMDtcblxuICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYWN0aW9uIHBpY2sgdGhlIGJlc3Qgb25lIGZvciB0aGUgZmlyc3Qga2V5XG4gICAgICAvLyBpbiB0aGUgc2VxdWVuY2VcbiAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgYWN0aW9uID0gX3BpY2tCZXN0QWN0aW9uKGtleXNbMF0sIFtdKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBjYWxsYmFjayB0byBpbmNyZWFzZSB0aGUgc2VxdWVuY2UgbGV2ZWwgZm9yIHRoaXMgc2VxdWVuY2UgYW5kIHJlc2V0XG4gICAgICAgKiBhbGwgb3RoZXIgc2VxdWVuY2VzIHRoYXQgd2VyZSBhY3RpdmVcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgKi9cbiAgICAgIHZhciBfaW5jcmVhc2VTZXF1ZW5jZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgX2luc2lkZV9zZXF1ZW5jZSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgKytfc2VxdWVuY2VfbGV2ZWxzW2NvbWJvXTtcbiAgICAgICAgICAgICAgX3Jlc2V0U2VxdWVuY2VUaW1lcigpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiB3cmFwcyB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluc2lkZSBvZiBhbm90aGVyIGZ1bmN0aW9uIGluIG9yZGVyXG4gICAgICAgICAgICogdG8gcmVzZXQgYWxsIHNlcXVlbmNlIGNvdW50ZXJzIGFzIHNvb24gYXMgdGhpcyBzZXF1ZW5jZSBpcyBkb25lXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgICAqL1xuICAgICAgICAgIF9jYWxsYmFja0FuZFJlc2V0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICBfZmlyZUNhbGxiYWNrKGNhbGxiYWNrLCBlKTtcblxuICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgaWdub3JlIHRoZSBuZXh0IGtleSB1cCBpZiB0aGUgYWN0aW9uIGlzIGtleSBkb3duXG4gICAgICAgICAgICAgIC8vIG9yIGtleXByZXNzLiAgdGhpcyBpcyBzbyBpZiB5b3UgZmluaXNoIGEgc2VxdWVuY2UgYW5kXG4gICAgICAgICAgICAgIC8vIHJlbGVhc2UgdGhlIGtleSB0aGUgZmluYWwga2V5IHdpbGwgbm90IHRyaWdnZXIgYSBrZXl1cFxuICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAna2V5dXAnKSB7XG4gICAgICAgICAgICAgICAgICBfaWdub3JlX25leHRfa2V5dXAgPSBfY2hhcmFjdGVyRnJvbUV2ZW50KGUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gd2VpcmQgcmFjZSBjb25kaXRpb24gaWYgYSBzZXF1ZW5jZSBlbmRzIHdpdGggdGhlIGtleVxuICAgICAgICAgICAgICAvLyBhbm90aGVyIHNlcXVlbmNlIGJlZ2lucyB3aXRoXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoX3Jlc2V0U2VxdWVuY2VzLCAxMCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpO1xuXG4gICAgICAvLyBsb29wIHRocm91Z2gga2V5cyBvbmUgYXQgYSB0aW1lIGFuZCBiaW5kIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja1xuICAgICAgLy8gZnVuY3Rpb24uICBmb3IgYW55IGtleSBsZWFkaW5nIHVwIHRvIHRoZSBmaW5hbCBvbmUgaXQgc2hvdWxkXG4gICAgICAvLyBpbmNyZWFzZSB0aGUgc2VxdWVuY2UuIGFmdGVyIHRoZSBmaW5hbCwgaXQgc2hvdWxkIHJlc2V0IGFsbCBzZXF1ZW5jZXNcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgX2JpbmRTaW5nbGUoa2V5c1tpXSwgaSA8IGtleXMubGVuZ3RoIC0gMSA/IF9pbmNyZWFzZVNlcXVlbmNlIDogX2NhbGxiYWNrQW5kUmVzZXQsIGFjdGlvbiwgY29tYm8sIGkpO1xuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGJpbmRzIGEgc2luZ2xlIGtleWJvYXJkIGNvbWJpbmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21iaW5hdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge3N0cmluZz19IGFjdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZz19IHNlcXVlbmNlX25hbWUgLSBuYW1lIG9mIHNlcXVlbmNlIGlmIHBhcnQgb2Ygc2VxdWVuY2VcbiAgICogQHBhcmFtIHtudW1iZXI9fSBsZXZlbCAtIHdoYXQgcGFydCBvZiB0aGUgc2VxdWVuY2UgdGhlIGNvbW1hbmQgaXNcbiAgICogQHJldHVybnMgdm9pZFxuICAgKi9cbiAgZnVuY3Rpb24gX2JpbmRTaW5nbGUoY29tYmluYXRpb24sIGNhbGxiYWNrLCBhY3Rpb24sIHNlcXVlbmNlX25hbWUsIGxldmVsKSB7XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBtdWx0aXBsZSBzcGFjZXMgaW4gYSByb3cgYmVjb21lIGEgc2luZ2xlIHNwYWNlXG4gICAgICBjb21iaW5hdGlvbiA9IGNvbWJpbmF0aW9uLnJlcGxhY2UoL1xccysvZywgJyAnKTtcblxuICAgICAgdmFyIHNlcXVlbmNlID0gY29tYmluYXRpb24uc3BsaXQoJyAnKSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBrZXlzLFxuICAgICAgICAgIG1vZGlmaWVycyA9IFtdO1xuXG4gICAgICAvLyBpZiB0aGlzIHBhdHRlcm4gaXMgYSBzZXF1ZW5jZSBvZiBrZXlzIHRoZW4gcnVuIHRocm91Z2ggdGhpcyBtZXRob2RcbiAgICAgIC8vIHRvIHJlcHJvY2VzcyBlYWNoIHBhdHRlcm4gb25lIGtleSBhdCBhIHRpbWVcbiAgICAgIGlmIChzZXF1ZW5jZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIF9iaW5kU2VxdWVuY2UoY29tYmluYXRpb24sIHNlcXVlbmNlLCBjYWxsYmFjaywgYWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLy8gdGFrZSB0aGUga2V5cyBmcm9tIHRoaXMgcGF0dGVybiBhbmQgZmlndXJlIG91dCB3aGF0IHRoZSBhY3R1YWxcbiAgICAgIC8vIHBhdHRlcm4gaXMgYWxsIGFib3V0XG4gICAgICBrZXlzID0gY29tYmluYXRpb24gPT09ICcrJyA/IFsnKyddIDogY29tYmluYXRpb24uc3BsaXQoJysnKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgLy8gbm9ybWFsaXplIGtleSBuYW1lc1xuICAgICAgICAgIGlmIChfU1BFQ0lBTF9BTElBU0VTW2tleV0pIHtcbiAgICAgICAgICAgICAga2V5ID0gX1NQRUNJQUxfQUxJQVNFU1trZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEga2V5cHJlc3MgZXZlbnQgdGhlbiB3ZSBzaG91bGRcbiAgICAgICAgICAvLyBiZSBzbWFydCBhYm91dCB1c2luZyBzaGlmdCBrZXlzXG4gICAgICAgICAgLy8gdGhpcyB3aWxsIG9ubHkgd29yayBmb3IgVVMga2V5Ym9hcmRzIGhvd2V2ZXJcbiAgICAgICAgICBpZiAoYWN0aW9uICYmIGFjdGlvbiAhPSAna2V5cHJlc3MnICYmIF9TSElGVF9NQVBba2V5XSkge1xuICAgICAgICAgICAgICBrZXkgPSBfU0hJRlRfTUFQW2tleV07XG4gICAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdzaGlmdCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHRoaXMga2V5IGlzIGEgbW9kaWZpZXIgdGhlbiBhZGQgaXQgdG8gdGhlIGxpc3Qgb2YgbW9kaWZpZXJzXG4gICAgICAgICAgaWYgKF9pc01vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRlcGVuZGluZyBvbiB3aGF0IHRoZSBrZXkgY29tYmluYXRpb24gaXNcbiAgICAgIC8vIHdlIHdpbGwgdHJ5IHRvIHBpY2sgdGhlIGJlc3QgZXZlbnQgZm9yIGl0XG4gICAgICBhY3Rpb24gPSBfcGlja0Jlc3RBY3Rpb24oa2V5LCBtb2RpZmllcnMsIGFjdGlvbik7XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbml0aWFsaXplIGFycmF5IGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWVcbiAgICAgIC8vIGEgY2FsbGJhY2sgaXMgYWRkZWQgZm9yIHRoaXMga2V5XG4gICAgICBpZiAoIV9jYWxsYmFja3Nba2V5XSkge1xuICAgICAgICAgIF9jYWxsYmFja3Nba2V5XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgYW4gZXhpc3RpbmcgbWF0Y2ggaWYgdGhlcmUgaXMgb25lXG4gICAgICBfZ2V0TWF0Y2hlcyhrZXksIG1vZGlmaWVycywgYWN0aW9uLCAhc2VxdWVuY2VfbmFtZSwgY29tYmluYXRpb24pO1xuXG4gICAgICAvLyBhZGQgdGhpcyBjYWxsIGJhY2sgdG8gdGhlIGFycmF5XG4gICAgICAvLyBpZiBpdCBpcyBhIHNlcXVlbmNlIHB1dCBpdCBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAvLyBpZiBub3QgcHV0IGl0IGF0IHRoZSBlbmRcbiAgICAgIC8vXG4gICAgICAvLyB0aGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSB3YXkgdGhlc2UgYXJlIHByb2Nlc3NlZCBleHBlY3RzXG4gICAgICAvLyB0aGUgc2VxdWVuY2Ugb25lcyB0byBjb21lIGZpcnN0XG4gICAgICBfY2FsbGJhY2tzW2tleV1bc2VxdWVuY2VfbmFtZSA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10oe1xuICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICBtb2RpZmllcnM6IG1vZGlmaWVycyxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBzZXE6IHNlcXVlbmNlX25hbWUsXG4gICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgIGNvbWJvOiBjb21iaW5hdGlvblxuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogYmluZHMgbXVsdGlwbGUgY29tYmluYXRpb25zIHRvIHRoZSBzYW1lIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbWJpbmF0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGFjdGlvblxuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqL1xuICBmdW5jdGlvbiBfYmluZE11bHRpcGxlKGNvbWJpbmF0aW9ucywgY2FsbGJhY2ssIGFjdGlvbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21iaW5hdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBfYmluZFNpbmdsZShjb21iaW5hdGlvbnNbaV0sIGNhbGxiYWNrLCBhY3Rpb24pO1xuICAgICAgfVxuICB9XG5cbiAgLy8gc3RhcnQhXG4gIF9hZGRFdmVudChkb2N1bWVudCwgJ2tleXByZXNzJywgX2hhbmRsZUtleSk7XG4gIF9hZGRFdmVudChkb2N1bWVudCwgJ2tleWRvd24nLCBfaGFuZGxlS2V5KTtcbiAgX2FkZEV2ZW50KGRvY3VtZW50LCAna2V5dXAnLCBfaGFuZGxlS2V5KTtcblxuICB2YXIgbW91c2V0cmFwID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIGJpbmRzIGFuIGV2ZW50IHRvIG1vdXNldHJhcFxuICAgICAgICpcbiAgICAgICAqIGNhbiBiZSBhIHNpbmdsZSBrZXksIGEgY29tYmluYXRpb24gb2Yga2V5cyBzZXBhcmF0ZWQgd2l0aCArLFxuICAgICAgICogYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBrZXlzLCBhbiBhcnJheSBvZiBrZXlzLCBvclxuICAgICAgICogYSBzZXF1ZW5jZSBvZiBrZXlzIHNlcGFyYXRlZCBieSBzcGFjZXNcbiAgICAgICAqXG4gICAgICAgKiBiZSBzdXJlIHRvIGxpc3QgdGhlIG1vZGlmaWVyIGtleXMgZmlyc3QgdG8gbWFrZSBzdXJlIHRoYXQgdGhlXG4gICAgICAgKiBjb3JyZWN0IGtleSBlbmRzIHVwIGdldHRpbmcgYm91bmQgKHRoZSBsYXN0IGtleSBpbiB0aGUgcGF0dGVybilcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0ga2V5c1xuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uIC0gJ2tleXByZXNzJywgJ2tleWRvd24nLCBvciAna2V5dXAnXG4gICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgKi9cbiAgICAgIGJpbmQ6IGZ1bmN0aW9uKGtleXMsIGNhbGxiYWNrLCBhY3Rpb24pIHtcbiAgICAgICAgICBfYmluZE11bHRpcGxlKGtleXMgaW5zdGFuY2VvZiBBcnJheSA/IGtleXMgOiBba2V5c10sIGNhbGxiYWNrLCBhY3Rpb24pO1xuICAgICAgICAgIF9kaXJlY3RfbWFwW2tleXMgKyAnOicgKyBhY3Rpb25dID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHVuYmluZHMgYW4gZXZlbnQgdG8gbW91c2V0cmFwXG4gICAgICAgKlxuICAgICAgICogdGhlIHVuYmluZGluZyBzZXRzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGtleSBjb21ib1xuICAgICAgICogdG8gYW4gZW1wdHkgZnVuY3Rpb24gYW5kIGRlbGV0ZXMgdGhlIGNvcnJlc3BvbmRpbmcga2V5IGluIHRoZVxuICAgICAgICogX2RpcmVjdF9tYXAgZGljdC5cbiAgICAgICAqXG4gICAgICAgKiB0aGUga2V5Y29tYm8rYWN0aW9uIGhhcyB0byBiZSBleGFjdGx5IHRoZSBzYW1lIGFzXG4gICAgICAgKiBpdCB3YXMgZGVmaW5lZCBpbiB0aGUgYmluZCBtZXRob2RcbiAgICAgICAqXG4gICAgICAgKiBUT0RPOiBhY3R1YWxseSByZW1vdmUgdGhpcyBmcm9tIHRoZSBfY2FsbGJhY2tzIGRpY3Rpb25hcnkgaW5zdGVhZFxuICAgICAgICogb2YgYmluZGluZyBhbiBlbXB0eSBmdW5jdGlvblxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBrZXlzXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgKi9cbiAgICAgIHVuYmluZDogZnVuY3Rpb24oa2V5cywgYWN0aW9uKSB7XG4gICAgICAgICAgaWYgKF9kaXJlY3RfbWFwW2tleXMgKyAnOicgKyBhY3Rpb25dKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBfZGlyZWN0X21hcFtrZXlzICsgJzonICsgYWN0aW9uXTtcbiAgICAgICAgICAgICAgdGhpcy5iaW5kKGtleXMsIGZ1bmN0aW9uKCkge30sIGFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiB0cmlnZ2VycyBhbiBldmVudCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5c1xuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBhY3Rpb25cbiAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAqL1xuICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oa2V5cywgYWN0aW9uKSB7XG4gICAgICAgICAgX2RpcmVjdF9tYXBba2V5cyArICc6JyArIGFjdGlvbl0oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogcmVzZXRzIHRoZSBsaWJyYXJ5IGJhY2sgdG8gaXRzIGluaXRpYWwgc3RhdGUuICB0aGlzIGlzIHVzZWZ1bFxuICAgICAgICogaWYgeW91IHdhbnQgdG8gY2xlYXIgb3V0IHRoZSBjdXJyZW50IGtleWJvYXJkIHNob3J0Y3V0cyBhbmQgYmluZFxuICAgICAgICogbmV3IG9uZXMgLSBmb3IgZXhhbXBsZSBpZiB5b3Ugc3dpdGNoIHRvIGFub3RoZXIgcGFnZVxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAqL1xuICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICBfZGlyZWN0X21hcCA9IHt9O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1vdXNldHJhcDtcblxuIiwiJCA9IHJlcXVpcmUoJy4uL2Jvd2VyX2NvbXBvbmVudHMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzJyk7XG5cbmZ1bmN0aW9uIHNldElucHV0VmFsdWUoZWwsIHZhbCkge1xuICAgIGVsLnZhbCh2YWwpO1xuICAgIC8vIHRpZ2dlckhhbmRsZXIgb25seSB3b3JrcyB3aXRoIGFuZ3VsYXIgZWxlbWVudCAobm90IGpxdWVyeSk/XG4gICAgYW5ndWxhci5lbGVtZW50KGVsKS50cmlnZ2VySGFuZGxlcihzbmlmZmVyLmhhc0V2ZW50KCdpbnB1dCcpID8gJ2lucHV0JyA6ICdjaGFuZ2UnKTtcbiAgICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIGNsaWNrKGVsKSB7XG4gICAgYW5ndWxhci5lbGVtZW50KGVsKS50cmlnZ2VySGFuZGxlcignY2xpY2snKTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZShodG1sLCBjb250ZW50cykge1xuICAgIHZhciBzY29wZSA9ICRyb290U2NvcGUuJG5ldygpO1xuICAgIHZhciBlbCA9ICRjb21waWxlKGh0bWwpKHNjb3BlKTtcbiAgICBhbmd1bGFyLmV4dGVuZChzY29wZSwgY29udGVudHMpO1xuICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICByZXR1cm4gJChlbCk7XG59XG5cbmZ1bmN0aW9uIGdldFNjb3BlKGVsKSB7XG4gICAgcmV0dXJuIGFuZ3VsYXIuZWxlbWVudChlbCkuc2NvcGUoKTtcbn1cblxuZXhwb3J0cy5pbmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICBpbmplY3QoZnVuY3Rpb24oXyRjb21waWxlXywgXyRyb290U2NvcGVfLCAkc25pZmZlcikge1xuICAgICAgICAkY29tcGlsZSA9IF8kY29tcGlsZV87XG4gICAgICAgICRyb290U2NvcGUgPSBfJHJvb3RTY29wZV87XG4gICAgICAgIHNuaWZmZXIgPSAkc25pZmZlcjtcbiAgICB9KTtcbn07XG5leHBvcnRzLnNldElucHV0VmFsdWUgPSBzZXRJbnB1dFZhbHVlO1xuZXhwb3J0cy5jbGljayA9IGNsaWNrO1xuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbmV4cG9ydHMuZ2V0U2NvcGUgPSBnZXRTY29wZTsiLCJ2YXIgTWFwQ29uZmlnVHJhbnNmb3JtZXIgPSByZXF1aXJlKCcuLi9saWIvbWFwc3RvcnkvTWFwQ29uZmlnVHJhbnNmb3JtZXIuanMnKS5NYXBDb25maWdUcmFuc2Zvcm1lcjtcblxuZGVzY3JpYmUoJ01hcENvbmZpZ1RyYW5zZm9ybWVyJywgZnVuY3Rpb24oKSB7XG4gICAgaXQoJ3Nob3VsZCB0cmFuc2Zvcm0gbWFwIGlkIDExOTMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKCd7XCJzb3VyY2VzXCI6IHtcIjFcIjoge1wiaGlkZGVuXCI6IHRydWUsIFwicHR5cGVcIjogXCJneHBfbWFwcXVlc3Rzb3VyY2VcIiwgXCJpZFwiOiBcIjFcIn0sIFwiMFwiOiB7XCJwdHlwZVwiOiBcImd4X29sc291cmNlXCIsIFwiaWRcIjogXCIwXCJ9LCBcIjJcIjoge1wiaGlkZGVuXCI6IHRydWUsIFwicHR5cGVcIjogXCJneHBfbWFwYm94c291cmNlXCIsIFwiaWRcIjogXCIyXCJ9LCBcImxvY2FsXCI6IHtcInRpdGxlXCI6IFwiTXkgR2VvU2VydmVyIFdNU1wiLCBcInVybFwiOiBcIi9nZW9zZXJ2ZXIvZ2Vvbm9kZS9CcmV3ZXJpZXMwL3dtc1wiLCBcImJhc2VQYXJhbXNcIjoge1wiVkVSU0lPTlwiOiBcIjEuMS4xXCIsIFwiUkVRVUVTVFwiOiBcIkdldENhcGFiaWxpdGllc1wiLCBcIlRJTEVEXCI6IHRydWUsIFwiU0VSVklDRVwiOiBcIldNU1wifSwgXCJwdHlwZVwiOiBcImd4cF93bXNjc291cmNlXCIsIFwicmVzdFVybFwiOiBcIi9ncy9yZXN0XCIsIFwiaGlkZGVuXCI6IHRydWUsIFwiaWRcIjogXCJsb2NhbFwifX0sIFwiYWJvdXRcIjoge1wiYWJzdHJhY3RcIjogXCJUaGlzIG1hcCBzaG93cyB0aGUgZXZvbHV0aW9uIGFuZCBkZXZlbG9wbWVudCBvZiB0aGUgIGJyZXdpbmcgaW5kdXN0cnkgaW4gdGhlIFVuaXRlZCBTdGF0ZXMuIFRoZSBpbmZvcm1hdGlvbiBpcyBvYnRhaW5lZCBmcm9tIHRoZSBib29rIEFtZXJpY2FuIEJyZXdlcmllcyBJSSBieSBEYWxlIFAuIFZhbiBXaWVyZW4uIFRoZSBzYW1lIGluZm9ybWF0aW9uIGNvdWxkIGFsc28gYmUgYWNjZXNzZWQgYXQgd3d3LmJlZXJib29rcy5jb21cIiwgXCJ0aXRsZVwiOiBcIkNocm9ub2xvZ3kgb2YgdGhlIEFtZXJpY2FuIEJyZXdpbmcgSW5kdXN0cnlcIn0sIFwibG9jYWxHZW9TZXJ2ZXJCYXNlVXJsXCI6IFwiaHR0cDovL21hcHN0b3J5Lm9yZy9nZW9zZXJ2ZXIvXCIsIFwibWFwXCI6IHtcImxheWVyc1wiOiBbe1wib3BhY2l0eVwiOiAxLjAsIFwiYXJnc1wiOiBbXCJObyBiYWNrZ3JvdW5kXCJdLCBcImdyb3VwXCI6IFwiYmFja2dyb3VuZFwiLCBcIm5hbWVcIjogXCJObyBiYWNrZ3JvdW5kXCIsIFwidGl0bGVcIjogXCJObyBiYWNrZ3JvdW5kXCIsIFwic2VsZWN0ZWRcIjogZmFsc2UsIFwidmlzaWJpbGl0eVwiOiBmYWxzZSwgXCJzb3VyY2VcIjogXCIwXCIsIFwiZml4ZWRcIjogdHJ1ZSwgXCJ0eXBlXCI6IFwiT3BlbkxheWVycy5MYXllclwifSwge1wib3BhY2l0eVwiOiAxLjAsIFwiYXJnc1wiOiBbXCJPcGVuU3RyZWV0TWFwXCJdLCBcImdyb3VwXCI6IFwiYmFja2dyb3VuZFwiLCBcIm5hbWVcIjogXCJPcGVuU3RyZWV0TWFwXCIsIFwidGl0bGVcIjogXCJPcGVuU3RyZWV0TWFwXCIsIFwic2VsZWN0ZWRcIjogZmFsc2UsIFwidmlzaWJpbGl0eVwiOiB0cnVlLCBcInNvdXJjZVwiOiBcIjBcIiwgXCJmaXhlZFwiOiB0cnVlLCBcInR5cGVcIjogXCJPcGVuTGF5ZXJzLkxheWVyLk9TTVwifSwge1wib3BhY2l0eVwiOiAxLjAsIFwiYXJnc1wiOiBbXCJIdW1hbml0YXJpYW4gT3BlblN0cmVldE1hcFwiLCBbXCJodHRwOi8vYS50aWxlLm9wZW5zdHJlZXRtYXAuZnIvaG90LyR7en0vJHt4fS8ke3l9LnBuZ1wiLCBcImh0dHA6Ly9iLnRpbGUub3BlbnN0cmVldG1hcC5mci9ob3QvJHt6fS8ke3h9LyR7eX0ucG5nXCIsIFwiaHR0cDovL2MudGlsZS5vcGVuc3RyZWV0bWFwLmZyL2hvdC8ke3p9LyR7eH0vJHt5fS5wbmdcIl0sIHtcInRpbGVPcHRpb25zXCI6IHtcImNyb3NzT3JpZ2luS2V5d29yZFwiOiBudWxsfX1dLCBcImdyb3VwXCI6IFwiYmFja2dyb3VuZFwiLCBcIm5hbWVcIjogXCJIdW1hbml0YXJpYW4gT3BlblN0cmVldE1hcFwiLCBcInRpdGxlXCI6IFwiSHVtYW5pdGFyaWFuIE9wZW5TdHJlZXRNYXBcIiwgXCJzZWxlY3RlZFwiOiBmYWxzZSwgXCJ2aXNpYmlsaXR5XCI6IGZhbHNlLCBcInNvdXJjZVwiOiBcIjBcIiwgXCJmaXhlZFwiOiB0cnVlLCBcInR5cGVcIjogXCJPcGVuTGF5ZXJzLkxheWVyLk9TTVwifSwge1wib3BhY2l0eVwiOiAxLjAsIFwiYXJnc1wiOiBbXCJOYWtlZCBFYXJ0aFwiLCBcImh0dHA6Ly9tYXBzLm9wZW5nZW8ub3JnL2dlb3dlYmNhY2hlL3NlcnZpY2Uvd21zXCIsIHtcImxheWVyc1wiOiBbXCJXYXluZVwiXSwgXCJ0aWxlZFwiOiB0cnVlLCBcInRpbGVzT3JpZ2luXCI6IFstMjAwMzc1MDguMzQsIC0yMDAzNzUwOC4zNF0sIFwiZm9ybWF0XCI6IFwiaW1hZ2UvcG5nXCJ9LCB7XCJidWZmZXJcIjogMH1dLCBcImdyb3VwXCI6IFwiYmFja2dyb3VuZFwiLCBcIm5hbWVcIjogXCJOYWtlZCBFYXJ0aFwiLCBcInRpdGxlXCI6IFwiTmFrZWQgRWFydGhcIiwgXCJzZWxlY3RlZFwiOiBmYWxzZSwgXCJ2aXNpYmlsaXR5XCI6IGZhbHNlLCBcInNvdXJjZVwiOiBcIjBcIiwgXCJmaXhlZFwiOiB0cnVlLCBcInR5cGVcIjogXCJPcGVuTGF5ZXJzLkxheWVyLldNU1wifSwge1wib3BhY2l0eVwiOiAxLjAsIFwiZ3JvdXBcIjogXCJiYWNrZ3JvdW5kXCIsIFwibmFtZVwiOiBcIm5haXBcIiwgXCJ0aXRsZVwiOiBcIlNhdGVsbGl0ZSBJbWFnZXJ5XCIsIFwic2VsZWN0ZWRcIjogZmFsc2UsIFwidmlzaWJpbGl0eVwiOiBmYWxzZSwgXCJzb3VyY2VcIjogXCIxXCIsIFwiZml4ZWRcIjogdHJ1ZX0sIHtcIm9wYWNpdHlcIjogMS4wLCBcImdyb3VwXCI6IFwiYmFja2dyb3VuZFwiLCBcIm5hbWVcIjogXCJuYXR1cmFsLWVhcnRoLTFcIiwgXCJ0aXRsZVwiOiBcIk5hdHVyYWwgRWFydGhcIiwgXCJzZWxlY3RlZFwiOiBmYWxzZSwgXCJ2aXNpYmlsaXR5XCI6IGZhbHNlLCBcInNvdXJjZVwiOiBcIjJcIiwgXCJmaXhlZFwiOiBmYWxzZX0sIHtcIm9wYWNpdHlcIjogMS4wLCBcImdyb3VwXCI6IFwiYmFja2dyb3VuZFwiLCBcIm5hbWVcIjogXCJuYXR1cmFsLWVhcnRoLTJcIiwgXCJ0aXRsZVwiOiBcIk5hdHVyYWwgRWFydGggMlwiLCBcInNlbGVjdGVkXCI6IGZhbHNlLCBcInZpc2liaWxpdHlcIjogZmFsc2UsIFwic291cmNlXCI6IFwiMlwiLCBcImZpeGVkXCI6IGZhbHNlfSwge1wib3BhY2l0eVwiOiAxLjAsIFwiZ3JvdXBcIjogXCJiYWNrZ3JvdW5kXCIsIFwibmFtZVwiOiBcImdlb2dyYXBoeS1jbGFzc1wiLCBcInRpdGxlXCI6IFwiR2VvZ3JhcGh5IENsYXNzXCIsIFwic2VsZWN0ZWRcIjogZmFsc2UsIFwidmlzaWJpbGl0eVwiOiBmYWxzZSwgXCJzb3VyY2VcIjogXCIyXCIsIFwiZml4ZWRcIjogZmFsc2V9LCB7XCJvcGFjaXR5XCI6IDEuMCwgXCJncm91cFwiOiBcImJhY2tncm91bmRcIiwgXCJuYW1lXCI6IFwid29ybGQtbGlnaHRcIiwgXCJ0aXRsZVwiOiBcIldvcmxkIExpZ2h0XCIsIFwic2VsZWN0ZWRcIjogZmFsc2UsIFwidmlzaWJpbGl0eVwiOiBmYWxzZSwgXCJzb3VyY2VcIjogXCIyXCIsIFwiZml4ZWRcIjogZmFsc2V9LCB7XCJvcGFjaXR5XCI6IDEuMCwgXCJzdHlsZXNcIjogXCJnZW9ub2RlX0JyZXdlcmllc1wiLCBcIm5hbWVcIjogXCJCcmV3ZXJpZXMwXCIsIFwiZm9ybWF0XCI6IFwiaW1hZ2UvcG5nXCIsIFwiY2FjaGVkXCI6IHRydWUsIFwic2VsZWN0ZWRcIjogdHJ1ZSwgXCJ2aXNpYmlsaXR5XCI6IHRydWUsIFwiY2FwYWJpbGl0eVwiOiB7XCJhYnN0cmFjdFwiOiBcIlwiLCBcIm5lc3RlZExheWVyc1wiOiBbXSwgXCJjYXNjYWRlZFwiOiAwLCBcImZpeGVkSGVpZ2h0XCI6IDAsIFwicHJlZml4XCI6IFwiQnJld2VyaWVzMFwiLCBcImtleXdvcmRzXCI6IFtdLCBcIm5vU3Vic2V0c1wiOiBmYWxzZSwgXCJkaW1lbnNpb25zXCI6IHtcInRpbWVcIjoge1wibmVhcmVzdFZhbFwiOiBmYWxzZSwgXCJtdWx0aXBsZVZhbFwiOiBmYWxzZSwgXCJuYW1lXCI6IFwidGltZVwiLCBcImRlZmF1bHRcIjogXCJjdXJyZW50XCIsIFwiY3VycmVudFwiOiBmYWxzZSwgXCJ1bml0c1wiOiBcIklTTzg2MDFcIiwgXCJ2YWx1ZXNcIjogW1wiMTU4Ny0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTYwNy0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTYwOS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTYxMi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTYxNC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTYyMC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTYzMi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTYzMy0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTYzNC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTYzNy0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTYzOS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTY3MC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTY4My0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTczNC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTczOC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTc2NS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTc3NC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTc4OS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTc5Mi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTc5My0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTgwOC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTgxMC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTgxOS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTgyNi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTgyOS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTgzMC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTgzMy0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTgzNi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTgzNy0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg0MC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg0NC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg0Ni0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg0Ny0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg0OC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg0OS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg1MC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg1Mi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg1My0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg1NC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg1NS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg1Ni0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg1Ny0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg1OS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg2Mi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg2NS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg2Ni0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg2Ny0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg2OC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg2OS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg3MS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg3Mi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg3My0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg3NS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg3Ny0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg4NC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg4NS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg4Ny0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg4OC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg4OS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg5MC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg5Mi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg5OC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTg5OS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTkwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTkwMS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTkwNS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTkxNi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTkyMi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTkyNi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTkzNS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk1MS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk1My0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk1OS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk2Mi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk2OS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk3Mi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk3Ny0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk4Mi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk4NC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk5MC0wMS0wMVQwMDowMDowMC4wMDBaXCJdLCBcInVuaXRzeW1ib2xcIjogbnVsbH19LCBcIm9wYXF1ZVwiOiBmYWxzZSwgXCJ0aWxlU2V0c1wiOiBbe1wibGF5ZXJzXCI6IFwiQnJld2VyaWVzMFwiLCBcInN0eWxlc1wiOiBcIlwiLCBcImZvcm1hdFwiOiBcImltYWdlL3BuZ1wiLCBcImhlaWdodFwiOiAyNTYsIFwic3JzXCI6IHtcIkVQU0c6OTAwOTEzXCI6IHRydWV9LCBcImJib3hcIjoge1wiRVBTRzo5MDA5MTNcIjoge1wic3JzXCI6IFwiRVBTRzo5MDA5MTNcIiwgXCJiYm94XCI6IFstMjAwMzc1MDguMzQsIDAsIDAsIDIwMDM3NTA4LjM0XX19LCBcInJlc29sdXRpb25zXCI6IFsxNTY1NDMuMDMzOTA2MjUsIDc4MjcxLjUxNjk1MzEyNDk5OSwgMzkxMzUuNzU4NDc2NTYyNSwgMTk1NjcuODc5MjM4MjgxMjUsIDk3ODMuOTM5NjE5MTQwNjI0OSwgNDg5MS45Njk4MDk1NzAzMTI1LCAyNDQ1Ljk4NDkwNDc4NTE1NjIsIDEyMjIuOTkyNDUyMzkyNTc4MSwgNjExLjQ5NjIyNjE5NjI4OTA2LCAzMDUuNzQ4MTEzMDk4MTQ0NTMsIDE1Mi44NzQwNTY1NDkwNzIyNiwgNzYuNDM3MDI4Mjc0NTM2MTMyLCAzOC4yMTg1MTQxMzcyNjgwNjYsIDE5LjEwOTI1NzA2ODYzNDAzMywgOS41NTQ2Mjg1MzQzMTcwMTY1LCA0Ljc3NzMxNDI2NzE1ODUwODMsIDIuMzg4NjU3MTMzNTc5MjU0MSwgMS4xOTQzMjg1NjY3ODk2MjcxLCAwLjU5NzE2NDI4MzM5NDgxMzUzLCAwLjI5ODU4MjE0MTY5NzQwNjc3LCAwLjE0OTI5MTA3MDg0ODcwMzM4LCAwLjA3NDY0NTUzNTQyNDM1MTY5MiwgMC4wMzczMjI3Njc3MTIxNzU4NDYsIDAuMDE4NjYxMzgzODU2MDg3OTIzLCAwLjAwOTMzMDY5MTkyODA0Mzk2MTUsIDAuMDA0NjY1MzQ1OTY0MDIxOTgwNywgMC4wMDIzMzI2NzI5ODIwMTA5OTA0LCAwLjAwMTE2NjMzNjQ5MTAwNTQ5NTIsIDAuMDAwNTgzMTY4MjQ1NTAyNzQ3NTksIDAuMDAwMjkxNTg0MTIyNzUxMzczOCwgMC4wMDAxNDU3OTIwNjEzNzU2ODY5XSwgXCJ3aWR0aFwiOiAyNTZ9XSwgXCJpbmZvRm9ybWF0c1wiOiBbXCJ0ZXh0L3BsYWluXCIsIFwiYXBwbGljYXRpb24vdm5kLm9nYy5nbWxcIiwgXCJhcHBsaWNhdGlvbi92bmQub2djLmdtbC8zLjEuMVwiLCBcInRleHQvaHRtbFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIl0sIFwic3R5bGVzXCI6IFt7XCJhYnN0cmFjdFwiOiBcIlwiLCBcInRpdGxlXCI6IFwiYXp1cmUgc3F1YXJlIHBvaW50IHN0eWxlXCIsIFwibGVnZW5kXCI6IHtcImhlaWdodFwiOiBcIjIwXCIsIFwid2lkdGhcIjogXCIyMFwiLCBcImhyZWZcIjogXCJodHRwOi8vbWFwc3Rvcnkub3JnOjgwL2dlb3NlcnZlci9nZW9ub2RlL0JyZXdlcmllczAvd21zP3JlcXVlc3Q9R2V0TGVnZW5kR3JhcGhpYyZmb3JtYXQ9aW1hZ2UlMkZwbmcmd2lkdGg9MjAmaGVpZ2h0PTIwJmxheWVyPUJyZXdlcmllczBcIiwgXCJmb3JtYXRcIjogXCJpbWFnZS9wbmdcIn0sIFwibmFtZVwiOiBcImdlb25vZGVfQnJld2VyaWVzXCJ9XSwgXCJhdHRyaWJ1dGlvblwiOiB7XCJ0aXRsZVwiOiBcImFkbWluXCJ9LCBcImF1dGhvcml0eVVSTHNcIjoge30sIFwiYmJveFwiOiB7XCJFUFNHOjQzMjZcIjoge1wic3JzXCI6IFwiRVBTRzo0MzI2XCIsIFwiYmJveFwiOiBbLTE1Ny44MTY2NjcsIDIxLjMwMDAwMDAwMDAwMDAwMSwgLTY5Ljc4MDAwMDAwMDAwMDAwMSwgNDYuNjAxOTQ0MDAwMDAwMDAzXX19LCBcImZpeGVkV2lkdGhcIjogMCwgXCJtZXRhZGF0YVVSTHNcIjogW10sIFwibmFtZVwiOiBcIkJyZXdlcmllczBcIiwgXCJpZGVudGlmaWVyc1wiOiB7fSwgXCJzcnNcIjoge1wiRVBTRzo5MDA5MTNcIjogdHJ1ZX0sIFwiZm9ybWF0c1wiOiBbXCJpbWFnZS9wbmdcIiwgXCJhcHBsaWNhdGlvbi9hdG9tIHhtbFwiLCBcImFwcGxpY2F0aW9uL2F0b20reG1sXCIsIFwiYXBwbGljYXRpb24vb3BlbmxheWVyc1wiLCBcImFwcGxpY2F0aW9uL3BkZlwiLCBcImFwcGxpY2F0aW9uL3JzcyB4bWxcIiwgXCJhcHBsaWNhdGlvbi9yc3MreG1sXCIsIFwiYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbWxcIiwgXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbCB4bWxcIiwgXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbCt4bWxcIiwgXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbCt4bWw7bW9kZT1uZXR3b3JrbGlua1wiLCBcImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua216XCIsIFwiYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbXogeG1sXCIsIFwiYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbXoreG1sXCIsIFwiYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbXo7bW9kZT1uZXR3b3JrbGlua1wiLCBcImF0b21cIiwgXCJpbWFnZS9nZW90aWZmXCIsIFwiaW1hZ2UvZ2VvdGlmZjhcIiwgXCJpbWFnZS9naWZcIiwgXCJpbWFnZS9naWY7c3VidHlwZT1hbmltYXRlZFwiLCBcImltYWdlL2pwZWdcIiwgXCJpbWFnZS9wbmc4XCIsIFwiaW1hZ2UvcG5nOyBtb2RlPThiaXRcIiwgXCJpbWFnZS9zdmdcIiwgXCJpbWFnZS9zdmcgeG1sXCIsIFwiaW1hZ2Uvc3ZnK3htbFwiLCBcImltYWdlL3RpZmZcIiwgXCJpbWFnZS90aWZmOFwiLCBcImttbFwiLCBcImttelwiLCBcIm9wZW5sYXllcnNcIiwgXCJyc3NcIl0sIFwidGl0bGVcIjogXCJCcmV3ZXJpZXMwXCIsIFwicXVlcnlhYmxlXCI6IHRydWUsIFwibGxiYm94XCI6IFstMTU3LjgxNjY2NywgMjEuMzAwMDAwMDAwMDAwMDAxLCAtNjkuNzgwMDAwMDAwMDAwMDAxLCA0Ni42MDE5NDQwMDAwMDAwMDNdfSwgXCJzb3VyY2VcIjogXCJsb2NhbFwiLCBcInRpbGVkXCI6IGZhbHNlLCBcInRpdGxlXCI6IFwiQnJld2VyaWVzMFwiLCBcImZpeGVkXCI6IGZhbHNlLCBcInRyYW5zcGFyZW50XCI6IHRydWV9XSwgXCJ3cmFwRGF0ZUxpbmVcIjogZmFsc2UsIFwicHJvamVjdGlvblwiOiBcIkVQU0c6OTAwOTEzXCIsIFwiY2VudGVyXCI6IFstMTI2Njc5NzIuNTM2NTgsIDQxNTI1MTQuMDMwMDgzNzAwMV0sIFwiem9vbVwiOiA0LCBcInVuaXRzXCI6IFwibVwiLCBcIm1heFJlc29sdXRpb25cIjogMTU2NTQzLjAzMzkwNjI1LCBcIm1heEV4dGVudFwiOiBbLTIwMDM3NTA4LjM0LCAtMjAwMzc1MDguMzQsIDIwMDM3NTA4LjM0LCAyMDAzNzUwOC4zNF0sIFwibnVtWm9vbUxldmVsc1wiOiAyMn0sIFwiZGVmYXVsdFNvdXJjZVR5cGVcIjogXCJneHBfd21zY3NvdXJjZVwiLCBcImFwaUtleXNcIjoge1wiZ29vZ2xlXCI6IFwiQUJRSUFBQUFrb2Zvb1p4VGZjQ3Y5V2kzenpHVFZ4VG5tZTVFd25MVnRFREduaC1sRlZ6UkpoYmRRaFFnQWhCMWVUXzJtdVp0YzBkbC1aU1dydHptcndcIn0sIFwidG9vbHNcIjogW3tcIm91dHB1dENvbmZpZ1wiOiB7XCJsb29wZWRcIjogdHJ1ZSwgXCJsYXlvdXRcIjogXCJ0b29sYmFyXCIsIFwieHR5cGVcIjogXCJhcHBfcGxheWJhY2t0b29sYmFyXCIsIFwiaGlkZVBhcmVudFwiOiB0cnVlLCBcImNvbnRyb2xDb25maWdcIjoge1widGltZVN0ZXBcIjogbnVsbCwgXCJhbmltYXRpb25SYW5nZVwiOiBbLTEyMDg2MzIzMjAwMDAwLCA2MzExNTIwMDAwMDBdLCBcInNuYXBUb0xpc3RcIjogdHJ1ZSwgXCJtb2RlbFwiOiB7XCJyYW5nZVwiOiBbLTEyMDg2MzIzMjAwMDAwLCA2MzExNTIwMDAwMDBdLCBcInZhbHVlc1wiOiBbLTEyMDg2MzIzMjAwMDAwLCAtMTE0NTUxNzEyMDAwMDAsIC0xMTM5MjAxMjgwMDAwMCwgLTExMjk3NDA0ODAwMDAwLCAtMTEyMzQyNDY0MDAwMDAsIC0xMTA0NDk0NDAwMDAwMCwgLTEwNjY2MjUyODAwMDAwLCAtMTA2MzQ2MzA0MDAwMDAsIC0xMDYwMzA5NDQwMDAwMCwgLTEwNTA4NDAwMDAwMDAwLCAtMTA0NDUzMjgwMDAwMDAsIC05NDY3MDIwODAwMDAwLCAtOTA1Njc5MzYwMDAwMCwgLTc0NDc0MjA4MDAwMDAsIC03MzIxMTkwNDAwMDAwLCAtNjQ2OTExMzYwMDAwMCwgLTYxODUxMTY4MDAwMDAsIC01NzExNzMxMjAwMDAwLCAtNTYxNzEyMzIwMDAwMCwgLTU1ODU1MDA4MDAwMDAsIC01MTEyMjg4MDAwMDAwLCAtNTA0OTEyOTYwMDAwMCwgLTQ3NjUxMzI4MDAwMDAsIC00NTQ0MjA4MDAwMDAwLCAtNDQ0OTUxMzYwMDAwMCwgLTQ0MTc5Nzc2MDAwMDAsIC00MzIzMjgzMjAwMDAwLCAtNDIyODY3NTIwMDAwMCwgLTQxOTcwNTI4MDAwMDAsIC00MTAyNDQ0ODAwMDAwLCAtMzk3NjIxNDQwMDAwMCwgLTM5MTMwNTYwMDAwMDAsIC0zODgxNTIwMDAwMDAwLCAtMzg0OTk4NDAwMDAwMCwgLTM4MTgzNjE2MDAwMDAsIC0zNzg2ODI1NjAwMDAwLCAtMzcyMzc1MzYwMDAwMCwgLTM2OTIxMzEyMDAwMDAsIC0zNjYwNTk1MjAwMDAwLCAtMzYyOTA1OTIwMDAwMCwgLTM1OTc1MjMyMDAwMDAsIC0zNTY1OTAwODAwMDAwLCAtMzUwMjgyODgwMDAwMCwgLTM0MDgxMzQ0MDAwMDAsIC0zMzEzNDQwMDAwMDAwLCAtMzI4MTkwNDAwMDAwMCwgLTMyNTAzNjgwMDAwMDAsIC0zMjE4ODMyMDAwMDAwLCAtMzE4NzIwOTYwMDAwMCwgLTMxMjQxMzc2MDAwMDAsIC0zMDkyNjAxNjAwMDAwLCAtMzA2MDk3OTIwMDAwMCwgLTI5OTc5MDcyMDAwMDAsIC0yOTM0NzQ4ODAwMDAwLCAtMjcxMzkxMDQwMDAwMCwgLTI2ODIyODgwMDAwMDAsIC0yNjE5MjE2MDAwMDAwLCAtMjU4NzY4MDAwMDAwMCwgLTI1NTYwNTc2MDAwMDAsIC0yNTI0NTIxNjAwMDAwLCAtMjQ2MTQ0OTYwMDAwMCwgLTIyNzIwNjA4MDAwMDAsIC0yMjQwNTI0ODAwMDAwLCAtMjIwODk4ODgwMDAwMCwgLTIxNzc0NTI4MDAwMDAsIC0yMDUxMjIyNDAwMDAwLCAtMTcwNDE1MzYwMDAwMCwgLTE1MTQ3NjQ4MDAwMDAsIC0xMzg4NTM0NDAwMDAwLCAtMTEwNDUzNzYwMDAwMCwgLTU5OTYxNjAwMDAwMCwgLTUzNjQ1NzYwMDAwMCwgLTM0NzE1NTIwMDAwMCwgLTI1MjQ2MDgwMDAwMCwgLTMxNTM2MDAwMDAwLCA2MzA3MjAwMDAwMCwgMjIwOTI0ODAwMDAwLCAzNzg2OTEyMDAwMDAsIDQ0MTc2MzIwMDAwMCwgNjMxMTUyMDAwMDAwXSwgXCJkaW1lbnNpb25cIjogXCJ0aW1lXCJ9LCBcImRpbWVuc2lvblwiOiBcInRpbWVcIiwgXCJsb29wXCI6IHRydWV9LCBcImxpc3RlbmVyc1wiOiB7XCJzaW5nbGVcIjogdHJ1ZX0sIFwicmVtb3ZlTW9kZVwiOiBcImNvbnRhaW5lclwiLCBcInBsYXliYWNrTW9kZVwiOiBcImN1bXVsYXRpdmVcIiwgXCJkZWZhdWx0c1wiOiB7XCJzY2FsZVwiOiBcIm1lZGl1bVwifSwgXCJhdXRvUGxheVwiOiBmYWxzZX0sIFwibG9vcGVkXCI6IHRydWUsIFwib3V0cHV0VGFyZ2V0XCI6IFwibWFwLWJiYXJcIiwgXCJwdHlwZVwiOiBcImd4cF9wbGF5YmFja1wiLCBcImlkXCI6IFwicGxheWJhY2stdG9vbFwifSwge1wiYmdDb2xvclwiOiBcIiM0NTQyMzhcIiwgXCJ3cmFwRGF0ZUxpbmVcIjogZmFsc2UsIFwicHR5cGVcIjogXCJtcy10b29sLWJhclwiLCBcIm51bVpvb21MZXZlbHNcIjogMjJ9LCB7XCJwbGF5YmFja1Rvb2xcIjogXCJwbGF5YmFjay10b29sXCIsIFwib3V0cHV0Q29uZmlnXCI6IHtcInRpdGxlXCI6IG51bGx9LCBcIm91dHB1dFRhcmdldFwiOiBcInRpbWVsaW5lLWNvbnRhaW5lclwiLCBcInB0eXBlXCI6IFwiZ3hwX3RpbWVsaW5lXCIsIFwiaWRcIjogXCJ0aW1lbGluZS10b29sXCJ9XSwgXCJhdXRob3JpemVkUm9sZXNcIjogW1wiUk9MRV9BTk9OWU1PVVNcIl0sIFwiaWRcIjogMTE5M30nKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IE1hcENvbmZpZ1RyYW5zZm9ybWVyKGRhdGEpO1xuICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSkudG9CZSgne1wiaWRcIjoxMTkzLFwicGxheWJhY2tNb2RlXCI6XCJjdW11bGF0aXZlXCIsXCJtYXBcIjp7XCJjZW50ZXJcIjpbLTEyNjY3OTcyLjUzNjU4LDQxNTI1MTQuMDMwMDgzN10sXCJwcm9qZWN0aW9uXCI6XCJFUFNHOjkwMDkxM1wiLFwiem9vbVwiOjQsXCJsYXllcnNcIjpbe1widmlzaWJpbGl0eVwiOnRydWUsXCJncm91cFwiOlwiYmFja2dyb3VuZFwiLFwidHlwZVwiOlwiT1NNXCIsXCJ0aXRsZVwiOlwiT3BlblN0cmVldE1hcFwifSx7XCJ2aXNpYmlsaXR5XCI6dHJ1ZSxcInR5cGVcIjpcIldNU1wiLFwic2luZ2xlVGlsZVwiOnRydWUsXCJpZFwiOlwiQnJld2VyaWVzMFwiLFwibmFtZVwiOlwiQnJld2VyaWVzMFwiLFwidGl0bGVcIjpcIkJyZXdlcmllczBcIixcInVybFwiOlwiL2dlb3NlcnZlci9nZW9ub2RlL0JyZXdlcmllczAvd21zXCIsXCJwYXJhbXNcIjp7XCJMQVlFUlNcIjpcIkJyZXdlcmllczBcIixcIlNUWUxFU1wiOlwiZ2Vvbm9kZV9CcmV3ZXJpZXNcIixcIlRJTEVEXCI6XCJUUlVFXCIsXCJGT1JNQVRcIjpcImltYWdlL3BuZ1wiLFwiVFJBTlNQQVJFTlRcIjp0cnVlLFwiVkVSU0lPTlwiOlwiMS4xLjFcIn0sXCJsYXRsb25CQk9YXCI6Wy0xNTcuODE2NjY3LDIxLjMsLTY5Ljc4LDQ2LjYwMTk0NF0sXCJ0aW1lc1wiOlstMTIwODYzMjMyMDAwMDAsLTExNDU1MTcxMjAwMDAwLC0xMTM5MjAxMjgwMDAwMCwtMTEyOTc0MDQ4MDAwMDAsLTExMjM0MjQ2NDAwMDAwLC0xMTA0NDk0NDAwMDAwMCwtMTA2NjYyNTI4MDAwMDAsLTEwNjM0NjMwNDAwMDAwLC0xMDYwMzA5NDQwMDAwMCwtMTA1MDg0ODY0MDAwMDAsLTEwNDQ1NDE0NDAwMDAwLC05NDY3MTA3MjAwMDAwLC05MDU2ODgwMDAwMDAwLC03NDQ3NDIwODAwMDAwLC03MzIxMTkwNDAwMDAwLC02NDY5MTEzNjAwMDAwLC02MTg1MjAzMjAwMDAwLC01NzExODE3NjAwMDAwLC01NjE3MjA5NjAwMDAwLC01NTg1NTg3MjAwMDAwLC01MTEyMjg4MDAwMDAwLC01MDQ5MTI5NjAwMDAwLC00NzY1MTMyODAwMDAwLC00NTQ0MjA4MDAwMDAwLC00NDQ5NTEzNjAwMDAwLC00NDE3OTc3NjAwMDAwLC00MzIzMjgzMjAwMDAwLC00MjI4Njc1MjAwMDAwLC00MTk3MDUyODAwMDAwLC00MTAyNDQ0ODAwMDAwLC0zOTc2MjE0NDAwMDAwLC0zOTEzMDU2MDAwMDAwLC0zODgxNTIwMDAwMDAwLC0zODQ5OTg0MDAwMDAwLC0zODE4MzYxNjAwMDAwLC0zNzg2ODI1NjAwMDAwLC0zNzIzNzUzNjAwMDAwLC0zNjkyMTMxMjAwMDAwLC0zNjYwNTk1MjAwMDAwLC0zNjI5MDU5MjAwMDAwLC0zNTk3NTIzMjAwMDAwLC0zNTY1OTAwODAwMDAwLC0zNTAyODI4ODAwMDAwLC0zNDA4MTM0NDAwMDAwLC0zMzEzNDQwMDAwMDAwLC0zMjgxOTA0MDAwMDAwLC0zMjUwMzY4MDAwMDAwLC0zMjE4ODMyMDAwMDAwLC0zMTg3MjA5NjAwMDAwLC0zMTI0MTM3NjAwMDAwLC0zMDkyNjAxNjAwMDAwLC0zMDYwOTc5MjAwMDAwLC0yOTk3OTA3MjAwMDAwLC0yOTM0NzQ4ODAwMDAwLC0yNzEzOTEwNDAwMDAwLC0yNjgyMjg4MDAwMDAwLC0yNjE5MjE2MDAwMDAwLC0yNTg3NjgwMDAwMDAwLC0yNTU2MDU3NjAwMDAwLC0yNTI0NTIxNjAwMDAwLC0yNDYxNDQ5NjAwMDAwLC0yMjcyMDYwODAwMDAwLC0yMjQwNTI0ODAwMDAwLC0yMjA4OTg4ODAwMDAwLC0yMTc3NDUyODAwMDAwLC0yMDUxMjIyNDAwMDAwLC0xNzA0MTUzNjAwMDAwLC0xNTE0NzY0ODAwMDAwLC0xMzg4NTM0NDAwMDAwLC0xMTA0NTM3NjAwMDAwLC01OTk2MTYwMDAwMDAsLTUzNjQ1NzYwMDAwMCwtMzQ3MTU1MjAwMDAwLC0yNTI0NjA4MDAwMDAsLTMxNTM2MDAwMDAwLDYzMDcyMDAwMDAwLDIyMDkyNDgwMDAwMCwzNzg2OTEyMDAwMDAsNDQxNzYzMjAwMDAwLDYzMTE1MjAwMDAwMF0sXCJiYm94XCI6Wy0yMDAzNzUwOC4zNCwwLDAsMjAwMzc1MDguMzRdLFwicmVzb2x1dGlvbnNcIjpbMTU2NTQzLjAzMzkwNjI1LDc4MjcxLjUxNjk1MzEyNSwzOTEzNS43NTg0NzY1NjI1LDE5NTY3Ljg3OTIzODI4MTI1LDk3ODMuOTM5NjE5MTQwNjI1LDQ4OTEuOTY5ODA5NTcwMzEyNSwyNDQ1Ljk4NDkwNDc4NTE1NjIsMTIyMi45OTI0NTIzOTI1NzgxLDYxMS40OTYyMjYxOTYyODkxLDMwNS43NDgxMTMwOTgxNDQ1MywxNTIuODc0MDU2NTQ5MDcyMjYsNzYuNDM3MDI4Mjc0NTM2MTMsMzguMjE4NTE0MTM3MjY4MDY2LDE5LjEwOTI1NzA2ODYzNDAzMyw5LjU1NDYyODUzNDMxNzAxNyw0Ljc3NzMxNDI2NzE1ODUwOCwyLjM4ODY1NzEzMzU3OTI1NCwxLjE5NDMyODU2Njc4OTYyNywwLjU5NzE2NDI4MzM5NDgxMzUsMC4yOTg1ODIxNDE2OTc0MDY3NywwLjE0OTI5MTA3MDg0ODcwMzM4LDAuMDc0NjQ1NTM1NDI0MzUxNjksMC4wMzczMjI3Njc3MTIxNzU4NDYsMC4wMTg2NjEzODM4NTYwODc5MjMsMC4wMDkzMzA2OTE5MjgwNDM5NjEsMC4wMDQ2NjUzNDU5NjQwMjE5ODEsMC4wMDIzMzI2NzI5ODIwMTA5OTA0LDAuMDAxMTY2MzM2NDkxMDA1NDk1MiwwLjAwMDU4MzE2ODI0NTUwMjc0NzYsMC4wMDAyOTE1ODQxMjI3NTEzNzM4LDAuMDAwMTQ1NzkyMDYxMzc1Njg2OV19XX19Jyk7XG4gICAgfSk7XG59KTtcbiIsInZhciBTTERTdHlsZUNvbnZlcnRlciA9IHJlcXVpcmUoJy4uL2xpYi9lZGl0L3N0eWxlL1NMRFN0eWxlQ29udmVydGVyLmpzJykuU0xEU3R5bGVDb252ZXJ0ZXI7XG52YXIgaW5zdGFuY2UgPSBuZXcgU0xEU3R5bGVDb252ZXJ0ZXIoKTtcblxuZGVzY3JpYmUoJ1NMRFN0eWxlQ29udmVydGVyJywgZnVuY3Rpb24oKSB7XG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBqYXNtaW5lLmFkZE1hdGNoZXJzKGN1c3RvbU1hdGNoZXJzKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCBzaW1wbGUgdHlwZXMgKHBvaW50KScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGVDb25maWcgPSB7XG4gICAgICAgICAgICBcInR5cGVOYW1lXCI6IFwic2ltcGxlXCIsXG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJjaXJjbGVcIixcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNUeXBlXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjZmYwMDAwXCIsXG4gICAgICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiA4MFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IFwiI2ZmZmYwMFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlV2lkdGhcIjogMyxcbiAgICAgICAgICAgICAgICBcInN0cm9rZVN0eWxlXCI6IFwiZG90dGVkXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VPcGFjaXR5XCI6IDkwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZW9tVHlwZVwiOiBcInBvaW50XCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0eWxlID0gaW5zdGFuY2UuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgJ3NpbXBsZScpO1xuICAgICAgICBleHBlY3Qoc3R5bGUpLnRvQmVYTUwoJzxzbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yIHhtbG5zOnNsZD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvc2xkXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6b2djPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIiB2ZXJzaW9uPVwiMS4wLjBcIj48c2xkOk5hbWVkTGF5ZXI+PHNsZDpOYW1lPnNpbXBsZTwvc2xkOk5hbWU+PHNsZDpVc2VyU3R5bGU+PHNsZDpGZWF0dXJlVHlwZVN0eWxlPjxzbGQ6UnVsZT48c2xkOlBvaW50U3ltYm9saXplcj48c2xkOkdyYXBoaWM+PHNsZDpNYXJrPjxzbGQ6V2VsbEtub3duTmFtZT5jaXJjbGU8L3NsZDpXZWxsS25vd25OYW1lPjxzbGQ6RmlsbD48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbFwiPiNmZjAwMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGwtb3BhY2l0eVwiPjAuODwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpGaWxsPjxzbGQ6U3Ryb2tlPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2VcIj4jZmZmZjAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utd2lkdGhcIj4zPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utb3BhY2l0eVwiPjAuOTwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLWRhc2hhcnJheVwiPjEgMjwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpTdHJva2U+PC9zbGQ6TWFyaz48c2xkOk9wYWNpdHk+MC44PC9zbGQ6T3BhY2l0eT48c2xkOlNpemU+MTA8L3NsZDpTaXplPjwvc2xkOkdyYXBoaWM+PC9zbGQ6UG9pbnRTeW1ib2xpemVyPjwvc2xkOlJ1bGU+PC9zbGQ6RmVhdHVyZVR5cGVTdHlsZT48L3NsZDpVc2VyU3R5bGU+PC9zbGQ6TmFtZWRMYXllcj48L3NsZDpTdHlsZWRMYXllckRlc2NyaXB0b3I+Jyk7XG4gICAgICAgIC8vIHN2ZyBzeW1ib2wgKGdyYXBoaWMpXG4gICAgICAgIHN0eWxlQ29uZmlnID0ge1xuICAgICAgICAgICAgXCJ0eXBlTmFtZVwiOiBcInNpbXBsZVwiLFxuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgXCJncmFwaGljXCI6IFwiaWNvbi5zdmdcIixcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNUeXBlXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjZmYwMDAwXCIsXG4gICAgICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiA4MFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IFwiI2ZmZmYwMFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlV2lkdGhcIjogMyxcbiAgICAgICAgICAgICAgICBcInN0cm9rZVN0eWxlXCI6IFwic29saWRcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZU9wYWNpdHlcIjogOTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21UeXBlXCI6IFwicG9pbnRcIlxuICAgICAgICB9O1xuICAgICAgICBzdHlsZSA9IGluc3RhbmNlLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsICdzaW1wbGUnKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlKS50b0JlWE1MKCc8c2xkOlN0eWxlZExheWVyRGVzY3JpcHRvciB4bWxuczpzbGQ9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3NsZFwiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhtbG5zOm9nYz1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCIgdmVyc2lvbj1cIjEuMC4wXCI+PHNsZDpOYW1lZExheWVyPjxzbGQ6TmFtZT5zaW1wbGU8L3NsZDpOYW1lPjxzbGQ6VXNlclN0eWxlPjxzbGQ6RmVhdHVyZVR5cGVTdHlsZT48c2xkOlJ1bGU+PHNsZDpQb2ludFN5bWJvbGl6ZXI+PHNsZDpHcmFwaGljPjxzbGQ6RXh0ZXJuYWxHcmFwaGljPjxzbGQ6T25saW5lUmVzb3VyY2UgeGxpbms6aHJlZj1cImh0dHA6Ly9sb2NhbGhvc3Q6OTg3Ni9pY29uLnN2Zz9maWxsPSUyM2ZmMDAwMCZhbXA7c3Ryb2tlPSUyM2ZmZmYwMFwiLz48c2xkOkZvcm1hdD5pbWFnZS9zdmcreG1sPC9zbGQ6Rm9ybWF0Pjwvc2xkOkV4dGVybmFsR3JhcGhpYz48c2xkOk9wYWNpdHk+MC44PC9zbGQ6T3BhY2l0eT48c2xkOlNpemU+MTA8L3NsZDpTaXplPjwvc2xkOkdyYXBoaWM+PC9zbGQ6UG9pbnRTeW1ib2xpemVyPjwvc2xkOlJ1bGU+PC9zbGQ6RmVhdHVyZVR5cGVTdHlsZT48L3NsZDpVc2VyU3R5bGU+PC9zbGQ6TmFtZWRMYXllcj48L3NsZDpTdHlsZWRMYXllckRlc2NyaXB0b3I+Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbnZlcnQgc2ltcGxlIHR5cGVzIChsaW5lKScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGVDb25maWcgPSB7XG4gICAgICAgICAgICBcInR5cGVOYW1lXCI6IFwic2ltcGxlIGxpbmVcIixcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IFwiI2ZmZmYwMFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlV2lkdGhcIjogMyxcbiAgICAgICAgICAgICAgICBcInN0cm9rZVN0eWxlXCI6IFwiZGFzaGVkXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VPcGFjaXR5XCI6IDkwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZW9tVHlwZVwiOiBcImxpbmVcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgc3R5bGUgPSBpbnN0YW5jZS5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnLCAnc2ltcGxlIGxpbmUnKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlKS50b0JlWE1MKCc8c2xkOlN0eWxlZExheWVyRGVzY3JpcHRvciB4bWxuczpzbGQ9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3NsZFwiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhtbG5zOm9nYz1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCIgdmVyc2lvbj1cIjEuMC4wXCI+PHNsZDpOYW1lZExheWVyPjxzbGQ6TmFtZT5zaW1wbGUgbGluZTwvc2xkOk5hbWU+PHNsZDpVc2VyU3R5bGU+PHNsZDpGZWF0dXJlVHlwZVN0eWxlPjxzbGQ6UnVsZT48c2xkOkxpbmVTeW1ib2xpemVyPjxzbGQ6U3Ryb2tlPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2VcIj4jZmZmZjAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utd2lkdGhcIj4zPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utb3BhY2l0eVwiPjAuOTwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLWRhc2hhcnJheVwiPjU8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6U3Ryb2tlPjwvc2xkOkxpbmVTeW1ib2xpemVyPjwvc2xkOlJ1bGU+PC9zbGQ6RmVhdHVyZVR5cGVTdHlsZT48L3NsZDpVc2VyU3R5bGU+PC9zbGQ6TmFtZWRMYXllcj48L3NsZDpTdHlsZWRMYXllckRlc2NyaXB0b3I+Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbnZlcnQgc2ltcGxlIHR5cGVzIChwb2x5Z29uKScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGVDb25maWcgPSB7XG4gICAgICAgICAgICBcInR5cGVOYW1lXCI6IFwic2ltcGxlIHBvbHlnb25cIixcbiAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiNmZjAwMDBcIixcbiAgICAgICAgICAgICAgICBcImZpbGxPcGFjaXR5XCI6IDgwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjZmZmZjAwXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VXaWR0aFwiOiAzLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlU3R5bGVcIjogXCJkYXNoZWRcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZU9wYWNpdHlcIjogOTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21UeXBlXCI6IFwicG9seWdvblwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHlsZSA9IGluc3RhbmNlLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsICdzaW1wbGUgcG9seWdvbicpO1xuICAgICAgICBleHBlY3Qoc3R5bGUpLnRvQmVYTUwoJzxzbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yIHhtbG5zOnNsZD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvc2xkXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6b2djPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIiB2ZXJzaW9uPVwiMS4wLjBcIj48c2xkOk5hbWVkTGF5ZXI+PHNsZDpOYW1lPnNpbXBsZSBwb2x5Z29uPC9zbGQ6TmFtZT48c2xkOlVzZXJTdHlsZT48c2xkOkZlYXR1cmVUeXBlU3R5bGU+PHNsZDpSdWxlPjxzbGQ6UG9seWdvblN5bWJvbGl6ZXI+PHNsZDpGaWxsPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsXCI+I2ZmMDAwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbC1vcGFjaXR5XCI+MC44PC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOkZpbGw+PHNsZDpTdHJva2U+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZVwiPiNmZmZmMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS13aWR0aFwiPjM8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1vcGFjaXR5XCI+MC45PC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2UtZGFzaGFycmF5XCI+NTwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpTdHJva2U+PC9zbGQ6UG9seWdvblN5bWJvbGl6ZXI+PC9zbGQ6UnVsZT48L3NsZDpGZWF0dXJlVHlwZVN0eWxlPjwvc2xkOlVzZXJTdHlsZT48L3NsZDpOYW1lZExheWVyPjwvc2xkOlN0eWxlZExheWVyRGVzY3JpcHRvcj4nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCBsYWJlbHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlQ29uZmlnID0ge1xuICAgICAgICAgICAgXCJ0eXBlTmFtZVwiOiBcInNpbXBsZVwiLFxuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiY2lyY2xlXCIsXG4gICAgICAgICAgICAgICAgXCJncmFwaGljXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgXCJncmFwaGljVHlwZVwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2ZmMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwiZmlsbE9wYWNpdHlcIjogODBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNmZmZmMDBcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZVdpZHRoXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VTdHlsZVwiOiBcInNvbGlkXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VPcGFjaXR5XCI6IDkwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJsYWJlbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVcIjogXCJmb29cIixcbiAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgICAgICBcImZvbnRGYW1pbHlcIjogXCJzZXJpZlwiLFxuICAgICAgICAgICAgICAgIFwiZm9udFNpemVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJmb250U3R5bGVcIjogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICBcImZvbnRXZWlnaHRcIjogXCJub3JtYWxcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbVR5cGVcIjogXCJwb2ludFwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHlsZSA9IGluc3RhbmNlLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsICdzaW1wbGUnKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlKS50b0JlWE1MKCc8c2xkOlN0eWxlZExheWVyRGVzY3JpcHRvciB4bWxuczpzbGQ9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3NsZFwiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhtbG5zOm9nYz1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCIgdmVyc2lvbj1cIjEuMC4wXCI+PHNsZDpOYW1lZExheWVyPjxzbGQ6TmFtZT5zaW1wbGU8L3NsZDpOYW1lPjxzbGQ6VXNlclN0eWxlPjxzbGQ6RmVhdHVyZVR5cGVTdHlsZT48c2xkOlJ1bGU+PHNsZDpQb2ludFN5bWJvbGl6ZXI+PHNsZDpHcmFwaGljPjxzbGQ6TWFyaz48c2xkOldlbGxLbm93bk5hbWU+Y2lyY2xlPC9zbGQ6V2VsbEtub3duTmFtZT48c2xkOkZpbGw+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGxcIj4jZmYwMDAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsLW9wYWNpdHlcIj4wLjg8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6RmlsbD48c2xkOlN0cm9rZT48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlXCI+I2ZmZmYwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLXdpZHRoXCI+Mzwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLW9wYWNpdHlcIj4wLjk8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1kYXNoYXJyYXlcIi8+PC9zbGQ6U3Ryb2tlPjwvc2xkOk1hcms+PHNsZDpPcGFjaXR5PjAuODwvc2xkOk9wYWNpdHk+PHNsZDpTaXplPjEwPC9zbGQ6U2l6ZT48L3NsZDpHcmFwaGljPjwvc2xkOlBvaW50U3ltYm9saXplcj48c2xkOlRleHRTeW1ib2xpemVyPjxzbGQ6TGFiZWw+PG9nYzpQcm9wZXJ0eU5hbWU+Zm9vPC9vZ2M6UHJvcGVydHlOYW1lPjwvc2xkOkxhYmVsPjxzbGQ6Rm9udD48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZm9udC1mYW1pbHlcIj5TZXJpZjwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZm9udC1zaXplXCI+MTA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZvbnQtc3R5bGVcIj5ub3JtYWw8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZvbnQtd2VpZ2h0XCI+bm9ybWFsPC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOkZvbnQ+PHNsZDpMYWJlbFBsYWNlbWVudD48c2xkOkxpbmVQbGFjZW1lbnQvPjwvc2xkOkxhYmVsUGxhY2VtZW50PjxzbGQ6SGFsbz48c2xkOlJhZGl1cz4xPC9zbGQ6UmFkaXVzPjxzbGQ6RmlsbD48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbFwiPiNGRkZGRkY8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6RmlsbD48L3NsZDpIYWxvPjxzbGQ6RmlsbD48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbFwiPiMwMDAwMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6RmlsbD48c2xkOlZlbmRvck9wdGlvbiBuYW1lPVwibWF4RGlzcGxhY2VtZW50XCI+NDA8L3NsZDpWZW5kb3JPcHRpb24+PHNsZDpWZW5kb3JPcHRpb24gbmFtZT1cImF1dG9XcmFwXCI+NDA8L3NsZDpWZW5kb3JPcHRpb24+PHNsZDpWZW5kb3JPcHRpb24gbmFtZT1cInNwYWNlQXJvdW5kXCI+MDwvc2xkOlZlbmRvck9wdGlvbj48c2xkOlZlbmRvck9wdGlvbiBuYW1lPVwiZm9sbG93TGluZVwiPmZhbHNlPC9zbGQ6VmVuZG9yT3B0aW9uPjxzbGQ6VmVuZG9yT3B0aW9uIG5hbWU9XCJncm91cFwiPnllczwvc2xkOlZlbmRvck9wdGlvbj48c2xkOlZlbmRvck9wdGlvbiBuYW1lPVwiZ29vZG5lc3NPZkZpdFwiPjAuMjwvc2xkOlZlbmRvck9wdGlvbj48c2xkOlZlbmRvck9wdGlvbiBuYW1lPVwiY29uZmxpY3RSZXNvbHV0aW9uXCI+dHJ1ZTwvc2xkOlZlbmRvck9wdGlvbj48L3NsZDpUZXh0U3ltYm9saXplcj48L3NsZDpSdWxlPjwvc2xkOkZlYXR1cmVUeXBlU3R5bGU+PC9zbGQ6VXNlclN0eWxlPjwvc2xkOk5hbWVkTGF5ZXI+PC9zbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yPicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IHVuaXF1ZSBjbGFzc2lmaWNhdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGVDb25maWcgPSB7XG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNmZmZmMDBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbVR5cGVcIjogXCJwb2ludFwiLFxuICAgICAgICAgICAgXCJjbGFzc2lmeVwiOiB7XG4gICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVcIjogXCJmb29cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicnVsZXNcIjogW3tcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiYmFyXCIsXG4gICAgICAgICAgICAgICAgXCJzdHlsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2ZmOTkwMFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjZmY5OTAwXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiYmF6XCIsXG4gICAgICAgICAgICAgICAgXCJzdHlsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2IzNmIwMFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjYjM2YjAwXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHlsZSA9IGluc3RhbmNlLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcpO1xuICAgICAgICBleHBlY3Qoc3R5bGUpLnRvQmVYTUwoJzxzbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yIHhtbG5zOnNsZD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvc2xkXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6b2djPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIiB2ZXJzaW9uPVwiMS4wLjBcIj48c2xkOk5hbWVkTGF5ZXI+PHNsZDpVc2VyU3R5bGU+PHNsZDpGZWF0dXJlVHlwZVN0eWxlPjxzbGQ6UnVsZT48b2djOkZpbHRlcj48b2djOlByb3BlcnR5SXNFcXVhbFRvPjxvZ2M6UHJvcGVydHlOYW1lPmZvbzwvb2djOlByb3BlcnR5TmFtZT48b2djOkxpdGVyYWw+YmFyPC9vZ2M6TGl0ZXJhbD48L29nYzpQcm9wZXJ0eUlzRXF1YWxUbz48L29nYzpGaWx0ZXI+PHNsZDpQb2ludFN5bWJvbGl6ZXI+PHNsZDpHcmFwaGljPjxzbGQ6TWFyaz48c2xkOldlbGxLbm93bk5hbWU+Y2lyY2xlPC9zbGQ6V2VsbEtub3duTmFtZT48c2xkOkZpbGw+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGxcIj4jZmY5OTAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsLW9wYWNpdHlcIj4xPC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOkZpbGw+PHNsZDpTdHJva2U+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZVwiPiNmZmZmMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS13aWR0aFwiLz48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLW9wYWNpdHlcIi8+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1kYXNoYXJyYXlcIi8+PC9zbGQ6U3Ryb2tlPjwvc2xkOk1hcms+PHNsZDpPcGFjaXR5PjE8L3NsZDpPcGFjaXR5PjxzbGQ6U2l6ZT4xMDwvc2xkOlNpemU+PC9zbGQ6R3JhcGhpYz48L3NsZDpQb2ludFN5bWJvbGl6ZXI+PC9zbGQ6UnVsZT48c2xkOlJ1bGU+PG9nYzpGaWx0ZXI+PG9nYzpQcm9wZXJ0eUlzRXF1YWxUbz48b2djOlByb3BlcnR5TmFtZT5mb288L29nYzpQcm9wZXJ0eU5hbWU+PG9nYzpMaXRlcmFsPmJhejwvb2djOkxpdGVyYWw+PC9vZ2M6UHJvcGVydHlJc0VxdWFsVG8+PC9vZ2M6RmlsdGVyPjxzbGQ6UG9pbnRTeW1ib2xpemVyPjxzbGQ6R3JhcGhpYz48c2xkOk1hcms+PHNsZDpXZWxsS25vd25OYW1lPmNpcmNsZTwvc2xkOldlbGxLbm93bk5hbWU+PHNsZDpGaWxsPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsXCI+I2IzNmIwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbC1vcGFjaXR5XCI+MTwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpGaWxsPjxzbGQ6U3Ryb2tlPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2VcIj4jZmZmZjAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utd2lkdGhcIi8+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1vcGFjaXR5XCIvPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2UtZGFzaGFycmF5XCIvPjwvc2xkOlN0cm9rZT48L3NsZDpNYXJrPjxzbGQ6T3BhY2l0eT4xPC9zbGQ6T3BhY2l0eT48c2xkOlNpemU+MTA8L3NsZDpTaXplPjwvc2xkOkdyYXBoaWM+PC9zbGQ6UG9pbnRTeW1ib2xpemVyPjwvc2xkOlJ1bGU+PC9zbGQ6RmVhdHVyZVR5cGVTdHlsZT48L3NsZDpVc2VyU3R5bGU+PC9zbGQ6TmFtZWRMYXllcj48L3NsZDpTdHlsZWRMYXllckRlc2NyaXB0b3I+Jyk7XG4gICAgICAgIHN0eWxlQ29uZmlnLmdlb21UeXBlID0gXCJsaW5lXCI7XG4gICAgICAgIHN0eWxlID0gaW5zdGFuY2UuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZyk7XG4gICAgICAgIGV4cGVjdChzdHlsZSkudG9CZVhNTCgnPHNsZDpTdHlsZWRMYXllckRlc2NyaXB0b3IgeG1sbnM6c2xkPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGRcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bWxuczpvZ2M9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiIHZlcnNpb249XCIxLjAuMFwiPjxzbGQ6TmFtZWRMYXllcj48c2xkOlVzZXJTdHlsZT48c2xkOkZlYXR1cmVUeXBlU3R5bGU+PHNsZDpSdWxlPjxvZ2M6RmlsdGVyPjxvZ2M6UHJvcGVydHlJc0VxdWFsVG8+PG9nYzpQcm9wZXJ0eU5hbWU+Zm9vPC9vZ2M6UHJvcGVydHlOYW1lPjxvZ2M6TGl0ZXJhbD5iYXI8L29nYzpMaXRlcmFsPjwvb2djOlByb3BlcnR5SXNFcXVhbFRvPjwvb2djOkZpbHRlcj48c2xkOkxpbmVTeW1ib2xpemVyPjxzbGQ6U3Ryb2tlPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2VcIj4jZmY5OTAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utd2lkdGhcIi8+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1vcGFjaXR5XCIvPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2UtZGFzaGFycmF5XCIvPjwvc2xkOlN0cm9rZT48L3NsZDpMaW5lU3ltYm9saXplcj48L3NsZDpSdWxlPjxzbGQ6UnVsZT48b2djOkZpbHRlcj48b2djOlByb3BlcnR5SXNFcXVhbFRvPjxvZ2M6UHJvcGVydHlOYW1lPmZvbzwvb2djOlByb3BlcnR5TmFtZT48b2djOkxpdGVyYWw+YmF6PC9vZ2M6TGl0ZXJhbD48L29nYzpQcm9wZXJ0eUlzRXF1YWxUbz48L29nYzpGaWx0ZXI+PHNsZDpMaW5lU3ltYm9saXplcj48c2xkOlN0cm9rZT48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlXCI+I2IzNmIwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLXdpZHRoXCIvPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utb3BhY2l0eVwiLz48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLWRhc2hhcnJheVwiLz48L3NsZDpTdHJva2U+PC9zbGQ6TGluZVN5bWJvbGl6ZXI+PC9zbGQ6UnVsZT48L3NsZDpGZWF0dXJlVHlwZVN0eWxlPjwvc2xkOlVzZXJTdHlsZT48L3NsZDpOYW1lZExheWVyPjwvc2xkOlN0eWxlZExheWVyRGVzY3JpcHRvcj4nKTtcbiAgICAgICAgc3R5bGVDb25maWcuZ2VvbVR5cGUgPSBcInBvbHlnb25cIjtcbiAgICAgICAgc3R5bGUgPSBpbnN0YW5jZS5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlKS50b0JlWE1MKCc8c2xkOlN0eWxlZExheWVyRGVzY3JpcHRvciB4bWxuczpzbGQ9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3NsZFwiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhtbG5zOm9nYz1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCIgdmVyc2lvbj1cIjEuMC4wXCI+PHNsZDpOYW1lZExheWVyPjxzbGQ6VXNlclN0eWxlPjxzbGQ6RmVhdHVyZVR5cGVTdHlsZT48c2xkOlJ1bGU+PG9nYzpGaWx0ZXI+PG9nYzpQcm9wZXJ0eUlzRXF1YWxUbz48b2djOlByb3BlcnR5TmFtZT5mb288L29nYzpQcm9wZXJ0eU5hbWU+PG9nYzpMaXRlcmFsPmJhcjwvb2djOkxpdGVyYWw+PC9vZ2M6UHJvcGVydHlJc0VxdWFsVG8+PC9vZ2M6RmlsdGVyPjxzbGQ6UG9seWdvblN5bWJvbGl6ZXI+PHNsZDpGaWxsPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsXCI+I2ZmOTkwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbC1vcGFjaXR5XCI+MTwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpGaWxsPjxzbGQ6U3Ryb2tlPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2VcIj4jZmZmZjAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utd2lkdGhcIi8+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1vcGFjaXR5XCIvPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2UtZGFzaGFycmF5XCIvPjwvc2xkOlN0cm9rZT48L3NsZDpQb2x5Z29uU3ltYm9saXplcj48L3NsZDpSdWxlPjxzbGQ6UnVsZT48b2djOkZpbHRlcj48b2djOlByb3BlcnR5SXNFcXVhbFRvPjxvZ2M6UHJvcGVydHlOYW1lPmZvbzwvb2djOlByb3BlcnR5TmFtZT48b2djOkxpdGVyYWw+YmF6PC9vZ2M6TGl0ZXJhbD48L29nYzpQcm9wZXJ0eUlzRXF1YWxUbz48L29nYzpGaWx0ZXI+PHNsZDpQb2x5Z29uU3ltYm9saXplcj48c2xkOkZpbGw+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGxcIj4jYjM2YjAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsLW9wYWNpdHlcIj4xPC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOkZpbGw+PHNsZDpTdHJva2U+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZVwiPiNmZmZmMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS13aWR0aFwiLz48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLW9wYWNpdHlcIi8+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1kYXNoYXJyYXlcIi8+PC9zbGQ6U3Ryb2tlPjwvc2xkOlBvbHlnb25TeW1ib2xpemVyPjwvc2xkOlJ1bGU+PC9zbGQ6RmVhdHVyZVR5cGVTdHlsZT48L3NsZDpVc2VyU3R5bGU+PC9zbGQ6TmFtZWRMYXllcj48L3NsZDpTdHlsZWRMYXllckRlc2NyaXB0b3I+Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbnZlcnQgcmFuZ2VzIG9mIGEgY2xhc3NpZmljYXRpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlQ29uZmlnID0ge1xuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjZmZmZjAwXCJcbiAgICAgICAgICAgIH0sICBcbiAgICAgICAgICAgIFwiZ2VvbVR5cGVcIjogXCJwb2ludFwiLFxuICAgICAgICAgICAgXCJjbGFzc2lmeVwiOiB7XG4gICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVcIjogXCJmb29cIlxuICAgICAgICAgICAgfSwgICAgICBcbiAgICAgICAgICAgIFwicnVsZXNcIjogW3tcbiAgICAgICAgICAgICAgICBcInJhbmdlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJtaW5cIjogMCxcbiAgICAgICAgICAgICAgICAgICAgXCJtYXhcIjogMTBcbiAgICAgICAgICAgICAgICB9LCAgXG4gICAgICAgICAgICAgICAgXCJzdHlsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2ZmOTkwMFwiXG4gICAgICAgICAgICAgICAgICAgIH0gICBcbiAgICAgICAgICAgICAgICB9ICAgXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwibWluXCI6IDEwLFxuICAgICAgICAgICAgICAgICAgICBcIm1heFwiOiAyMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzdHlsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2IzNmIwMFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XVxuICAgICAgICB9OyAgXG4gICAgICAgIHZhciBzdHlsZSA9IGluc3RhbmNlLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcpO1xuICAgICAgICBleHBlY3Qoc3R5bGUpLnRvQmVYTUwoJzxzbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yIHhtbG5zOnNsZD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvc2xkXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6b2djPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIiB2ZXJzaW9uPVwiMS4wLjBcIj48c2xkOk5hbWVkTGF5ZXI+PHNsZDpVc2VyU3R5bGU+PHNsZDpGZWF0dXJlVHlwZVN0eWxlPjxzbGQ6UnVsZT48b2djOkZpbHRlcj48b2djOlByb3BlcnR5SXNCZXR3ZWVuPjxvZ2M6UHJvcGVydHlOYW1lPmZvbzwvb2djOlByb3BlcnR5TmFtZT48b2djOkxvd2VyQm91bmRhcnk+PG9nYzpMaXRlcmFsPjA8L29nYzpMaXRlcmFsPjwvb2djOkxvd2VyQm91bmRhcnk+PG9nYzpVcHBlckJvdW5kYXJ5PjxvZ2M6TGl0ZXJhbD4xMDwvb2djOkxpdGVyYWw+PC9vZ2M6VXBwZXJCb3VuZGFyeT48L29nYzpQcm9wZXJ0eUlzQmV0d2Vlbj48L29nYzpGaWx0ZXI+PHNsZDpQb2ludFN5bWJvbGl6ZXI+PHNsZDpHcmFwaGljPjxzbGQ6TWFyaz48c2xkOldlbGxLbm93bk5hbWU+Y2lyY2xlPC9zbGQ6V2VsbEtub3duTmFtZT48c2xkOkZpbGw+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGxcIj4jZmY5OTAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsLW9wYWNpdHlcIj4xPC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOkZpbGw+PHNsZDpTdHJva2U+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZVwiPiNmZmZmMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS13aWR0aFwiLz48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLW9wYWNpdHlcIi8+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1kYXNoYXJyYXlcIi8+PC9zbGQ6U3Ryb2tlPjwvc2xkOk1hcms+PHNsZDpPcGFjaXR5PjE8L3NsZDpPcGFjaXR5PjxzbGQ6U2l6ZT4xMDwvc2xkOlNpemU+PC9zbGQ6R3JhcGhpYz48L3NsZDpQb2ludFN5bWJvbGl6ZXI+PC9zbGQ6UnVsZT48c2xkOlJ1bGU+PG9nYzpGaWx0ZXI+PG9nYzpQcm9wZXJ0eUlzQmV0d2Vlbj48b2djOlByb3BlcnR5TmFtZT5mb288L29nYzpQcm9wZXJ0eU5hbWU+PG9nYzpMb3dlckJvdW5kYXJ5PjxvZ2M6TGl0ZXJhbD4xMDwvb2djOkxpdGVyYWw+PC9vZ2M6TG93ZXJCb3VuZGFyeT48b2djOlVwcGVyQm91bmRhcnk+PG9nYzpMaXRlcmFsPjIwPC9vZ2M6TGl0ZXJhbD48L29nYzpVcHBlckJvdW5kYXJ5Pjwvb2djOlByb3BlcnR5SXNCZXR3ZWVuPjwvb2djOkZpbHRlcj48c2xkOlBvaW50U3ltYm9saXplcj48c2xkOkdyYXBoaWM+PHNsZDpNYXJrPjxzbGQ6V2VsbEtub3duTmFtZT5jaXJjbGU8L3NsZDpXZWxsS25vd25OYW1lPjxzbGQ6RmlsbD48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbFwiPiNiMzZiMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGwtb3BhY2l0eVwiPjE8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6RmlsbD48c2xkOlN0cm9rZT48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlXCI+I2ZmZmYwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLXdpZHRoXCIvPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utb3BhY2l0eVwiLz48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLWRhc2hhcnJheVwiLz48L3NsZDpTdHJva2U+PC9zbGQ6TWFyaz48c2xkOk9wYWNpdHk+MTwvc2xkOk9wYWNpdHk+PHNsZDpTaXplPjEwPC9zbGQ6U2l6ZT48L3NsZDpHcmFwaGljPjwvc2xkOlBvaW50U3ltYm9saXplcj48L3NsZDpSdWxlPjwvc2xkOkZlYXR1cmVUeXBlU3R5bGU+PC9zbGQ6VXNlclN0eWxlPjwvc2xkOk5hbWVkTGF5ZXI+PC9zbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yPicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IHJvdGF0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIFwidHlwZU5hbWVcIjogXCJzaW1wbGVcIixcbiAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICBcInNpemVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcInRyaWFuZ2xlXCIsXG4gICAgICAgICAgICAgICAgXCJncmFwaGljXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgXCJncmFwaGljVHlwZVwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2ZmMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwiZmlsbE9wYWNpdHlcIjogODAsXG4gICAgICAgICAgICAgICAgXCJyb3RhdGlvbkF0dHJpYnV0ZVwiOiBcInJvdGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJyb3RhdGlvblVuaXRzXCI6IFwiZGVncmVlc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjZmZmZjAwXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VXaWR0aFwiOiAzLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlU3R5bGVcIjogXCJkb3R0ZWRcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZU9wYWNpdHlcIjogOTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21UeXBlXCI6IFwicG9pbnRcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgc3R5bGUgPSBpbnN0YW5jZS5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlKS50b0JlWE1MKCc8c2xkOlN0eWxlZExheWVyRGVzY3JpcHRvciB4bWxuczpzbGQ9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3NsZFwiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhtbG5zOm9nYz1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCIgdmVyc2lvbj1cIjEuMC4wXCI+PHNsZDpOYW1lZExheWVyPjxzbGQ6VXNlclN0eWxlPjxzbGQ6RmVhdHVyZVR5cGVTdHlsZT48c2xkOlJ1bGU+PHNsZDpQb2ludFN5bWJvbGl6ZXI+PHNsZDpHcmFwaGljPjxzbGQ6TWFyaz48c2xkOldlbGxLbm93bk5hbWU+dHJpYW5nbGU8L3NsZDpXZWxsS25vd25OYW1lPjxzbGQ6RmlsbD48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbFwiPiNmZjAwMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGwtb3BhY2l0eVwiPjAuODwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpGaWxsPjxzbGQ6U3Ryb2tlPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2VcIj4jZmZmZjAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utd2lkdGhcIj4zPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utb3BhY2l0eVwiPjAuOTwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLWRhc2hhcnJheVwiPjEgMjwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpTdHJva2U+PC9zbGQ6TWFyaz48c2xkOk9wYWNpdHk+MC44PC9zbGQ6T3BhY2l0eT48c2xkOlNpemU+MTA8L3NsZDpTaXplPjxzbGQ6Um90YXRpb24+PG9nYzpQcm9wZXJ0eU5hbWU+cm90YXRpb248L29nYzpQcm9wZXJ0eU5hbWU+PC9zbGQ6Um90YXRpb24+PC9zbGQ6R3JhcGhpYz48L3NsZDpQb2ludFN5bWJvbGl6ZXI+PC9zbGQ6UnVsZT48L3NsZDpGZWF0dXJlVHlwZVN0eWxlPjwvc2xkOlVzZXJTdHlsZT48L3NsZDpOYW1lZExheWVyPjwvc2xkOlN0eWxlZExheWVyRGVzY3JpcHRvcj4nKTtcblxuICAgICAgICAgLy8gbm93IHVzZSByYWRpYW5zXG4gICAgICAgICBzdHlsZUNvbmZpZy5zeW1ib2wucm90YXRpb25Vbml0cyA9IFwicmFkaWFuc1wiO1xuICAgICAgICAgc3R5bGUgPSBpbnN0YW5jZS5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnKTtcbiAgICAgICAgIGV4cGVjdChzdHlsZSkudG9CZVhNTCgnPHNsZDpTdHlsZWRMYXllckRlc2NyaXB0b3IgeG1sbnM6c2xkPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGRcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bWxuczpvZ2M9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiIHZlcnNpb249XCIxLjAuMFwiPjxzbGQ6TmFtZWRMYXllcj48c2xkOlVzZXJTdHlsZT48c2xkOkZlYXR1cmVUeXBlU3R5bGU+PHNsZDpSdWxlPjxzbGQ6UG9pbnRTeW1ib2xpemVyPjxzbGQ6R3JhcGhpYz48c2xkOk1hcms+PHNsZDpXZWxsS25vd25OYW1lPnRyaWFuZ2xlPC9zbGQ6V2VsbEtub3duTmFtZT48c2xkOkZpbGw+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGxcIj4jZmYwMDAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsLW9wYWNpdHlcIj4wLjg8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6RmlsbD48c2xkOlN0cm9rZT48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlXCI+I2ZmZmYwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLXdpZHRoXCI+Mzwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLW9wYWNpdHlcIj4wLjk8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1kYXNoYXJyYXlcIj4xIDI8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6U3Ryb2tlPjwvc2xkOk1hcms+PHNsZDpPcGFjaXR5PjAuODwvc2xkOk9wYWNpdHk+PHNsZDpTaXplPjEwPC9zbGQ6U2l6ZT48c2xkOlJvdGF0aW9uPjxvZ2M6RGl2PjxvZ2M6UHJvcGVydHlOYW1lPnJvdGF0aW9uPC9vZ2M6UHJvcGVydHlOYW1lPjxvZ2M6RGl2PjxvZ2M6RnVuY3Rpb24gbmFtZT1cInBpXCIvPjxvZ2M6TGl0ZXJhbD4zNjA8L29nYzpMaXRlcmFsPjwvb2djOkRpdj48L29nYzpEaXY+PC9zbGQ6Um90YXRpb24+PC9zbGQ6R3JhcGhpYz48L3NsZDpQb2ludFN5bWJvbGl6ZXI+PC9zbGQ6UnVsZT48L3NsZDpGZWF0dXJlVHlwZVN0eWxlPjwvc2xkOlVzZXJTdHlsZT48L3NsZDpOYW1lZExheWVyPjwvc2xkOlN0eWxlZExheWVyRGVzY3JpcHRvcj4nKTtcbiAgICB9KTtcblxufSk7XG4iLCJ2YXIgU3R5bGVDb21wbGV0ZSA9IHJlcXVpcmUoJy4uL2xpYi9lZGl0L3N0eWxlL1N0eWxlQ29tcGxldGUuanMnKS5TdHlsZUNvbXBsZXRlO1xudmFyIGluc3RhbmNlID0gbmV3IFN0eWxlQ29tcGxldGUoKTtcblxuZGVzY3JpYmUoJ1N0eWxlQ29tcGxldGUnLCBmdW5jdGlvbigpIHtcblxuICAgIGl0KCd1bmlxdWUgY2xhc3NpZmljYXRpb24gbmVlZHMgYXR0cmlidXRlLCBtYXhDbGFzc2VzIGFuZCBjb2xvclBhbGV0dGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgXCJjbGFzc2lmeVwiOiB7XG4gICAgICAgICAgICAgICAgXCJtZXRob2RcIjogXCJ1bmlxdWVcIixcbiAgICAgICAgICAgICAgICBcIm1heENsYXNzZXNcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXN1bHQgPSBpbnN0YW5jZS5pc0NvbXBsZXRlKHN0eWxlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZUZhbHN5KCk7XG4gICAgICAgIHN0eWxlLmNsYXNzaWZ5LmF0dHJpYnV0ZSA9ICdmb28nO1xuICAgICAgICByZXN1bHQgPSBpbnN0YW5jZS5pc0NvbXBsZXRlKHN0eWxlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZUZhbHN5KCk7XG4gICAgICAgIHN0eWxlLmNsYXNzaWZ5Lm1heENsYXNzZXMgPSAxMDtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZUZhbHN5KCk7XG4gICAgICAgIHN0eWxlLmNsYXNzaWZ5LmNvbG9yUGFsZXR0ZSA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IGluc3RhbmNlLmlzQ29tcGxldGUoc3R5bGUpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlVHJ1dGh5KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnb3RoZXIgY2xhc3NpZmNhdGlvbiB0eXBlcyBuZWVkIHRvIGhhdmUgYWxsIGluZm8nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgXCJjbGFzc2lmeVwiOiB7XG4gICAgICAgICAgICAgICAgXCJtZXRob2RcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiY29sb3JSYW1wXCI6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydWxlczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGluc3RhbmNlLmlzQ29tcGxldGUoc3R5bGUpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlRmFsc3koKTtcbiAgICAgICAgc3R5bGUuY2xhc3NpZnkubWV0aG9kID0gJ2Zvbyc7XG4gICAgICAgIHJlc3VsdCA9IGluc3RhbmNlLmlzQ29tcGxldGUoc3R5bGUpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlRmFsc3koKTtcbiAgICAgICAgc3R5bGUuY2xhc3NpZnkuYXR0cmlidXRlID0gJ2Jhcic7XG4gICAgICAgIHJlc3VsdCA9IGluc3RhbmNlLmlzQ29tcGxldGUoc3R5bGUpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlRmFsc3koKTtcbiAgICAgICAgc3R5bGUuY2xhc3NpZnkuY29sb3JSYW1wID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0ID0gaW5zdGFuY2UuaXNDb21wbGV0ZShzdHlsZSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVGYWxzeSgpO1xuICAgICAgICBzdHlsZS5ydWxlcy5wdXNoKHt9KTtcbiAgICAgICAgcmVzdWx0ID0gaW5zdGFuY2UuaXNDb21wbGV0ZShzdHlsZSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVUcnV0aHkoKTtcbiAgICB9KTtcblxufSk7XG5cbiIsInZhciBXRlNfREZUID0gcmVxdWlyZSgnLi4vbGliL2VkaXQvc3R5bGUvV0ZTRGVzY3JpYmVGZWF0dXJlVHlwZS5qcycpLldGU0Rlc2NyaWJlRmVhdHVyZVR5cGU7XG52YXIgaW5zdGFuY2UgPSBuZXcgV0ZTX0RGVCgpO1xuXG5kZXNjcmliZSgnV0ZTRGVzY3JpYmVGZWF0dXJlVHlwZScsIGZ1bmN0aW9uKCkge1xuICAgIGl0KCdzaG91bGQgcGFyc2UgYSBXRlMgRGVzY3JpYmVGZWF0dXJlVHlwZSByZXNwb25zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeG1sID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/Pjx4c2Q6c2NoZW1hIHhtbG5zOnhzZD1cImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hXCIgeG1sbnM6Z2Vvbm9kZT1cImh0dHA6Ly9nZW9ub2RlLm9yZy9cIiB4bWxuczpnbWw9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbFwiIGVsZW1lbnRGb3JtRGVmYXVsdD1cInF1YWxpZmllZFwiIHRhcmdldE5hbWVzcGFjZT1cImh0dHA6Ly9nZW9ub2RlLm9yZy9cIj4nICtcbicgIDx4c2Q6aW1wb3J0IG5hbWVzcGFjZT1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sXCIgc2NoZW1hTG9jYXRpb249XCJodHRwOi8vbWFwc3Rvcnkub3JnOjgwL2dlb3NlcnZlci9zY2hlbWFzL2dtbC8yLjEuMi9mZWF0dXJlLnhzZFwiLz4nICtcbicgIDx4c2Q6Y29tcGxleFR5cGUgbmFtZT1cImFmcmljYW5fYmVlc18yMDA5VHlwZVwiPicgK1xuJyAgICA8eHNkOmNvbXBsZXhDb250ZW50PicgK1xuJyAgICAgIDx4c2Q6ZXh0ZW5zaW9uIGJhc2U9XCJnbWw6QWJzdHJhY3RGZWF0dXJlVHlwZVwiPicgK1xuJyAgICAgICAgPHhzZDpzZXF1ZW5jZT4nICtcbicgICAgICAgICAgPHhzZDplbGVtZW50IG1heE9jY3Vycz1cIjFcIiBtaW5PY2N1cnM9XCIwXCIgbmFtZT1cInRoZV9nZW9tXCIgbmlsbGFibGU9XCJ0cnVlXCIgdHlwZT1cImdtbDpNdWx0aVBvbHlnb25Qcm9wZXJ0eVR5cGVcIi8+JyArXG4nICAgICAgICAgIDx4c2Q6ZWxlbWVudCBtYXhPY2N1cnM9XCIxXCIgbWluT2NjdXJzPVwiMFwiIG5hbWU9XCJBUkVBXCIgbmlsbGFibGU9XCJ0cnVlXCIgdHlwZT1cInhzZDpkb3VibGVcIi8+JyArXG4nICAgICAgICAgIDx4c2Q6ZWxlbWVudCBtYXhPY2N1cnM9XCIxXCIgbWluT2NjdXJzPVwiMFwiIG5hbWU9XCJQRVJJTUVURVJcIiBuaWxsYWJsZT1cInRydWVcIiB0eXBlPVwieHNkOmRvdWJsZVwiLz4nICtcbicgICAgICAgICAgPHhzZDplbGVtZW50IG1heE9jY3Vycz1cIjFcIiBtaW5PY2N1cnM9XCIwXCIgbmFtZT1cIkFGUkJFRVAwMjBcIiBuaWxsYWJsZT1cInRydWVcIiB0eXBlPVwieHNkOmxvbmdcIi8+JyArXG4nICAgICAgICAgIDx4c2Q6ZWxlbWVudCBtYXhPY2N1cnM9XCIxXCIgbWluT2NjdXJzPVwiMFwiIG5hbWU9XCJTVEFURVwiIG5pbGxhYmxlPVwidHJ1ZVwiIHR5cGU9XCJ4c2Q6c3RyaW5nXCIvPicgK1xuJyAgICAgICAgICA8eHNkOmVsZW1lbnQgbWF4T2NjdXJzPVwiMVwiIG1pbk9jY3Vycz1cIjBcIiBuYW1lPVwiQ09VTlRZXCIgbmlsbGFibGU9XCJ0cnVlXCIgdHlwZT1cInhzZDpzdHJpbmdcIi8+JyArXG4nICAgICAgICAgIDx4c2Q6ZWxlbWVudCBtYXhPY2N1cnM9XCIxXCIgbWluT2NjdXJzPVwiMFwiIG5hbWU9XCJGSVBTXCIgbmlsbGFibGU9XCJ0cnVlXCIgdHlwZT1cInhzZDpzdHJpbmdcIi8+JyArXG4nICAgICAgICAgIDx4c2Q6ZWxlbWVudCBtYXhPY2N1cnM9XCIxXCIgbWluT2NjdXJzPVwiMFwiIG5hbWU9XCJTVEFURV9GSVBTXCIgbmlsbGFibGU9XCJ0cnVlXCIgdHlwZT1cInhzZDpzdHJpbmdcIi8+JyArXG4nICAgICAgICAgIDx4c2Q6ZWxlbWVudCBtYXhPY2N1cnM9XCIxXCIgbWluT2NjdXJzPVwiMFwiIG5hbWU9XCJGSVJTVF9ZUlwiIG5pbGxhYmxlPVwidHJ1ZVwiIHR5cGU9XCJ4c2Q6ZGF0ZVRpbWVcIi8+JyArXG4nICAgICAgICA8L3hzZDpzZXF1ZW5jZT4nICtcbicgICAgICA8L3hzZDpleHRlbnNpb24+JyArXG4nICAgIDwveHNkOmNvbXBsZXhDb250ZW50PicgK1xuJyAgPC94c2Q6Y29tcGxleFR5cGU+JyArXG4nICA8eHNkOmVsZW1lbnQgbmFtZT1cImFmcmljYW5fYmVlc18yMDA5XCIgc3Vic3RpdHV0aW9uR3JvdXA9XCJnbWw6X0ZlYXR1cmVcIiB0eXBlPVwiZ2Vvbm9kZTphZnJpY2FuX2JlZXNfMjAwOVR5cGVcIi8+JyArXG4nPC94c2Q6c2NoZW1hPic7XG4gICAgICAgIGV4cGVjdChKU09OLnN0cmluZ2lmeShpbnN0YW5jZS5wYXJzZVJlc3VsdCh4bWwpKSkudG9CZSgne1widGltZUF0dHJpYnV0ZVwiOlwiRklSU1RfWVJcIixcImZlYXR1cmVOU1wiOlwiaHR0cDovL2dlb25vZGUub3JnL1wiLFwiZ2VvbVR5cGVcIjpcInBvbHlnb25cIixcImF0dHJpYnV0ZXNcIjpbe1wibmFtZVwiOlwidGhlX2dlb21cIixcInR5cGVcIjpcIk11bHRpUG9seWdvblByb3BlcnR5VHlwZVwiLFwidHlwZU5TXCI6XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbFwifSx7XCJuYW1lXCI6XCJBUkVBXCIsXCJ0eXBlXCI6XCJkb3VibGVcIixcInR5cGVOU1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWFcIn0se1wibmFtZVwiOlwiUEVSSU1FVEVSXCIsXCJ0eXBlXCI6XCJkb3VibGVcIixcInR5cGVOU1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWFcIn0se1wibmFtZVwiOlwiQUZSQkVFUDAyMFwiLFwidHlwZVwiOlwibG9uZ1wiLFwidHlwZU5TXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYVwifSx7XCJuYW1lXCI6XCJTVEFURVwiLFwidHlwZVwiOlwic3RyaW5nXCIsXCJ0eXBlTlNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hXCJ9LHtcIm5hbWVcIjpcIkNPVU5UWVwiLFwidHlwZVwiOlwic3RyaW5nXCIsXCJ0eXBlTlNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hXCJ9LHtcIm5hbWVcIjpcIkZJUFNcIixcInR5cGVcIjpcInN0cmluZ1wiLFwidHlwZU5TXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYVwifSx7XCJuYW1lXCI6XCJTVEFURV9GSVBTXCIsXCJ0eXBlXCI6XCJzdHJpbmdcIixcInR5cGVOU1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWFcIn0se1wibmFtZVwiOlwiRklSU1RfWVJcIixcInR5cGVcIjpcImRhdGVUaW1lXCIsXCJ0eXBlTlNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hXCJ9XX0nKTtcbiAgICB9KTtcbn0pO1xuIiwidmFyIFdQU0NsYXNzaWZ5ID0gcmVxdWlyZSgnLi4vbGliL2VkaXQvc3R5bGUvV1BTQ2xhc3NpZnkuanMnKS5XUFNDbGFzc2lmeTtcbnZhciBpbnN0YW5jZSA9IG5ldyBXUFNDbGFzc2lmeSgpO1xuXG5kZXNjcmliZSgnV1BTQ2xhc3NpZnknLCBmdW5jdGlvbigpIHtcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGphc21pbmUuYWRkTWF0Y2hlcnMoY3VzdG9tTWF0Y2hlcnMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgdGhlIGNvcnJlY3QgV1BTIHJlcXVlc3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICB0eXBlTmFtZTogJ2NpdGU6c3RhdGVzJyxcbiAgICAgICAgICAgIGZlYXR1cmVOUzogJ2h0dHA6Ly93d3cub3Blbmdlb3NwYXRpYWwubmV0L2NpdGUnLFxuICAgICAgICAgICAgZmVhdHVyZVByZWZpeDogJ2NpdGUnLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnUE9QVUxBVElPTicsXG4gICAgICAgICAgICBudW1DbGFzc2VzOiAxMCxcbiAgICAgICAgICAgIG1ldGhvZDogJ0VRVUFMX0lOVEVSVkFMJ1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGluc3RhbmNlLmNsYXNzaWZ5VmVjdG9yKGRhdGEpO1xuICAgICAgICBleHBlY3QocmVxdWVzdCkudG9CZVhNTCgnPHdwczpFeGVjdXRlIHhtbG5zOndwcz1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvd3BzLzEuMC4wXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6b3dzPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vd3MvMS4xXCIgeG1sbnM6d2ZzPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93ZnNcIiBzZXJ2aWNlPVwiV1BTXCIgdmVyc2lvbj1cIjEuMC4wXCI+PG93czpJZGVudGlmaWVyPnZlYzpGZWF0dXJlQ2xhc3NTdGF0czwvb3dzOklkZW50aWZpZXI+PHdwczpEYXRhSW5wdXRzPjx3cHM6SW5wdXQ+PG93czpJZGVudGlmaWVyPmZlYXR1cmVzPC9vd3M6SWRlbnRpZmllcj48d3BzOlJlZmVyZW5jZSB4bGluazpocmVmPVwiaHR0cDovL2dlb3NlcnZlci93ZnNcIiBtZXRob2Q9XCJQT1NUXCIgbWltZVR5cGU9XCJ0ZXh0L3htbFwiPjx3cHM6Qm9keT48d2ZzOkdldEZlYXR1cmUgc2VydmljZT1cIldGU1wiIHZlcnNpb249XCIxLjEuMFwiIG91dHB1dEZvcm1hdD1cIkdNTDJcIj48d2ZzOlF1ZXJ5IHhtbG5zOmNpdGU9XCJodHRwOi8vd3d3Lm9wZW5nZW9zcGF0aWFsLm5ldC9jaXRlXCIgdHlwZU5hbWU9XCJjaXRlOnN0YXRlc1wiLz48L3dmczpHZXRGZWF0dXJlPjwvd3BzOkJvZHk+PC93cHM6UmVmZXJlbmNlPjwvd3BzOklucHV0Pjx3cHM6SW5wdXQ+PG93czpJZGVudGlmaWVyPmF0dHJpYnV0ZTwvb3dzOklkZW50aWZpZXI+PHdwczpEYXRhPjx3cHM6TGl0ZXJhbERhdGE+UE9QVUxBVElPTjwvd3BzOkxpdGVyYWxEYXRhPjwvd3BzOkRhdGE+PC93cHM6SW5wdXQ+PHdwczpJbnB1dD48b3dzOklkZW50aWZpZXI+Y2xhc3Nlczwvb3dzOklkZW50aWZpZXI+PHdwczpEYXRhPjx3cHM6TGl0ZXJhbERhdGE+MTA8L3dwczpMaXRlcmFsRGF0YT48L3dwczpEYXRhPjwvd3BzOklucHV0Pjx3cHM6SW5wdXQ+PG93czpJZGVudGlmaWVyPm1ldGhvZDwvb3dzOklkZW50aWZpZXI+PHdwczpEYXRhPjx3cHM6TGl0ZXJhbERhdGE+RVFVQUxfSU5URVJWQUw8L3dwczpMaXRlcmFsRGF0YT48L3dwczpEYXRhPjwvd3BzOklucHV0Pjx3cHM6SW5wdXQ+PG93czpJZGVudGlmaWVyPnN0YXRzPC9vd3M6SWRlbnRpZmllcj48d3BzOkRhdGE+PHdwczpMaXRlcmFsRGF0YT5tZWFuPC93cHM6TGl0ZXJhbERhdGE+PC93cHM6RGF0YT48L3dwczpJbnB1dD48L3dwczpEYXRhSW5wdXRzPjx3cHM6UmVzcG9uc2VGb3JtPjx3cHM6UmF3RGF0YU91dHB1dD48b3dzOklkZW50aWZpZXI+cmVzdWx0czwvb3dzOklkZW50aWZpZXI+PC93cHM6UmF3RGF0YU91dHB1dD48L3dwczpSZXNwb25zZUZvcm0+PC93cHM6RXhlY3V0ZT4nKTtcbiAgICB9KTtcblxufSk7XG4iLCJ2YXIgYm94ZXMgPSByZXF1aXJlKCcuLi9saWIvY29yZS90aW1lL2JveGVzLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi9saWIvY29yZS90aW1lL3V0aWxzLmpzJyk7XG52YXIgQm94ID0gYm94ZXMuQm94O1xudmFyIEJveE1vZGVsID0gYm94ZXMuQm94TW9kZWw7XG5cbmRlc2NyaWJlKFwidGVzdCBib3hlc1wiLCBmdW5jdGlvbigpIHtcbiAgICBpdChcImZpbmRzIHRoZSByaWdodCBib3ggYnkgaW5kZXhcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGV4cGVjdEJveE9mZnNldChkYXRhLCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3QoYm94ZXMuZmluZEJveChkYXRhLCBpZHgpLl9vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgdmFyIGRhdGEgPSBbe19vZmZzZXQ6IDB9XTtcbiAgICAgICAgZXhwZWN0Qm94T2Zmc2V0KGRhdGEsIDApLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdEJveE9mZnNldChkYXRhLCAxKS50b0JlKDApO1xuXG4gICAgICAgIGRhdGEgPSBbe19vZmZzZXQ6IDB9LCB7X29mZnNldDogMTB9XTtcbiAgICAgICAgZXhwZWN0Qm94T2Zmc2V0KGRhdGEsIDApLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdEJveE9mZnNldChkYXRhLCA1KS50b0JlKDApO1xuICAgICAgICBleHBlY3RCb3hPZmZzZXQoZGF0YSwgMTApLnRvQmUoMTApO1xuICAgICAgICBleHBlY3RCb3hPZmZzZXQoZGF0YSwgMTEpLnRvQmUoMTApO1xuICAgIH0pO1xuICAgIGl0KFwiYm94IHN0ZXBzIHdvcmtzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2V4cGVjdChuZXcgQm94KHtkYXRhOiBbMSwgMiwgM119KS5nZXRTdGVwcygpKS50b0JlKDMpO1xuICAgICAgICBleHBlY3QobmV3IEJveCh7cmFuZ2U6IHV0aWxzLmNyZWF0ZVJhbmdlKDEwMDAwLCAyMDAwMCksIHNwZWVkOiB7aW50ZXJ2YWw6IDEwMDB9fSkuZ2V0U3RlcHMoKSkudG9CZSgxMSk7XG4gICAgICAgIGV4cGVjdChuZXcgQm94KHtyYW5nZTogdXRpbHMuY3JlYXRlUmFuZ2UoMTAwMDAsIDExMDAwKSwgc3BlZWQ6IHtpbnRlcnZhbDogMzMzfX0pLmdldFN0ZXBzKCkpLnRvQmUoNCk7XG4gICAgfSk7XG4gICAgaXQoXCJib3ggZ2V0SW5kZXggd29ya3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBib3ggPSBuZXcgQm94KHtkYXRhOiBbMSwgNSwgMTBdfSk7XG4gICAgICAgIGV4cGVjdChib3guZ2V0SW5kZXgoMCkpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChib3guZ2V0SW5kZXgoMSkpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChib3guZ2V0SW5kZXgoMykpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChib3guZ2V0SW5kZXgoMTApKS50b0JlKDIpO1xuXG4gICAgICAgIGJveCA9IG5ldyBCb3goe3JhbmdlOiB1dGlscy5jcmVhdGVSYW5nZSgxMCwgMjApLCBzcGVlZDoge2ludGVydmFsOiA1fX0pO1xuICAgICAgICBleHBlY3QoYm94LmdldEluZGV4KDUpKS50b0JlKDApO1xuICAgICAgICBleHBlY3QoYm94LmdldEluZGV4KDEwKSkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0KGJveC5nZXRJbmRleCgxMikpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChib3guZ2V0SW5kZXgoMTUpKS50b0JlKDEpO1xuICAgICAgICBleHBlY3QoYm94LmdldEluZGV4KDE4KSkudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KGJveC5nZXRJbmRleCgyMCkpLnRvQmUoMik7XG4gICAgICAgIGV4cGVjdChib3guZ2V0SW5kZXgoMjUpKS50b0JlKDIpO1xuICAgIH0pO1xuICAgIGl0KFwiYm94IGdldERhdGUgd29ya3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBib3ggPSBuZXcgQm94KHtkYXRhOiBbMSwgNSwgMTBdfSk7XG4gICAgICAgIGJveC5fb2Zmc2V0ID0gMDtcbiAgICAgICAgZXhwZWN0KGJveC5nZXREYXRlKDApKS50b0JlKDEpO1xuICAgICAgICBib3guX29mZnNldCA9IDEwO1xuICAgICAgICBleHBlY3QoYm94LmdldERhdGUoMTEpKS50b0JlKDUpO1xuXG4gICAgICAgIGJveCA9IG5ldyBCb3goe3JhbmdlOiB1dGlscy5jcmVhdGVSYW5nZSgxMCwgMjApLCBzcGVlZDoge2ludGVydmFsOiA1fX0pO1xuICAgICAgICBib3guX29mZnNldCA9IDA7XG4gICAgICAgIGV4cGVjdChib3guZ2V0RGF0ZSgwKSkudG9CZSgxMCk7XG4gICAgICAgIGJveC5fb2Zmc2V0ID0gMTA7XG4gICAgICAgIGV4cGVjdChib3guZ2V0RGF0ZSgxMSkpLnRvQmUoMTUpO1xuICAgIH0pO1xufSk7XG5cbmRlc2NyaWJlKFwidGVzdCBib3ggbW9kZWxcIiwgZnVuY3Rpb24oKSB7XG4gICAgaXQoXCJzaG91bGQgd29yayB3aXRoIGEgc2luZ2xlIGJveCBvZiBsaXN0IGRhdGFcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IEJveE1vZGVsKFt7ZGF0YTogWzEsIDIsIDNdfV0pO1xuICAgICAgICB2YXIgcmFuZ2UgPSBjb250cm9sbGVyLmdldFJhbmdlKCk7XG4gICAgICAgIGV4cGVjdChyYW5nZS5zdGFydCkudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KHJhbmdlLmVuZCkudG9CZSgzKTtcbiAgICAgICAgLy9leHBlY3QoY29udHJvbGxlci5nZXRTdGVwcygpKS50b0JlKDMpO1xuICAgICAgICByYW5nZSA9IGNvbnRyb2xsZXIuZ2V0UmFuZ2VBdCgwLCAxKTtcbiAgICAgICAgZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKDEpO1xuICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKDIpO1xuICAgICAgICBleHBlY3QoY29udHJvbGxlci5nZXRJbmRleCgxKSkudG9CZSgwKTtcbiAgICB9KTtcbiAgICBpdChcInNob3VsZCB3b3JrIHdpdGggdHdvIGxpc3QgYm94ZXNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IEJveE1vZGVsKFt7ZGF0YTogWzEsIDIsIDNdfSwge2RhdGE6IFs0LCA1LCA2XX1dKTtcbiAgICAgICAgdmFyIHJhbmdlID0gY29udHJvbGxlci5nZXRSYW5nZSgpO1xuICAgICAgICBleHBlY3QocmFuZ2Uuc3RhcnQpLnRvQmUoMSk7XG4gICAgICAgIGV4cGVjdChyYW5nZS5lbmQpLnRvQmUoNik7XG4gICAgICAgIC8vZXhwZWN0KGNvbnRyb2xsZXIuZ2V0U3RlcHMoKSkudG9CZSg2KTtcbiAgICAgICAgcmFuZ2UgPSBjb250cm9sbGVyLmdldFJhbmdlQXQoMiwgMyk7XG4gICAgICAgIC8vZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKDMpO1xuICAgICAgICAvL2V4cGVjdChyYW5nZS5lbmQpLnRvQmUoNCk7XG4gICAgICAgIGV4cGVjdChjb250cm9sbGVyLmdldEluZGV4KDApKS50b0JlKDApO1xuICAgICAgICBleHBlY3QoY29udHJvbGxlci5nZXRJbmRleCgzKSkudG9CZSgyKTtcbiAgICAgICAgLy9leHBlY3QoY29udHJvbGxlci5nZXRJbmRleCg0KSkudG9CZSgzKTtcbiAgICAgICAgLy9leHBlY3QoY29udHJvbGxlci5nZXRJbmRleCg3KSkudG9CZSg2KTtcbiAgICB9KTtcbiAgICBpdChcInNob3VsZCB3b3JrIHdpdGggb25lIHJhbmdlIGJveFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgQm94TW9kZWwoW3tyYW5nZTogdXRpbHMuY3JlYXRlUmFuZ2UoMTAsIDIwKSwgc3BlZWQ6IHtpbnRlcnZhbDogNX19XSk7XG4gICAgICAgIHZhciByYW5nZSA9IGNvbnRyb2xsZXIuZ2V0UmFuZ2UoKTtcbiAgICAgICAgZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKDEwKTtcbiAgICAgICAgZXhwZWN0KHJhbmdlLmVuZCkudG9CZSgyMCk7XG4gICAgICAgIC8vZXhwZWN0KGNvbnRyb2xsZXIuZ2V0U3RlcHMoKSkudG9CZSgzKTtcbiAgICAgICAgcmFuZ2UgPSBjb250cm9sbGVyLmdldFJhbmdlQXQoMCwgMSk7XG4gICAgICAgIGV4cGVjdChyYW5nZS5zdGFydCkudG9CZSgxMCk7XG4gICAgICAgIGV4cGVjdChyYW5nZS5lbmQpLnRvQmUoMTUpO1xuICAgICAgICBleHBlY3QoY29udHJvbGxlci5nZXRJbmRleCgxKSkudG9CZSgwKTtcbiAgICAgICAgXG4gICAgfSk7XG4gICAgaXQoXCJzaG91bGQgd29yayB3aXRoIHR3byByYW5nZSBib3hlc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgQm94TW9kZWwoW1xuICAgICAgICAgICAge3JhbmdlOiB1dGlscy5jcmVhdGVSYW5nZSgxMCwgMjApLCBzcGVlZDoge2ludGVydmFsOiA1fX0sXG4gICAgICAgICAgICB7cmFuZ2U6IHV0aWxzLmNyZWF0ZVJhbmdlKDMwLCA1MCksIHNwZWVkOiB7aW50ZXJ2YWw6IDEwfX1cbiAgICAgICAgXSk7XG4gICAgICAgIHZhciByYW5nZSA9IGNvbnRyb2xsZXIuZ2V0UmFuZ2UoKTtcbiAgICAgICAgZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKDEwKTtcbiAgICAgICAgZXhwZWN0KHJhbmdlLmVuZCkudG9CZSg1MCk7XG4gICAgICAgIGV4cGVjdChjb250cm9sbGVyLmdldFN0ZXBzKCkpLnRvQmUoNik7XG4gICAgICAgIHJhbmdlID0gY29udHJvbGxlci5nZXRSYW5nZUF0KDIsIDMpO1xuICAgICAgICBleHBlY3QocmFuZ2Uuc3RhcnQpLnRvQmUoMjApO1xuICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKDMwKTtcbiAgICAgICAgZXhwZWN0KGNvbnRyb2xsZXIuZ2V0SW5kZXgoNDApKS50b0JlKDQpO1xuICAgIH0pO1xufSk7XG4iLCJ2YXIgbWFwcyA9IHJlcXVpcmUoJy4uL2xpYi9jb3JlL3RpbWUvbWFwcy5qcycpO1xucmVxdWlyZSgnLi4vbGliL25nL2NvcmUvb2djL21vZHVsZS5qcycpO1xuXG5kZXNjcmliZShcInRlc3QgbWFwc1wiLCBmdW5jdGlvbigpIHtcbiAgICBpdChcInJlYWRDYXBhYmlsaXRpZXNUaW1lRGltZW5zaW9ucyB3b3Jrc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gbWFrZUNhcHMoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbmZpZykubWFwKGZ1bmN0aW9uKGx5cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge25hbWU6IGx5ciwgZGltZW5zaW9uOiB7fSwgZXh0ZW50OiBbe3ZhbHVlOiBjb25maWdbbHlyXX1dfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleHBlY3REYXRhKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3QobWFwcy5yZWFkQ2FwYWJpbGl0aWVzVGltZURpbWVuc2lvbnMobWFrZUNhcHMoYXJncykpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWFkKHZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1hcHMucmVhZENhcGFiaWxpdGllc1RpbWVEaW1lbnNpb25zKG1ha2VDYXBzKHtkYXRhOnZhbHVlc30pKS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRpbWUoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoc3RyKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSByZWFkKCcxOTkwLTAxLTAxVDAwOjAwOjAwLjAwMFovMjAwOS0wMS0wMVQwMDowMDowMC4wMDBaL1AxWScpO1xuICAgICAgICBleHBlY3Qoci5zdGFydCkudG9CZSh0aW1lKCcxOTkwLTAxLTAxVDAwOjAwOjAwLjAwMFonKSk7XG4gICAgICAgIGV4cGVjdChyLmVuZCkudG9CZSh0aW1lKCcyMDA5LTAxLTAxVDAwOjAwOjAwLjAwMFonKSk7XG4gICAgICAgIGV4cGVjdChyLmludGVydmFsKS50b0JlKDMxNTM2MDAwMDAwKTtcblxuICAgICAgICBleHBlY3REYXRhKHtsaXN0OiAnMTk5MCd9KS50b0VxdWFsKFxuICAgICAgICAgICAgICAgIHtsaXN0OiBbdGltZSgnMTk5MCcpXX1cbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0RGF0YSh7bGlzdDogJzE5OTAsMTk5MSwxOTkyJ30pLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAge2xpc3Q6IFt0aW1lKCcxOTkwJyksdGltZSgnMTk5MScpLHRpbWUoJzE5OTInKV19XG4gICAgICAgICk7XG5cbiAgICAgICAgciA9IHJlYWQoJzIwMDAvMjAwMScpO1xuICAgICAgICBleHBlY3Qoci5zdGFydCkudG9CZSh0aW1lKCcyMDAwJykpO1xuICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUodGltZSgnMjAwMScpKTtcbiAgICB9KTtcbiAgICBpdChcInJlYWRDYXBhYmlsaXRpZXNUaW1lRGltZW5zaW9ucyB3b3JrcyBmb3IgT3BlbkxheWVycyAyIGNvbmZpZ1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gbWFrZUNhcHMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RpbWUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFtcIi0zMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTg5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTkwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTkxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTkyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTkzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTk0LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTk1LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTk2LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTk3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTk4LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTk5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDAyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDAzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDA0LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDA1LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDA2LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDA3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDA4LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDA5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDEwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDExLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDEyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIyMDEzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIl1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGEgPSBtYXBzLnJlYWRDYXBhYmlsaXRpZXNUaW1lRGltZW5zaW9ucyhtYWtlQ2FwcygpLCB0cnVlKTtcbiAgICAgICAgZXhwZWN0KGRhdGEubGVuZ3RoKS50b0JlKDI2KTtcbiAgICAgICAgZXhwZWN0KGRhdGFbMF0pLnRvQmUoLTE1NjgzODAzMjAwMDAwMCk7XG4gICAgICAgIGV4cGVjdChkYXRhWzFdKS50b0JlKDU5OTYxNjAwMDAwMCk7XG4gICAgICAgIGV4cGVjdChkYXRhWzI1XSkudG9CZSgxMzU2OTk4NDAwMDAwKTtcbiAgICB9KTtcbiAgICBkZXNjcmliZSgnY29tcHV0ZVZlY3RvclJhbmdlIHdvcmtzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdG9yeUxheWVyLCBmZWF0dXJlcywgcmFuZ2UsIFN0b3J5TGF5ZXI7XG5cbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlIGlzIHdvcmsgYXJvdW5kIGJyb3dzZXJpZnkgY29uZmxpY3RcbiAgICAgICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmNvcmUub2djJyk7XG5cbiAgICAgICAgICAgIGluamVjdChmdW5jdGlvbigkaW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBTdG9yeUxheWVyID0gJGluamVjdG9yLmdldCgnU3RvcnlMYXllcicpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHN0b3J5TGF5ZXIgPSBuZXcgU3RvcnlMYXllcih7XG4gICAgICAgICAgICAgICAgdGltZUF0dHJpYnV0ZTogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJWRUNUT1JcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdG9yeUxheWVyLmdldExheWVyKCkuc2V0U291cmNlKG5ldyBvbC5zb3VyY2UuVmVjdG9yKCkpO1xuXG4gICAgICAgICAgICBmZWF0dXJlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgb2wuRmVhdHVyZSh7dGltZTogMTAwMH0pXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2ZlYXR1cmVzJywgZmVhdHVyZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgndXNpbmcgZmVhdHVyZXMgYXMgcHJvcGVydHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJhbmdlID0gbWFwcy5jb21wdXRlVmVjdG9yUmFuZ2Uoc3RvcnlMYXllcik7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2Uuc3RhcnQpLnRvQmUoMTAwMCk7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3VzaW5nIGZlYXR1cmVzIGZyb20gc291cmNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdG9yeUxheWVyLnNldCgnZmVhdHVyZXMnLCBudWxsKTtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuZ2V0TGF5ZXIoKS5nZXRTb3VyY2UoKS5hZGRGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICAgICAgICByYW5nZSA9IG1hcHMuY29tcHV0ZVZlY3RvclJhbmdlKHN0b3J5TGF5ZXIpO1xuICAgICAgICAgICAgZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKDEwMDApO1xuICAgICAgICAgICAgZXhwZWN0KHJhbmdlLmVuZCkudG9CZSgxMDAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCd3aGVuIGVtcHR5IGVuZFRpbWVBdHRyaWJ1dGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdlbmRUaW1lQXR0cmlidXRlJywgJ2VuZFRpbWUnKTtcbiAgICAgICAgICAgIHJhbmdlID0gbWFwcy5jb21wdXRlVmVjdG9yUmFuZ2Uoc3RvcnlMYXllcik7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2Uuc3RhcnQpLnRvQmUoMTAwMCk7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3doZW4gdW5zb3J0ZWQgbWl4ZWQgZGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2VuZFRpbWVBdHRyaWJ1dGUnLCAnZW5kVGltZScpO1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChuZXcgb2wuRmVhdHVyZSh7dGltZTogNTAwfSkpO1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChuZXcgb2wuRmVhdHVyZSh7dGltZTogMTAwLCBlbmRUaW1lOiA5MDB9KSk7XG4gICAgICAgICAgICByYW5nZSA9IG1hcHMuY29tcHV0ZVZlY3RvclJhbmdlKHN0b3J5TGF5ZXIpO1xuICAgICAgICAgICAgZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKDEwMCk7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3dpdGggc2luZ2xlIGVuZEF0dHJpYnV0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2VuZFRpbWVBdHRyaWJ1dGUnLCAnZW5kVGltZScpO1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2ZlYXR1cmVzJywgW25ldyBvbC5GZWF0dXJlKHtlbmRUaW1lOiA2Nzh9KV0pO1xuICAgICAgICAgICAgcmFuZ2UgPSBtYXBzLmNvbXB1dGVWZWN0b3JSYW5nZShzdG9yeUxheWVyKTtcbiAgICAgICAgICAgIGV4cGVjdChyYW5nZS5zdGFydCkudG9CZSg2NzgpO1xuICAgICAgICAgICAgZXhwZWN0KHJhbmdlLmVuZCkudG9CZSg2NzgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3doZW4gdGV4dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gd29ya3Mgd2l0aCB0ZXh0XG4gICAgICAgICAgICBzdG9yeUxheWVyLnNldCgnZmVhdHVyZXMnLCBbbmV3IG9sLkZlYXR1cmUoe3RpbWU6ICcyMDAxJ30pXSk7XG4gICAgICAgICAgICByYW5nZSA9IG1hcHMuY29tcHV0ZVZlY3RvclJhbmdlKHN0b3J5TGF5ZXIpO1xuICAgICAgICAgICAgZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKERhdGUucGFyc2UoJzIwMDEnKSk7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKERhdGUucGFyc2UoJzIwMDEnKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRlc2NyaWJlKCdmaWx0ZXJWZWN0b3JMYXllciB3b3JrcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RvcnlMYXllciwgZmVhdHVyZXMsIFN0b3J5TGF5ZXI7XG5cbiAgICAgICAgZnVuY3Rpb24gaWRzKCkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gc3RvcnlMYXllci5nZXRMYXllcigpO1xuICAgICAgICAgICAgdmFyIGlkcyA9IGxheWVyLmdldFNvdXJjZSgpLmdldEZlYXR1cmVzKCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5nZXQoJ2lkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlkcy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlIGlzIHdvcmsgYXJvdW5kIGJyb3dzZXJpZnkgY29uZmxpY3RcbiAgICAgICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmNvcmUub2djJyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpbmplY3QoZnVuY3Rpb24oJGluamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgU3RvcnlMYXllciA9ICRpbmplY3Rvci5nZXQoJ1N0b3J5TGF5ZXInKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzdG9yeUxheWVyID0gbmV3IFN0b3J5TGF5ZXIoe1xuICAgICAgICAgICAgICB0aW1lQXR0cmlidXRlOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgZW5kVGltZUF0dHJpYnV0ZTogXCJlbmRUaW1lXCIsXG4gICAgICAgICAgICAgIHR5cGU6IFwiVkVDVE9SXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RvcnlMYXllci5nZXRMYXllcigpLnNldFNvdXJjZShuZXcgb2wuc291cmNlLlZlY3RvcigpKTtcbiAgICAgICAgICAgIHZhciBpZCA9IDE7XG4gICAgICAgICAgICBmZWF0dXJlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgb2wuRmVhdHVyZSh7aWQ6aWQrKywgdGltZTogMTAwMH0pLFxuICAgICAgICAgICAgICAgIG5ldyBvbC5GZWF0dXJlKHtpZDppZCsrLCB0aW1lOiAxMDAwLCBlbmRUaW1lOiAyMDAwfSksXG4gICAgICAgICAgICAgICAgbmV3IG9sLkZlYXR1cmUoe2lkOmlkKyssIHRpbWU6IDIwMDB9KSxcbiAgICAgICAgICAgICAgICBuZXcgb2wuRmVhdHVyZSh7aWQ6aWQrKywgdGltZTogMjAwMCwgZW5kVGltZTogMzAwMH0pXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2ZlYXR1cmVzJywgZmVhdHVyZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ2ZpbHRlcnMgaW5zdGFudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdlbmRUaW1lQXR0cmlidXRlJywgbnVsbCk7XG4gICAgICAgICAgICAvLyByYW5nZSBiZWZvcmUgZXZlcnl0aGluZ1xuICAgICAgICAgICAgbWFwcy5maWx0ZXJWZWN0b3JMYXllcihzdG9yeUxheWVyLCB7c3RhcnQ6NTAwLCBlbmQ6IDUwMX0pO1xuICAgICAgICAgICAgZXhwZWN0KGlkcygpKS50b0VxdWFsKFtdKTtcbiAgICAgICAgICAgIC8vIHJhbmdlIGFmdGVyIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIG1hcHMuZmlsdGVyVmVjdG9yTGF5ZXIoc3RvcnlMYXllciwge3N0YXJ0OjI1MDAsIGVuZDogMjYwMH0pO1xuICAgICAgICAgICAgZXhwZWN0KGlkcygpKS50b0VxdWFsKFtdKTtcbiAgICAgICAgICAgIC8vIGRpcmVjdCBoaXQgKGlnbm9yZXMgZW5kIGV4Y2x1c2lvbilcbiAgICAgICAgICAgIG1hcHMuZmlsdGVyVmVjdG9yTGF5ZXIoc3RvcnlMYXllciwge3N0YXJ0OjIwMDAsIGVuZDogMjAwMH0pO1xuICAgICAgICAgICAgZXhwZWN0KGlkcygpKS50b0VxdWFsKFszLDRdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdmaWx0ZXJzIGV4dGVudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlIGJlZm9yZSBldmVyeXRoaW5nXG4gICAgICAgICAgICBtYXBzLmZpbHRlclZlY3RvckxheWVyKHN0b3J5TGF5ZXIsIHtzdGFydDo1MDAsIGVuZDogNTAxfSk7XG4gICAgICAgICAgICBleHBlY3QoaWRzKCkpLnRvRXF1YWwoW10pO1xuICAgICAgICAgICAgLy8gcmFuZ2UgYmVmb3JlIGFuZCBhZnRlciBldmVyeXRoaW5nXG4gICAgICAgICAgICBtYXBzLmZpbHRlclZlY3RvckxheWVyKHN0b3J5TGF5ZXIsIHtzdGFydDo1MDAsIGVuZDogNDAwMH0pO1xuICAgICAgICAgICAgZXhwZWN0KGlkcygpKS50b0VxdWFsKFsxLDIsMyw0XSk7XG4gICAgICAgICAgICAvLyBleGNsdWRlcyAzIGR1ZSB0byBpbnRlcnNlY3Rpb24gcnVsZXMgd2l0aCBlbmRcbiAgICAgICAgICAgIG1hcHMuZmlsdGVyVmVjdG9yTGF5ZXIoc3RvcnlMYXllciwge3N0YXJ0OjEwMDAsIGVuZDoyMDAwfSk7XG4gICAgICAgICAgICBleHBlY3QoaWRzKCkpLnRvRXF1YWwoWzEsMl0pO1xuICAgICAgICAgICAgLy8gMSBhbmQgMyBpbmNsdWRlZCBhcyB0aGV5IGFyZSBvcGVuIGVuZGVkIGFuZCBiZWZvcmVcbiAgICAgICAgICAgIG1hcHMuZmlsdGVyVmVjdG9yTGF5ZXIoc3RvcnlMYXllciwge3N0YXJ0OjMwMDAsIGVuZDo0MDAwfSk7XG4gICAgICAgICAgICBleHBlY3QoaWRzKCkpLnRvRXF1YWwoWzEsMyw0XSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ01hcENvbmZpZycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUgaXMgd29yayBhcm91bmQgYnJvd3NlcmlmeSBjb25mbGljdFxuICAgICAgICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5jb3JlLm9nYycpO1xuICBcbiAgICAgICAgICAgICAgaW5qZWN0KGZ1bmN0aW9uKCRpbmplY3Rvcikge1xuICAgICAgICAgICAgICAgICAgU3RvcnlNYXAgPSAkaW5qZWN0b3IuZ2V0KCdTdG9yeU1hcCcpO1xuICAgICAgICAgICAgICAgICAgRWRpdGFibGVTdG9yeU1hcCA9ICRpbmplY3Rvci5nZXQoJ0VkaXRhYmxlU3RvcnlNYXAnKTtcbiAgICAgICAgICAgICAgICAgIHN0U3RvcnlNYXBCdWlsZGVyID0gJGluamVjdG9yLmdldCgnc3RTdG9yeU1hcEJ1aWxkZXInKTtcbiAgICAgICAgICAgICAgICAgIHN0U3RvcnlNYXBCYXNlQnVpbGRlciA9ICRpbmplY3Rvci5nZXQoJ3N0U3RvcnlNYXBCYXNlQnVpbGRlcicpO1xuICAgICAgICAgICAgICAgICAgc3RMYXllckJ1aWxkZXIgPSAkaW5qZWN0b3IuZ2V0KCdzdExheWVyQnVpbGRlcicpO1xuICAgICAgICAgICAgICAgICAgJHRpbWVvdXQgPSAkaW5qZWN0b3IuZ2V0KCckdGltZW91dCcpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyppdCgnc2hvdWxkIHRyYW5zZm9ybSB0byBJbnRlcnZhbCBvYmplY3QnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoJ3tcImlkXCI6MjE0LFwibWFwXCI6e1wiY2VudGVyXCI6WzAsMF0sXCJwcm9qZWN0aW9uXCI6XCJFUFNHOjM4NTdcIixcInpvb21cIjozLFwibGF5ZXJzXCI6W3tcImlkXCI6XCJmb29cIixcIm5hbWVcIjpcImZvb1wiLFwidGl0bGVcIjpcIk15IGxheWVyXCIsXCJnZW9tVHlwZVwiOlwicG9pbnRcIixcImF0dHJpYnV0ZXNcIjogW1wiYXR0cjFcIiwgXCJhdHRyMlwiXSxcInRpbWVBdHRyaWJ1dGVcIjpcImF0dHIxXCIsXCJyZXNvbHV0aW9uc1wiOlswLDEwLCAyMF0sXCJiYm94XCI6IFswLDEwMCwxMDAsMjAwXSxcImxhdGxvbkJCT1hcIjpbLTEwLC0xMCwxMCwxMF0sXCJ0aW1lc1wiOntcInN0YXJ0XCI6IDYzMTE1MjAwMDAwMCwgXCJlbmRcIjogMTIzMDc2ODAwMDAwMCwgXCJkdXJhdGlvblwiOiBcIlAxWVwifSxcInNpbmdsZVRpbGVcIjpmYWxzZSxcInR5cGVcIjpcIldNU1wiLFwidXJsXCI6XCJodHRwOi8vbXlzZXJ2ZXJcIixcInBhcmFtc1wiOntcIkxBWUVSU1wiOlwieFwifX1dfX0nKTtcbiAgICAgICAgICAgIHZhciBzdG9yeU1hcCA9IG5ldyBTdG9yeU1hcCh7dGFyZ2V0OiAnZm9vJ30pO1xuICAgICAgICAgICAgc3RvcnlNYXAuZ2V0U3RvcnlMYXllcnMoKS5vbignY2hhbmdlOmxlbmd0aCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBleHBlY3Qoc3RvcnlNYXAuZ2V0U3RvcnlMYXllcnMoKS5pdGVtKDApLmdldCgndGltZXMnKS5pbnRlcnZhbCkudG9CZSgzMTUzNjAwMDAwMCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RTdG9yeU1hcEJ1aWxkZXIubW9kaWZ5U3RvcnlNYXAoc3RvcnlNYXAsIGRhdGEpO1xuICAgICAgICAgICAgJHRpbWVvdXQuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgICovXG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjb252ZXJ0IGV4dGVudCwgem9vbSBhbmQgcHJvamVjdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN0b3J5TWFwID0gbmV3IEVkaXRhYmxlU3RvcnlNYXAoe3RhcmdldDogJ2Zvbyd9KTtcbiAgICAgICAgICAgIHN0b3J5TWFwLnNldCgnaWQnLCAyMTUpO1xuICAgICAgICAgICAgc3RvcnlNYXAuZ2V0TWFwKCkuc2V0VmlldyhuZXcgb2wuVmlldyh7Y2VudGVyOiBbMCwwXSwgem9vbTogM30pKTtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBzdG9yeU1hcC5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gJ3tcIm1hcFwiOntcImNlbnRlclwiOlswLDBdLFwicHJvamVjdGlvblwiOlwiRVBTRzozODU3XCIsXCJ6b29tXCI6MyxcImxheWVyc1wiOltdfSxcImlkXCI6MjE1fSc7XG4gICAgICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSkudG9CZShleHBlY3RlZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgY29udmVydCBhIHRpbGVkIFdNUyBsYXllcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIHZhciBzdG9yeU1hcCA9IG5ldyBFZGl0YWJsZVN0b3J5TWFwKHt0YXJnZXQ6ICdmb28nfSk7XG4gICAgICAgICAgICBzdG9yeU1hcC5zZXQoJ2lkJywgMjE2KTsgXG4gICAgICAgICAgICBzdG9yeU1hcC5nZXRNYXAoKS5zZXRWaWV3KG5ldyBvbC5WaWV3KHtjZW50ZXI6IFswLDBdLCB6b29tOiAzfSkpO1xuICAgICAgICAgICAgc3RMYXllckJ1aWxkZXIuYnVpbGRMYXllcih7XG4gICAgICAgICAgICAgIHR5cGU6ICdXTVMnLFxuICAgICAgICAgICAgICBpZDogJ2ZvbycsXG4gICAgICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICAgICAgdGl0bGU6ICdNeSBsYXllcicsXG4gICAgICAgICAgICAgIGdlb21UeXBlOiAncG9pbnQnLFxuICAgICAgICAgICAgICB0aW1lQXR0cmlidXRlOiAnYXR0cjEnLFxuICAgICAgICAgICAgICB0aW1lczogWycyMDAxJywgJzIwMDInLCAnMjAwMyddLFxuICAgICAgICAgICAgICB1cmw6ICdodHRwOi8vbXlzZXJ2ZXInLFxuICAgICAgICAgICAgICBsYXRsb25CQk9YOiBbLTkwLC0xODAsOTAsMTgwXSxcbiAgICAgICAgICAgICAgYmJveDogWzAsMCwxLDFdLFxuICAgICAgICAgICAgICByZXNvbHV0aW9uczogWzEwMCw1MCwxMF0sXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnZm9vJywnYmFyJ11cbiAgICAgICAgICAgIH0sIHN0b3J5TWFwLmdldE1hcCgpKS50aGVuKGZ1bmN0aW9uKHNsKSB7XG4gICAgICAgICAgICAgIHN0b3J5TWFwLmFkZFN0b3J5TGF5ZXIoc2wpO1xuICAgICAgICAgICAgICBleHBlY3Qoc2wuZ2V0TGF5ZXIoKSBpbnN0YW5jZW9mIG9sLmxheWVyLlRpbGUpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICAgIGV4cGVjdChzbC5nZXRMYXllcigpLmdldFNvdXJjZSgpIGluc3RhbmNlb2Ygb2wuc291cmNlLlRpbGVXTVMpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICAgIHZhciBjb25maWcgPSBzdG9yeU1hcC5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSAne1wibWFwXCI6e1wiY2VudGVyXCI6WzAsMF0sXCJwcm9qZWN0aW9uXCI6XCJFUFNHOjM4NTdcIixcInpvb21cIjozLFwibGF5ZXJzXCI6W3tcInR5cGVcIjpcIldNU1wiLFwiaWRcIjpcImZvb1wiLFwibmFtZVwiOlwieFwiLFwidGl0bGVcIjpcIk15IGxheWVyXCIsXCJnZW9tVHlwZVwiOlwicG9pbnRcIixcInRpbWVBdHRyaWJ1dGVcIjpcImF0dHIxXCIsXCJ0aW1lc1wiOltcIjIwMDFcIixcIjIwMDJcIixcIjIwMDNcIl0sXCJ1cmxcIjpcImh0dHA6Ly9teXNlcnZlclwiLFwibGF0bG9uQkJPWFwiOlstOTAsLTE4MCw5MCwxODBdLFwiYmJveFwiOlswLDAsMSwxXSxcInJlc29sdXRpb25zXCI6WzEwMCw1MCwxMF0sXCJhdHRyaWJ1dGVzXCI6W1wiZm9vXCIsXCJiYXJcIl19XX0sXCJpZFwiOjIxNn0nO1xuICAgICAgICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSkudG9CZShleHBlY3RlZCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHRpbWVvdXQuZmx1c2goKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjb252ZXJ0IGFuIHVudGlsZWQgV01TIGxheWVyJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgdmFyIHN0b3J5TWFwID0gbmV3IEVkaXRhYmxlU3RvcnlNYXAoe3RhcmdldDogJ2Zvbyd9KTtcbiAgICAgICAgICAgIHN0b3J5TWFwLnNldCgnaWQnLCAyMTcpO1xuICAgICAgICAgICAgc3RvcnlNYXAuZ2V0TWFwKCkuc2V0VmlldyhuZXcgb2wuVmlldyh7Y2VudGVyOiBbMCwwXSwgem9vbTogM30pKTtcbiAgICAgICAgICAgIHN0TGF5ZXJCdWlsZGVyLmJ1aWxkTGF5ZXIoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdXTVMnLFxuICAgICAgICAgICAgICAgIHNpbmdsZVRpbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdNeSBsYXllcicsXG4gICAgICAgICAgICAgICAgaWQ6ICdmb28nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvaW50JyxcbiAgICAgICAgICAgICAgICB0aW1lQXR0cjogJ2F0dHIxJyxcbiAgICAgICAgICAgICAgICB0aW1lczogWycyMDAxJywgJzIwMDInLCAnMjAwMyddLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHA6Ly9teXNlcnZlcicsXG4gICAgICAgICAgICAgICAgbGF0bG9uQkJPWDogWy05MCwtMTgwLDkwLDE4MF0sXG4gICAgICAgICAgICAgICAgYmJveDogWzAsMCwxLDFdLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb25zOiBbMTAwLDUwLDEwXSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2ZvbycsJ2JhciddXG4gICAgICAgICAgICB9LCBzdG9yeU1hcC5nZXRNYXAoKSkudGhlbihmdW5jdGlvbihzbCkge1xuICAgICAgICAgICAgICAgIHN0b3J5TWFwLmFkZFN0b3J5TGF5ZXIoc2wpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChzbC5nZXRMYXllcigpIGluc3RhbmNlb2Ygb2wubGF5ZXIuSW1hZ2UpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHNsLmdldExheWVyKCkuZ2V0U291cmNlKCkgaW5zdGFuY2VvZiBvbC5zb3VyY2UuSW1hZ2VXTVMpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHN0b3J5TWFwLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gJ3tcIm1hcFwiOntcImNlbnRlclwiOlswLDBdLFwicHJvamVjdGlvblwiOlwiRVBTRzozODU3XCIsXCJ6b29tXCI6MyxcImxheWVyc1wiOlt7XCJ0eXBlXCI6XCJXTVNcIixcInNpbmdsZVRpbGVcIjp0cnVlLFwidGl0bGVcIjpcIk15IGxheWVyXCIsXCJpZFwiOlwiZm9vXCIsXCJuYW1lXCI6XCJ4XCIsXCJnZW9tVHlwZVwiOlwicG9pbnRcIixcInRpbWVBdHRyXCI6XCJhdHRyMVwiLFwidGltZXNcIjpbXCIyMDAxXCIsXCIyMDAyXCIsXCIyMDAzXCJdLFwidXJsXCI6XCJodHRwOi8vbXlzZXJ2ZXJcIixcImxhdGxvbkJCT1hcIjpbLTkwLC0xODAsOTAsMTgwXSxcImJib3hcIjpbMCwwLDEsMV0sXCJyZXNvbHV0aW9uc1wiOlsxMDAsNTAsMTBdLFwiYXR0cmlidXRlc1wiOltcImZvb1wiLFwiYmFyXCJdfV19LFwiaWRcIjoyMTd9JztcbiAgICAgICAgICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSkudG9CZShleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkdGltZW91dC5mbHVzaCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGNvbnZlcnQgYSB2ZWN0b3IgbGF5ZXInLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICB2YXIgc3RvcnlNYXAgPSBuZXcgRWRpdGFibGVTdG9yeU1hcCh7dGFyZ2V0OiAnZm9vJ30pO1xuICAgICAgICAgICAgc3RvcnlNYXAuc2V0KCdpZCcsIDIyNyk7XG4gICAgICAgICAgICBzdG9yeU1hcC5nZXRNYXAoKS5zZXRWaWV3KG5ldyBvbC5WaWV3KHtjZW50ZXI6IFswLDBdLCB6b29tOiAzfSkpO1xuICAgICAgICAgICAgc3RMYXllckJ1aWxkZXIuYnVpbGRMYXllcih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1ZFQ1RPUicsXG4gICAgICAgICAgICAgICAgaWQ6ICdmb28nLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnTXkgbGF5ZXInLFxuICAgICAgICAgICAgICAgIHVybDogJy9nZW9zZXJ2ZXIvd2ZzJyxcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvaW50JyxcbiAgICAgICAgICAgICAgICB0aW1lQXR0cjogJ2F0dHIxJyxcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogJ2ZvbycsXG4gICAgICAgICAgICAgICAgdGltZXM6IFsnMjAwMScsICcyMDAyJywgJzIwMDMnXSxcbiAgICAgICAgICAgICAgICBsYXRsb25CQk9YOiBbLTkwLC0xODAsOTAsMTgwXSxcbiAgICAgICAgICAgICAgICBiYm94OiBbMCwwLDEsMV0sXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbnM6IFsxMDAsNTAsMTBdLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnZm9vJywnYmFyJ11cbiAgICAgICAgICAgIH0sIHN0b3J5TWFwLmdldE1hcCgpKS50aGVuKGZ1bmN0aW9uKHNsKSB7XG4gICAgICAgICAgICAgICAgc3RvcnlNYXAuYWRkU3RvcnlMYXllcihzbCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHNsLmdldExheWVyKCkgaW5zdGFuY2VvZiBvbC5sYXllci5WZWN0b3IpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHN0b3J5TWFwLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gJ3tcIm1hcFwiOntcImNlbnRlclwiOlswLDBdLFwicHJvamVjdGlvblwiOlwiRVBTRzozODU3XCIsXCJ6b29tXCI6MyxcImxheWVyc1wiOlt7XCJ0eXBlXCI6XCJWRUNUT1JcIixcImlkXCI6XCJmb29cIixcInRpdGxlXCI6XCJNeSBsYXllclwiLFwidXJsXCI6XCIvZ2Vvc2VydmVyL3dmc1wiLFwiZ2VvbVR5cGVcIjpcInBvaW50XCIsXCJ0aW1lQXR0clwiOlwiYXR0cjFcIixcInR5cGVOYW1lXCI6XCJmb29cIixcInRpbWVzXCI6W1wiMjAwMVwiLFwiMjAwMlwiLFwiMjAwM1wiXSxcImxhdGxvbkJCT1hcIjpbLTkwLC0xODAsOTAsMTgwXSxcImJib3hcIjpbMCwwLDEsMV0sXCJyZXNvbHV0aW9uc1wiOlsxMDAsNTAsMTBdLFwiYXR0cmlidXRlc1wiOltcImZvb1wiLFwiYmFyXCJdfV19LFwiaWRcIjoyMjd9JztcbiAgICAgICAgICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSkudG9CZShleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkdGltZW91dC5mbHVzaCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGNvbnZlcnQgYW4gT1NNIGxheWVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc3RvcnlNYXAgPSBuZXcgRWRpdGFibGVTdG9yeU1hcCh7dGFyZ2V0OiAnZm9vJ30pO1xuICAgICAgICAgICAgc3RvcnlNYXAuc2V0KCdpZCcsIDIxOCk7XG4gICAgICAgICAgICBzdG9yeU1hcC5nZXRNYXAoKS5zZXRWaWV3KG5ldyBvbC5WaWV3KHtjZW50ZXI6IFswLDBdLCB6b29tOiAzfSkpO1xuICAgICAgICAgICAgc3RTdG9yeU1hcEJhc2VCdWlsZGVyLnNldEJhc2VMYXllcihzdG9yeU1hcCwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdPU00nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZCA9ICd7XCJtYXBcIjp7XCJjZW50ZXJcIjpbMCwwXSxcInByb2plY3Rpb25cIjpcIkVQU0c6Mzg1N1wiLFwiem9vbVwiOjMsXCJsYXllcnNcIjpbe1widHlwZVwiOlwiT1NNXCIsXCJncm91cFwiOlwiYmFja2dyb3VuZFwiLFwidmlzaWJpbGl0eVwiOnRydWV9XX0sXCJpZFwiOjIxOH0nO1xuICAgICAgICAgICAgZXhwZWN0KEpTT04uc3RyaW5naWZ5KHN0b3J5TWFwLmdldFN0YXRlKCkpKS50b0JlKGV4cGVjdGVkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjb252ZXJ0IGFuIE1hcFF1ZXN0IGxheWVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc3RvcnlNYXAgPSBuZXcgRWRpdGFibGVTdG9yeU1hcCh7dGFyZ2V0OiAnZm9vJ30pO1xuICAgICAgICAgICAgc3RvcnlNYXAuc2V0KCdpZCcsIDIxOSk7XG4gICAgICAgICAgICBzdG9yeU1hcC5nZXRNYXAoKS5zZXRWaWV3KG5ldyBvbC5WaWV3KHtjZW50ZXI6IFswLDBdLCB6b29tOiAzfSkpO1xuICAgICAgICAgICAgc3RTdG9yeU1hcEJhc2VCdWlsZGVyLnNldEJhc2VMYXllcihzdG9yeU1hcCwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNYXBRdWVzdCcsXG4gICAgICAgICAgICAgICAgbGF5ZXI6ICdzYXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZCA9ICd7XCJtYXBcIjp7XCJjZW50ZXJcIjpbMCwwXSxcInByb2plY3Rpb25cIjpcIkVQU0c6Mzg1N1wiLFwiem9vbVwiOjMsXCJsYXllcnNcIjpbe1widHlwZVwiOlwiTWFwUXVlc3RcIixcImxheWVyXCI6XCJzYXRcIixcImdyb3VwXCI6XCJiYWNrZ3JvdW5kXCIsXCJ2aXNpYmlsaXR5XCI6dHJ1ZX1dfSxcImlkXCI6MjE5fSc7XG4gICAgICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkoc3RvcnlNYXAuZ2V0U3RhdGUoKSkpLnRvQmUoZXhwZWN0ZWQpO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG59KTtcbiIsInJlcXVpcmUoJy4uL2xpYi9uZy9jb3JlL3N0eWxlL29sM1N0eWxlQ29udmVydGVyLmpzJyk7XG5yZXF1aXJlKCcuLi9saWIvbmcvY29yZS9zdHlsZS9zdmdJY29uLmpzJyk7XG5cbmRlc2NyaWJlKCdvbDNTdHlsZUNvbnZlcnRlcicsIGZ1bmN0aW9uKCkge1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUgaXMgd29yayBhcm91bmQgYnJvd3NlcmlmeSBjb25mbGljdFxuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5jb3JlLnN0eWxlLm9sM1N0eWxlQ29udmVydGVyJyk7XG4gICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmNvcmUuc3R5bGUuc3ZnSWNvbicpO1xuXG4gICAgICAgIGluamVjdChmdW5jdGlvbihvbDNTdHlsZUNvbnZlcnRlcikge1xuICAgICAgICAgICAgdGhpcy5vbDNTdHlsZUNvbnZlcnRlciA9IG9sM1N0eWxlQ29udmVydGVyO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCBzaW1wbGUgc3R5cGVzJywgaW5qZWN0KGZ1bmN0aW9uKG9sM1N0eWxlQ29udmVydGVyKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICBcInNpemVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcImNpcmNsZVwiLFxuICAgICAgICAgICAgICAgIFwiZ3JhcGhpY1wiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiZ3JhcGhpY1R5cGVcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiNmZjAwMDBcIixcbiAgICAgICAgICAgICAgICBcImZpbGxPcGFjaXR5XCI6IDgwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjZmZmZjAwXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VXaWR0aFwiOiAzLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlU3R5bGVcIjogXCJzb2xpZFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlT3BhY2l0eVwiOiA5MFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc3R5bGUgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlWzBdIGluc3RhbmNlb2Ygb2wuc3R5bGUuU3R5bGUpLnRvQmVUcnV0aHkoKTtcbiAgICAgICAgdmFyIGltYWdlID0gc3R5bGVbMF0uZ2V0SW1hZ2UoKTtcbiAgICAgICAgZXhwZWN0KGltYWdlIGluc3RhbmNlb2Ygb2wuc3R5bGUuQ2lyY2xlKS50b0JlVHJ1dGh5KCk7XG4gICAgICAgIGV4cGVjdChpbWFnZS5nZXRSYWRpdXMoKSkudG9CZSgxMC8yKTtcbiAgICAgICAgZXhwZWN0KGltYWdlLmdldEZpbGwoKS5nZXRDb2xvcigpKS50b0JlKCdyZ2JhKDI1NSwwLDAsMC44KScpO1xuICAgICAgICBleHBlY3QoaW1hZ2UuZ2V0U3Ryb2tlKCkuZ2V0Q29sb3IoKSkudG9CZSgncmdiYSgyNTUsMjU1LDAsMC45KScpO1xuICAgICAgICBleHBlY3QoaW1hZ2UuZ2V0U3Ryb2tlKCkuZ2V0V2lkdGgoKSkudG9CZSgzKTtcbiAgICAgICAgdmFyIG5ld1N0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZyk7XG4gICAgICAgIGV4cGVjdChzdHlsZSA9PT0gbmV3U3R5bGUpLnRvQmVUcnV0aHkoKTtcbiAgICB9KSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbnZlcnQgdG8gc3F1YXJlJywgaW5qZWN0KGZ1bmN0aW9uKG9sM1N0eWxlQ29udmVydGVyKSB7XG4gICAgICAgIHZhciBzaGFwZUNvbmZpZyA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU2hhcGVDb25maWcoe1xuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwic3F1YXJlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5wb2ludHMpLnRvQmUoNCk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5yYWRpdXMpLnRvQmUoMTAvMik7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5hbmdsZSkudG9CZShNYXRoLlBJIC8gNCk7XG4gICAgfSkpO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IHRvIHRyaWFuZ2xlJywgaW5qZWN0KGZ1bmN0aW9uKG9sM1N0eWxlQ29udmVydGVyKSB7XG4gICAgICAgIHZhciBzaGFwZUNvbmZpZyA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU2hhcGVDb25maWcoe1xuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwidHJpYW5nbGVcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHNoYXBlQ29uZmlnLnBvaW50cykudG9CZSgzKTtcbiAgICAgICAgZXhwZWN0KHNoYXBlQ29uZmlnLnJhZGl1cykudG9CZSgxMC8yKTtcbiAgICAgICAgZXhwZWN0KHNoYXBlQ29uZmlnLmFuZ2xlKS50b0JlKDApO1xuICAgIH0pKTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCB0byBzdGFyJywgaW5qZWN0KGZ1bmN0aW9uKG9sM1N0eWxlQ29udmVydGVyKSB7XG4gICAgICAgIHZhciBzaGFwZUNvbmZpZyA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU2hhcGVDb25maWcoe1xuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwic3RhclwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBleHBlY3Qoc2hhcGVDb25maWcucG9pbnRzKS50b0JlKDUpO1xuICAgICAgICBleHBlY3Qoc2hhcGVDb25maWcucmFkaXVzKS50b0JlKDEwLzIpO1xuICAgICAgICBleHBlY3Qoc2hhcGVDb25maWcucmFkaXVzMikudG9CZSgxMC80KTtcbiAgICAgICAgZXhwZWN0KHNoYXBlQ29uZmlnLmFuZ2xlKS50b0JlKDApO1xuICAgIH0pKTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCB0byBjcm9zcycsIGluamVjdChmdW5jdGlvbihvbDNTdHlsZUNvbnZlcnRlcikge1xuICAgICAgICB2YXIgc2hhcGVDb25maWcgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVNoYXBlQ29uZmlnKHtcbiAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICBcInNpemVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcImNyb3NzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5wb2ludHMpLnRvQmUoNCk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5yYWRpdXMpLnRvQmUoMTAvMik7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5yYWRpdXMyKS50b0JlKDApO1xuICAgICAgICBleHBlY3Qoc2hhcGVDb25maWcuYW5nbGUpLnRvQmUoMCk7XG4gICAgfSkpO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IHRvIHgnLCBpbmplY3QoZnVuY3Rpb24ob2wzU3R5bGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdmFyIHNoYXBlQ29uZmlnID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTaGFwZUNvbmZpZyh7XG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJ4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5wb2ludHMpLnRvQmUoNCk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5yYWRpdXMpLnRvQmUoMTAvMik7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5yYWRpdXMyKS50b0JlKDApO1xuICAgICAgICBleHBlY3Qoc2hhcGVDb25maWcuYW5nbGUpLnRvQmUoTWF0aC5QSSAvIDQpO1xuICAgIH0pKTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCBsYWJlbHMnLCBpbmplY3QoZnVuY3Rpb24ob2wzU3R5bGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZSh7XG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJjaXJjbGVcIixcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNUeXBlXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjZmYwMDAwXCIsXG4gICAgICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiA4MFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IFwiI2ZmZmYwMFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlV2lkdGhcIjogMyxcbiAgICAgICAgICAgICAgICBcInN0cm9rZVN0eWxlXCI6IFwic29saWRcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZU9wYWNpdHlcIjogOTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImxhYmVsXCI6IHtcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBcImZvb1wiLFxuICAgICAgICAgICAgICAgIFwiZm9udFN0eWxlXCI6IFwiaXRhbGljXCIsXG4gICAgICAgICAgICAgICAgXCJmb250V2VpZ2h0XCI6IFwiYm9sZFwiLFxuICAgICAgICAgICAgICAgIFwiZm9udFNpemVcIjogMTIsXG4gICAgICAgICAgICAgICAgXCJmb250RmFtaWx5XCI6IFwiU2VyaWZcIixcbiAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiMwMDAwZmZcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBuZXcgb2wuRmVhdHVyZSh7J2Zvbyc6ICdiYXInfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGUubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgICB2YXIgdGV4dCA9IHN0eWxlWzBdLmdldFRleHQoKTtcbiAgICAgICAgZXhwZWN0KHRleHQgaW5zdGFuY2VvZiBvbC5zdHlsZS5UZXh0KS50b0JlVHJ1dGh5KCk7XG4gICAgICAgIGV4cGVjdCh0ZXh0LmdldFRleHQoKSkudG9CZSgnYmFyJyk7XG4gICAgICAgIGV4cGVjdCh0ZXh0LmdldEZvbnQoKSkudG9CZSgnaXRhbGljIGJvbGQgMTJweCBTZXJpZicpO1xuICAgICAgICBleHBlY3QodGV4dC5nZXRGaWxsKCkuZ2V0Q29sb3IoKSkudG9CZSgnIzAwMDBmZicpO1xuICAgIH0pKTtcblxuICAgIGl0KCdzaG91bGQgdGFrZSByb3RhdGlvbiBpbnRvIGFjY291bnQnLCBpbmplY3QoZnVuY3Rpb24ob2wzU3R5bGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZSh7XG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJ0cmlhbmdsZVwiLFxuICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2ZmMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwicm90YXRpb25BdHRyaWJ1dGVcIjogJ3JvdGF0aW9uJyxcbiAgICAgICAgICAgICAgICBcInJvdGF0aW9uVW5pdHNcIjogJ3JhZGlhbnMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG5ldyBvbC5GZWF0dXJlKHsncm90YXRpb24nOiBNYXRoLlBJLzR9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRJbWFnZSgpLmdldFJvdGF0aW9uKCkpLnRvQmUoTWF0aC5QSS80KTtcbiAgICAgICAgdmFyIG5ld1N0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZSh7XG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJ0cmlhbmdsZVwiLFxuICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2ZmMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwicm90YXRpb25BdHRyaWJ1dGVcIjogJ3JvdGF0aW9uJyxcbiAgICAgICAgICAgICAgICBcInJvdGF0aW9uVW5pdHNcIjogJ3JhZGlhbnMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG5ldyBvbC5GZWF0dXJlKHsncm90YXRpb24nOiBNYXRoLlBJLzR9KSk7XG4gICAgICAgIC8vIHRha2VuIGZyb20gc3R5bGUgY2FjaGVcbiAgICAgICAgZXhwZWN0KG5ld1N0eWxlID09PSBzdHlsZSkudG9CZVRydXRoeSgpO1xuICAgICAgICBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoe1xuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwidHJpYW5nbGVcIixcbiAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiNmZjAwMDBcIixcbiAgICAgICAgICAgICAgICBcInJvdGF0aW9uQXR0cmlidXRlXCI6ICdyb3RhdGlvbicsXG4gICAgICAgICAgICAgICAgXCJyb3RhdGlvblVuaXRzXCI6ICdkZWdyZWVzJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBuZXcgb2wuRmVhdHVyZSh7J3JvdGF0aW9uJzogMTgwfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGVbMF0uZ2V0SW1hZ2UoKS5nZXRSb3RhdGlvbigpKS50b0JlKE1hdGguUEkvMik7XG4gICAgfSkpO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IHVuaXF1ZSBjbGFzc2lmaWNhdGlvbicsIGluamVjdChmdW5jdGlvbihvbDNTdHlsZUNvbnZlcnRlcikge1xuICAgICAgICB2YXIgc3R5bGVDb25maWcgPSB7XG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNmZmZmMDBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICBcInNpemVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcImNpcmNsZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZW9tVHlwZVwiOiBcInBvaW50XCIsXG4gICAgICAgICAgICBcImNsYXNzaWZ5XCI6IHtcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBcImZvb1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJydWxlc1wiOiBbe1xuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJiYXJcIixcbiAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjZmY5OTAwXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNmZjk5MDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJiYXpcIixcbiAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjYjM2YjAwXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNiMzZiMDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0gICAgXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogJ2Jhcid9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRJbWFnZSgpLmdldEZpbGwoKS5nZXRDb2xvcigpKS50b0JlKCcjZmY5OTAwJyk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRJbWFnZSgpLmdldFN0cm9rZSgpLmdldENvbG9yKCkpLnRvQmUoJ3JnYmEoMjU1LDI1NSwwLDEpJyk7XG4gICAgICAgIHN0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgbmV3IG9sLkZlYXR1cmUoeydmb28nOiAnYmF6J30pKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlWzBdLmdldEltYWdlKCkuZ2V0RmlsbCgpLmdldENvbG9yKCkpLnRvQmUoJyNiMzZiMDAnKTsgXG5cbiAgICAgICAgc3R5bGVDb25maWcuZ2VvbVR5cGUgPSBcImxpbmVcIjtcbiAgICAgICAgc3R5bGUgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnLCBuZXcgb2wuRmVhdHVyZSh7J2Zvbyc6ICdiYXInfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGVbMF0uZ2V0U3Ryb2tlKCkuZ2V0Q29sb3IoKSkudG9CZSgnI2ZmOTkwMCcpO1xuICAgICAgICBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogJ2Jheid9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRTdHJva2UoKS5nZXRDb2xvcigpKS50b0JlKCcjYjM2YjAwJyk7XG5cbiAgICAgICAgc3R5bGVDb25maWcuZ2VvbVR5cGUgPSBcInBvbHlnb25cIjtcbiAgICAgICAgc3R5bGUgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnLCBuZXcgb2wuRmVhdHVyZSh7J2Zvbyc6ICdiYXInfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGVbMF0uZ2V0RmlsbCgpLmdldENvbG9yKCkpLnRvQmUoJyNmZjk5MDAnKTtcbiAgICAgICAgc3R5bGUgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnLCBuZXcgb2wuRmVhdHVyZSh7J2Zvbyc6ICdiYXonfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGVbMF0uZ2V0RmlsbCgpLmdldENvbG9yKCkpLnRvQmUoJyNiMzZiMDAnKTtcbiAgICB9KSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbnZlcnQgcmFuZ2VzIG9mIGEgY2xhc3NpZmljYXRpb24nLCBpbmplY3QoZnVuY3Rpb24ob2wzU3R5bGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdmFyIHN0eWxlQ29uZmlnID0ge1xuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjZmZmZjAwXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJjaXJjbGVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbVR5cGVcIjogXCJwb2ludFwiLFxuICAgICAgICAgICAgXCJjbGFzc2lmeVwiOiB7XG4gICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVcIjogXCJmb29cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicnVsZXNcIjogW3tcbiAgICAgICAgICAgICAgICBcInJhbmdlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJtaW5cIjogMCxcbiAgICAgICAgICAgICAgICAgICAgXCJtYXhcIjogMTBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3R5bGVcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiNmZjk5MDBcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IFwiI2ZmOTkwMFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwibWluXCI6IDEwLFxuICAgICAgICAgICAgICAgICAgICBcIm1heFwiOiAyMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzdHlsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2IzNmIwMFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjYjM2YjAwXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICAgIC8vIHRoaXMgdGVzdHMgZm9yIGJlaW5nIGluY2x1c2l2ZSBvbiB0aGUgbG93ZXIgYm91bmRhcnlcbiAgICAgICAgdmFyIHN0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgbmV3IG9sLkZlYXR1cmUoeydmb28nOiAwfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGVbMF0uZ2V0SW1hZ2UoKS5nZXRGaWxsKCkuZ2V0Q29sb3IoKSkudG9CZSgnI2ZmOTkwMCcpO1xuICAgICAgICBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogMTV9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRJbWFnZSgpLmdldEZpbGwoKS5nZXRDb2xvcigpKS50b0JlKCcjYjM2YjAwJyk7XG5cbiAgICAgICAgc3R5bGVDb25maWcuZ2VvbVR5cGUgPSBcImxpbmVcIjtcbiAgICAgICAgc3R5bGUgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnLCBuZXcgb2wuRmVhdHVyZSh7J2Zvbyc6IDV9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRTdHJva2UoKS5nZXRDb2xvcigpKS50b0JlKCcjZmY5OTAwJyk7XG4gICAgICAgIHN0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgbmV3IG9sLkZlYXR1cmUoeydmb28nOiAxNX0pKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlWzBdLmdldFN0cm9rZSgpLmdldENvbG9yKCkpLnRvQmUoJyNiMzZiMDAnKTtcblxuICAgICAgICBzdHlsZUNvbmZpZy5nZW9tVHlwZSA9IFwicG9seWdvblwiO1xuICAgICAgICBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogNX0pKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlWzBdLmdldEZpbGwoKS5nZXRDb2xvcigpKS50b0JlKCcjZmY5OTAwJyk7XG4gICAgICAgIC8vIHRoaXMgdGVzdHMgZm9yIGJlaW5nIGluY2x1c2l2ZSBvbiB0aGUgdXBwZXIgYm9uZGFyeVxuICAgICAgICBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogMjB9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRGaWxsKCkuZ2V0Q29sb3IoKSkudG9CZSgnI2IzNmIwMCcpO1xuXG4gICAgfSkpO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IHVuaXF1ZSBjbGFzc2lmaWNhdGlvbiB3aXRoIGxhYmVsJywgaW5qZWN0KGZ1bmN0aW9uKG9sM1N0eWxlQ29udmVydGVyKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IFwiI2ZmZmYwMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiY2lyY2xlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21UeXBlXCI6IFwicG9pbnRcIixcbiAgICAgICAgICAgIFwiY2xhc3NpZnlcIjoge1xuICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlXCI6IFwiZm9vXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImxhYmVsXCI6IHtcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBcImZvb1wiLFxuICAgICAgICAgICAgICAgIFwiZm9udFdlaWdodFwiOiBcImJvbGRcIixcbiAgICAgICAgICAgICAgICBcImZvbnRTaXplXCI6IDEyLFxuICAgICAgICAgICAgICAgIFwiZm9udEZhbWlseVwiOiBcIlNlcmlmXCIsXG4gICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjMDAwMGZmXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFt7XG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcImJhclwiLFxuICAgICAgICAgICAgICAgIFwic3R5bGVcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiNmZjk5MDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJiYXpcIixcbiAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjYjM2YjAwXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogJ2Jheid9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRUZXh0KCkuZ2V0VGV4dCgpKS50b0JlKCdiYXonKTtcbiAgICAgICAgdmFyIG5ld1N0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgbmV3IG9sLkZlYXR1cmUoeydmb28nOiAnYmF6J30pKTtcbiAgICAgICAgLy8gdGFrZW4gZnJvbSBzdHlsZSBjYWNoZVxuICAgICAgICBleHBlY3QobmV3U3R5bGUgPT09IHN0eWxlKS50b0JlVHJ1dGh5KCk7XG4gICAgICAgIG5ld1N0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgbmV3IG9sLkZlYXR1cmUoeydmb28nOiAnYmFyJ30pKTtcbiAgICAgICAgLy8gbm90IHRha2VuIGZyb20gc3R5bGUgY2FjaGVcbiAgICAgICAgZXhwZWN0KG5ld1N0eWxlID09PSBzdHlsZSkudG9CZUZhbHN5KCk7XG4gICAgICAgIHN0eWxlQ29uZmlnLnN0cm9rZS5zdHJva2VDb2xvciA9IFwiI2ZmMDAwMFwiO1xuICAgICAgICBuZXdTdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogJ2Jheid9KSk7XG4gICAgICAgIC8vIG5vdCB0YWtlbiBmcm9tIHN0eWxlIGNhY2hlIHNpbmNlIHN0cm9rZUNvbG9yIGNoYW5nZWRcbiAgICAgICAgZXhwZWN0KG5ld1N0eWxlID09PSBzdHlsZSkudG9CZUZhbHN5KCk7XG4gICAgfSkpO1xuXG59KTtcbiIsInBpbnMgPSByZXF1aXJlKCcuLi9saWIvY29yZS90aW1lL3BpbnMuanMnKTtcblxuZGVzY3JpYmUoJ3Rlc3Qgc3RvcnlQaW5zJywgZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgZGVzY3JpYmUoJ1N0b3J5UGluIGNsYXNzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdjb25zdHJ1Y3RvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNwID0gbmV3IHBpbnMuU3RvcnlQaW4oe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAndGVzdCcsXG4gICAgICAgICAgICAgICAgdGhlX2dlb206ICd7XCJ0eXBlXCI6XCJQb2ludFwiLFwiY29vcmRpbmF0ZXNcIjpbMTIzLDMyMV19JyxcbiAgICAgICAgICAgICAgICBpZDogMjJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHNwLmdldCgndGl0bGUnKSkudG9CZSgndGVzdCcpO1xuICAgICAgICAgICAgZXhwZWN0KHNwLnRpdGxlKS50b0JlKCd0ZXN0Jyk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0SWQoKSkudG9CZSgyMik7XG4gICAgICAgICAgICBleHBlY3Qoc3AuaWQpLnRvQmUoMjIpO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHNwLmdldEdlb21ldHJ5KCkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICAgIGV4cGVjdChjb29yZHNbMF0pLnRvQmUoMTIzKTtcbiAgICAgICAgICAgIGV4cGVjdChjb29yZHNbMV0pLnRvQmUoMzIxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCd1cGRhdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzcCA9IG5ldyBwaW5zLlN0b3J5UGluKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ3Rlc3QnLFxuICAgICAgICAgICAgICAgIHRoZV9nZW9tOiAne1widHlwZVwiOlwiUG9pbnRcIixcImNvb3JkaW5hdGVzXCI6WzEyMywzMjFdfSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHNwLmNvbnRlbnQpLnRvQmUobnVsbCk7XG4gICAgICAgICAgICBleHBlY3Qoc3AudGl0bGUpLnRvQmUoJ3Rlc3QnKTtcbiAgICAgICAgICAgIHNwLnNldFByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdjb250ZW50J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuY29udGVudCkudG9CZSgnY29udGVudCcpO1xuICAgICAgICAgICAgZXhwZWN0KHNwLnRpdGxlKS50b0JlKG51bGwpO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHNwLmdldEdlb21ldHJ5KCkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICAgIGV4cGVjdChjb29yZHNbMF0pLnRvQmUoMTIzKTtcbiAgICAgICAgICAgIGV4cGVjdChjb29yZHNbMV0pLnRvQmUoMzIxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdlbXB0eScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNwID0gbmV3IHBpbnMuU3RvcnlQaW4oKTtcbiAgICAgICAgICAgIGV4cGVjdChzcC5jb250ZW50KS50b0JlKG51bGwpO1xuICAgICAgICAgICAgZXhwZWN0KHNwLnRpdGxlKS50b0JlKG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGdlb2pzb24gPSB7XG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IDI0LFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7IHR5cGU6J1BvaW50JywgY29vcmRpbmF0ZXM6Wy05MCw0NV0gfSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAndGVzdCcsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X3RpbWU6IDEwMDAwMDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9O1xuICAgIGRlc2NyaWJlKCdsb2FkRnJvbUdlb0pTT04nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3dvcmtzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gcGlucy5sb2FkRnJvbUdlb0pTT04oZ2VvanNvbik7XG4gICAgICAgICAgICBleHBlY3QobG9hZGVkLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIHZhciBzcCA9IGxvYWRlZFswXTtcbiAgICAgICAgICAgIGV4cGVjdChzcC5pZCkudG9CZSgyNCk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0R2VvbWV0cnkoKS5nZXRDb29yZGluYXRlcygpWzBdKS50b0JlKC05MCk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0R2VvbWV0cnkoKS5nZXRDb29yZGluYXRlcygpWzFdKS50b0JlKDQ1KTtcbiAgICAgICAgICAgIGV4cGVjdChzcC5zdGFydF90aW1lKS50b0JlKDEwMDAwMDAwMDApO1xuICAgICAgICAgICAgZXhwZWN0KHNwLmVuZF90aW1lKS50b0JlKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3dvcmtzIHdpdGggcHJvamVjdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxvYWRlZCA9IHBpbnMubG9hZEZyb21HZW9KU09OKGdlb2pzb24sIG9sLnByb2ouZ2V0KCdFUFNHOjM4NTcnKSk7XG4gICAgICAgICAgICB2YXIgc3AgPSBsb2FkZWRbMF07XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0R2VvbWV0cnkoKS5nZXRDb29yZGluYXRlcygpWzBdKS50b0JlKC0xMDAxODc1NC4xNzEzOTQ2MjIpO1xuICAgICAgICAgICAgZXhwZWN0KHNwLmdldEdlb21ldHJ5KCkuZ2V0Q29vcmRpbmF0ZXMoKVsxXSkudG9CZSg1NjIxNTIxLjQ4NjE5MjA2Nik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRlc2NyaWJlKCd0b0dlb0pTT04nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3dvcmtzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyB0byBkbyB0aGlzIGNvcnJlY3RseSwgd2UgbmVlZCB0byB1bmRlcnN0YW5kIHRoZSBjdXJyZW50IHByb2plY3Rpb25cbiAgICAgICAgICAgIC8vIHRoaXMgdGVzdCBqdXN0IHZlcmlmaWVzIHRoZSBvbDMgZm9ybWF0IHdvcmtzIHByb3Blcmx5XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gbmV3IG9sLmZvcm1hdC5HZW9KU09OKHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0RGF0YVByb2plY3Rpb246ICdFUFNHOjQzMjYnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzcCA9IG5ldyBwaW5zLlN0b3J5UGluKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ3Rlc3QnLFxuICAgICAgICAgICAgICAgIHRoZV9nZW9tOiAne1widHlwZVwiOlwiUG9pbnRcIixcImNvb3JkaW5hdGVzXCI6WzEyMywzMjFdfScsXG4gICAgICAgICAgICAgICAgaWQ6IDIyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzcCA9IGZvcm1hdC5yZWFkRmVhdHVyZShmb3JtYXQud3JpdGVGZWF0dXJlKHNwKSk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0KCd0aXRsZScpKS50b0JlKCd0ZXN0Jyk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0SWQoKSkudG9CZSgyMik7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gc3AuZ2V0R2VvbWV0cnkoKS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICAgICAgZXhwZWN0KGNvb3Jkc1swXSkudG9CZSgxMjMpO1xuICAgICAgICAgICAgZXhwZWN0KGNvb3Jkc1sxXSkudG9CZSgzMjEpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIiwic3Rvcnl0b29scyA9IHtcbiAgICBjb3JlOiByZXF1aXJlKCcuLi9saWIvY29yZS9pbmRleC5qcycpXG59O1xucmVxdWlyZSgnLi4vbGliL25nL2NvcmUvcGlucy9tb2R1bGUuanMnKTtcblxuZGVzY3JpYmUoJ3Rlc3Qgc3RvcnlQaW5zJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIFN0b3J5UGluO1xuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlIGlzIHdvcmsgYXJvdW5kIGJyb3dzZXJpZnkgY29uZmxpY3RcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuY29yZS5waW5zJyk7XG5cbiAgICAgICAgaW5qZWN0KGZ1bmN0aW9uKCRpbmplY3Rvcikge1xuICAgICAgICAgICAgU3RvcnlQaW4gPSAkaW5qZWN0b3IuZ2V0KCdTdG9yeVBpbicpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdTdG9yeVBpbkxheWVyTWFuYWdlcicsIGZ1bmN0aW9uKCkge1xuXG4gICAgfSk7XG5cbn0pOyIsInJlcXVpcmUoJy4uL2xpYi9uZy9lZGl0L3N0eWxlL3NlcnZpY2VzL3N0eWxlQ2hvaWNlcy5qcycpO1xuXG5kZXNjcmliZSgndGVzdCBzdHlsZUNob2ljZXMnLCBmdW5jdGlvbigpIHtcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmVkaXQuc3R5bGUuc3R5bGVDaG9pY2VzJyk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnc3RSZWNlbnRDaG9pY2VzIHdvcmtzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGluamVjdChmdW5jdGlvbigkaW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBzdFJlY2VudENob2ljZXMgPSAkaW5qZWN0b3IuZ2V0KCdzdFJlY2VudENob2ljZXMnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3Nob3VsZCBzdG9yZSByZWNlbnQgaWNvbnMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpY29ucyA9IHN0UmVjZW50Q2hvaWNlcy5pY29ucztcbiAgICAgICAgICAgIGljb25zLmNsZWFyKCk7XG4gICAgICAgICAgICBpY29ucy5hZGQoJ2EnKTtcbiAgICAgICAgICAgIGV4cGVjdChpY29ucy5yZWNlbnQpLnRvRXF1YWwoWydhJ10pO1xuICAgICAgICAgICAgaWNvbnMuYWRkKCdiJyk7XG4gICAgICAgICAgICBleHBlY3QoaWNvbnMucmVjZW50KS50b0VxdWFsKFsnYScsICdiJ10pO1xuICAgICAgICAgICAgaWNvbnMuYWRkKCdiJyk7XG4gICAgICAgICAgICBleHBlY3QoaWNvbnMucmVjZW50KS50b0VxdWFsKFsnYScsICdiJ10pO1xuICAgICAgICAgICAgdmFyIG90aGVycyA9ICdjZGVmZ2hpamtsbW9ucHFyc3R1dnh5eic7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8b3RoZXJzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgICAgICBpY29ucy5hZGQob3RoZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdChpY29ucy5yZWNlbnQubGVuZ3RoKS50b0JlKGljb25zLl9tYXgpO1xuICAgICAgICAgICAgLy8gdGhpcyBhc3NlcnRpb24gaXMgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gb2YgX21heD0yNC4uLlxuICAgICAgICAgICAgZXhwZWN0KGljb25zLnJlY2VudFswXSkudG9CZSgnYicpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pOyIsInJlcXVpcmUoJy4uL2xpYi9uZy9lZGl0L3N0eWxlL2RpcmVjdGl2ZXMvZGlyZWN0aXZlcy5qcycpO1xucmVxdWlyZSgnLi4vbGliL25nL2VkaXQvc3R5bGUvc2VydmljZXMvaWNvbkNvbW1vbnMuanMnKTtcbnJlcXVpcmUoJy4uL2xpYi9uZy9lZGl0L3N0eWxlL3NlcnZpY2VzL3N0eWxlQ2hvaWNlcy5qcycpO1xucmVxdWlyZSgnLi4vbGliL25nL2NvcmUvc3R5bGUvb2wzU3R5bGVDb252ZXJ0ZXIuanMnKTtcbnJlcXVpcmUoJy4uL2xpYi9uZy9jb3JlL3N0eWxlL3N2Z0ljb24uanMnKTtcbmhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMuanMnKTtcbiQgPSByZXF1aXJlKCcuLi9ib3dlcl9jb21wb25lbnRzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcycpO1xuXG5kZXNjcmliZSgndGVzdCBzdHlsZSBkaXJlY3RpdmVzJywgZnVuY3Rpb24oKSB7XG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBAdG9kbyBtb2NrIGRlcGVuZGVuY3kgZm9yIG5vdyAtIHVzZWQgYnkgZ3JhcGhpY0VkaXRvclxuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZShmdW5jdGlvbigkcHJvdmlkZSkge1xuICAgICAgICAgICAgJHByb3ZpZGUudmFsdWUoJyRtb2RhbCcsIHtvcGVuOiBuZXcgRnVuY3Rpb24oKX0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSBpcyB3b3JrIGFyb3VuZCBicm93c2VyaWZ5IGNvbmZsaWN0XG4gICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmVkaXQuc3R5bGUuZGlyZWN0aXZlcycpO1xuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5hbGxUZW1wbGF0ZXMnKTtcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5zdHlsZUNob2ljZXMnKTtcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5pY29uQ29tbW9ucycpO1xuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5jb3JlLnN0eWxlLm9sM1N0eWxlQ29udmVydGVyJyk7XG4gICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmNvcmUuc3R5bGUuc3ZnSWNvbicpO1xuXG4gICAgICAgIGluamVjdChoZWxwZXJzLmluamVjdCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnYXR0cmlidXRlLWNvbWJvJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdzaG91bGQgZmlsdGVyIGF0dHJpYnV0ZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW1xuICAgICAgICAgICAgICAgIHtuYW1lOiAncycsIHR5cGU6ICdzdHJpbmcnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2knLCB0eXBlOiAnaW50ZWdlcid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnZCcsIHR5cGU6ICdkb3VibGUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3QnLCB0eXBlOiAnZGF0ZVRpbWUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2cnLCB0eXBlOiAnZ2VvbScsIHR5cGVOUzonaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHtcbiAgICAgICAgICAgICAgICBsYXllcjoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gYXR0cmlidXRlVGV4dChlbCkge1xuICAgICAgICAgICAgICAgIC8vIGV4dHJhY3QgYXR0cmlidXRlIHRleHQgZnJvbSBlbGVtZW50cyBkaXNyZWdhcmRpbmcgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuZ3VsYXIuZWxlbWVudChlbC5maW5kKCdsaScpLnNwbGljZSgxKSkudGV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXhwZWN0aW5nIGFsbCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICB2YXIgZWwgPSBoZWxwZXJzLmNvbXBpbGUoXCI8YXR0cmlidXRlLWNvbWJvIGxheWVyPWxheWVyPjwvYXR0cmlidXRlLWNvbWJvPlwiLCBzY29wZSk7XG4gICAgICAgICAgICBleHBlY3QoYXR0cmlidXRlVGV4dChlbCkpLnRvQmUoJ2RnaXN0Jyk7XG4gICAgICAgICAgICAvLyBleGNsdWRlIGdlb21cbiAgICAgICAgICAgIGVsID0gaGVscGVycy5jb21waWxlKFwiPGF0dHJpYnV0ZS1jb21ibyBmaWx0ZXI9bm9nZW9tIGxheWVyPWxheWVyPjwvYXR0cmlidXRlLWNvbWJvPlwiLCBzY29wZSk7XG4gICAgICAgICAgICBleHBlY3QoYXR0cmlidXRlVGV4dChlbCkpLnRvQmUoJ2Rpc3QnKTtcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgc3RyaW5nIGFuZCBpbnRlZ2VyXG4gICAgICAgICAgICBlbCA9IGhlbHBlcnMuY29tcGlsZShcIjxhdHRyaWJ1dGUtY29tYm8gaW5jbHVkZT0nc3RyaW5nLGludGVnZXInIGxheWVyPWxheWVyPjwvYXR0cmlidXRlLWNvbWJvPlwiLCBzY29wZSk7XG4gICAgICAgICAgICBleHBlY3QoYXR0cmlidXRlVGV4dChlbCkpLnRvQmUoJ2lzJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ251bWJlciBlZGl0b3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCBiaW5kIGFuZCBlZGl0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBoZWxwZXJzLmNvbXBpbGUoXCI8bnVtYmVyLWVkaXRvciBzdC1tb2RlbD0ndGhpbmcnIHByb3BlcnR5PSd2YWx1ZSc+PC9udW1iZXItZWRpdG9yPlwiLCB7dGhpbmc6IHt2YWx1ZTogNDJ9fSk7XG4gICAgICAgICAgICBleHBlY3QoZWwuZmluZCgnYnV0dG9uJykudGV4dCgpLnRyaW0oKSkudG9CZSgnNDInKTtcbiAgICAgICAgICAgIGhlbHBlcnMuc2V0SW5wdXRWYWx1ZShlbC5maW5kKCdpbnB1dCcpLCAnMTMnKTtcbiAgICAgICAgICAgIGV4cGVjdChoZWxwZXJzLmdldFNjb3BlKGVsKS50aGluZy52YWx1ZSkudG9CZSgxMyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NvbG9yIGVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnc2hvdWxkIGJpbmQgYW5kIGVkaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGhlbHBlcnMuY29tcGlsZShcIjxjb2xvci1lZGl0b3Igc3QtbW9kZWw9J3RoaW5nJyBwcm9wZXJ0eT0ndmFsdWUnPjwvY29sb3ItZWRpdG9yPlwiLCB7dGhpbmc6IHt2YWx1ZTogJyNmYWEnfX0pO1xuICAgICAgICAgICAgZXhwZWN0KGVsLmZpbmQoJ2knKS5jc3MoJ2JhY2tncm91bmRDb2xvcicpKS50b0JlKCdyZ2IoMjU1LCAxNzAsIDE3MCknKTtcbiAgICAgICAgICAgIGhlbHBlcnMuc2V0SW5wdXRWYWx1ZShlbC5maW5kKCdpbnB1dCcpLCAnI2FhYScpO1xuICAgICAgICAgICAgZXhwZWN0KGhlbHBlcnMuZ2V0U2NvcGUoZWwpLnRoaW5nLnZhbHVlKS50b0JlKCcjYWFhJyk7XG4gICAgICAgICAgICBleHBlY3QoZWwuZmluZCgnaScpLmNzcygnYmFja2dyb3VuZENvbG9yJykpLnRvQmUoJ3JnYigxNzAsIDE3MCwgMTcwKScpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdncmFwaGljLWVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBiZWZvcmVFYWNoKGluamVjdChmdW5jdGlvbigkaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHN0UmVjZW50Q2hvaWNlcyA9ICRpbmplY3Rvci5nZXQoJ3N0UmVjZW50Q2hvaWNlcycpO1xuICAgICAgICAgICAgLy8gY2xlYXIgdGhlc2UgYXMgdGhleSBtYXkgdHJpZ2dlciBodHRwIHJlcXVlc3RzXG4gICAgICAgICAgICBzdFJlY2VudENob2ljZXMuaWNvbnMuY2xlYXIoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBpdCgnc2hvdWxkIGJpbmQgYW5kIGVkaXQgbWFya3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGhlbHBlcnMuY29tcGlsZShcIjxncmFwaGljLWVkaXRvciBzeW1ib2w9J3RoaW5nJz48L2dyYXBoaWMtZWRpdG9yPlwiLCB7dGhpbmc6IHtzaGFwZTogJ2NpcmNsZSd9fSk7XG4gICAgICAgICAgICAvLyBAdG9kbyBub3QgYSBncmVhdCB0ZXN0IC0gaW5zdGVhZCBvZiB1c2luZyBhIGNhbnZhcywgdGhpcyBjb3VsZCBiZSBhbiBpbWFnZSB3LyBkYXRhIFVSSVxuICAgICAgICAgICAgZXhwZWN0KGVsLmZpbmQoJ3NwYW4gY2FudmFzJykuYXR0cignbWFyaycpKS50b0JlKCdjaXJjbGUnKTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbC5maW5kKCdjYW52YXMnKSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGUgPSBhbmd1bGFyLmVsZW1lbnQoZSk7XG4gICAgICAgICAgICAgICAgaWYgKGUuYXR0cignbWFyaycpID09ICdzcXVhcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGUudHJpZ2dlckhhbmRsZXIoJ2NsaWNrJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZWwuZmluZCgnc3BhbiBjYW52YXMnKS5hdHRyKCdtYXJrJykpLnRvQmUoJ3NxdWFyZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVzY3JpYmUoJ3dvcmtzIHdpdGggaWNvbiBjb21tb25zJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBleHRyYSBnbmFybCAtIHJlbmRlcmluZyBvZiB0aGUgcmVjZW50LWljb25zIHJlcXVpcmVzIHNvbWVcbiAgICAgICAgICAgIC8vIG1vY2sgaHR0cCB0byB0YWxrIHRvIHRoZSBpY29uQ29tbW9ucyBhbmQgd2FpdCB1bnRpbCB0aGVcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZSB1cGRhdGVzIGl0c2VsZiAtIHNlZSB3aGVuUmVhZHlcbiAgICAgICAgICAgIGJlZm9yZUVhY2goaW5qZWN0KGZ1bmN0aW9uKCRpbmplY3Rvcikge1xuICAgICAgICAgICAgICAgICRodHRwQmFja2VuZCA9ICRpbmplY3Rvci5nZXQoJyRodHRwQmFja2VuZCcpO1xuICAgICAgICAgICAgICAgIHN0UmVjZW50Q2hvaWNlcyA9ICRpbmplY3Rvci5nZXQoJ3N0UmVjZW50Q2hvaWNlcycpO1xuICAgICAgICAgICAgICAgICRxID0gJGluamVjdG9yLmdldCgnJHEnKTtcbiAgICAgICAgICAgICAgICAkdGltZW91dCA9ICRpbmplY3Rvci5nZXQoJyR0aW1lb3V0Jyk7XG5cbiAgICAgICAgICAgICAgICBzdFJlY2VudENob2ljZXMuaWNvbnMuYWRkKCcvaXRlbTEuc3ZnJyk7XG4gICAgICAgICAgICAgICAgc3RSZWNlbnRDaG9pY2VzLmljb25zLmFkZCgnL2l0ZW0yLnN2ZycpO1xuICAgICAgICAgICAgICAgIC8vIG1vY2sgcmVxdWVzdHMgZm9yIHRoZSBpY29uc1xuICAgICAgICAgICAgICAgICRodHRwQmFja2VuZC53aGVuKCdHRVQnLCAnL2l0ZW0xLnN2ZycpLnJlc3BvbmQoJzxzdmc+PC9zdmc+JywgeydDb250ZW50LVR5cGUnOiAndGV4dC94bWwnfSk7XG4gICAgICAgICAgICAgICAgJGh0dHBCYWNrZW5kLndoZW4oJ0dFVCcsICcvaXRlbTIuc3ZnJykucmVzcG9uZCgnPHN2Zz48L3N2Zz4nLCB7J0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3htbCd9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb25jZSB0aGUgaHR0cCByZXF1ZXN0cyBoYXZlXG4gICAgICAgICAgICAvLyBjb21wbGV0ZWQgYW5kIHRoZSByZWNlbnQgaWNvbnMgaGF2ZSBiZWVuIHNldCBpbiB0aGUgc2NvcGVcbiAgICAgICAgICAgIGZ1bmN0aW9uIHdoZW5SZWFkeShlbCwgJGh0dHBCYWNrZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JhYiB0aGUgZGlyZWN0aXZlIHNjb3BlIGFuZCB3YXRjaCBmb3Igc3ZnIGljb25zIHRvIHJlc29sdmUgYmVmb3JlIHJ1bm5pbmcgdGVzdHNcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSBoZWxwZXJzLmdldFNjb3BlKGVsLmNoaWxkcmVuKCkpO1xuICAgICAgICAgICAgICAgIHZhciBsb2FkZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaCgncmVjZW50JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZC5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGZsdXNoIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAkaHR0cEJhY2tlbmQuZmx1c2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVkLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQgOiBmb3IgYWxsIHRlc3RzIGhlcmUsIGlmIGBkb25lYCBpcyBub3QgY2FsbGVkLCBqYXNtaW5lIHdpbGwgdGltZW91dCAtXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgY292ZXIgdGhlIGZhaWx1cmUgY2FzZS4gc2VlOiBodHRwOi8vamFzbWluZS5naXRodWIuaW8vMi4wL2ludHJvZHVjdGlvbi5odG1sI3NlY3Rpb24tQXN5bmNocm9ub3VzX1N1cHBvcnRcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogJHRpbWVvdXQuZmx1c2goKSBpcyByZXF1aXJlZCB0byB0cmlnZ2VyIHByb21pc2UgcmVzb2x1dGlvblxuICAgICAgICAgICAgaXQoJ3Nob3VsZCBiaW5kIHRvIHJlY2VudCBjaG9pY2VzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGhlbHBlcnMuY29tcGlsZShcIjxncmFwaGljLWVkaXRvciBzeW1ib2w9J3RoaW5nJz48L2dyYXBoaWMtZWRpdG9yPlwiLCB7dGhpbmc6IHt9fSk7XG4gICAgICAgICAgICAgICAgd2hlblJlYWR5KGVsLCAkaHR0cEJhY2tlbmQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBlbC5maW5kKCcucmVjZW50LWljb25zIGltZycpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoaW1nLmxlbmd0aCkudG9CZSgyKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmZsdXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0KCdzaG91bGQgdXBkYXRlIHdpdGggY2hhbmdlIGluIHJlY2VudCBjaG9pY2VzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGhlbHBlcnMuY29tcGlsZShcIjxncmFwaGljLWVkaXRvciBzeW1ib2w9J3RoaW5nJz48L2dyYXBoaWMtZWRpdG9yPlwiLCB7dGhpbmc6IHt9fSk7XG5cbiAgICAgICAgICAgICAgICB3aGVuUmVhZHkoZWwsICRodHRwQmFja2VuZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IGVsLmZpbmQoJy5yZWNlbnQtaWNvbnMgaW1nJyk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChpbWcubGVuZ3RoKS50b0JlKDIpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoaW1nLmF0dHIoJ3NyYycpLmluZGV4T2YoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJykpLnRvQmUoMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSdyZSBhbHJlYWR5IGluIHRoZSBkaWdlc3QsIGNhbGwgdGhpcyB3aXRoIGEgdGltZW91dFxuICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHF1ZXVlIHVwIGV4cGVjdGVkIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICRodHRwQmFja2VuZC53aGVuKCdHRVQnLCAnL2l0ZW0zLnN2ZycpLnJlc3BvbmQoJzxzdmc+PC9zdmc+JywgeydDb250ZW50LVR5cGUnOiAndGV4dC94bWwnfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYWRkIHRoaXMgcmVjZW50IGNob2ljZSAobm9ybWFsbHkgd291bGQgYmUgZnJvbSB1c2VyIHNlbGVjdGluZyBmcm9tIGljb24tY29tbW9ucyBkaWFsb2dcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0UmVjZW50Q2hvaWNlcy5pY29ucy5hZGQoJy9pdGVtMy5zdmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdHJpZ2dlcnMgYW4gdXBkYXRlIGFzIGlmIHVzZXIgdXNlZCB0aGUgZGlhbG9nXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJzLmdldFNjb3BlKGVsLmNoaWxkcmVuKCkpLl91cGRhdGVSZWNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIHNob3VsZCBiZSAzIGljb25zIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlblJlYWR5KGVsLCAkaHR0cEJhY2tlbmQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IGVsLmZpbmQoJy5yZWNlbnQtaWNvbnMgaW1nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGltZy5sZW5ndGgpLnRvQmUoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmZsdXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0KCdzaG91bGQgYmluZCBhbmQgZWRpdCBzdmcnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gaGVscGVycy5jb21waWxlKFwiPGdyYXBoaWMtZWRpdG9yIHN5bWJvbD0ndGhpbmcnPjwvZ3JhcGhpYy1lZGl0b3I+XCIsIHt0aGluZzoge2dyYXBoaWM6ICcvaXRlbTEuc3ZnJ319KTtcbiAgICAgICAgICAgICAgICB3aGVuUmVhZHkoZWwsICRodHRwQmFja2VuZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IGVsLmZpbmQoJy5yZWNlbnQtaWNvbnMgaW1nJyk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChpbWcubGVuZ3RoKS50b0JlKDIpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoaW1nLmF0dHIoJ3NyYycpLmluZGV4T2YoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJykpLnRvQmUoMCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkdGltZW91dC5mbHVzaCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnbGFiZWwtZWRpdG9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdzaG91bGQgYmluZCBhbmQgZWRpdCBhdHRyaWJ1dGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHtcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwiZm9udEZhbWlseVwiOiBcIlNlcmlmXCIsXG4gICAgICAgICAgICAgICAgXCJmb250U2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcImZvbnRTdHlsZVwiOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICAgIFwiZm9udFdlaWdodFwiOiBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdhJywgdHlwZTogJ3N0cmluZyd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnYicsIHR5cGU6ICdpbnRlZ2VyJ31cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgZWwgPSBoZWxwZXJzLmNvbXBpbGUoXCI8bGFiZWwtZWRpdG9yIGxheWVyPWxheWVyIHN0LW1vZGVsPSd0aGluZyc+PC9ncmFwaGljLWVkaXRvcj5cIiwge1xuICAgICAgICAgICAgICAgIHRoaW5nOiB7bGFiZWw6IGxhYmVsfSxcbiAgICAgICAgICAgICAgICBsYXllcjoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9jayBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGVsLmZpbmQoJy5kcm9wZG93bi10b2dnbGUnKS5lcSgwKS50ZXh0KCkudHJpbSgpKS50b0JlKCdTZWxlY3QgQXR0cmlidXRlJyk7XG4gICAgICAgICAgICBoZWxwZXJzLmNsaWNrKGVsLmZpbmQoJy5kcm9wZG93bi1tZW51JykuZXEoMCkuZmluZCgnbGknKS5lcSgxKSk7XG4gICAgICAgICAgICBleHBlY3QobGFiZWwuYXR0cmlidXRlKS50b0JlKCdhJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NsYXNzaWZ5LWVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2xhc3NpZnksIGVsO1xuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xhc3NpZnkgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBudWxsLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBtYXhDbGFzc2VzOiA1LFxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiAxNlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2EnLCB0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdiJywgdHlwZTogJ2ludGVnZXInfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGVsID0gaGVscGVycy5jb21waWxlKFwiPGNsYXNzaWZ5LWVkaXRvciBzaG93LW1heC1jbGFzc2VzPXRydWUgc2hvdy1maXhlZC1jbGFzc2VzPjwvY2xhc3NpZnktZWRpdG9yPlwiLCB7XG4gICAgICAgICAgICAgICAgbGF5ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhY3RpdmVTdHlsZToge2NsYXNzaWZ5OiBjbGFzc2lmeX0sXG4gICAgICAgICAgICAgICAgY2hhbmdlQ2xhc3NpZnlQcm9wZXJ0eTogZnVuY3Rpb24ocHJvcCwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzaWZ5W3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2hvd01heENsYXNzZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hvd0ZpeGVkQ2xhc3NlczogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnc2hvdWxkIGJpbmQgYW5kIGVkaXQgYXR0cmlidXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoZWxwZXJzLmNsaWNrKGVsLmZpbmQoJ3VsLmRyb3Bkb3duLW1lbnUgbGknKS5nZXQoMSkpO1xuICAgICAgICAgICAgZXhwZWN0KGNsYXNzaWZ5LmF0dHJpYnV0ZSkudG9CZSgnYScpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3Nob3VsZCBiaW5kIGFuZCBlZGl0IG1heENsYXNzZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhlbHBlcnMuc2V0SW5wdXRWYWx1ZShlbC5maW5kKCdbbmctaWY9c2hvd01heENsYXNzZXNdIGlucHV0JykuZXEoMCksICc3Jyk7XG4gICAgICAgICAgICBleHBlY3QoY2xhc3NpZnkubWF4Q2xhc3NlcykudG9CZSg3KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnc3Ryb2tlLWVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnaGFzIGEgc21va2UgdGVzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsID0gaGVscGVycy5jb21waWxlKFwiPHN0cm9rZS1lZGl0b3Igc3QtbW9kZWw9J3RoaW5nJz48L3N0cm9rZS1lZGl0b3I+XCIsIHt0aGluZzoge3N0cm9rZToge319fSk7XG4gICAgICAgICAgICBleHBlY3QoZWwuY2hpbGRyZW4oKS5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3J1bGVzLWVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnaGFzIGEgc21va2UgdGVzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsID0gaGVscGVycy5jb21waWxlKFwiPHJ1bGVzLWVkaXRvcj48L3J1bGVzLWVkaXRvcj5cIiwge30pO1xuICAgICAgICAgICAgZXhwZWN0KGVsLmNoaWxkcmVuKCkubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdzeW1ib2wtZWRpdG9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdoYXMgYSBzbW9rZSB0ZXN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBoZWxwZXJzLmNvbXBpbGUoXCI8c3ltYm9sLWVkaXRvciBzdC1tb2RlbD0ndGhpbmcnPjwvc3ltYm9sLWVkaXRvcj5cIiwge3RoaW5nOiB7c3ltYm9sOiB7fX19KTtcbiAgICAgICAgICAgIGV4cGVjdChlbC5jaGlsZHJlbigpLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcbiIsInJlcXVpcmUoJy4uL2xpYi9uZy9lZGl0L3N0eWxlL3NlcnZpY2VzL3N0eWxlUnVsZUJ1aWxkZXIuanMnKTtcbnJlcXVpcmUoJy4uL2xpYi9uZy9lZGl0L3N0eWxlL3NlcnZpY2VzL3N0eWxlQ2hvaWNlcy5qcycpO1xucmVxdWlyZSgnLi4vbGliL25nL2VkaXQvc3R5bGUvc2VydmljZXMvc3R5bGVUeXBlcy5qcycpO1xuXG5kZXNjcmliZSgnc3R5bGVSdWxlQnVpbGRlcicsIGZ1bmN0aW9uKCkge1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUgaXMgd29yayBhcm91bmQgYnJvd3NlcmlmeSBjb25mbGljdFxuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnN0eWxlLnN0eWxlUnVsZUJ1aWxkZXInKTtcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5zdHlsZUNob2ljZXMnKTtcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5zdHlsZVR5cGVzJyk7XG5cbiAgICAgICAgaW5qZWN0KGZ1bmN0aW9uKHN0U3R5bGVSdWxlQnVpbGRlcikge1xuICAgICAgICAgICAgdGhpcy5zdFN0eWxlUnVsZUJ1aWxkZXIgPSBzdFN0eWxlUnVsZUJ1aWxkZXI7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwaWNrIHZhbHVlcyBmcm9tIGEgMi1zdG9wIGNvbG9yIHJhbXAnLCBpbmplY3QoZnVuY3Rpb24oc3RTdHlsZVJ1bGVCdWlsZGVyKSB7XG4gICAgICAgIHZhbHMgPSBzdFN0eWxlUnVsZUJ1aWxkZXIuX2NvbG9yUmFtcFZhbHVlcyh7MDonI2ZmMDAwMCcsMTonIzAwMDBmZid9LDIpO1xuICAgICAgICBleHBlY3QodmFscy5sZW5ndGgpLnRvQmUoMik7XG4gICAgICAgIGV4cGVjdCh2YWxzKS50b0VxdWFsKFsnI2ZmMDAwMCcsJyMwMDAwZmYnXSk7XG4gICAgfSkpO1xuXG4gICAgaXQoJ3Nob3VsZCBwaWNrIHZhbHVlcyBmcm9tIGEgMy1zdG9wIGNvbG9yIHJhbXAnLCBpbmplY3QoZnVuY3Rpb24oc3RTdHlsZVJ1bGVCdWlsZGVyKSB7XG4gICAgICAgIHZhbHMgPSBzdFN0eWxlUnVsZUJ1aWxkZXIuX2NvbG9yUmFtcFZhbHVlcyh7MDonI2ZmMDAwMCcsMTonIzAwMDBmZid9LDMpO1xuICAgICAgICBleHBlY3QodmFscy5sZW5ndGgpLnRvQmUoMyk7XG4gICAgICAgIGV4cGVjdCh2YWxzKS50b0VxdWFsKFsnI2ZmMDAwMCcsICcjN2YwMDdmJywgJyMwMDAwZmYnXSk7XG4gICAgfSkpO1xufSk7IiwicmVxdWlyZSgnLi4vbGliL25nL2VkaXQvdGltZS9kaXJlY3RpdmVzLmpzJyk7XG5oZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzLmpzJyk7XG5cbmRlc2NyaWJlKCd0ZXN0IHRpbWUgZGlyZWN0aXZlcycsIGZ1bmN0aW9uKCkge1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUgaXMgd29yayBhcm91bmQgYnJvd3NlcmlmeSBjb25mbGljdFxuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnRpbWUuZGlyZWN0aXZlcycpO1xuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5hbGxUZW1wbGF0ZXMnKTtcblxuICAgICAgICBpbmplY3QoaGVscGVycy5pbmplY3QpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3N0LWRhdGUtdGltZS1maWVsZCBkaXJlY3RpdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXBvY2ggcHJvcGVybHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGhlbHBlcnMuY29tcGlsZSgnPHN0LWRhdGUtdGltZS1maWVsZCBkYXRlLXRpbWU9XCJ2YWx1ZVwiPjwvc3QtZGF0ZS10aW1lLWZpZWxkPicsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnB1dCA9IGVsLmZpbmQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBleHBlY3QoaW5wdXQudmFsKCkpLnRvQmUoJzE5NzAtMDEtMDFUMDA6MDA6MDAuMDAwWicpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pOyIsInN0b3J5dG9vbHMgPSB7XG4gICAgY29yZTogcmVxdWlyZSgnLi4vbGliL2NvcmUvaW5kZXguanMnKVxufTtcbnJlcXVpcmUoJy4uL2xpYi9uZy9jb3JlL3RpbWUvc2VydmljZXMuanMnKTtcblxuZGVzY3JpYmUoJ3Rlc3QgdGltZSBzZXJ2aWNlcycsIGZ1bmN0aW9uKCkge1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuY29yZS50aW1lLnNlcnZpY2VzJyk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnVGltZU1hY2hpbmUgd29ya3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gdGltZUxheWVycygpIHtcbiAgICAgICAgICAgIHZhciBsYXllcnMgPSBbXTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICAgICAgfVxuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpbmplY3QoZnVuY3Rpb24oJGluamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgVGltZU1hY2hpbmUgPSAkaW5qZWN0b3IuZ2V0KCdUaW1lTWFjaGluZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnc2hvdWxkIGNvbXB1dGUgdGlja3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxheWVycyA9IHRpbWVMYXllcnMoXG4gICAgICAgICAgICAgICAgWzEsIDEwLCAxMDAwXSxcbiAgICAgICAgICAgICAgICBbMTAwMDAsIDEwLCAxMF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QoVGltZU1hY2hpbmUuY29tcHV0ZVRpY2tzKGxheWVycykpLnRvRXF1YWwoWyAxLCAxMCwgMTAwMCwgMTAwMDAgXSk7XG5cbiAgICAgICAgICAgIGxheWVycyA9IHRpbWVMYXllcnMoXG4gICAgICAgICAgICAgICAgWzEwMDAwLCA0MDAwMF0sXG4gICAgICAgICAgICAgICAgWzIwMDAwLCAzMDAwMF0sXG4gICAgICAgICAgICAgICAgbmV3IHN0b3J5dG9vbHMuY29yZS50aW1lLnV0aWxzLkludGVydmFsKHtzdGFydDogNTAwMCwgZW5kOiA1MDAwMCwgZHVyYXRpb246J1A1Uyd9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gNTAwMDsgaSA8PSA1MDAwMDsgaSs9IDUwMDAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KFRpbWVNYWNoaW5lLmNvbXB1dGVUaWNrcyhsYXllcnMpKS50b0VxdWFsKHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vbGliL2NvcmUvdGltZS91dGlscy5qcycpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG4vKlxuTk9URSAtIG51bWVyaWMgdmFsdWVzIGluIHRoZXNlIHRlc3RzIChhbmQgdGhlIEFQSSkgYXJlIGFsbCBtaWxsaXNlY29uZHNcbiAgICAgICBkZXNwaXRlIGxvb2tpbmcgbGlrZSB5ZWFycyAtIHBhcnR5IGxpa2UgaXQncyBcIjE5NzAtMDEtMDFUMDA6MDA6MDEuOTk5WlwiIVxuKi9cbmRlc2NyaWJlKFwidGVzdCB1dGlsc1wiLCBmdW5jdGlvbigpIHtcbiAgICBpdChcInRlc3RzIGZpbmRpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0gWzEsNSwxMF07XG4gICAgICAgIGV4cGVjdCh1dGlscy5maW5kKGRhdGEsIDApKS50b0JlKDApO1xuICAgICAgICBleHBlY3QodXRpbHMuZmluZChkYXRhLCAxKSkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0KHV0aWxzLmZpbmQoZGF0YSwgMikpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdCh1dGlscy5maW5kKGRhdGEsIDUpKS50b0JlKDEpO1xuICAgICAgICBleHBlY3QodXRpbHMuZmluZChkYXRhLCA2KSkudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KHV0aWxzLmZpbmQoZGF0YSwgMTApKS50b0JlKDIpO1xuICAgICAgICBleHBlY3QodXRpbHMuZmluZChkYXRhLCAxMSkpLnRvQmUoMik7XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoXCJyYW5nZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoXCJjcmVhdGVSYW5nZSB3b3Jrc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByO1xuICAgICAgICAgICAgLy8gdGV4dFxuICAgICAgICAgICAgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKCcyMDAwJywgJzIwMDEnKTtcbiAgICAgICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKERhdGUucGFyc2UoJzIwMDAnKSk7XG4gICAgICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUoRGF0ZS5wYXJzZSgnMjAwMScpKTtcbiAgICAgICAgICAgIC8vIG51bWJlcnMgKG1pbGxpcylcbiAgICAgICAgICAgIHIgPSB1dGlscy5jcmVhdGVSYW5nZSgyMDAwLCAyMDAzKTtcbiAgICAgICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKDIwMDApO1xuICAgICAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKDIwMDMpO1xuICAgICAgICAgICAgLy8gY29weVxuICAgICAgICAgICAgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKHIpO1xuICAgICAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUoMjAwMCk7XG4gICAgICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUoMjAwMyk7XG4gICAgICAgICAgICAvLyBzaW5nbGUgYXJnXG4gICAgICAgICAgICByID0gdXRpbHMuY3JlYXRlUmFuZ2UoMTk5OSk7XG4gICAgICAgICAgICBleHBlY3Qoci5zdGFydCkudG9CZSgxOTk5KTtcbiAgICAgICAgICAgIGV4cGVjdChyLmVuZCkudG9CZSgxOTk5KTtcbiAgICAgICAgICAgIC8vIG51bGwgMXN0IGFyZyAob3BlbiByYW5nZSlcbiAgICAgICAgICAgIHIgPSB1dGlscy5jcmVhdGVSYW5nZSgxOTk5LCBudWxsKTtcbiAgICAgICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKDE5OTkpO1xuICAgICAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKG51bGwpO1xuICAgICAgICAgICAgLy8gbnVsbCAybmQgYXJnIChvcGVuIHJhbmdlKVxuICAgICAgICAgICAgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKG51bGwsIDY3ODkpO1xuICAgICAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUobnVsbCk7XG4gICAgICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUoNjc4OSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdChcImJhc2ljcyB3b3JrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHIgPSB1dGlscy5jcmVhdGVSYW5nZSgyMDAwLCAyMDAzKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmNlbnRlcigpKS50b0JlKDIwMDEpO1xuICAgICAgICAgICAgZXhwZWN0KHIud2lkdGgoKSkudG9CZSgzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KFwiZXh0ZW5kIHdvcmtzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHIgPSB1dGlscy5jcmVhdGVSYW5nZSgyMDAwLCAyMDAzKTtcbiAgICAgICAgICAgIC8vIGlkZW1wb3RlbnRcbiAgICAgICAgICAgIHIuZXh0ZW5kKHIpO1xuICAgICAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUoMjAwMCk7XG4gICAgICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUoMjAwMyk7XG4gICAgICAgICAgICAvLyBzaW5nbGUgbGVmdFxuICAgICAgICAgICAgci5leHRlbmQoMTk5NSk7XG4gICAgICAgICAgICBleHBlY3Qoci5zdGFydCkudG9CZSgxOTk1KTtcbiAgICAgICAgICAgIGV4cGVjdChyLmVuZCkudG9CZSgyMDAzKTtcbiAgICAgICAgICAgIC8vIHNpbmdsZSByaWdodFxuICAgICAgICAgICAgci5leHRlbmQoMjAwNCk7XG4gICAgICAgICAgICBleHBlY3Qoci5zdGFydCkudG9CZSgxOTk1KTtcbiAgICAgICAgICAgIGV4cGVjdChyLmVuZCkudG9CZSgyMDA0KTtcbiAgICAgICAgICAgIC8vIGJvdGggc2lkZXNcbiAgICAgICAgICAgIHIuZXh0ZW5kKHV0aWxzLmNyZWF0ZVJhbmdlKDE5MDAsIDIwMTApKTtcbiAgICAgICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKDE5MDApO1xuICAgICAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKDIwMTApO1xuICAgICAgICAgICAgLy8gc3RhcnQgd2l0aCBub3RoaW5nLCBleHRlbmQgdy8gbm90aGluZ1xuICAgICAgICAgICAgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgci5leHRlbmQociA9IHV0aWxzLmNyZWF0ZVJhbmdlKG51bGwsIG51bGwpKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmlzRW1wdHkoKSkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHdpdGggbm90aGluZywgZXh0ZW5kIG9wZW4tZW5kZWQgc3RhcnRcbiAgICAgICAgICAgIHIgPSB1dGlscy5jcmVhdGVSYW5nZShudWxsLCBudWxsKTtcbiAgICAgICAgICAgIHIuZXh0ZW5kKHV0aWxzLmNyZWF0ZVJhbmdlKDEyMzQsIG51bGwpKTtcbiAgICAgICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKDEyMzQpO1xuICAgICAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKDEyMzQpO1xuICAgICAgICAgICAgLy8gc3RhcnRpbmcgd2l0aCBub3RoaW5nLCBleHRlbmQgb3Blbi1lbmRlZCBlbmRcbiAgICAgICAgICAgIHIgPSB1dGlscy5jcmVhdGVSYW5nZShudWxsLCBudWxsKTtcbiAgICAgICAgICAgIHIuZXh0ZW5kKHV0aWxzLmNyZWF0ZVJhbmdlKG51bGwsIDU2NzgpKTtcbiAgICAgICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKDU2NzgpO1xuICAgICAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKDU2NzgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoXCJpbnRlcnNlY3RzIHdvcmtzIHdpdGggaW5zdGFudHNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKDIwMDAsIDIwMDMpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaW50ZXJzZWN0cygxOTk5KSkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKDIwMDApKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaW50ZXJzZWN0cygyMDAxKSkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHMoMjAwMykpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgLy8gaW5zdGFudCByYW5nZSwgdG9vXG4gICAgICAgICAgICByID0gdXRpbHMuY3JlYXRlUmFuZ2UoMjAwMCwgMjAwMCk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKDIwMDApKS50b0JlKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoXCJpbnRlcnNlY3RzIHdvcmtzIG9uIG9wZW4gcmFuZ2Ugd2l0aCBpbnN0YW50c1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByID0gdXRpbHMuY3JlYXRlUmFuZ2UobnVsbCwgMjAwMyk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKDE5OTkpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaW50ZXJzZWN0cygyMDA0KSkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICByID0gdXRpbHMuY3JlYXRlUmFuZ2UoMjAwMywgbnVsbCk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKDE5OTkpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHMoMjAwNCkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdChcImludGVyc2VjdHMgd29ya3Mgb24gaW5zdGFudCByYW5nZSB3aXRoIG9wZW4gcmFuZ2VzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHIgPSB1dGlscy5jcmVhdGVSYW5nZSgyMDAzLCAyMDAzKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHModXRpbHMuY3JlYXRlUmFuZ2UoMTk5OSwgbnVsbCkpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaW50ZXJzZWN0cyh1dGlscy5jcmVhdGVSYW5nZShudWxsLCAyMDA0KSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKHV0aWxzLmNyZWF0ZVJhbmdlKDIwMDQsIG51bGwpKSkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKHV0aWxzLmNyZWF0ZVJhbmdlKG51bGwsIDIwMDIpKSkudG9CZShmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdChcImludGVyc2VjdHMgd29ya3Mgd2l0aCBleHRlbnRzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHIgPSB1dGlscy5jcmVhdGVSYW5nZSgyMDAwLCAyMDAzKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHModXRpbHMuY3JlYXRlUmFuZ2UoMTk5OSwgMjAwMCkpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaW50ZXJzZWN0cyh1dGlscy5jcmVhdGVSYW5nZSgyMDAwLCAyMDAxKSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKHV0aWxzLmNyZWF0ZVJhbmdlKDIwMDIsIDIwMDMpKSkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHModXRpbHMuY3JlYXRlUmFuZ2UoMTk5OSwgMjAwMykpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaW50ZXJzZWN0cyh1dGlscy5jcmVhdGVSYW5nZSgxOTk5LCAyMDA0KSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKHV0aWxzLmNyZWF0ZVJhbmdlKDIwMDQsIDIwMDUpKSkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKHV0aWxzLmNyZWF0ZVJhbmdlKDE5OTgsIDE5OTkpKSkudG9CZShmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdChcImlzUmFuZ2VMaWtlIHdvcmtzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZXhwZWN0KHV0aWxzLmlzUmFuZ2VMaWtlKG51bGwpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGV4cGVjdCh1dGlscy5pc1JhbmdlTGlrZSh1bmRlZmluZWQpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGV4cGVjdCh1dGlscy5pc1JhbmdlTGlrZSgneCcpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGV4cGVjdCh1dGlscy5pc1JhbmdlTGlrZSgyMikpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KHV0aWxzLmlzUmFuZ2VMaWtlKHtzdGFydDoxfSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QodXRpbHMuaXNSYW5nZUxpa2Uoe2VuZDoxfSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QodXRpbHMuaXNSYW5nZUxpa2Uoe3N0YXJ0OjEsIGVuZDoxfSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGl0KFwidGVzdHMgaW50ZXJ2YWwgcGlja2luZ1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KHV0aWxzLnBpY2tJbnRlcnZhbCh1dGlscy5jcmVhdGVSYW5nZSgnMjAwMCcsJzIwMDEnKSkpLnRvQmUoXG4gICAgICAgICAgICBtb21lbnQuZHVyYXRpb24oMSwgJ21vbnRocycpLmFzTWlsbGlzZWNvbmRzKClcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KHV0aWxzLnBpY2tJbnRlcnZhbCh1dGlscy5jcmVhdGVSYW5nZSgnMjAwMC0wMS0wMScsJzIwMDAtMDItMDEnKSkpLnRvQmUoXG4gICAgICAgICAgICBtb21lbnQuZHVyYXRpb24oMSwgJ3dlZWtzJykuYXNNaWxsaXNlY29uZHMoKVxuICAgICAgICApO1xuICAgIH0pO1xuICAgIGl0KFwidGVzdHMgY29tcHV0ZSByYW5nZSB3b3Jrc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHIgPSB1dGlscy5jb21wdXRlUmFuZ2UoW3V0aWxzLmNyZWF0ZVJhbmdlKDEwMCwyMDApXSk7XG4gICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKDEwMCk7XG4gICAgICAgIGV4cGVjdChyLmVuZCkudG9CZSgyMDApO1xuICAgICAgICByID0gdXRpbHMuY29tcHV0ZVJhbmdlKFt1dGlscy5jcmVhdGVSYW5nZSgxMDAsNDAwKSwgdXRpbHMuY3JlYXRlUmFuZ2UoMTAwLDMwMCldKTtcbiAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUoMTAwKTtcbiAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKDQwMCk7XG4gICAgICAgIHIgPSB1dGlscy5jb21wdXRlUmFuZ2UoWzIwLDEwLDUwXSk7XG4gICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKDEwKTtcbiAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKDUwKTtcbiAgICB9KTtcbiAgICBpdChcInRlc3RzIGNyZWF0ZU9mZnNldHRlciB3b3Jrc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gb2Zmc2V0QXNJU08odGltZXN0YW1wLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHV0aWxzLmNyZWF0ZU9mZnNldHRlcihkdXJhdGlvbikodGltZXN0YW1wKSkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3Qob2Zmc2V0QXNJU08oJzE5NzAnLCAnUDFZJykpLnRvQmUoJzE5NzEtMDEtMDFUMDA6MDA6MDAuMDAwWicpO1xuICAgICAgICBleHBlY3Qob2Zmc2V0QXNJU08oJzE5NzAtMDYtMDEnLCAnUDFZMU0nKSkudG9CZSgnMTk3MS0wNy0wMVQwMDowMDowMC4wMDBaJyk7XG4gICAgICAgIGV4cGVjdChvZmZzZXRBc0lTTygnMTk3NC0wMi0yOFQxMjoyNCcsICdQMlkyTScpKS50b0JlKCcxOTc2LTA0LTI4VDEyOjI0OjAwLjAwMFonKTtcbiAgICAgICAgZXhwZWN0KG9mZnNldEFzSVNPKCcxOTc0LTAyLTI4VDEyOjI0JywgJ1AyWTJNJykpLnRvQmUoJzE5NzYtMDQtMjhUMTI6MjQ6MDAuMDAwWicpO1xuICAgICAgICAvLyB2ZXJpZnkgY3VycmVudCBhbGdvcml0aG0gZmFpbHMgLSBqYW4gMzFzdCArIDFtb250aCB3cmFwcyBpbnRvIG1hcmNoXG4gICAgICAgIGV4cGVjdChvZmZzZXRBc0lTTygnMTk3NC0wMS0zMVQxMjoyNCcsICdQMlkxTScpKS50b0JlKCcxOTc2LTAzLTAyVDEyOjI0OjAwLjAwMFonKTtcbiAgICB9KTtcbiAgICAgICAgaXQoXCJwYXJzZUlTT0R1cmF0aW9uIHNob3VsZCB0aHJvdyBzb21ldGltZXNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHV0aWxzLnBhcnNlSVNPRHVyYXRpb24oJ1RQMU0nKTtcbiAgICAgICAgfSkudG9UaHJvd0Vycm9yKCdleHBlY3RlZCBQIGFzIHN0YXJ0aW5nIGR1cmF0aW9uIDogVFAxTScpO1xuICAgICAgICBleHBlY3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB1dGlscy5wYXJzZUlTT0R1cmF0aW9uKCdQMVgnKTtcbiAgICAgICAgfSkudG9UaHJvd0Vycm9yKCd1bmtub3duIGR1cmF0aW9uIHNwZWNpZmllciA6IFgnKTtcbiAgICB9KTtcbiAgICBpdChcInBhcnNlSVNPRHVyYXRpb24gc2hvdWxkIHBhcnNlIGNvcnJlY3RseVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KHV0aWxzLnBhcnNlSVNPRHVyYXRpb24oJ1BUMVMnKSkudG9CZSgxMDAwKTtcbiAgICAgICAgZXhwZWN0KHV0aWxzLnBhcnNlSVNPRHVyYXRpb24oJ1BUMU0nKSkudG9CZSg2MDAwMCk7XG4gICAgICAgIGV4cGVjdCh1dGlscy5wYXJzZUlTT0R1cmF0aW9uKCdQVDFIJykpLnRvQmUoMzYwMDAwMCk7XG4gICAgICAgIGV4cGVjdCh1dGlscy5wYXJzZUlTT0R1cmF0aW9uKCdQMUQnKSkudG9CZSg4NjQwMDAwMCk7XG4gICAgICAgIGV4cGVjdCh1dGlscy5wYXJzZUlTT0R1cmF0aW9uKCdQMVcnKSkudG9CZSg2MDQ4MDAwMDApO1xuICAgICAgICBleHBlY3QodXRpbHMucGFyc2VJU09EdXJhdGlvbignUDFNJykpLnRvQmUoMjU5MjAwMDAwMCk7XG4gICAgICAgIGV4cGVjdCh1dGlscy5wYXJzZUlTT0R1cmF0aW9uKCdQMVknKSkudG9CZSgzMTUzNjAwMDAwMCk7XG4gICAgICAgIGV4cGVjdCh1dGlscy5wYXJzZUlTT0R1cmF0aW9uKCdQMU1UMU0nKSkudG9CZSgyNTkyMDAwMDAwICsgNjAwMDApO1xuICAgIH0pO1xufSk7XG4iXX0=
